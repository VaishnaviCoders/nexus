
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model AcademicYear
 * 
 */
export type AcademicYear = $Result.DefaultSelection<Prisma.$AcademicYearPayload>
/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Grade
 * 
 */
export type Grade = $Result.DefaultSelection<Prisma.$GradePayload>
/**
 * Model Section
 * 
 */
export type Section = $Result.DefaultSelection<Prisma.$SectionPayload>
/**
 * Model Teacher
 * 
 */
export type Teacher = $Result.DefaultSelection<Prisma.$TeacherPayload>
/**
 * Model TeacherProfile
 * 
 */
export type TeacherProfile = $Result.DefaultSelection<Prisma.$TeacherProfilePayload>
/**
 * Model Subject
 * 
 */
export type Subject = $Result.DefaultSelection<Prisma.$SubjectPayload>
/**
 * Model TeachingAssignment
 * 
 */
export type TeachingAssignment = $Result.DefaultSelection<Prisma.$TeachingAssignmentPayload>
/**
 * Model Student
 * 
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>
/**
 * Model Parent
 * 
 */
export type Parent = $Result.DefaultSelection<Prisma.$ParentPayload>
/**
 * Model ParentStudent
 * 
 */
export type ParentStudent = $Result.DefaultSelection<Prisma.$ParentStudentPayload>
/**
 * Model StudentAttendance
 * 
 */
export type StudentAttendance = $Result.DefaultSelection<Prisma.$StudentAttendancePayload>
/**
 * Model StudentDocument
 * 
 */
export type StudentDocument = $Result.DefaultSelection<Prisma.$StudentDocumentPayload>
/**
 * Model Fee
 * 
 */
export type Fee = $Result.DefaultSelection<Prisma.$FeePayload>
/**
 * Model FeePayment
 * 
 */
export type FeePayment = $Result.DefaultSelection<Prisma.$FeePaymentPayload>
/**
 * Model ScheduledJob
 * 
 */
export type ScheduledJob = $Result.DefaultSelection<Prisma.$ScheduledJobPayload>
/**
 * Model FeeCategory
 * 
 */
export type FeeCategory = $Result.DefaultSelection<Prisma.$FeeCategoryPayload>
/**
 * Model AcademicCalendar
 * 
 */
export type AcademicCalendar = $Result.DefaultSelection<Prisma.$AcademicCalendarPayload>
/**
 * Model AnonymousComplaint
 * 
 */
export type AnonymousComplaint = $Result.DefaultSelection<Prisma.$AnonymousComplaintPayload>
/**
 * Model ComplaintStatusTimeline
 * 
 */
export type ComplaintStatusTimeline = $Result.DefaultSelection<Prisma.$ComplaintStatusTimelinePayload>
/**
 * Model Notice
 * 
 */
export type Notice = $Result.DefaultSelection<Prisma.$NoticePayload>
/**
 * Model NotificationLog
 * 
 */
export type NotificationLog = $Result.DefaultSelection<Prisma.$NotificationLogPayload>
/**
 * Model ExamSession
 * 
 */
export type ExamSession = $Result.DefaultSelection<Prisma.$ExamSessionPayload>
/**
 * Model Exam
 * 
 */
export type Exam = $Result.DefaultSelection<Prisma.$ExamPayload>
/**
 * Model ExamEnrollment
 * 
 */
export type ExamEnrollment = $Result.DefaultSelection<Prisma.$ExamEnrollmentPayload>
/**
 * Model ExamResult
 * 
 */
export type ExamResult = $Result.DefaultSelection<Prisma.$ExamResultPayload>
/**
 * Model HallTicket
 * 
 */
export type HallTicket = $Result.DefaultSelection<Prisma.$HallTicketPayload>
/**
 * Model ReportCard
 * 
 */
export type ReportCard = $Result.DefaultSelection<Prisma.$ReportCardPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const PlanType: {
  FREE: 'FREE',
  STANDARD: 'STANDARD',
  PREMIUM: 'PREMIUM',
  ENTERPRISE: 'ENTERPRISE'
};

export type PlanType = (typeof PlanType)[keyof typeof PlanType]


export const NoticeType: {
  GENERAL: 'GENERAL',
  EVENT: 'EVENT',
  EXAM: 'EXAM',
  HOLIDAY: 'HOLIDAY',
  DEADLINE: 'DEADLINE',
  TIMETABLE: 'TIMETABLE',
  RESULT: 'RESULT',
  SMS: 'SMS'
};

export type NoticeType = (typeof NoticeType)[keyof typeof NoticeType]


export const OrganizationType: {
  SCHOOL: 'SCHOOL',
  COLLEGE: 'COLLEGE',
  COACHING_CLASS: 'COACHING_CLASS',
  UNIVERSITY: 'UNIVERSITY',
  KINDERGARTEN: 'KINDERGARTEN',
  TRAINING_INSTITUTE: 'TRAINING_INSTITUTE',
  OTHER: 'OTHER'
};

export type OrganizationType = (typeof OrganizationType)[keyof typeof OrganizationType]


export const YearType: {
  ANNUAL: 'ANNUAL',
  SEMESTER: 'SEMESTER',
  TRIMESTER: 'TRIMESTER',
  BATCH: 'BATCH'
};

export type YearType = (typeof YearType)[keyof typeof YearType]


export const AssignmentStatus: {
  PENDING: 'PENDING',
  ASSIGNED: 'ASSIGNED',
  COMPLETED: 'COMPLETED',
  INACTIVE: 'INACTIVE'
};

export type AssignmentStatus = (typeof AssignmentStatus)[keyof typeof AssignmentStatus]


export const DocumentType: {
  AADHAAR: 'AADHAAR',
  PAN: 'PAN',
  PASSPORT: 'PASSPORT',
  BIRTH_CERTIFICATE: 'BIRTH_CERTIFICATE',
  TRANSFER_CERTIFICATE: 'TRANSFER_CERTIFICATE',
  BANK_PASSBOOK: 'BANK_PASSBOOK',
  PARENT_ID: 'PARENT_ID',
  AGREEMENT: 'AGREEMENT'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const PaymentMethod: {
  CASH: 'CASH',
  UPI: 'UPI',
  CARD: 'CARD',
  BANK_TRANSFER: 'BANK_TRANSFER',
  CHEQUE: 'CHEQUE',
  ONLINE: 'ONLINE'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const PaymentStatus: {
  PENDING: 'PENDING',
  UNPAID: 'UNPAID',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED',
  CANCELLED: 'CANCELLED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const FeeStatus: {
  PAID: 'PAID',
  UNPAID: 'UNPAID',
  OVERDUE: 'OVERDUE'
};

export type FeeStatus = (typeof FeeStatus)[keyof typeof FeeStatus]


export const scheduledJobType: {
  FEE_REMINDER: 'FEE_REMINDER',
  NOTICE: 'NOTICE'
};

export type scheduledJobType = (typeof scheduledJobType)[keyof typeof scheduledJobType]


export const AttendanceStatus: {
  PRESENT: 'PRESENT',
  ABSENT: 'ABSENT',
  LATE: 'LATE'
};

export type AttendanceStatus = (typeof AttendanceStatus)[keyof typeof AttendanceStatus]


export const CalendarEventType: {
  PLANNED: 'PLANNED',
  SUDDEN: 'SUDDEN',
  INSTITUTION_SPECIFIC: 'INSTITUTION_SPECIFIC'
};

export type CalendarEventType = (typeof CalendarEventType)[keyof typeof CalendarEventType]


export const Severity: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL'
};

export type Severity = (typeof Severity)[keyof typeof Severity]


export const ComplaintStatus: {
  PENDING: 'PENDING',
  RESOLVED: 'RESOLVED',
  CLOSED: 'CLOSED',
  UNDER_REVIEW: 'UNDER_REVIEW',
  INVESTIGATING: 'INVESTIGATING',
  REJECTED: 'REJECTED'
};

export type ComplaintStatus = (typeof ComplaintStatus)[keyof typeof ComplaintStatus]


export const NotificationType: {
  NOTICE: 'NOTICE',
  FEE_REMINDER: 'FEE_REMINDER',
  ATTENDANCE_ALERT: 'ATTENDANCE_ALERT',
  DOCUMENT_REQUEST: 'DOCUMENT_REQUEST',
  GENERAL_ANNOUNCEMENT: 'GENERAL_ANNOUNCEMENT',
  Exam: 'Exam'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const NotificationChannel: {
  EMAIL: 'EMAIL',
  SMS: 'SMS',
  WHATSAPP: 'WHATSAPP',
  PUSH: 'PUSH'
};

export type NotificationChannel = (typeof NotificationChannel)[keyof typeof NotificationChannel]


export const NotificationStatus: {
  PENDING: 'PENDING',
  SENT: 'SENT',
  FAILED: 'FAILED',
  DELIVERED: 'DELIVERED'
};

export type NotificationStatus = (typeof NotificationStatus)[keyof typeof NotificationStatus]


export const Role: {
  ADMIN: 'ADMIN',
  TEACHER: 'TEACHER',
  STUDENT: 'STUDENT',
  PARENT: 'PARENT'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const EmploymentStatus: {
  ACTIVE: 'ACTIVE',
  ON_LEAVE: 'ON_LEAVE',
  RESIGNED: 'RESIGNED',
  RETIRED: 'RETIRED',
  TERMINATED: 'TERMINATED',
  CONTRACTUAL: 'CONTRACTUAL',
  PROBATION: 'PROBATION',
  SUSPENDED: 'SUSPENDED'
};

export type EmploymentStatus = (typeof EmploymentStatus)[keyof typeof EmploymentStatus]


export const EvaluationType: {
  TEST: 'TEST',
  EXAM: 'EXAM',
  ASSIGNMENT: 'ASSIGNMENT',
  PROJECT: 'PROJECT',
  PRACTICAL: 'PRACTICAL',
  QUIZ: 'QUIZ',
  ORAL: 'ORAL',
  INTERNAL: 'INTERNAL',
  FINAL: 'FINAL',
  OTHER: 'OTHER'
};

export type EvaluationType = (typeof EvaluationType)[keyof typeof EvaluationType]


export const ExamStatus: {
  UPCOMING: 'UPCOMING',
  LIVE: 'LIVE',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type ExamStatus = (typeof ExamStatus)[keyof typeof ExamStatus]


export const StudentExamStatus: {
  ENROLLED: 'ENROLLED',
  ATTENDED: 'ATTENDED',
  ABSENT: 'ABSENT',
  EXEMPT: 'EXEMPT',
  DISQUALIFIED: 'DISQUALIFIED'
};

export type StudentExamStatus = (typeof StudentExamStatus)[keyof typeof StudentExamStatus]


export const ExamMode: {
  ONLINE: 'ONLINE',
  OFFLINE: 'OFFLINE',
  PRACTICAL: 'PRACTICAL',
  VIVA: 'VIVA',
  TAKE_HOME: 'TAKE_HOME'
};

export type ExamMode = (typeof ExamMode)[keyof typeof ExamMode]


export const ResultStatus: {
  PASSED: 'PASSED',
  FAILED: 'FAILED',
  PROMOTED: 'PROMOTED',
  COMPARTMENT: 'COMPARTMENT',
  WITHHELD: 'WITHHELD'
};

export type ResultStatus = (typeof ResultStatus)[keyof typeof ResultStatus]

}

export type PlanType = $Enums.PlanType

export const PlanType: typeof $Enums.PlanType

export type NoticeType = $Enums.NoticeType

export const NoticeType: typeof $Enums.NoticeType

export type OrganizationType = $Enums.OrganizationType

export const OrganizationType: typeof $Enums.OrganizationType

export type YearType = $Enums.YearType

export const YearType: typeof $Enums.YearType

export type AssignmentStatus = $Enums.AssignmentStatus

export const AssignmentStatus: typeof $Enums.AssignmentStatus

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type FeeStatus = $Enums.FeeStatus

export const FeeStatus: typeof $Enums.FeeStatus

export type scheduledJobType = $Enums.scheduledJobType

export const scheduledJobType: typeof $Enums.scheduledJobType

export type AttendanceStatus = $Enums.AttendanceStatus

export const AttendanceStatus: typeof $Enums.AttendanceStatus

export type CalendarEventType = $Enums.CalendarEventType

export const CalendarEventType: typeof $Enums.CalendarEventType

export type Severity = $Enums.Severity

export const Severity: typeof $Enums.Severity

export type ComplaintStatus = $Enums.ComplaintStatus

export const ComplaintStatus: typeof $Enums.ComplaintStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type NotificationChannel = $Enums.NotificationChannel

export const NotificationChannel: typeof $Enums.NotificationChannel

export type NotificationStatus = $Enums.NotificationStatus

export const NotificationStatus: typeof $Enums.NotificationStatus

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type EmploymentStatus = $Enums.EmploymentStatus

export const EmploymentStatus: typeof $Enums.EmploymentStatus

export type EvaluationType = $Enums.EvaluationType

export const EvaluationType: typeof $Enums.EvaluationType

export type ExamStatus = $Enums.ExamStatus

export const ExamStatus: typeof $Enums.ExamStatus

export type StudentExamStatus = $Enums.StudentExamStatus

export const StudentExamStatus: typeof $Enums.StudentExamStatus

export type ExamMode = $Enums.ExamMode

export const ExamMode: typeof $Enums.ExamMode

export type ResultStatus = $Enums.ResultStatus

export const ResultStatus: typeof $Enums.ResultStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more AcademicYears
 * const academicYears = await prisma.academicYear.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more AcademicYears
   * const academicYears = await prisma.academicYear.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.academicYear`: Exposes CRUD operations for the **AcademicYear** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AcademicYears
    * const academicYears = await prisma.academicYear.findMany()
    * ```
    */
  get academicYear(): Prisma.AcademicYearDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.grade`: Exposes CRUD operations for the **Grade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Grades
    * const grades = await prisma.grade.findMany()
    * ```
    */
  get grade(): Prisma.GradeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.section`: Exposes CRUD operations for the **Section** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sections
    * const sections = await prisma.section.findMany()
    * ```
    */
  get section(): Prisma.SectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teacher`: Exposes CRUD operations for the **Teacher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teachers
    * const teachers = await prisma.teacher.findMany()
    * ```
    */
  get teacher(): Prisma.TeacherDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teacherProfile`: Exposes CRUD operations for the **TeacherProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeacherProfiles
    * const teacherProfiles = await prisma.teacherProfile.findMany()
    * ```
    */
  get teacherProfile(): Prisma.TeacherProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subject`: Exposes CRUD operations for the **Subject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subjects
    * const subjects = await prisma.subject.findMany()
    * ```
    */
  get subject(): Prisma.SubjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teachingAssignment`: Exposes CRUD operations for the **TeachingAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeachingAssignments
    * const teachingAssignments = await prisma.teachingAssignment.findMany()
    * ```
    */
  get teachingAssignment(): Prisma.TeachingAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parent`: Exposes CRUD operations for the **Parent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parents
    * const parents = await prisma.parent.findMany()
    * ```
    */
  get parent(): Prisma.ParentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parentStudent`: Exposes CRUD operations for the **ParentStudent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ParentStudents
    * const parentStudents = await prisma.parentStudent.findMany()
    * ```
    */
  get parentStudent(): Prisma.ParentStudentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentAttendance`: Exposes CRUD operations for the **StudentAttendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentAttendances
    * const studentAttendances = await prisma.studentAttendance.findMany()
    * ```
    */
  get studentAttendance(): Prisma.StudentAttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentDocument`: Exposes CRUD operations for the **StudentDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentDocuments
    * const studentDocuments = await prisma.studentDocument.findMany()
    * ```
    */
  get studentDocument(): Prisma.StudentDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fee`: Exposes CRUD operations for the **Fee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fees
    * const fees = await prisma.fee.findMany()
    * ```
    */
  get fee(): Prisma.FeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feePayment`: Exposes CRUD operations for the **FeePayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeePayments
    * const feePayments = await prisma.feePayment.findMany()
    * ```
    */
  get feePayment(): Prisma.FeePaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scheduledJob`: Exposes CRUD operations for the **ScheduledJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScheduledJobs
    * const scheduledJobs = await prisma.scheduledJob.findMany()
    * ```
    */
  get scheduledJob(): Prisma.ScheduledJobDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feeCategory`: Exposes CRUD operations for the **FeeCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeeCategories
    * const feeCategories = await prisma.feeCategory.findMany()
    * ```
    */
  get feeCategory(): Prisma.FeeCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.academicCalendar`: Exposes CRUD operations for the **AcademicCalendar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AcademicCalendars
    * const academicCalendars = await prisma.academicCalendar.findMany()
    * ```
    */
  get academicCalendar(): Prisma.AcademicCalendarDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.anonymousComplaint`: Exposes CRUD operations for the **AnonymousComplaint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnonymousComplaints
    * const anonymousComplaints = await prisma.anonymousComplaint.findMany()
    * ```
    */
  get anonymousComplaint(): Prisma.AnonymousComplaintDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.complaintStatusTimeline`: Exposes CRUD operations for the **ComplaintStatusTimeline** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComplaintStatusTimelines
    * const complaintStatusTimelines = await prisma.complaintStatusTimeline.findMany()
    * ```
    */
  get complaintStatusTimeline(): Prisma.ComplaintStatusTimelineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notice`: Exposes CRUD operations for the **Notice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notices
    * const notices = await prisma.notice.findMany()
    * ```
    */
  get notice(): Prisma.NoticeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationLog`: Exposes CRUD operations for the **NotificationLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationLogs
    * const notificationLogs = await prisma.notificationLog.findMany()
    * ```
    */
  get notificationLog(): Prisma.NotificationLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.examSession`: Exposes CRUD operations for the **ExamSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamSessions
    * const examSessions = await prisma.examSession.findMany()
    * ```
    */
  get examSession(): Prisma.ExamSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exam`: Exposes CRUD operations for the **Exam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exams
    * const exams = await prisma.exam.findMany()
    * ```
    */
  get exam(): Prisma.ExamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.examEnrollment`: Exposes CRUD operations for the **ExamEnrollment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamEnrollments
    * const examEnrollments = await prisma.examEnrollment.findMany()
    * ```
    */
  get examEnrollment(): Prisma.ExamEnrollmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.examResult`: Exposes CRUD operations for the **ExamResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamResults
    * const examResults = await prisma.examResult.findMany()
    * ```
    */
  get examResult(): Prisma.ExamResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hallTicket`: Exposes CRUD operations for the **HallTicket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HallTickets
    * const hallTickets = await prisma.hallTicket.findMany()
    * ```
    */
  get hallTicket(): Prisma.HallTicketDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reportCard`: Exposes CRUD operations for the **ReportCard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportCards
    * const reportCards = await prisma.reportCard.findMany()
    * ```
    */
  get reportCard(): Prisma.ReportCardDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.13.0
   * Query Engine version: 361e86d0ea4987e9f53a565309b3eed797a6bcbd
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    AcademicYear: 'AcademicYear',
    Organization: 'Organization',
    User: 'User',
    Grade: 'Grade',
    Section: 'Section',
    Teacher: 'Teacher',
    TeacherProfile: 'TeacherProfile',
    Subject: 'Subject',
    TeachingAssignment: 'TeachingAssignment',
    Student: 'Student',
    Parent: 'Parent',
    ParentStudent: 'ParentStudent',
    StudentAttendance: 'StudentAttendance',
    StudentDocument: 'StudentDocument',
    Fee: 'Fee',
    FeePayment: 'FeePayment',
    ScheduledJob: 'ScheduledJob',
    FeeCategory: 'FeeCategory',
    AcademicCalendar: 'AcademicCalendar',
    AnonymousComplaint: 'AnonymousComplaint',
    ComplaintStatusTimeline: 'ComplaintStatusTimeline',
    Notice: 'Notice',
    NotificationLog: 'NotificationLog',
    ExamSession: 'ExamSession',
    Exam: 'Exam',
    ExamEnrollment: 'ExamEnrollment',
    ExamResult: 'ExamResult',
    HallTicket: 'HallTicket',
    ReportCard: 'ReportCard'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "academicYear" | "organization" | "user" | "grade" | "section" | "teacher" | "teacherProfile" | "subject" | "teachingAssignment" | "student" | "parent" | "parentStudent" | "studentAttendance" | "studentDocument" | "fee" | "feePayment" | "scheduledJob" | "feeCategory" | "academicCalendar" | "anonymousComplaint" | "complaintStatusTimeline" | "notice" | "notificationLog" | "examSession" | "exam" | "examEnrollment" | "examResult" | "hallTicket" | "reportCard"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      AcademicYear: {
        payload: Prisma.$AcademicYearPayload<ExtArgs>
        fields: Prisma.AcademicYearFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcademicYearFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcademicYearFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          findFirst: {
            args: Prisma.AcademicYearFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcademicYearFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          findMany: {
            args: Prisma.AcademicYearFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>[]
          }
          create: {
            args: Prisma.AcademicYearCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          createMany: {
            args: Prisma.AcademicYearCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AcademicYearCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>[]
          }
          delete: {
            args: Prisma.AcademicYearDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          update: {
            args: Prisma.AcademicYearUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          deleteMany: {
            args: Prisma.AcademicYearDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AcademicYearUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AcademicYearUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>[]
          }
          upsert: {
            args: Prisma.AcademicYearUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          aggregate: {
            args: Prisma.AcademicYearAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAcademicYear>
          }
          groupBy: {
            args: Prisma.AcademicYearGroupByArgs<ExtArgs>
            result: $Utils.Optional<AcademicYearGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcademicYearCountArgs<ExtArgs>
            result: $Utils.Optional<AcademicYearCountAggregateOutputType> | number
          }
        }
      }
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Grade: {
        payload: Prisma.$GradePayload<ExtArgs>
        fields: Prisma.GradeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GradeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GradeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          findFirst: {
            args: Prisma.GradeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GradeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          findMany: {
            args: Prisma.GradeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>[]
          }
          create: {
            args: Prisma.GradeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          createMany: {
            args: Prisma.GradeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GradeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>[]
          }
          delete: {
            args: Prisma.GradeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          update: {
            args: Prisma.GradeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          deleteMany: {
            args: Prisma.GradeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GradeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GradeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>[]
          }
          upsert: {
            args: Prisma.GradeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          aggregate: {
            args: Prisma.GradeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGrade>
          }
          groupBy: {
            args: Prisma.GradeGroupByArgs<ExtArgs>
            result: $Utils.Optional<GradeGroupByOutputType>[]
          }
          count: {
            args: Prisma.GradeCountArgs<ExtArgs>
            result: $Utils.Optional<GradeCountAggregateOutputType> | number
          }
        }
      }
      Section: {
        payload: Prisma.$SectionPayload<ExtArgs>
        fields: Prisma.SectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          findFirst: {
            args: Prisma.SectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          findMany: {
            args: Prisma.SectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>[]
          }
          create: {
            args: Prisma.SectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          createMany: {
            args: Prisma.SectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>[]
          }
          delete: {
            args: Prisma.SectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          update: {
            args: Prisma.SectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          deleteMany: {
            args: Prisma.SectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>[]
          }
          upsert: {
            args: Prisma.SectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          aggregate: {
            args: Prisma.SectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSection>
          }
          groupBy: {
            args: Prisma.SectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SectionCountArgs<ExtArgs>
            result: $Utils.Optional<SectionCountAggregateOutputType> | number
          }
        }
      }
      Teacher: {
        payload: Prisma.$TeacherPayload<ExtArgs>
        fields: Prisma.TeacherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeacherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeacherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          findFirst: {
            args: Prisma.TeacherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeacherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          findMany: {
            args: Prisma.TeacherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>[]
          }
          create: {
            args: Prisma.TeacherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          createMany: {
            args: Prisma.TeacherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeacherCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>[]
          }
          delete: {
            args: Prisma.TeacherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          update: {
            args: Prisma.TeacherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          deleteMany: {
            args: Prisma.TeacherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeacherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeacherUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>[]
          }
          upsert: {
            args: Prisma.TeacherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          aggregate: {
            args: Prisma.TeacherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeacher>
          }
          groupBy: {
            args: Prisma.TeacherGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeacherGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeacherCountArgs<ExtArgs>
            result: $Utils.Optional<TeacherCountAggregateOutputType> | number
          }
        }
      }
      TeacherProfile: {
        payload: Prisma.$TeacherProfilePayload<ExtArgs>
        fields: Prisma.TeacherProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeacherProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeacherProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherProfilePayload>
          }
          findFirst: {
            args: Prisma.TeacherProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeacherProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherProfilePayload>
          }
          findMany: {
            args: Prisma.TeacherProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherProfilePayload>[]
          }
          create: {
            args: Prisma.TeacherProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherProfilePayload>
          }
          createMany: {
            args: Prisma.TeacherProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeacherProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherProfilePayload>[]
          }
          delete: {
            args: Prisma.TeacherProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherProfilePayload>
          }
          update: {
            args: Prisma.TeacherProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherProfilePayload>
          }
          deleteMany: {
            args: Prisma.TeacherProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeacherProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeacherProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherProfilePayload>[]
          }
          upsert: {
            args: Prisma.TeacherProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherProfilePayload>
          }
          aggregate: {
            args: Prisma.TeacherProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeacherProfile>
          }
          groupBy: {
            args: Prisma.TeacherProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeacherProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeacherProfileCountArgs<ExtArgs>
            result: $Utils.Optional<TeacherProfileCountAggregateOutputType> | number
          }
        }
      }
      Subject: {
        payload: Prisma.$SubjectPayload<ExtArgs>
        fields: Prisma.SubjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findFirst: {
            args: Prisma.SubjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findMany: {
            args: Prisma.SubjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          create: {
            args: Prisma.SubjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          createMany: {
            args: Prisma.SubjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          delete: {
            args: Prisma.SubjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          update: {
            args: Prisma.SubjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          deleteMany: {
            args: Prisma.SubjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          upsert: {
            args: Prisma.SubjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          aggregate: {
            args: Prisma.SubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubject>
          }
          groupBy: {
            args: Prisma.SubjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubjectCountArgs<ExtArgs>
            result: $Utils.Optional<SubjectCountAggregateOutputType> | number
          }
        }
      }
      TeachingAssignment: {
        payload: Prisma.$TeachingAssignmentPayload<ExtArgs>
        fields: Prisma.TeachingAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeachingAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachingAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeachingAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachingAssignmentPayload>
          }
          findFirst: {
            args: Prisma.TeachingAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachingAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeachingAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachingAssignmentPayload>
          }
          findMany: {
            args: Prisma.TeachingAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachingAssignmentPayload>[]
          }
          create: {
            args: Prisma.TeachingAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachingAssignmentPayload>
          }
          createMany: {
            args: Prisma.TeachingAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeachingAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachingAssignmentPayload>[]
          }
          delete: {
            args: Prisma.TeachingAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachingAssignmentPayload>
          }
          update: {
            args: Prisma.TeachingAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachingAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.TeachingAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeachingAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeachingAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachingAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.TeachingAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachingAssignmentPayload>
          }
          aggregate: {
            args: Prisma.TeachingAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeachingAssignment>
          }
          groupBy: {
            args: Prisma.TeachingAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeachingAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeachingAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<TeachingAssignmentCountAggregateOutputType> | number
          }
        }
      }
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>
        fields: Prisma.StudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          createMany: {
            args: Prisma.StudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      Parent: {
        payload: Prisma.$ParentPayload<ExtArgs>
        fields: Prisma.ParentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          findFirst: {
            args: Prisma.ParentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          findMany: {
            args: Prisma.ParentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>[]
          }
          create: {
            args: Prisma.ParentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          createMany: {
            args: Prisma.ParentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>[]
          }
          delete: {
            args: Prisma.ParentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          update: {
            args: Prisma.ParentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          deleteMany: {
            args: Prisma.ParentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ParentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>[]
          }
          upsert: {
            args: Prisma.ParentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          aggregate: {
            args: Prisma.ParentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParent>
          }
          groupBy: {
            args: Prisma.ParentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParentCountArgs<ExtArgs>
            result: $Utils.Optional<ParentCountAggregateOutputType> | number
          }
        }
      }
      ParentStudent: {
        payload: Prisma.$ParentStudentPayload<ExtArgs>
        fields: Prisma.ParentStudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParentStudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentStudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParentStudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentStudentPayload>
          }
          findFirst: {
            args: Prisma.ParentStudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentStudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParentStudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentStudentPayload>
          }
          findMany: {
            args: Prisma.ParentStudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentStudentPayload>[]
          }
          create: {
            args: Prisma.ParentStudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentStudentPayload>
          }
          createMany: {
            args: Prisma.ParentStudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParentStudentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentStudentPayload>[]
          }
          delete: {
            args: Prisma.ParentStudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentStudentPayload>
          }
          update: {
            args: Prisma.ParentStudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentStudentPayload>
          }
          deleteMany: {
            args: Prisma.ParentStudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParentStudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ParentStudentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentStudentPayload>[]
          }
          upsert: {
            args: Prisma.ParentStudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentStudentPayload>
          }
          aggregate: {
            args: Prisma.ParentStudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParentStudent>
          }
          groupBy: {
            args: Prisma.ParentStudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParentStudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParentStudentCountArgs<ExtArgs>
            result: $Utils.Optional<ParentStudentCountAggregateOutputType> | number
          }
        }
      }
      StudentAttendance: {
        payload: Prisma.$StudentAttendancePayload<ExtArgs>
        fields: Prisma.StudentAttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentAttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentAttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>
          }
          findFirst: {
            args: Prisma.StudentAttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentAttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>
          }
          findMany: {
            args: Prisma.StudentAttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>[]
          }
          create: {
            args: Prisma.StudentAttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>
          }
          createMany: {
            args: Prisma.StudentAttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentAttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>[]
          }
          delete: {
            args: Prisma.StudentAttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>
          }
          update: {
            args: Prisma.StudentAttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>
          }
          deleteMany: {
            args: Prisma.StudentAttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentAttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentAttendanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>[]
          }
          upsert: {
            args: Prisma.StudentAttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>
          }
          aggregate: {
            args: Prisma.StudentAttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentAttendance>
          }
          groupBy: {
            args: Prisma.StudentAttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentAttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentAttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<StudentAttendanceCountAggregateOutputType> | number
          }
        }
      }
      StudentDocument: {
        payload: Prisma.$StudentDocumentPayload<ExtArgs>
        fields: Prisma.StudentDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentDocumentPayload>
          }
          findFirst: {
            args: Prisma.StudentDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentDocumentPayload>
          }
          findMany: {
            args: Prisma.StudentDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentDocumentPayload>[]
          }
          create: {
            args: Prisma.StudentDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentDocumentPayload>
          }
          createMany: {
            args: Prisma.StudentDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentDocumentPayload>[]
          }
          delete: {
            args: Prisma.StudentDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentDocumentPayload>
          }
          update: {
            args: Prisma.StudentDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentDocumentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentDocumentPayload>[]
          }
          upsert: {
            args: Prisma.StudentDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentDocumentPayload>
          }
          aggregate: {
            args: Prisma.StudentDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentDocument>
          }
          groupBy: {
            args: Prisma.StudentDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentDocumentCountAggregateOutputType> | number
          }
        }
      }
      Fee: {
        payload: Prisma.$FeePayload<ExtArgs>
        fields: Prisma.FeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePayload>
          }
          findFirst: {
            args: Prisma.FeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePayload>
          }
          findMany: {
            args: Prisma.FeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePayload>[]
          }
          create: {
            args: Prisma.FeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePayload>
          }
          createMany: {
            args: Prisma.FeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePayload>[]
          }
          delete: {
            args: Prisma.FeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePayload>
          }
          update: {
            args: Prisma.FeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePayload>
          }
          deleteMany: {
            args: Prisma.FeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePayload>[]
          }
          upsert: {
            args: Prisma.FeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePayload>
          }
          aggregate: {
            args: Prisma.FeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFee>
          }
          groupBy: {
            args: Prisma.FeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeeCountArgs<ExtArgs>
            result: $Utils.Optional<FeeCountAggregateOutputType> | number
          }
        }
      }
      FeePayment: {
        payload: Prisma.$FeePaymentPayload<ExtArgs>
        fields: Prisma.FeePaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeePaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeePaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload>
          }
          findFirst: {
            args: Prisma.FeePaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeePaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload>
          }
          findMany: {
            args: Prisma.FeePaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload>[]
          }
          create: {
            args: Prisma.FeePaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload>
          }
          createMany: {
            args: Prisma.FeePaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeePaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload>[]
          }
          delete: {
            args: Prisma.FeePaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload>
          }
          update: {
            args: Prisma.FeePaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload>
          }
          deleteMany: {
            args: Prisma.FeePaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeePaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeePaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload>[]
          }
          upsert: {
            args: Prisma.FeePaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload>
          }
          aggregate: {
            args: Prisma.FeePaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeePayment>
          }
          groupBy: {
            args: Prisma.FeePaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeePaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeePaymentCountArgs<ExtArgs>
            result: $Utils.Optional<FeePaymentCountAggregateOutputType> | number
          }
        }
      }
      ScheduledJob: {
        payload: Prisma.$ScheduledJobPayload<ExtArgs>
        fields: Prisma.ScheduledJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduledJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduledJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledJobPayload>
          }
          findFirst: {
            args: Prisma.ScheduledJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduledJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledJobPayload>
          }
          findMany: {
            args: Prisma.ScheduledJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledJobPayload>[]
          }
          create: {
            args: Prisma.ScheduledJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledJobPayload>
          }
          createMany: {
            args: Prisma.ScheduledJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduledJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledJobPayload>[]
          }
          delete: {
            args: Prisma.ScheduledJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledJobPayload>
          }
          update: {
            args: Prisma.ScheduledJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledJobPayload>
          }
          deleteMany: {
            args: Prisma.ScheduledJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduledJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScheduledJobUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledJobPayload>[]
          }
          upsert: {
            args: Prisma.ScheduledJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledJobPayload>
          }
          aggregate: {
            args: Prisma.ScheduledJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScheduledJob>
          }
          groupBy: {
            args: Prisma.ScheduledJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduledJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduledJobCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduledJobCountAggregateOutputType> | number
          }
        }
      }
      FeeCategory: {
        payload: Prisma.$FeeCategoryPayload<ExtArgs>
        fields: Prisma.FeeCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeeCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeeCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeCategoryPayload>
          }
          findFirst: {
            args: Prisma.FeeCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeeCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeCategoryPayload>
          }
          findMany: {
            args: Prisma.FeeCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeCategoryPayload>[]
          }
          create: {
            args: Prisma.FeeCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeCategoryPayload>
          }
          createMany: {
            args: Prisma.FeeCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeeCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeCategoryPayload>[]
          }
          delete: {
            args: Prisma.FeeCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeCategoryPayload>
          }
          update: {
            args: Prisma.FeeCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeCategoryPayload>
          }
          deleteMany: {
            args: Prisma.FeeCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeeCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeeCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeCategoryPayload>[]
          }
          upsert: {
            args: Prisma.FeeCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeCategoryPayload>
          }
          aggregate: {
            args: Prisma.FeeCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeeCategory>
          }
          groupBy: {
            args: Prisma.FeeCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeeCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeeCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<FeeCategoryCountAggregateOutputType> | number
          }
        }
      }
      AcademicCalendar: {
        payload: Prisma.$AcademicCalendarPayload<ExtArgs>
        fields: Prisma.AcademicCalendarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcademicCalendarFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicCalendarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcademicCalendarFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicCalendarPayload>
          }
          findFirst: {
            args: Prisma.AcademicCalendarFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicCalendarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcademicCalendarFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicCalendarPayload>
          }
          findMany: {
            args: Prisma.AcademicCalendarFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicCalendarPayload>[]
          }
          create: {
            args: Prisma.AcademicCalendarCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicCalendarPayload>
          }
          createMany: {
            args: Prisma.AcademicCalendarCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AcademicCalendarCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicCalendarPayload>[]
          }
          delete: {
            args: Prisma.AcademicCalendarDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicCalendarPayload>
          }
          update: {
            args: Prisma.AcademicCalendarUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicCalendarPayload>
          }
          deleteMany: {
            args: Prisma.AcademicCalendarDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AcademicCalendarUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AcademicCalendarUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicCalendarPayload>[]
          }
          upsert: {
            args: Prisma.AcademicCalendarUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicCalendarPayload>
          }
          aggregate: {
            args: Prisma.AcademicCalendarAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAcademicCalendar>
          }
          groupBy: {
            args: Prisma.AcademicCalendarGroupByArgs<ExtArgs>
            result: $Utils.Optional<AcademicCalendarGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcademicCalendarCountArgs<ExtArgs>
            result: $Utils.Optional<AcademicCalendarCountAggregateOutputType> | number
          }
        }
      }
      AnonymousComplaint: {
        payload: Prisma.$AnonymousComplaintPayload<ExtArgs>
        fields: Prisma.AnonymousComplaintFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnonymousComplaintFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousComplaintPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnonymousComplaintFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousComplaintPayload>
          }
          findFirst: {
            args: Prisma.AnonymousComplaintFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousComplaintPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnonymousComplaintFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousComplaintPayload>
          }
          findMany: {
            args: Prisma.AnonymousComplaintFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousComplaintPayload>[]
          }
          create: {
            args: Prisma.AnonymousComplaintCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousComplaintPayload>
          }
          createMany: {
            args: Prisma.AnonymousComplaintCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnonymousComplaintCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousComplaintPayload>[]
          }
          delete: {
            args: Prisma.AnonymousComplaintDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousComplaintPayload>
          }
          update: {
            args: Prisma.AnonymousComplaintUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousComplaintPayload>
          }
          deleteMany: {
            args: Prisma.AnonymousComplaintDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnonymousComplaintUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnonymousComplaintUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousComplaintPayload>[]
          }
          upsert: {
            args: Prisma.AnonymousComplaintUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousComplaintPayload>
          }
          aggregate: {
            args: Prisma.AnonymousComplaintAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnonymousComplaint>
          }
          groupBy: {
            args: Prisma.AnonymousComplaintGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnonymousComplaintGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnonymousComplaintCountArgs<ExtArgs>
            result: $Utils.Optional<AnonymousComplaintCountAggregateOutputType> | number
          }
        }
      }
      ComplaintStatusTimeline: {
        payload: Prisma.$ComplaintStatusTimelinePayload<ExtArgs>
        fields: Prisma.ComplaintStatusTimelineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComplaintStatusTimelineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintStatusTimelinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComplaintStatusTimelineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintStatusTimelinePayload>
          }
          findFirst: {
            args: Prisma.ComplaintStatusTimelineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintStatusTimelinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComplaintStatusTimelineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintStatusTimelinePayload>
          }
          findMany: {
            args: Prisma.ComplaintStatusTimelineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintStatusTimelinePayload>[]
          }
          create: {
            args: Prisma.ComplaintStatusTimelineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintStatusTimelinePayload>
          }
          createMany: {
            args: Prisma.ComplaintStatusTimelineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComplaintStatusTimelineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintStatusTimelinePayload>[]
          }
          delete: {
            args: Prisma.ComplaintStatusTimelineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintStatusTimelinePayload>
          }
          update: {
            args: Prisma.ComplaintStatusTimelineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintStatusTimelinePayload>
          }
          deleteMany: {
            args: Prisma.ComplaintStatusTimelineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComplaintStatusTimelineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ComplaintStatusTimelineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintStatusTimelinePayload>[]
          }
          upsert: {
            args: Prisma.ComplaintStatusTimelineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintStatusTimelinePayload>
          }
          aggregate: {
            args: Prisma.ComplaintStatusTimelineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComplaintStatusTimeline>
          }
          groupBy: {
            args: Prisma.ComplaintStatusTimelineGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComplaintStatusTimelineGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComplaintStatusTimelineCountArgs<ExtArgs>
            result: $Utils.Optional<ComplaintStatusTimelineCountAggregateOutputType> | number
          }
        }
      }
      Notice: {
        payload: Prisma.$NoticePayload<ExtArgs>
        fields: Prisma.NoticeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NoticeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NoticeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          findFirst: {
            args: Prisma.NoticeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NoticeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          findMany: {
            args: Prisma.NoticeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>[]
          }
          create: {
            args: Prisma.NoticeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          createMany: {
            args: Prisma.NoticeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NoticeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>[]
          }
          delete: {
            args: Prisma.NoticeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          update: {
            args: Prisma.NoticeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          deleteMany: {
            args: Prisma.NoticeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NoticeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NoticeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>[]
          }
          upsert: {
            args: Prisma.NoticeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          aggregate: {
            args: Prisma.NoticeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotice>
          }
          groupBy: {
            args: Prisma.NoticeGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoticeGroupByOutputType>[]
          }
          count: {
            args: Prisma.NoticeCountArgs<ExtArgs>
            result: $Utils.Optional<NoticeCountAggregateOutputType> | number
          }
        }
      }
      NotificationLog: {
        payload: Prisma.$NotificationLogPayload<ExtArgs>
        fields: Prisma.NotificationLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          findFirst: {
            args: Prisma.NotificationLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          findMany: {
            args: Prisma.NotificationLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>[]
          }
          create: {
            args: Prisma.NotificationLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          createMany: {
            args: Prisma.NotificationLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>[]
          }
          delete: {
            args: Prisma.NotificationLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          update: {
            args: Prisma.NotificationLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          deleteMany: {
            args: Prisma.NotificationLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>[]
          }
          upsert: {
            args: Prisma.NotificationLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          aggregate: {
            args: Prisma.NotificationLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationLog>
          }
          groupBy: {
            args: Prisma.NotificationLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationLogCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationLogCountAggregateOutputType> | number
          }
        }
      }
      ExamSession: {
        payload: Prisma.$ExamSessionPayload<ExtArgs>
        fields: Prisma.ExamSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSessionPayload>
          }
          findFirst: {
            args: Prisma.ExamSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSessionPayload>
          }
          findMany: {
            args: Prisma.ExamSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSessionPayload>[]
          }
          create: {
            args: Prisma.ExamSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSessionPayload>
          }
          createMany: {
            args: Prisma.ExamSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExamSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSessionPayload>[]
          }
          delete: {
            args: Prisma.ExamSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSessionPayload>
          }
          update: {
            args: Prisma.ExamSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSessionPayload>
          }
          deleteMany: {
            args: Prisma.ExamSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExamSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSessionPayload>[]
          }
          upsert: {
            args: Prisma.ExamSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSessionPayload>
          }
          aggregate: {
            args: Prisma.ExamSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamSession>
          }
          groupBy: {
            args: Prisma.ExamSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamSessionCountArgs<ExtArgs>
            result: $Utils.Optional<ExamSessionCountAggregateOutputType> | number
          }
        }
      }
      Exam: {
        payload: Prisma.$ExamPayload<ExtArgs>
        fields: Prisma.ExamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          findFirst: {
            args: Prisma.ExamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          findMany: {
            args: Prisma.ExamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          create: {
            args: Prisma.ExamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          createMany: {
            args: Prisma.ExamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          delete: {
            args: Prisma.ExamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          update: {
            args: Prisma.ExamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          deleteMany: {
            args: Prisma.ExamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          upsert: {
            args: Prisma.ExamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          aggregate: {
            args: Prisma.ExamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExam>
          }
          groupBy: {
            args: Prisma.ExamGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamCountArgs<ExtArgs>
            result: $Utils.Optional<ExamCountAggregateOutputType> | number
          }
        }
      }
      ExamEnrollment: {
        payload: Prisma.$ExamEnrollmentPayload<ExtArgs>
        fields: Prisma.ExamEnrollmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamEnrollmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamEnrollmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamEnrollmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamEnrollmentPayload>
          }
          findFirst: {
            args: Prisma.ExamEnrollmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamEnrollmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamEnrollmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamEnrollmentPayload>
          }
          findMany: {
            args: Prisma.ExamEnrollmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamEnrollmentPayload>[]
          }
          create: {
            args: Prisma.ExamEnrollmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamEnrollmentPayload>
          }
          createMany: {
            args: Prisma.ExamEnrollmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExamEnrollmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamEnrollmentPayload>[]
          }
          delete: {
            args: Prisma.ExamEnrollmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamEnrollmentPayload>
          }
          update: {
            args: Prisma.ExamEnrollmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamEnrollmentPayload>
          }
          deleteMany: {
            args: Prisma.ExamEnrollmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamEnrollmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExamEnrollmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamEnrollmentPayload>[]
          }
          upsert: {
            args: Prisma.ExamEnrollmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamEnrollmentPayload>
          }
          aggregate: {
            args: Prisma.ExamEnrollmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamEnrollment>
          }
          groupBy: {
            args: Prisma.ExamEnrollmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamEnrollmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamEnrollmentCountArgs<ExtArgs>
            result: $Utils.Optional<ExamEnrollmentCountAggregateOutputType> | number
          }
        }
      }
      ExamResult: {
        payload: Prisma.$ExamResultPayload<ExtArgs>
        fields: Prisma.ExamResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamResultPayload>
          }
          findFirst: {
            args: Prisma.ExamResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamResultPayload>
          }
          findMany: {
            args: Prisma.ExamResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamResultPayload>[]
          }
          create: {
            args: Prisma.ExamResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamResultPayload>
          }
          createMany: {
            args: Prisma.ExamResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExamResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamResultPayload>[]
          }
          delete: {
            args: Prisma.ExamResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamResultPayload>
          }
          update: {
            args: Prisma.ExamResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamResultPayload>
          }
          deleteMany: {
            args: Prisma.ExamResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExamResultUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamResultPayload>[]
          }
          upsert: {
            args: Prisma.ExamResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamResultPayload>
          }
          aggregate: {
            args: Prisma.ExamResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamResult>
          }
          groupBy: {
            args: Prisma.ExamResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamResultCountArgs<ExtArgs>
            result: $Utils.Optional<ExamResultCountAggregateOutputType> | number
          }
        }
      }
      HallTicket: {
        payload: Prisma.$HallTicketPayload<ExtArgs>
        fields: Prisma.HallTicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HallTicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HallTicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HallTicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HallTicketPayload>
          }
          findFirst: {
            args: Prisma.HallTicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HallTicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HallTicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HallTicketPayload>
          }
          findMany: {
            args: Prisma.HallTicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HallTicketPayload>[]
          }
          create: {
            args: Prisma.HallTicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HallTicketPayload>
          }
          createMany: {
            args: Prisma.HallTicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HallTicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HallTicketPayload>[]
          }
          delete: {
            args: Prisma.HallTicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HallTicketPayload>
          }
          update: {
            args: Prisma.HallTicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HallTicketPayload>
          }
          deleteMany: {
            args: Prisma.HallTicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HallTicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HallTicketUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HallTicketPayload>[]
          }
          upsert: {
            args: Prisma.HallTicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HallTicketPayload>
          }
          aggregate: {
            args: Prisma.HallTicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHallTicket>
          }
          groupBy: {
            args: Prisma.HallTicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<HallTicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.HallTicketCountArgs<ExtArgs>
            result: $Utils.Optional<HallTicketCountAggregateOutputType> | number
          }
        }
      }
      ReportCard: {
        payload: Prisma.$ReportCardPayload<ExtArgs>
        fields: Prisma.ReportCardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportCardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportCardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload>
          }
          findFirst: {
            args: Prisma.ReportCardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportCardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload>
          }
          findMany: {
            args: Prisma.ReportCardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload>[]
          }
          create: {
            args: Prisma.ReportCardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload>
          }
          createMany: {
            args: Prisma.ReportCardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportCardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload>[]
          }
          delete: {
            args: Prisma.ReportCardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload>
          }
          update: {
            args: Prisma.ReportCardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload>
          }
          deleteMany: {
            args: Prisma.ReportCardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportCardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportCardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload>[]
          }
          upsert: {
            args: Prisma.ReportCardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload>
          }
          aggregate: {
            args: Prisma.ReportCardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportCard>
          }
          groupBy: {
            args: Prisma.ReportCardGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportCardGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCardCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCardCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    academicYear?: AcademicYearOmit
    organization?: OrganizationOmit
    user?: UserOmit
    grade?: GradeOmit
    section?: SectionOmit
    teacher?: TeacherOmit
    teacherProfile?: TeacherProfileOmit
    subject?: SubjectOmit
    teachingAssignment?: TeachingAssignmentOmit
    student?: StudentOmit
    parent?: ParentOmit
    parentStudent?: ParentStudentOmit
    studentAttendance?: StudentAttendanceOmit
    studentDocument?: StudentDocumentOmit
    fee?: FeeOmit
    feePayment?: FeePaymentOmit
    scheduledJob?: ScheduledJobOmit
    feeCategory?: FeeCategoryOmit
    academicCalendar?: AcademicCalendarOmit
    anonymousComplaint?: AnonymousComplaintOmit
    complaintStatusTimeline?: ComplaintStatusTimelineOmit
    notice?: NoticeOmit
    notificationLog?: NotificationLogOmit
    examSession?: ExamSessionOmit
    exam?: ExamOmit
    examEnrollment?: ExamEnrollmentOmit
    examResult?: ExamResultOmit
    hallTicket?: HallTicketOmit
    reportCard?: ReportCardOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AcademicYearCountOutputType
   */

  export type AcademicYearCountOutputType = {
    complaints: number
    notices: number
    TeachingAssignment: number
    StudentAttendance: number
    AcademicCalendar: number
    ExamSession: number
  }

  export type AcademicYearCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    complaints?: boolean | AcademicYearCountOutputTypeCountComplaintsArgs
    notices?: boolean | AcademicYearCountOutputTypeCountNoticesArgs
    TeachingAssignment?: boolean | AcademicYearCountOutputTypeCountTeachingAssignmentArgs
    StudentAttendance?: boolean | AcademicYearCountOutputTypeCountStudentAttendanceArgs
    AcademicCalendar?: boolean | AcademicYearCountOutputTypeCountAcademicCalendarArgs
    ExamSession?: boolean | AcademicYearCountOutputTypeCountExamSessionArgs
  }

  // Custom InputTypes
  /**
   * AcademicYearCountOutputType without action
   */
  export type AcademicYearCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYearCountOutputType
     */
    select?: AcademicYearCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AcademicYearCountOutputType without action
   */
  export type AcademicYearCountOutputTypeCountComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnonymousComplaintWhereInput
  }

  /**
   * AcademicYearCountOutputType without action
   */
  export type AcademicYearCountOutputTypeCountNoticesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoticeWhereInput
  }

  /**
   * AcademicYearCountOutputType without action
   */
  export type AcademicYearCountOutputTypeCountTeachingAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeachingAssignmentWhereInput
  }

  /**
   * AcademicYearCountOutputType without action
   */
  export type AcademicYearCountOutputTypeCountStudentAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentAttendanceWhereInput
  }

  /**
   * AcademicYearCountOutputType without action
   */
  export type AcademicYearCountOutputTypeCountAcademicCalendarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicCalendarWhereInput
  }

  /**
   * AcademicYearCountOutputType without action
   */
  export type AcademicYearCountOutputTypeCountExamSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamSessionWhereInput
  }


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    users: number
    notices: number
    Student: number
    StudentDocument: number
    Grade: number
    Section: number
    Fee: number
    FeeCategory: number
    FeePayment: number
    AcademicCalendar: number
    AnonymousComplaint: number
    Teacher: number
    Subject: number
    TeachingAssignment: number
    NotificationLog: number
    AcademicYear: number
    scheduledJob: number
    Exam: number
    hallTicket: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | OrganizationCountOutputTypeCountUsersArgs
    notices?: boolean | OrganizationCountOutputTypeCountNoticesArgs
    Student?: boolean | OrganizationCountOutputTypeCountStudentArgs
    StudentDocument?: boolean | OrganizationCountOutputTypeCountStudentDocumentArgs
    Grade?: boolean | OrganizationCountOutputTypeCountGradeArgs
    Section?: boolean | OrganizationCountOutputTypeCountSectionArgs
    Fee?: boolean | OrganizationCountOutputTypeCountFeeArgs
    FeeCategory?: boolean | OrganizationCountOutputTypeCountFeeCategoryArgs
    FeePayment?: boolean | OrganizationCountOutputTypeCountFeePaymentArgs
    AcademicCalendar?: boolean | OrganizationCountOutputTypeCountAcademicCalendarArgs
    AnonymousComplaint?: boolean | OrganizationCountOutputTypeCountAnonymousComplaintArgs
    Teacher?: boolean | OrganizationCountOutputTypeCountTeacherArgs
    Subject?: boolean | OrganizationCountOutputTypeCountSubjectArgs
    TeachingAssignment?: boolean | OrganizationCountOutputTypeCountTeachingAssignmentArgs
    NotificationLog?: boolean | OrganizationCountOutputTypeCountNotificationLogArgs
    AcademicYear?: boolean | OrganizationCountOutputTypeCountAcademicYearArgs
    scheduledJob?: boolean | OrganizationCountOutputTypeCountScheduledJobArgs
    Exam?: boolean | OrganizationCountOutputTypeCountExamArgs
    hallTicket?: boolean | OrganizationCountOutputTypeCountHallTicketArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountNoticesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoticeWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountStudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountStudentDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentDocumentWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountGradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountSectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountFeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountFeeCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeCategoryWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountFeePaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeePaymentWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountAcademicCalendarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicCalendarWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountAnonymousComplaintArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnonymousComplaintWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountTeacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountSubjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountTeachingAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeachingAssignmentWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountNotificationLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationLogWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountAcademicYearArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicYearWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountScheduledJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledJobWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountExamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountHallTicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HallTicketWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    FeePayment: number
    NotificationLog: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FeePayment?: boolean | UserCountOutputTypeCountFeePaymentArgs
    NotificationLog?: boolean | UserCountOutputTypeCountNotificationLogArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFeePaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeePaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationLogWhereInput
  }


  /**
   * Count Type GradeCountOutputType
   */

  export type GradeCountOutputType = {
    students: number
    section: number
    TeachingAssignment: number
  }

  export type GradeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | GradeCountOutputTypeCountStudentsArgs
    section?: boolean | GradeCountOutputTypeCountSectionArgs
    TeachingAssignment?: boolean | GradeCountOutputTypeCountTeachingAssignmentArgs
  }

  // Custom InputTypes
  /**
   * GradeCountOutputType without action
   */
  export type GradeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeCountOutputType
     */
    select?: GradeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GradeCountOutputType without action
   */
  export type GradeCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * GradeCountOutputType without action
   */
  export type GradeCountOutputTypeCountSectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionWhereInput
  }

  /**
   * GradeCountOutputType without action
   */
  export type GradeCountOutputTypeCountTeachingAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeachingAssignmentWhereInput
  }


  /**
   * Count Type SectionCountOutputType
   */

  export type SectionCountOutputType = {
    students: number
    StudentAttendance: number
    TeachingAssignment: number
  }

  export type SectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | SectionCountOutputTypeCountStudentsArgs
    StudentAttendance?: boolean | SectionCountOutputTypeCountStudentAttendanceArgs
    TeachingAssignment?: boolean | SectionCountOutputTypeCountTeachingAssignmentArgs
  }

  // Custom InputTypes
  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionCountOutputType
     */
    select?: SectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeCountStudentAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentAttendanceWhereInput
  }

  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeCountTeachingAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeachingAssignmentWhereInput
  }


  /**
   * Count Type TeacherCountOutputType
   */

  export type TeacherCountOutputType = {
    TeachingAssignment: number
    Section: number
  }

  export type TeacherCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TeachingAssignment?: boolean | TeacherCountOutputTypeCountTeachingAssignmentArgs
    Section?: boolean | TeacherCountOutputTypeCountSectionArgs
  }

  // Custom InputTypes
  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherCountOutputType
     */
    select?: TeacherCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountTeachingAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeachingAssignmentWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountSectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionWhereInput
  }


  /**
   * Count Type SubjectCountOutputType
   */

  export type SubjectCountOutputType = {
    teachingAssignments: number
    exam: number
    examResult: number
  }

  export type SubjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teachingAssignments?: boolean | SubjectCountOutputTypeCountTeachingAssignmentsArgs
    exam?: boolean | SubjectCountOutputTypeCountExamArgs
    examResult?: boolean | SubjectCountOutputTypeCountExamResultArgs
  }

  // Custom InputTypes
  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectCountOutputType
     */
    select?: SubjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountTeachingAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeachingAssignmentWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountExamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountExamResultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamResultWhereInput
  }


  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    Fee: number
    parents: number
    StudentAttendance: number
    StudentDocument: number
    NotificationLog: number
    reportCard: number
    hallTicket: number
    examResult: number
    examEnrollment: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Fee?: boolean | StudentCountOutputTypeCountFeeArgs
    parents?: boolean | StudentCountOutputTypeCountParentsArgs
    StudentAttendance?: boolean | StudentCountOutputTypeCountStudentAttendanceArgs
    StudentDocument?: boolean | StudentCountOutputTypeCountStudentDocumentArgs
    NotificationLog?: boolean | StudentCountOutputTypeCountNotificationLogArgs
    reportCard?: boolean | StudentCountOutputTypeCountReportCardArgs
    hallTicket?: boolean | StudentCountOutputTypeCountHallTicketArgs
    examResult?: boolean | StudentCountOutputTypeCountExamResultArgs
    examEnrollment?: boolean | StudentCountOutputTypeCountExamEnrollmentArgs
  }

  // Custom InputTypes
  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountFeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountParentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentStudentWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudentAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentAttendanceWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudentDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentDocumentWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountNotificationLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationLogWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountReportCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportCardWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountHallTicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HallTicketWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountExamResultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamResultWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountExamEnrollmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamEnrollmentWhereInput
  }


  /**
   * Count Type ParentCountOutputType
   */

  export type ParentCountOutputType = {
    students: number
    NotificationLog: number
  }

  export type ParentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | ParentCountOutputTypeCountStudentsArgs
    NotificationLog?: boolean | ParentCountOutputTypeCountNotificationLogArgs
  }

  // Custom InputTypes
  /**
   * ParentCountOutputType without action
   */
  export type ParentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentCountOutputType
     */
    select?: ParentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ParentCountOutputType without action
   */
  export type ParentCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentStudentWhereInput
  }

  /**
   * ParentCountOutputType without action
   */
  export type ParentCountOutputTypeCountNotificationLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationLogWhereInput
  }


  /**
   * Count Type FeeCountOutputType
   */

  export type FeeCountOutputType = {
    payments: number
  }

  export type FeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | FeeCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * FeeCountOutputType without action
   */
  export type FeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeCountOutputType
     */
    select?: FeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FeeCountOutputType without action
   */
  export type FeeCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeePaymentWhereInput
  }


  /**
   * Count Type FeeCategoryCountOutputType
   */

  export type FeeCategoryCountOutputType = {
    fees: number
  }

  export type FeeCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fees?: boolean | FeeCategoryCountOutputTypeCountFeesArgs
  }

  // Custom InputTypes
  /**
   * FeeCategoryCountOutputType without action
   */
  export type FeeCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeCategoryCountOutputType
     */
    select?: FeeCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FeeCategoryCountOutputType without action
   */
  export type FeeCategoryCountOutputTypeCountFeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeWhereInput
  }


  /**
   * Count Type AnonymousComplaintCountOutputType
   */

  export type AnonymousComplaintCountOutputType = {
    ComplaintStatusTimeline: number
  }

  export type AnonymousComplaintCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ComplaintStatusTimeline?: boolean | AnonymousComplaintCountOutputTypeCountComplaintStatusTimelineArgs
  }

  // Custom InputTypes
  /**
   * AnonymousComplaintCountOutputType without action
   */
  export type AnonymousComplaintCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousComplaintCountOutputType
     */
    select?: AnonymousComplaintCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AnonymousComplaintCountOutputType without action
   */
  export type AnonymousComplaintCountOutputTypeCountComplaintStatusTimelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintStatusTimelineWhereInput
  }


  /**
   * Count Type ExamSessionCountOutputType
   */

  export type ExamSessionCountOutputType = {
    exams: number
    reportCards: number
    hallTickets: number
  }

  export type ExamSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exams?: boolean | ExamSessionCountOutputTypeCountExamsArgs
    reportCards?: boolean | ExamSessionCountOutputTypeCountReportCardsArgs
    hallTickets?: boolean | ExamSessionCountOutputTypeCountHallTicketsArgs
  }

  // Custom InputTypes
  /**
   * ExamSessionCountOutputType without action
   */
  export type ExamSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSessionCountOutputType
     */
    select?: ExamSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExamSessionCountOutputType without action
   */
  export type ExamSessionCountOutputTypeCountExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
  }

  /**
   * ExamSessionCountOutputType without action
   */
  export type ExamSessionCountOutputTypeCountReportCardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportCardWhereInput
  }

  /**
   * ExamSessionCountOutputType without action
   */
  export type ExamSessionCountOutputTypeCountHallTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HallTicketWhereInput
  }


  /**
   * Count Type ExamCountOutputType
   */

  export type ExamCountOutputType = {
    hallTickets: number
    examResult: number
    examEnrollment: number
  }

  export type ExamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hallTickets?: boolean | ExamCountOutputTypeCountHallTicketsArgs
    examResult?: boolean | ExamCountOutputTypeCountExamResultArgs
    examEnrollment?: boolean | ExamCountOutputTypeCountExamEnrollmentArgs
  }

  // Custom InputTypes
  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCountOutputType
     */
    select?: ExamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeCountHallTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HallTicketWhereInput
  }

  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeCountExamResultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamResultWhereInput
  }

  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeCountExamEnrollmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamEnrollmentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model AcademicYear
   */

  export type AggregateAcademicYear = {
    _count: AcademicYearCountAggregateOutputType | null
    _min: AcademicYearMinAggregateOutputType | null
    _max: AcademicYearMaxAggregateOutputType | null
  }

  export type AcademicYearMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    type: $Enums.YearType | null
    isCurrent: boolean | null
    description: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcademicYearMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    type: $Enums.YearType | null
    isCurrent: boolean | null
    description: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcademicYearCountAggregateOutputType = {
    id: number
    organizationId: number
    name: number
    startDate: number
    endDate: number
    type: number
    isCurrent: number
    description: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AcademicYearMinAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    startDate?: true
    endDate?: true
    type?: true
    isCurrent?: true
    description?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcademicYearMaxAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    startDate?: true
    endDate?: true
    type?: true
    isCurrent?: true
    description?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcademicYearCountAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    startDate?: true
    endDate?: true
    type?: true
    isCurrent?: true
    description?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AcademicYearAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicYear to aggregate.
     */
    where?: AcademicYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicYears to fetch.
     */
    orderBy?: AcademicYearOrderByWithRelationInput | AcademicYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcademicYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AcademicYears
    **/
    _count?: true | AcademicYearCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcademicYearMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcademicYearMaxAggregateInputType
  }

  export type GetAcademicYearAggregateType<T extends AcademicYearAggregateArgs> = {
        [P in keyof T & keyof AggregateAcademicYear]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademicYear[P]>
      : GetScalarType<T[P], AggregateAcademicYear[P]>
  }




  export type AcademicYearGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicYearWhereInput
    orderBy?: AcademicYearOrderByWithAggregationInput | AcademicYearOrderByWithAggregationInput[]
    by: AcademicYearScalarFieldEnum[] | AcademicYearScalarFieldEnum
    having?: AcademicYearScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcademicYearCountAggregateInputType | true
    _min?: AcademicYearMinAggregateInputType
    _max?: AcademicYearMaxAggregateInputType
  }

  export type AcademicYearGroupByOutputType = {
    id: string
    organizationId: string
    name: string
    startDate: Date
    endDate: Date
    type: $Enums.YearType
    isCurrent: boolean
    description: string | null
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: AcademicYearCountAggregateOutputType | null
    _min: AcademicYearMinAggregateOutputType | null
    _max: AcademicYearMaxAggregateOutputType | null
  }

  type GetAcademicYearGroupByPayload<T extends AcademicYearGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcademicYearGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcademicYearGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcademicYearGroupByOutputType[P]>
            : GetScalarType<T[P], AcademicYearGroupByOutputType[P]>
        }
      >
    >


  export type AcademicYearSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    type?: boolean
    isCurrent?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    complaints?: boolean | AcademicYear$complaintsArgs<ExtArgs>
    notices?: boolean | AcademicYear$noticesArgs<ExtArgs>
    TeachingAssignment?: boolean | AcademicYear$TeachingAssignmentArgs<ExtArgs>
    StudentAttendance?: boolean | AcademicYear$StudentAttendanceArgs<ExtArgs>
    AcademicCalendar?: boolean | AcademicYear$AcademicCalendarArgs<ExtArgs>
    ExamSession?: boolean | AcademicYear$ExamSessionArgs<ExtArgs>
    _count?: boolean | AcademicYearCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicYear"]>

  export type AcademicYearSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    type?: boolean
    isCurrent?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicYear"]>

  export type AcademicYearSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    type?: boolean
    isCurrent?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicYear"]>

  export type AcademicYearSelectScalar = {
    id?: boolean
    organizationId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    type?: boolean
    isCurrent?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AcademicYearOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "name" | "startDate" | "endDate" | "type" | "isCurrent" | "description" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["academicYear"]>
  export type AcademicYearInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    complaints?: boolean | AcademicYear$complaintsArgs<ExtArgs>
    notices?: boolean | AcademicYear$noticesArgs<ExtArgs>
    TeachingAssignment?: boolean | AcademicYear$TeachingAssignmentArgs<ExtArgs>
    StudentAttendance?: boolean | AcademicYear$StudentAttendanceArgs<ExtArgs>
    AcademicCalendar?: boolean | AcademicYear$AcademicCalendarArgs<ExtArgs>
    ExamSession?: boolean | AcademicYear$ExamSessionArgs<ExtArgs>
    _count?: boolean | AcademicYearCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AcademicYearIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type AcademicYearIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $AcademicYearPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AcademicYear"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      complaints: Prisma.$AnonymousComplaintPayload<ExtArgs>[]
      notices: Prisma.$NoticePayload<ExtArgs>[]
      TeachingAssignment: Prisma.$TeachingAssignmentPayload<ExtArgs>[]
      StudentAttendance: Prisma.$StudentAttendancePayload<ExtArgs>[]
      AcademicCalendar: Prisma.$AcademicCalendarPayload<ExtArgs>[]
      ExamSession: Prisma.$ExamSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      name: string
      startDate: Date
      endDate: Date
      type: $Enums.YearType
      isCurrent: boolean
      description: string | null
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["academicYear"]>
    composites: {}
  }

  type AcademicYearGetPayload<S extends boolean | null | undefined | AcademicYearDefaultArgs> = $Result.GetResult<Prisma.$AcademicYearPayload, S>

  type AcademicYearCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AcademicYearFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AcademicYearCountAggregateInputType | true
    }

  export interface AcademicYearDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AcademicYear'], meta: { name: 'AcademicYear' } }
    /**
     * Find zero or one AcademicYear that matches the filter.
     * @param {AcademicYearFindUniqueArgs} args - Arguments to find a AcademicYear
     * @example
     * // Get one AcademicYear
     * const academicYear = await prisma.academicYear.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AcademicYearFindUniqueArgs>(args: SelectSubset<T, AcademicYearFindUniqueArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AcademicYear that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AcademicYearFindUniqueOrThrowArgs} args - Arguments to find a AcademicYear
     * @example
     * // Get one AcademicYear
     * const academicYear = await prisma.academicYear.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AcademicYearFindUniqueOrThrowArgs>(args: SelectSubset<T, AcademicYearFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicYear that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearFindFirstArgs} args - Arguments to find a AcademicYear
     * @example
     * // Get one AcademicYear
     * const academicYear = await prisma.academicYear.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AcademicYearFindFirstArgs>(args?: SelectSubset<T, AcademicYearFindFirstArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicYear that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearFindFirstOrThrowArgs} args - Arguments to find a AcademicYear
     * @example
     * // Get one AcademicYear
     * const academicYear = await prisma.academicYear.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AcademicYearFindFirstOrThrowArgs>(args?: SelectSubset<T, AcademicYearFindFirstOrThrowArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AcademicYears that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcademicYears
     * const academicYears = await prisma.academicYear.findMany()
     * 
     * // Get first 10 AcademicYears
     * const academicYears = await prisma.academicYear.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const academicYearWithIdOnly = await prisma.academicYear.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AcademicYearFindManyArgs>(args?: SelectSubset<T, AcademicYearFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AcademicYear.
     * @param {AcademicYearCreateArgs} args - Arguments to create a AcademicYear.
     * @example
     * // Create one AcademicYear
     * const AcademicYear = await prisma.academicYear.create({
     *   data: {
     *     // ... data to create a AcademicYear
     *   }
     * })
     * 
     */
    create<T extends AcademicYearCreateArgs>(args: SelectSubset<T, AcademicYearCreateArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AcademicYears.
     * @param {AcademicYearCreateManyArgs} args - Arguments to create many AcademicYears.
     * @example
     * // Create many AcademicYears
     * const academicYear = await prisma.academicYear.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AcademicYearCreateManyArgs>(args?: SelectSubset<T, AcademicYearCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AcademicYears and returns the data saved in the database.
     * @param {AcademicYearCreateManyAndReturnArgs} args - Arguments to create many AcademicYears.
     * @example
     * // Create many AcademicYears
     * const academicYear = await prisma.academicYear.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AcademicYears and only return the `id`
     * const academicYearWithIdOnly = await prisma.academicYear.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AcademicYearCreateManyAndReturnArgs>(args?: SelectSubset<T, AcademicYearCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AcademicYear.
     * @param {AcademicYearDeleteArgs} args - Arguments to delete one AcademicYear.
     * @example
     * // Delete one AcademicYear
     * const AcademicYear = await prisma.academicYear.delete({
     *   where: {
     *     // ... filter to delete one AcademicYear
     *   }
     * })
     * 
     */
    delete<T extends AcademicYearDeleteArgs>(args: SelectSubset<T, AcademicYearDeleteArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AcademicYear.
     * @param {AcademicYearUpdateArgs} args - Arguments to update one AcademicYear.
     * @example
     * // Update one AcademicYear
     * const academicYear = await prisma.academicYear.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AcademicYearUpdateArgs>(args: SelectSubset<T, AcademicYearUpdateArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AcademicYears.
     * @param {AcademicYearDeleteManyArgs} args - Arguments to filter AcademicYears to delete.
     * @example
     * // Delete a few AcademicYears
     * const { count } = await prisma.academicYear.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AcademicYearDeleteManyArgs>(args?: SelectSubset<T, AcademicYearDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcademicYears
     * const academicYear = await prisma.academicYear.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AcademicYearUpdateManyArgs>(args: SelectSubset<T, AcademicYearUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicYears and returns the data updated in the database.
     * @param {AcademicYearUpdateManyAndReturnArgs} args - Arguments to update many AcademicYears.
     * @example
     * // Update many AcademicYears
     * const academicYear = await prisma.academicYear.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AcademicYears and only return the `id`
     * const academicYearWithIdOnly = await prisma.academicYear.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AcademicYearUpdateManyAndReturnArgs>(args: SelectSubset<T, AcademicYearUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AcademicYear.
     * @param {AcademicYearUpsertArgs} args - Arguments to update or create a AcademicYear.
     * @example
     * // Update or create a AcademicYear
     * const academicYear = await prisma.academicYear.upsert({
     *   create: {
     *     // ... data to create a AcademicYear
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcademicYear we want to update
     *   }
     * })
     */
    upsert<T extends AcademicYearUpsertArgs>(args: SelectSubset<T, AcademicYearUpsertArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AcademicYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearCountArgs} args - Arguments to filter AcademicYears to count.
     * @example
     * // Count the number of AcademicYears
     * const count = await prisma.academicYear.count({
     *   where: {
     *     // ... the filter for the AcademicYears we want to count
     *   }
     * })
    **/
    count<T extends AcademicYearCountArgs>(
      args?: Subset<T, AcademicYearCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcademicYearCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AcademicYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcademicYearAggregateArgs>(args: Subset<T, AcademicYearAggregateArgs>): Prisma.PrismaPromise<GetAcademicYearAggregateType<T>>

    /**
     * Group by AcademicYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcademicYearGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcademicYearGroupByArgs['orderBy'] }
        : { orderBy?: AcademicYearGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcademicYearGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcademicYearGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AcademicYear model
   */
  readonly fields: AcademicYearFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcademicYear.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcademicYearClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    complaints<T extends AcademicYear$complaintsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicYear$complaintsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnonymousComplaintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notices<T extends AcademicYear$noticesArgs<ExtArgs> = {}>(args?: Subset<T, AcademicYear$noticesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TeachingAssignment<T extends AcademicYear$TeachingAssignmentArgs<ExtArgs> = {}>(args?: Subset<T, AcademicYear$TeachingAssignmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeachingAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StudentAttendance<T extends AcademicYear$StudentAttendanceArgs<ExtArgs> = {}>(args?: Subset<T, AcademicYear$StudentAttendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AcademicCalendar<T extends AcademicYear$AcademicCalendarArgs<ExtArgs> = {}>(args?: Subset<T, AcademicYear$AcademicCalendarArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicCalendarPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ExamSession<T extends AcademicYear$ExamSessionArgs<ExtArgs> = {}>(args?: Subset<T, AcademicYear$ExamSessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AcademicYear model
   */
  interface AcademicYearFieldRefs {
    readonly id: FieldRef<"AcademicYear", 'String'>
    readonly organizationId: FieldRef<"AcademicYear", 'String'>
    readonly name: FieldRef<"AcademicYear", 'String'>
    readonly startDate: FieldRef<"AcademicYear", 'DateTime'>
    readonly endDate: FieldRef<"AcademicYear", 'DateTime'>
    readonly type: FieldRef<"AcademicYear", 'YearType'>
    readonly isCurrent: FieldRef<"AcademicYear", 'Boolean'>
    readonly description: FieldRef<"AcademicYear", 'String'>
    readonly createdBy: FieldRef<"AcademicYear", 'String'>
    readonly createdAt: FieldRef<"AcademicYear", 'DateTime'>
    readonly updatedAt: FieldRef<"AcademicYear", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AcademicYear findUnique
   */
  export type AcademicYearFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * Filter, which AcademicYear to fetch.
     */
    where: AcademicYearWhereUniqueInput
  }

  /**
   * AcademicYear findUniqueOrThrow
   */
  export type AcademicYearFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * Filter, which AcademicYear to fetch.
     */
    where: AcademicYearWhereUniqueInput
  }

  /**
   * AcademicYear findFirst
   */
  export type AcademicYearFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * Filter, which AcademicYear to fetch.
     */
    where?: AcademicYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicYears to fetch.
     */
    orderBy?: AcademicYearOrderByWithRelationInput | AcademicYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicYears.
     */
    cursor?: AcademicYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicYears.
     */
    distinct?: AcademicYearScalarFieldEnum | AcademicYearScalarFieldEnum[]
  }

  /**
   * AcademicYear findFirstOrThrow
   */
  export type AcademicYearFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * Filter, which AcademicYear to fetch.
     */
    where?: AcademicYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicYears to fetch.
     */
    orderBy?: AcademicYearOrderByWithRelationInput | AcademicYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicYears.
     */
    cursor?: AcademicYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicYears.
     */
    distinct?: AcademicYearScalarFieldEnum | AcademicYearScalarFieldEnum[]
  }

  /**
   * AcademicYear findMany
   */
  export type AcademicYearFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * Filter, which AcademicYears to fetch.
     */
    where?: AcademicYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicYears to fetch.
     */
    orderBy?: AcademicYearOrderByWithRelationInput | AcademicYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AcademicYears.
     */
    cursor?: AcademicYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicYears.
     */
    skip?: number
    distinct?: AcademicYearScalarFieldEnum | AcademicYearScalarFieldEnum[]
  }

  /**
   * AcademicYear create
   */
  export type AcademicYearCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * The data needed to create a AcademicYear.
     */
    data: XOR<AcademicYearCreateInput, AcademicYearUncheckedCreateInput>
  }

  /**
   * AcademicYear createMany
   */
  export type AcademicYearCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AcademicYears.
     */
    data: AcademicYearCreateManyInput | AcademicYearCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AcademicYear createManyAndReturn
   */
  export type AcademicYearCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * The data used to create many AcademicYears.
     */
    data: AcademicYearCreateManyInput | AcademicYearCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AcademicYear update
   */
  export type AcademicYearUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * The data needed to update a AcademicYear.
     */
    data: XOR<AcademicYearUpdateInput, AcademicYearUncheckedUpdateInput>
    /**
     * Choose, which AcademicYear to update.
     */
    where: AcademicYearWhereUniqueInput
  }

  /**
   * AcademicYear updateMany
   */
  export type AcademicYearUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AcademicYears.
     */
    data: XOR<AcademicYearUpdateManyMutationInput, AcademicYearUncheckedUpdateManyInput>
    /**
     * Filter which AcademicYears to update
     */
    where?: AcademicYearWhereInput
    /**
     * Limit how many AcademicYears to update.
     */
    limit?: number
  }

  /**
   * AcademicYear updateManyAndReturn
   */
  export type AcademicYearUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * The data used to update AcademicYears.
     */
    data: XOR<AcademicYearUpdateManyMutationInput, AcademicYearUncheckedUpdateManyInput>
    /**
     * Filter which AcademicYears to update
     */
    where?: AcademicYearWhereInput
    /**
     * Limit how many AcademicYears to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AcademicYear upsert
   */
  export type AcademicYearUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * The filter to search for the AcademicYear to update in case it exists.
     */
    where: AcademicYearWhereUniqueInput
    /**
     * In case the AcademicYear found by the `where` argument doesn't exist, create a new AcademicYear with this data.
     */
    create: XOR<AcademicYearCreateInput, AcademicYearUncheckedCreateInput>
    /**
     * In case the AcademicYear was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcademicYearUpdateInput, AcademicYearUncheckedUpdateInput>
  }

  /**
   * AcademicYear delete
   */
  export type AcademicYearDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * Filter which AcademicYear to delete.
     */
    where: AcademicYearWhereUniqueInput
  }

  /**
   * AcademicYear deleteMany
   */
  export type AcademicYearDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicYears to delete
     */
    where?: AcademicYearWhereInput
    /**
     * Limit how many AcademicYears to delete.
     */
    limit?: number
  }

  /**
   * AcademicYear.complaints
   */
  export type AcademicYear$complaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousComplaint
     */
    select?: AnonymousComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnonymousComplaint
     */
    omit?: AnonymousComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousComplaintInclude<ExtArgs> | null
    where?: AnonymousComplaintWhereInput
    orderBy?: AnonymousComplaintOrderByWithRelationInput | AnonymousComplaintOrderByWithRelationInput[]
    cursor?: AnonymousComplaintWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnonymousComplaintScalarFieldEnum | AnonymousComplaintScalarFieldEnum[]
  }

  /**
   * AcademicYear.notices
   */
  export type AcademicYear$noticesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    where?: NoticeWhereInput
    orderBy?: NoticeOrderByWithRelationInput | NoticeOrderByWithRelationInput[]
    cursor?: NoticeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoticeScalarFieldEnum | NoticeScalarFieldEnum[]
  }

  /**
   * AcademicYear.TeachingAssignment
   */
  export type AcademicYear$TeachingAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingAssignment
     */
    select?: TeachingAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeachingAssignment
     */
    omit?: TeachingAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingAssignmentInclude<ExtArgs> | null
    where?: TeachingAssignmentWhereInput
    orderBy?: TeachingAssignmentOrderByWithRelationInput | TeachingAssignmentOrderByWithRelationInput[]
    cursor?: TeachingAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeachingAssignmentScalarFieldEnum | TeachingAssignmentScalarFieldEnum[]
  }

  /**
   * AcademicYear.StudentAttendance
   */
  export type AcademicYear$StudentAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    where?: StudentAttendanceWhereInput
    orderBy?: StudentAttendanceOrderByWithRelationInput | StudentAttendanceOrderByWithRelationInput[]
    cursor?: StudentAttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentAttendanceScalarFieldEnum | StudentAttendanceScalarFieldEnum[]
  }

  /**
   * AcademicYear.AcademicCalendar
   */
  export type AcademicYear$AcademicCalendarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCalendar
     */
    select?: AcademicCalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicCalendar
     */
    omit?: AcademicCalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCalendarInclude<ExtArgs> | null
    where?: AcademicCalendarWhereInput
    orderBy?: AcademicCalendarOrderByWithRelationInput | AcademicCalendarOrderByWithRelationInput[]
    cursor?: AcademicCalendarWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AcademicCalendarScalarFieldEnum | AcademicCalendarScalarFieldEnum[]
  }

  /**
   * AcademicYear.ExamSession
   */
  export type AcademicYear$ExamSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSession
     */
    select?: ExamSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamSession
     */
    omit?: ExamSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSessionInclude<ExtArgs> | null
    where?: ExamSessionWhereInput
    orderBy?: ExamSessionOrderByWithRelationInput | ExamSessionOrderByWithRelationInput[]
    cursor?: ExamSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamSessionScalarFieldEnum | ExamSessionScalarFieldEnum[]
  }

  /**
   * AcademicYear without action
   */
  export type AcademicYearDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
  }


  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _avg: OrganizationAvgAggregateOutputType | null
    _sum: OrganizationSumAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationAvgAggregateOutputType = {
    maxStudents: number | null
  }

  export type OrganizationSumAggregateOutputType = {
    maxStudents: number | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    name: string | null
    organizationSlug: string | null
    organizationLogo: string | null
    contactEmail: string | null
    contactPhone: string | null
    website: string | null
    isActive: boolean | null
    isPaid: boolean | null
    plan: $Enums.PlanType | null
    planStartedAt: Date | null
    planExpiresAt: Date | null
    maxStudents: number | null
    organizationType: $Enums.OrganizationType | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    organizationSlug: string | null
    organizationLogo: string | null
    contactEmail: string | null
    contactPhone: string | null
    website: string | null
    isActive: boolean | null
    isPaid: boolean | null
    plan: $Enums.PlanType | null
    planStartedAt: Date | null
    planExpiresAt: Date | null
    maxStudents: number | null
    organizationType: $Enums.OrganizationType | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    name: number
    organizationSlug: number
    organizationLogo: number
    contactEmail: number
    contactPhone: number
    website: number
    isActive: number
    isPaid: number
    plan: number
    planStartedAt: number
    planExpiresAt: number
    maxStudents: number
    organizationType: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrganizationAvgAggregateInputType = {
    maxStudents?: true
  }

  export type OrganizationSumAggregateInputType = {
    maxStudents?: true
  }

  export type OrganizationMinAggregateInputType = {
    id?: true
    name?: true
    organizationSlug?: true
    organizationLogo?: true
    contactEmail?: true
    contactPhone?: true
    website?: true
    isActive?: true
    isPaid?: true
    plan?: true
    planStartedAt?: true
    planExpiresAt?: true
    maxStudents?: true
    organizationType?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    organizationSlug?: true
    organizationLogo?: true
    contactEmail?: true
    contactPhone?: true
    website?: true
    isActive?: true
    isPaid?: true
    plan?: true
    planStartedAt?: true
    planExpiresAt?: true
    maxStudents?: true
    organizationType?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    name?: true
    organizationSlug?: true
    organizationLogo?: true
    contactEmail?: true
    contactPhone?: true
    website?: true
    isActive?: true
    isPaid?: true
    plan?: true
    planStartedAt?: true
    planExpiresAt?: true
    maxStudents?: true
    organizationType?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganizationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganizationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _avg?: OrganizationAvgAggregateInputType
    _sum?: OrganizationSumAggregateInputType
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    name: string | null
    organizationSlug: string
    organizationLogo: string | null
    contactEmail: string | null
    contactPhone: string | null
    website: string | null
    isActive: boolean
    isPaid: boolean
    plan: $Enums.PlanType
    planStartedAt: Date | null
    planExpiresAt: Date | null
    maxStudents: number | null
    organizationType: $Enums.OrganizationType | null
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: OrganizationCountAggregateOutputType | null
    _avg: OrganizationAvgAggregateOutputType | null
    _sum: OrganizationSumAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    organizationSlug?: boolean
    organizationLogo?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    website?: boolean
    isActive?: boolean
    isPaid?: boolean
    plan?: boolean
    planStartedAt?: boolean
    planExpiresAt?: boolean
    maxStudents?: boolean
    organizationType?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Organization$usersArgs<ExtArgs>
    notices?: boolean | Organization$noticesArgs<ExtArgs>
    Student?: boolean | Organization$StudentArgs<ExtArgs>
    StudentDocument?: boolean | Organization$StudentDocumentArgs<ExtArgs>
    Grade?: boolean | Organization$GradeArgs<ExtArgs>
    Section?: boolean | Organization$SectionArgs<ExtArgs>
    Fee?: boolean | Organization$FeeArgs<ExtArgs>
    FeeCategory?: boolean | Organization$FeeCategoryArgs<ExtArgs>
    FeePayment?: boolean | Organization$FeePaymentArgs<ExtArgs>
    AcademicCalendar?: boolean | Organization$AcademicCalendarArgs<ExtArgs>
    AnonymousComplaint?: boolean | Organization$AnonymousComplaintArgs<ExtArgs>
    Teacher?: boolean | Organization$TeacherArgs<ExtArgs>
    Subject?: boolean | Organization$SubjectArgs<ExtArgs>
    TeachingAssignment?: boolean | Organization$TeachingAssignmentArgs<ExtArgs>
    NotificationLog?: boolean | Organization$NotificationLogArgs<ExtArgs>
    AcademicYear?: boolean | Organization$AcademicYearArgs<ExtArgs>
    scheduledJob?: boolean | Organization$scheduledJobArgs<ExtArgs>
    Exam?: boolean | Organization$ExamArgs<ExtArgs>
    hallTicket?: boolean | Organization$hallTicketArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    organizationSlug?: boolean
    organizationLogo?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    website?: boolean
    isActive?: boolean
    isPaid?: boolean
    plan?: boolean
    planStartedAt?: boolean
    planExpiresAt?: boolean
    maxStudents?: boolean
    organizationType?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    organizationSlug?: boolean
    organizationLogo?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    website?: boolean
    isActive?: boolean
    isPaid?: boolean
    plan?: boolean
    planStartedAt?: boolean
    planExpiresAt?: boolean
    maxStudents?: boolean
    organizationType?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    name?: boolean
    organizationSlug?: boolean
    organizationLogo?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    website?: boolean
    isActive?: boolean
    isPaid?: boolean
    plan?: boolean
    planStartedAt?: boolean
    planExpiresAt?: boolean
    maxStudents?: boolean
    organizationType?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrganizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "organizationSlug" | "organizationLogo" | "contactEmail" | "contactPhone" | "website" | "isActive" | "isPaid" | "plan" | "planStartedAt" | "planExpiresAt" | "maxStudents" | "organizationType" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["organization"]>
  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Organization$usersArgs<ExtArgs>
    notices?: boolean | Organization$noticesArgs<ExtArgs>
    Student?: boolean | Organization$StudentArgs<ExtArgs>
    StudentDocument?: boolean | Organization$StudentDocumentArgs<ExtArgs>
    Grade?: boolean | Organization$GradeArgs<ExtArgs>
    Section?: boolean | Organization$SectionArgs<ExtArgs>
    Fee?: boolean | Organization$FeeArgs<ExtArgs>
    FeeCategory?: boolean | Organization$FeeCategoryArgs<ExtArgs>
    FeePayment?: boolean | Organization$FeePaymentArgs<ExtArgs>
    AcademicCalendar?: boolean | Organization$AcademicCalendarArgs<ExtArgs>
    AnonymousComplaint?: boolean | Organization$AnonymousComplaintArgs<ExtArgs>
    Teacher?: boolean | Organization$TeacherArgs<ExtArgs>
    Subject?: boolean | Organization$SubjectArgs<ExtArgs>
    TeachingAssignment?: boolean | Organization$TeachingAssignmentArgs<ExtArgs>
    NotificationLog?: boolean | Organization$NotificationLogArgs<ExtArgs>
    AcademicYear?: boolean | Organization$AcademicYearArgs<ExtArgs>
    scheduledJob?: boolean | Organization$scheduledJobArgs<ExtArgs>
    Exam?: boolean | Organization$ExamArgs<ExtArgs>
    hallTicket?: boolean | Organization$hallTicketArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OrganizationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      notices: Prisma.$NoticePayload<ExtArgs>[]
      Student: Prisma.$StudentPayload<ExtArgs>[]
      StudentDocument: Prisma.$StudentDocumentPayload<ExtArgs>[]
      Grade: Prisma.$GradePayload<ExtArgs>[]
      Section: Prisma.$SectionPayload<ExtArgs>[]
      Fee: Prisma.$FeePayload<ExtArgs>[]
      FeeCategory: Prisma.$FeeCategoryPayload<ExtArgs>[]
      FeePayment: Prisma.$FeePaymentPayload<ExtArgs>[]
      AcademicCalendar: Prisma.$AcademicCalendarPayload<ExtArgs>[]
      AnonymousComplaint: Prisma.$AnonymousComplaintPayload<ExtArgs>[]
      Teacher: Prisma.$TeacherPayload<ExtArgs>[]
      Subject: Prisma.$SubjectPayload<ExtArgs>[]
      TeachingAssignment: Prisma.$TeachingAssignmentPayload<ExtArgs>[]
      NotificationLog: Prisma.$NotificationLogPayload<ExtArgs>[]
      AcademicYear: Prisma.$AcademicYearPayload<ExtArgs>[]
      scheduledJob: Prisma.$ScheduledJobPayload<ExtArgs>[]
      Exam: Prisma.$ExamPayload<ExtArgs>[]
      hallTicket: Prisma.$HallTicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      organizationSlug: string
      organizationLogo: string | null
      contactEmail: string | null
      contactPhone: string | null
      website: string | null
      isActive: boolean
      isPaid: boolean
      plan: $Enums.PlanType
      planStartedAt: Date | null
      planExpiresAt: Date | null
      maxStudents: number | null
      organizationType: $Enums.OrganizationType | null
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations and returns the data updated in the database.
     * @param {OrganizationUpdateManyAndReturnArgs} args - Arguments to update many Organizations.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Organization$usersArgs<ExtArgs> = {}>(args?: Subset<T, Organization$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notices<T extends Organization$noticesArgs<ExtArgs> = {}>(args?: Subset<T, Organization$noticesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Student<T extends Organization$StudentArgs<ExtArgs> = {}>(args?: Subset<T, Organization$StudentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StudentDocument<T extends Organization$StudentDocumentArgs<ExtArgs> = {}>(args?: Subset<T, Organization$StudentDocumentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Grade<T extends Organization$GradeArgs<ExtArgs> = {}>(args?: Subset<T, Organization$GradeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Section<T extends Organization$SectionArgs<ExtArgs> = {}>(args?: Subset<T, Organization$SectionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Fee<T extends Organization$FeeArgs<ExtArgs> = {}>(args?: Subset<T, Organization$FeeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    FeeCategory<T extends Organization$FeeCategoryArgs<ExtArgs> = {}>(args?: Subset<T, Organization$FeeCategoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    FeePayment<T extends Organization$FeePaymentArgs<ExtArgs> = {}>(args?: Subset<T, Organization$FeePaymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AcademicCalendar<T extends Organization$AcademicCalendarArgs<ExtArgs> = {}>(args?: Subset<T, Organization$AcademicCalendarArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicCalendarPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AnonymousComplaint<T extends Organization$AnonymousComplaintArgs<ExtArgs> = {}>(args?: Subset<T, Organization$AnonymousComplaintArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnonymousComplaintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Teacher<T extends Organization$TeacherArgs<ExtArgs> = {}>(args?: Subset<T, Organization$TeacherArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Subject<T extends Organization$SubjectArgs<ExtArgs> = {}>(args?: Subset<T, Organization$SubjectArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TeachingAssignment<T extends Organization$TeachingAssignmentArgs<ExtArgs> = {}>(args?: Subset<T, Organization$TeachingAssignmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeachingAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    NotificationLog<T extends Organization$NotificationLogArgs<ExtArgs> = {}>(args?: Subset<T, Organization$NotificationLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AcademicYear<T extends Organization$AcademicYearArgs<ExtArgs> = {}>(args?: Subset<T, Organization$AcademicYearArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    scheduledJob<T extends Organization$scheduledJobArgs<ExtArgs> = {}>(args?: Subset<T, Organization$scheduledJobArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledJobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Exam<T extends Organization$ExamArgs<ExtArgs> = {}>(args?: Subset<T, Organization$ExamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    hallTicket<T extends Organization$hallTicketArgs<ExtArgs> = {}>(args?: Subset<T, Organization$hallTicketArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HallTicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'String'>
    readonly name: FieldRef<"Organization", 'String'>
    readonly organizationSlug: FieldRef<"Organization", 'String'>
    readonly organizationLogo: FieldRef<"Organization", 'String'>
    readonly contactEmail: FieldRef<"Organization", 'String'>
    readonly contactPhone: FieldRef<"Organization", 'String'>
    readonly website: FieldRef<"Organization", 'String'>
    readonly isActive: FieldRef<"Organization", 'Boolean'>
    readonly isPaid: FieldRef<"Organization", 'Boolean'>
    readonly plan: FieldRef<"Organization", 'PlanType'>
    readonly planStartedAt: FieldRef<"Organization", 'DateTime'>
    readonly planExpiresAt: FieldRef<"Organization", 'DateTime'>
    readonly maxStudents: FieldRef<"Organization", 'Int'>
    readonly organizationType: FieldRef<"Organization", 'OrganizationType'>
    readonly createdBy: FieldRef<"Organization", 'String'>
    readonly createdAt: FieldRef<"Organization", 'DateTime'>
    readonly updatedAt: FieldRef<"Organization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization updateManyAndReturn
   */
  export type OrganizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to delete.
     */
    limit?: number
  }

  /**
   * Organization.users
   */
  export type Organization$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Organization.notices
   */
  export type Organization$noticesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    where?: NoticeWhereInput
    orderBy?: NoticeOrderByWithRelationInput | NoticeOrderByWithRelationInput[]
    cursor?: NoticeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoticeScalarFieldEnum | NoticeScalarFieldEnum[]
  }

  /**
   * Organization.Student
   */
  export type Organization$StudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Organization.StudentDocument
   */
  export type Organization$StudentDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentDocument
     */
    omit?: StudentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentInclude<ExtArgs> | null
    where?: StudentDocumentWhereInput
    orderBy?: StudentDocumentOrderByWithRelationInput | StudentDocumentOrderByWithRelationInput[]
    cursor?: StudentDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentDocumentScalarFieldEnum | StudentDocumentScalarFieldEnum[]
  }

  /**
   * Organization.Grade
   */
  export type Organization$GradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    where?: GradeWhereInput
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    cursor?: GradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Organization.Section
   */
  export type Organization$SectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    where?: SectionWhereInput
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    cursor?: SectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Organization.Fee
   */
  export type Organization$FeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fee
     */
    omit?: FeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeInclude<ExtArgs> | null
    where?: FeeWhereInput
    orderBy?: FeeOrderByWithRelationInput | FeeOrderByWithRelationInput[]
    cursor?: FeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeeScalarFieldEnum | FeeScalarFieldEnum[]
  }

  /**
   * Organization.FeeCategory
   */
  export type Organization$FeeCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeCategory
     */
    select?: FeeCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeCategory
     */
    omit?: FeeCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeCategoryInclude<ExtArgs> | null
    where?: FeeCategoryWhereInput
    orderBy?: FeeCategoryOrderByWithRelationInput | FeeCategoryOrderByWithRelationInput[]
    cursor?: FeeCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeeCategoryScalarFieldEnum | FeeCategoryScalarFieldEnum[]
  }

  /**
   * Organization.FeePayment
   */
  export type Organization$FeePaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeePayment
     */
    omit?: FeePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
    where?: FeePaymentWhereInput
    orderBy?: FeePaymentOrderByWithRelationInput | FeePaymentOrderByWithRelationInput[]
    cursor?: FeePaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeePaymentScalarFieldEnum | FeePaymentScalarFieldEnum[]
  }

  /**
   * Organization.AcademicCalendar
   */
  export type Organization$AcademicCalendarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCalendar
     */
    select?: AcademicCalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicCalendar
     */
    omit?: AcademicCalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCalendarInclude<ExtArgs> | null
    where?: AcademicCalendarWhereInput
    orderBy?: AcademicCalendarOrderByWithRelationInput | AcademicCalendarOrderByWithRelationInput[]
    cursor?: AcademicCalendarWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AcademicCalendarScalarFieldEnum | AcademicCalendarScalarFieldEnum[]
  }

  /**
   * Organization.AnonymousComplaint
   */
  export type Organization$AnonymousComplaintArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousComplaint
     */
    select?: AnonymousComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnonymousComplaint
     */
    omit?: AnonymousComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousComplaintInclude<ExtArgs> | null
    where?: AnonymousComplaintWhereInput
    orderBy?: AnonymousComplaintOrderByWithRelationInput | AnonymousComplaintOrderByWithRelationInput[]
    cursor?: AnonymousComplaintWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnonymousComplaintScalarFieldEnum | AnonymousComplaintScalarFieldEnum[]
  }

  /**
   * Organization.Teacher
   */
  export type Organization$TeacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    where?: TeacherWhereInput
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    cursor?: TeacherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Organization.Subject
   */
  export type Organization$SubjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    cursor?: SubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Organization.TeachingAssignment
   */
  export type Organization$TeachingAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingAssignment
     */
    select?: TeachingAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeachingAssignment
     */
    omit?: TeachingAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingAssignmentInclude<ExtArgs> | null
    where?: TeachingAssignmentWhereInput
    orderBy?: TeachingAssignmentOrderByWithRelationInput | TeachingAssignmentOrderByWithRelationInput[]
    cursor?: TeachingAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeachingAssignmentScalarFieldEnum | TeachingAssignmentScalarFieldEnum[]
  }

  /**
   * Organization.NotificationLog
   */
  export type Organization$NotificationLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    where?: NotificationLogWhereInput
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    cursor?: NotificationLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * Organization.AcademicYear
   */
  export type Organization$AcademicYearArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    where?: AcademicYearWhereInput
    orderBy?: AcademicYearOrderByWithRelationInput | AcademicYearOrderByWithRelationInput[]
    cursor?: AcademicYearWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AcademicYearScalarFieldEnum | AcademicYearScalarFieldEnum[]
  }

  /**
   * Organization.scheduledJob
   */
  export type Organization$scheduledJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledJob
     */
    select?: ScheduledJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledJob
     */
    omit?: ScheduledJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledJobInclude<ExtArgs> | null
    where?: ScheduledJobWhereInput
    orderBy?: ScheduledJobOrderByWithRelationInput | ScheduledJobOrderByWithRelationInput[]
    cursor?: ScheduledJobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduledJobScalarFieldEnum | ScheduledJobScalarFieldEnum[]
  }

  /**
   * Organization.Exam
   */
  export type Organization$ExamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    cursor?: ExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Organization.hallTicket
   */
  export type Organization$hallTicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HallTicket
     */
    select?: HallTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HallTicket
     */
    omit?: HallTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallTicketInclude<ExtArgs> | null
    where?: HallTicketWhereInput
    orderBy?: HallTicketOrderByWithRelationInput | HallTicketOrderByWithRelationInput[]
    cursor?: HallTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HallTicketScalarFieldEnum | HallTicketScalarFieldEnum[]
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    password: string | null
    profileImage: string | null
    role: $Enums.Role | null
    clerkId: string | null
    isActive: boolean | null
    organizationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    password: string | null
    profileImage: string | null
    role: $Enums.Role | null
    clerkId: string | null
    isActive: boolean | null
    organizationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    password: number
    profileImage: number
    role: number
    clerkId: number
    isActive: number
    organizationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    profileImage?: true
    role?: true
    clerkId?: true
    isActive?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    profileImage?: true
    role?: true
    clerkId?: true
    isActive?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    profileImage?: true
    role?: true
    clerkId?: true
    isActive?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    email: string
    password: string | null
    profileImage: string
    role: $Enums.Role
    clerkId: string
    isActive: boolean
    organizationId: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    profileImage?: boolean
    role?: boolean
    clerkId?: boolean
    isActive?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | User$organizationArgs<ExtArgs>
    teacher?: boolean | User$teacherArgs<ExtArgs>
    student?: boolean | User$studentArgs<ExtArgs>
    parent?: boolean | User$parentArgs<ExtArgs>
    FeePayment?: boolean | User$FeePaymentArgs<ExtArgs>
    NotificationLog?: boolean | User$NotificationLogArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    profileImage?: boolean
    role?: boolean
    clerkId?: boolean
    isActive?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | User$organizationArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    profileImage?: boolean
    role?: boolean
    clerkId?: boolean
    isActive?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | User$organizationArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    profileImage?: boolean
    role?: boolean
    clerkId?: boolean
    isActive?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName" | "email" | "password" | "profileImage" | "role" | "clerkId" | "isActive" | "organizationId" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | User$organizationArgs<ExtArgs>
    teacher?: boolean | User$teacherArgs<ExtArgs>
    student?: boolean | User$studentArgs<ExtArgs>
    parent?: boolean | User$parentArgs<ExtArgs>
    FeePayment?: boolean | User$FeePaymentArgs<ExtArgs>
    NotificationLog?: boolean | User$NotificationLogArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | User$organizationArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | User$organizationArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
      teacher: Prisma.$TeacherPayload<ExtArgs> | null
      student: Prisma.$StudentPayload<ExtArgs> | null
      parent: Prisma.$ParentPayload<ExtArgs> | null
      FeePayment: Prisma.$FeePaymentPayload<ExtArgs>[]
      NotificationLog: Prisma.$NotificationLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      lastName: string
      email: string
      password: string | null
      profileImage: string
      role: $Enums.Role
      clerkId: string
      isActive: boolean
      organizationId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends User$organizationArgs<ExtArgs> = {}>(args?: Subset<T, User$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    teacher<T extends User$teacherArgs<ExtArgs> = {}>(args?: Subset<T, User$teacherArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    student<T extends User$studentArgs<ExtArgs> = {}>(args?: Subset<T, User$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    parent<T extends User$parentArgs<ExtArgs> = {}>(args?: Subset<T, User$parentArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    FeePayment<T extends User$FeePaymentArgs<ExtArgs> = {}>(args?: Subset<T, User$FeePaymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    NotificationLog<T extends User$NotificationLogArgs<ExtArgs> = {}>(args?: Subset<T, User$NotificationLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly profileImage: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly clerkId: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly organizationId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.organization
   */
  export type User$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * User.teacher
   */
  export type User$teacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    where?: TeacherWhereInput
  }

  /**
   * User.student
   */
  export type User$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * User.parent
   */
  export type User$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    where?: ParentWhereInput
  }

  /**
   * User.FeePayment
   */
  export type User$FeePaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeePayment
     */
    omit?: FeePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
    where?: FeePaymentWhereInput
    orderBy?: FeePaymentOrderByWithRelationInput | FeePaymentOrderByWithRelationInput[]
    cursor?: FeePaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeePaymentScalarFieldEnum | FeePaymentScalarFieldEnum[]
  }

  /**
   * User.NotificationLog
   */
  export type User$NotificationLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    where?: NotificationLogWhereInput
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    cursor?: NotificationLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Grade
   */

  export type AggregateGrade = {
    _count: GradeCountAggregateOutputType | null
    _min: GradeMinAggregateOutputType | null
    _max: GradeMaxAggregateOutputType | null
  }

  export type GradeMinAggregateOutputType = {
    id: string | null
    grade: string | null
    organizationId: string | null
  }

  export type GradeMaxAggregateOutputType = {
    id: string | null
    grade: string | null
    organizationId: string | null
  }

  export type GradeCountAggregateOutputType = {
    id: number
    grade: number
    organizationId: number
    _all: number
  }


  export type GradeMinAggregateInputType = {
    id?: true
    grade?: true
    organizationId?: true
  }

  export type GradeMaxAggregateInputType = {
    id?: true
    grade?: true
    organizationId?: true
  }

  export type GradeCountAggregateInputType = {
    id?: true
    grade?: true
    organizationId?: true
    _all?: true
  }

  export type GradeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Grade to aggregate.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Grades
    **/
    _count?: true | GradeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GradeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GradeMaxAggregateInputType
  }

  export type GetGradeAggregateType<T extends GradeAggregateArgs> = {
        [P in keyof T & keyof AggregateGrade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrade[P]>
      : GetScalarType<T[P], AggregateGrade[P]>
  }




  export type GradeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeWhereInput
    orderBy?: GradeOrderByWithAggregationInput | GradeOrderByWithAggregationInput[]
    by: GradeScalarFieldEnum[] | GradeScalarFieldEnum
    having?: GradeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GradeCountAggregateInputType | true
    _min?: GradeMinAggregateInputType
    _max?: GradeMaxAggregateInputType
  }

  export type GradeGroupByOutputType = {
    id: string
    grade: string
    organizationId: string
    _count: GradeCountAggregateOutputType | null
    _min: GradeMinAggregateOutputType | null
    _max: GradeMaxAggregateOutputType | null
  }

  type GetGradeGroupByPayload<T extends GradeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GradeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GradeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GradeGroupByOutputType[P]>
            : GetScalarType<T[P], GradeGroupByOutputType[P]>
        }
      >
    >


  export type GradeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    grade?: boolean
    organizationId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    students?: boolean | Grade$studentsArgs<ExtArgs>
    section?: boolean | Grade$sectionArgs<ExtArgs>
    TeachingAssignment?: boolean | Grade$TeachingAssignmentArgs<ExtArgs>
    _count?: boolean | GradeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grade"]>

  export type GradeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    grade?: boolean
    organizationId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grade"]>

  export type GradeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    grade?: boolean
    organizationId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grade"]>

  export type GradeSelectScalar = {
    id?: boolean
    grade?: boolean
    organizationId?: boolean
  }

  export type GradeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "grade" | "organizationId", ExtArgs["result"]["grade"]>
  export type GradeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    students?: boolean | Grade$studentsArgs<ExtArgs>
    section?: boolean | Grade$sectionArgs<ExtArgs>
    TeachingAssignment?: boolean | Grade$TeachingAssignmentArgs<ExtArgs>
    _count?: boolean | GradeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GradeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type GradeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $GradePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Grade"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      students: Prisma.$StudentPayload<ExtArgs>[]
      section: Prisma.$SectionPayload<ExtArgs>[]
      TeachingAssignment: Prisma.$TeachingAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      grade: string
      organizationId: string
    }, ExtArgs["result"]["grade"]>
    composites: {}
  }

  type GradeGetPayload<S extends boolean | null | undefined | GradeDefaultArgs> = $Result.GetResult<Prisma.$GradePayload, S>

  type GradeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GradeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GradeCountAggregateInputType | true
    }

  export interface GradeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Grade'], meta: { name: 'Grade' } }
    /**
     * Find zero or one Grade that matches the filter.
     * @param {GradeFindUniqueArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GradeFindUniqueArgs>(args: SelectSubset<T, GradeFindUniqueArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Grade that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GradeFindUniqueOrThrowArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GradeFindUniqueOrThrowArgs>(args: SelectSubset<T, GradeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Grade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFindFirstArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GradeFindFirstArgs>(args?: SelectSubset<T, GradeFindFirstArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Grade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFindFirstOrThrowArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GradeFindFirstOrThrowArgs>(args?: SelectSubset<T, GradeFindFirstOrThrowArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Grades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Grades
     * const grades = await prisma.grade.findMany()
     * 
     * // Get first 10 Grades
     * const grades = await prisma.grade.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gradeWithIdOnly = await prisma.grade.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GradeFindManyArgs>(args?: SelectSubset<T, GradeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Grade.
     * @param {GradeCreateArgs} args - Arguments to create a Grade.
     * @example
     * // Create one Grade
     * const Grade = await prisma.grade.create({
     *   data: {
     *     // ... data to create a Grade
     *   }
     * })
     * 
     */
    create<T extends GradeCreateArgs>(args: SelectSubset<T, GradeCreateArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Grades.
     * @param {GradeCreateManyArgs} args - Arguments to create many Grades.
     * @example
     * // Create many Grades
     * const grade = await prisma.grade.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GradeCreateManyArgs>(args?: SelectSubset<T, GradeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Grades and returns the data saved in the database.
     * @param {GradeCreateManyAndReturnArgs} args - Arguments to create many Grades.
     * @example
     * // Create many Grades
     * const grade = await prisma.grade.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Grades and only return the `id`
     * const gradeWithIdOnly = await prisma.grade.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GradeCreateManyAndReturnArgs>(args?: SelectSubset<T, GradeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Grade.
     * @param {GradeDeleteArgs} args - Arguments to delete one Grade.
     * @example
     * // Delete one Grade
     * const Grade = await prisma.grade.delete({
     *   where: {
     *     // ... filter to delete one Grade
     *   }
     * })
     * 
     */
    delete<T extends GradeDeleteArgs>(args: SelectSubset<T, GradeDeleteArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Grade.
     * @param {GradeUpdateArgs} args - Arguments to update one Grade.
     * @example
     * // Update one Grade
     * const grade = await prisma.grade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GradeUpdateArgs>(args: SelectSubset<T, GradeUpdateArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Grades.
     * @param {GradeDeleteManyArgs} args - Arguments to filter Grades to delete.
     * @example
     * // Delete a few Grades
     * const { count } = await prisma.grade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GradeDeleteManyArgs>(args?: SelectSubset<T, GradeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Grades
     * const grade = await prisma.grade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GradeUpdateManyArgs>(args: SelectSubset<T, GradeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grades and returns the data updated in the database.
     * @param {GradeUpdateManyAndReturnArgs} args - Arguments to update many Grades.
     * @example
     * // Update many Grades
     * const grade = await prisma.grade.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Grades and only return the `id`
     * const gradeWithIdOnly = await prisma.grade.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GradeUpdateManyAndReturnArgs>(args: SelectSubset<T, GradeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Grade.
     * @param {GradeUpsertArgs} args - Arguments to update or create a Grade.
     * @example
     * // Update or create a Grade
     * const grade = await prisma.grade.upsert({
     *   create: {
     *     // ... data to create a Grade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Grade we want to update
     *   }
     * })
     */
    upsert<T extends GradeUpsertArgs>(args: SelectSubset<T, GradeUpsertArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeCountArgs} args - Arguments to filter Grades to count.
     * @example
     * // Count the number of Grades
     * const count = await prisma.grade.count({
     *   where: {
     *     // ... the filter for the Grades we want to count
     *   }
     * })
    **/
    count<T extends GradeCountArgs>(
      args?: Subset<T, GradeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GradeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Grade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GradeAggregateArgs>(args: Subset<T, GradeAggregateArgs>): Prisma.PrismaPromise<GetGradeAggregateType<T>>

    /**
     * Group by Grade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GradeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GradeGroupByArgs['orderBy'] }
        : { orderBy?: GradeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GradeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGradeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Grade model
   */
  readonly fields: GradeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Grade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GradeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    students<T extends Grade$studentsArgs<ExtArgs> = {}>(args?: Subset<T, Grade$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    section<T extends Grade$sectionArgs<ExtArgs> = {}>(args?: Subset<T, Grade$sectionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TeachingAssignment<T extends Grade$TeachingAssignmentArgs<ExtArgs> = {}>(args?: Subset<T, Grade$TeachingAssignmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeachingAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Grade model
   */
  interface GradeFieldRefs {
    readonly id: FieldRef<"Grade", 'String'>
    readonly grade: FieldRef<"Grade", 'String'>
    readonly organizationId: FieldRef<"Grade", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Grade findUnique
   */
  export type GradeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade findUniqueOrThrow
   */
  export type GradeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade findFirst
   */
  export type GradeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grades.
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grades.
     */
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Grade findFirstOrThrow
   */
  export type GradeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grades.
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grades.
     */
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Grade findMany
   */
  export type GradeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grades to fetch.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Grades.
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Grade create
   */
  export type GradeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * The data needed to create a Grade.
     */
    data: XOR<GradeCreateInput, GradeUncheckedCreateInput>
  }

  /**
   * Grade createMany
   */
  export type GradeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Grades.
     */
    data: GradeCreateManyInput | GradeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Grade createManyAndReturn
   */
  export type GradeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * The data used to create many Grades.
     */
    data: GradeCreateManyInput | GradeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Grade update
   */
  export type GradeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * The data needed to update a Grade.
     */
    data: XOR<GradeUpdateInput, GradeUncheckedUpdateInput>
    /**
     * Choose, which Grade to update.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade updateMany
   */
  export type GradeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Grades.
     */
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyInput>
    /**
     * Filter which Grades to update
     */
    where?: GradeWhereInput
    /**
     * Limit how many Grades to update.
     */
    limit?: number
  }

  /**
   * Grade updateManyAndReturn
   */
  export type GradeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * The data used to update Grades.
     */
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyInput>
    /**
     * Filter which Grades to update
     */
    where?: GradeWhereInput
    /**
     * Limit how many Grades to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Grade upsert
   */
  export type GradeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * The filter to search for the Grade to update in case it exists.
     */
    where: GradeWhereUniqueInput
    /**
     * In case the Grade found by the `where` argument doesn't exist, create a new Grade with this data.
     */
    create: XOR<GradeCreateInput, GradeUncheckedCreateInput>
    /**
     * In case the Grade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GradeUpdateInput, GradeUncheckedUpdateInput>
  }

  /**
   * Grade delete
   */
  export type GradeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter which Grade to delete.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade deleteMany
   */
  export type GradeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Grades to delete
     */
    where?: GradeWhereInput
    /**
     * Limit how many Grades to delete.
     */
    limit?: number
  }

  /**
   * Grade.students
   */
  export type Grade$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Grade.section
   */
  export type Grade$sectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    where?: SectionWhereInput
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    cursor?: SectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Grade.TeachingAssignment
   */
  export type Grade$TeachingAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingAssignment
     */
    select?: TeachingAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeachingAssignment
     */
    omit?: TeachingAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingAssignmentInclude<ExtArgs> | null
    where?: TeachingAssignmentWhereInput
    orderBy?: TeachingAssignmentOrderByWithRelationInput | TeachingAssignmentOrderByWithRelationInput[]
    cursor?: TeachingAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeachingAssignmentScalarFieldEnum | TeachingAssignmentScalarFieldEnum[]
  }

  /**
   * Grade without action
   */
  export type GradeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
  }


  /**
   * Model Section
   */

  export type AggregateSection = {
    _count: SectionCountAggregateOutputType | null
    _min: SectionMinAggregateOutputType | null
    _max: SectionMaxAggregateOutputType | null
  }

  export type SectionMinAggregateOutputType = {
    id: string | null
    name: string | null
    gradeId: string | null
    organizationId: string | null
    classTeacherId: string | null
  }

  export type SectionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    gradeId: string | null
    organizationId: string | null
    classTeacherId: string | null
  }

  export type SectionCountAggregateOutputType = {
    id: number
    name: number
    gradeId: number
    organizationId: number
    classTeacherId: number
    _all: number
  }


  export type SectionMinAggregateInputType = {
    id?: true
    name?: true
    gradeId?: true
    organizationId?: true
    classTeacherId?: true
  }

  export type SectionMaxAggregateInputType = {
    id?: true
    name?: true
    gradeId?: true
    organizationId?: true
    classTeacherId?: true
  }

  export type SectionCountAggregateInputType = {
    id?: true
    name?: true
    gradeId?: true
    organizationId?: true
    classTeacherId?: true
    _all?: true
  }

  export type SectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Section to aggregate.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sections
    **/
    _count?: true | SectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SectionMaxAggregateInputType
  }

  export type GetSectionAggregateType<T extends SectionAggregateArgs> = {
        [P in keyof T & keyof AggregateSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSection[P]>
      : GetScalarType<T[P], AggregateSection[P]>
  }




  export type SectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionWhereInput
    orderBy?: SectionOrderByWithAggregationInput | SectionOrderByWithAggregationInput[]
    by: SectionScalarFieldEnum[] | SectionScalarFieldEnum
    having?: SectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SectionCountAggregateInputType | true
    _min?: SectionMinAggregateInputType
    _max?: SectionMaxAggregateInputType
  }

  export type SectionGroupByOutputType = {
    id: string
    name: string
    gradeId: string
    organizationId: string
    classTeacherId: string | null
    _count: SectionCountAggregateOutputType | null
    _min: SectionMinAggregateOutputType | null
    _max: SectionMaxAggregateOutputType | null
  }

  type GetSectionGroupByPayload<T extends SectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SectionGroupByOutputType[P]>
            : GetScalarType<T[P], SectionGroupByOutputType[P]>
        }
      >
    >


  export type SectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    gradeId?: boolean
    organizationId?: boolean
    classTeacherId?: boolean
    grade?: boolean | GradeDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    classTeacher?: boolean | Section$classTeacherArgs<ExtArgs>
    students?: boolean | Section$studentsArgs<ExtArgs>
    StudentAttendance?: boolean | Section$StudentAttendanceArgs<ExtArgs>
    TeachingAssignment?: boolean | Section$TeachingAssignmentArgs<ExtArgs>
    _count?: boolean | SectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["section"]>

  export type SectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    gradeId?: boolean
    organizationId?: boolean
    classTeacherId?: boolean
    grade?: boolean | GradeDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    classTeacher?: boolean | Section$classTeacherArgs<ExtArgs>
  }, ExtArgs["result"]["section"]>

  export type SectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    gradeId?: boolean
    organizationId?: boolean
    classTeacherId?: boolean
    grade?: boolean | GradeDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    classTeacher?: boolean | Section$classTeacherArgs<ExtArgs>
  }, ExtArgs["result"]["section"]>

  export type SectionSelectScalar = {
    id?: boolean
    name?: boolean
    gradeId?: boolean
    organizationId?: boolean
    classTeacherId?: boolean
  }

  export type SectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "gradeId" | "organizationId" | "classTeacherId", ExtArgs["result"]["section"]>
  export type SectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grade?: boolean | GradeDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    classTeacher?: boolean | Section$classTeacherArgs<ExtArgs>
    students?: boolean | Section$studentsArgs<ExtArgs>
    StudentAttendance?: boolean | Section$StudentAttendanceArgs<ExtArgs>
    TeachingAssignment?: boolean | Section$TeachingAssignmentArgs<ExtArgs>
    _count?: boolean | SectionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grade?: boolean | GradeDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    classTeacher?: boolean | Section$classTeacherArgs<ExtArgs>
  }
  export type SectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grade?: boolean | GradeDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    classTeacher?: boolean | Section$classTeacherArgs<ExtArgs>
  }

  export type $SectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Section"
    objects: {
      grade: Prisma.$GradePayload<ExtArgs>
      organization: Prisma.$OrganizationPayload<ExtArgs>
      classTeacher: Prisma.$TeacherPayload<ExtArgs> | null
      students: Prisma.$StudentPayload<ExtArgs>[]
      StudentAttendance: Prisma.$StudentAttendancePayload<ExtArgs>[]
      TeachingAssignment: Prisma.$TeachingAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      gradeId: string
      organizationId: string
      classTeacherId: string | null
    }, ExtArgs["result"]["section"]>
    composites: {}
  }

  type SectionGetPayload<S extends boolean | null | undefined | SectionDefaultArgs> = $Result.GetResult<Prisma.$SectionPayload, S>

  type SectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SectionCountAggregateInputType | true
    }

  export interface SectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Section'], meta: { name: 'Section' } }
    /**
     * Find zero or one Section that matches the filter.
     * @param {SectionFindUniqueArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SectionFindUniqueArgs>(args: SelectSubset<T, SectionFindUniqueArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Section that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SectionFindUniqueOrThrowArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SectionFindUniqueOrThrowArgs>(args: SelectSubset<T, SectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Section that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindFirstArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SectionFindFirstArgs>(args?: SelectSubset<T, SectionFindFirstArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Section that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindFirstOrThrowArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SectionFindFirstOrThrowArgs>(args?: SelectSubset<T, SectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sections
     * const sections = await prisma.section.findMany()
     * 
     * // Get first 10 Sections
     * const sections = await prisma.section.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sectionWithIdOnly = await prisma.section.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SectionFindManyArgs>(args?: SelectSubset<T, SectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Section.
     * @param {SectionCreateArgs} args - Arguments to create a Section.
     * @example
     * // Create one Section
     * const Section = await prisma.section.create({
     *   data: {
     *     // ... data to create a Section
     *   }
     * })
     * 
     */
    create<T extends SectionCreateArgs>(args: SelectSubset<T, SectionCreateArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sections.
     * @param {SectionCreateManyArgs} args - Arguments to create many Sections.
     * @example
     * // Create many Sections
     * const section = await prisma.section.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SectionCreateManyArgs>(args?: SelectSubset<T, SectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sections and returns the data saved in the database.
     * @param {SectionCreateManyAndReturnArgs} args - Arguments to create many Sections.
     * @example
     * // Create many Sections
     * const section = await prisma.section.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sections and only return the `id`
     * const sectionWithIdOnly = await prisma.section.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SectionCreateManyAndReturnArgs>(args?: SelectSubset<T, SectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Section.
     * @param {SectionDeleteArgs} args - Arguments to delete one Section.
     * @example
     * // Delete one Section
     * const Section = await prisma.section.delete({
     *   where: {
     *     // ... filter to delete one Section
     *   }
     * })
     * 
     */
    delete<T extends SectionDeleteArgs>(args: SelectSubset<T, SectionDeleteArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Section.
     * @param {SectionUpdateArgs} args - Arguments to update one Section.
     * @example
     * // Update one Section
     * const section = await prisma.section.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SectionUpdateArgs>(args: SelectSubset<T, SectionUpdateArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sections.
     * @param {SectionDeleteManyArgs} args - Arguments to filter Sections to delete.
     * @example
     * // Delete a few Sections
     * const { count } = await prisma.section.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SectionDeleteManyArgs>(args?: SelectSubset<T, SectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sections
     * const section = await prisma.section.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SectionUpdateManyArgs>(args: SelectSubset<T, SectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sections and returns the data updated in the database.
     * @param {SectionUpdateManyAndReturnArgs} args - Arguments to update many Sections.
     * @example
     * // Update many Sections
     * const section = await prisma.section.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sections and only return the `id`
     * const sectionWithIdOnly = await prisma.section.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SectionUpdateManyAndReturnArgs>(args: SelectSubset<T, SectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Section.
     * @param {SectionUpsertArgs} args - Arguments to update or create a Section.
     * @example
     * // Update or create a Section
     * const section = await prisma.section.upsert({
     *   create: {
     *     // ... data to create a Section
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Section we want to update
     *   }
     * })
     */
    upsert<T extends SectionUpsertArgs>(args: SelectSubset<T, SectionUpsertArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionCountArgs} args - Arguments to filter Sections to count.
     * @example
     * // Count the number of Sections
     * const count = await prisma.section.count({
     *   where: {
     *     // ... the filter for the Sections we want to count
     *   }
     * })
    **/
    count<T extends SectionCountArgs>(
      args?: Subset<T, SectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Section.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SectionAggregateArgs>(args: Subset<T, SectionAggregateArgs>): Prisma.PrismaPromise<GetSectionAggregateType<T>>

    /**
     * Group by Section.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SectionGroupByArgs['orderBy'] }
        : { orderBy?: SectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Section model
   */
  readonly fields: SectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Section.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    grade<T extends GradeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GradeDefaultArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    classTeacher<T extends Section$classTeacherArgs<ExtArgs> = {}>(args?: Subset<T, Section$classTeacherArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    students<T extends Section$studentsArgs<ExtArgs> = {}>(args?: Subset<T, Section$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StudentAttendance<T extends Section$StudentAttendanceArgs<ExtArgs> = {}>(args?: Subset<T, Section$StudentAttendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TeachingAssignment<T extends Section$TeachingAssignmentArgs<ExtArgs> = {}>(args?: Subset<T, Section$TeachingAssignmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeachingAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Section model
   */
  interface SectionFieldRefs {
    readonly id: FieldRef<"Section", 'String'>
    readonly name: FieldRef<"Section", 'String'>
    readonly gradeId: FieldRef<"Section", 'String'>
    readonly organizationId: FieldRef<"Section", 'String'>
    readonly classTeacherId: FieldRef<"Section", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Section findUnique
   */
  export type SectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section findUniqueOrThrow
   */
  export type SectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section findFirst
   */
  export type SectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sections.
     */
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section findFirstOrThrow
   */
  export type SectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sections.
     */
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section findMany
   */
  export type SectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Sections to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section create
   */
  export type SectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * The data needed to create a Section.
     */
    data: XOR<SectionCreateInput, SectionUncheckedCreateInput>
  }

  /**
   * Section createMany
   */
  export type SectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sections.
     */
    data: SectionCreateManyInput | SectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Section createManyAndReturn
   */
  export type SectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * The data used to create many Sections.
     */
    data: SectionCreateManyInput | SectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Section update
   */
  export type SectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * The data needed to update a Section.
     */
    data: XOR<SectionUpdateInput, SectionUncheckedUpdateInput>
    /**
     * Choose, which Section to update.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section updateMany
   */
  export type SectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sections.
     */
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyInput>
    /**
     * Filter which Sections to update
     */
    where?: SectionWhereInput
    /**
     * Limit how many Sections to update.
     */
    limit?: number
  }

  /**
   * Section updateManyAndReturn
   */
  export type SectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * The data used to update Sections.
     */
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyInput>
    /**
     * Filter which Sections to update
     */
    where?: SectionWhereInput
    /**
     * Limit how many Sections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Section upsert
   */
  export type SectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * The filter to search for the Section to update in case it exists.
     */
    where: SectionWhereUniqueInput
    /**
     * In case the Section found by the `where` argument doesn't exist, create a new Section with this data.
     */
    create: XOR<SectionCreateInput, SectionUncheckedCreateInput>
    /**
     * In case the Section was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SectionUpdateInput, SectionUncheckedUpdateInput>
  }

  /**
   * Section delete
   */
  export type SectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter which Section to delete.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section deleteMany
   */
  export type SectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sections to delete
     */
    where?: SectionWhereInput
    /**
     * Limit how many Sections to delete.
     */
    limit?: number
  }

  /**
   * Section.classTeacher
   */
  export type Section$classTeacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    where?: TeacherWhereInput
  }

  /**
   * Section.students
   */
  export type Section$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Section.StudentAttendance
   */
  export type Section$StudentAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    where?: StudentAttendanceWhereInput
    orderBy?: StudentAttendanceOrderByWithRelationInput | StudentAttendanceOrderByWithRelationInput[]
    cursor?: StudentAttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentAttendanceScalarFieldEnum | StudentAttendanceScalarFieldEnum[]
  }

  /**
   * Section.TeachingAssignment
   */
  export type Section$TeachingAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingAssignment
     */
    select?: TeachingAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeachingAssignment
     */
    omit?: TeachingAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingAssignmentInclude<ExtArgs> | null
    where?: TeachingAssignmentWhereInput
    orderBy?: TeachingAssignmentOrderByWithRelationInput | TeachingAssignmentOrderByWithRelationInput[]
    cursor?: TeachingAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeachingAssignmentScalarFieldEnum | TeachingAssignmentScalarFieldEnum[]
  }

  /**
   * Section without action
   */
  export type SectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
  }


  /**
   * Model Teacher
   */

  export type AggregateTeacher = {
    _count: TeacherCountAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  export type TeacherMinAggregateOutputType = {
    id: string | null
    userId: string | null
    employeeCode: string | null
    employmentStatus: $Enums.EmploymentStatus | null
    isActive: boolean | null
    organizationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeacherMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    employeeCode: string | null
    employmentStatus: $Enums.EmploymentStatus | null
    isActive: boolean | null
    organizationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeacherCountAggregateOutputType = {
    id: number
    userId: number
    employeeCode: number
    employmentStatus: number
    isActive: number
    organizationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeacherMinAggregateInputType = {
    id?: true
    userId?: true
    employeeCode?: true
    employmentStatus?: true
    isActive?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeacherMaxAggregateInputType = {
    id?: true
    userId?: true
    employeeCode?: true
    employmentStatus?: true
    isActive?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeacherCountAggregateInputType = {
    id?: true
    userId?: true
    employeeCode?: true
    employmentStatus?: true
    isActive?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeacherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teacher to aggregate.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teachers
    **/
    _count?: true | TeacherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherMaxAggregateInputType
  }

  export type GetTeacherAggregateType<T extends TeacherAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacher[P]>
      : GetScalarType<T[P], AggregateTeacher[P]>
  }




  export type TeacherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherWhereInput
    orderBy?: TeacherOrderByWithAggregationInput | TeacherOrderByWithAggregationInput[]
    by: TeacherScalarFieldEnum[] | TeacherScalarFieldEnum
    having?: TeacherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherCountAggregateInputType | true
    _min?: TeacherMinAggregateInputType
    _max?: TeacherMaxAggregateInputType
  }

  export type TeacherGroupByOutputType = {
    id: string
    userId: string
    employeeCode: string | null
    employmentStatus: $Enums.EmploymentStatus
    isActive: boolean
    organizationId: string
    createdAt: Date
    updatedAt: Date
    _count: TeacherCountAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  type GetTeacherGroupByPayload<T extends TeacherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherGroupByOutputType[P]>
        }
      >
    >


  export type TeacherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    employeeCode?: boolean
    employmentStatus?: boolean
    isActive?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    profile?: boolean | Teacher$profileArgs<ExtArgs>
    TeachingAssignment?: boolean | Teacher$TeachingAssignmentArgs<ExtArgs>
    Section?: boolean | Teacher$SectionArgs<ExtArgs>
    _count?: boolean | TeacherCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher"]>

  export type TeacherSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    employeeCode?: boolean
    employmentStatus?: boolean
    isActive?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher"]>

  export type TeacherSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    employeeCode?: boolean
    employmentStatus?: boolean
    isActive?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher"]>

  export type TeacherSelectScalar = {
    id?: boolean
    userId?: boolean
    employeeCode?: boolean
    employmentStatus?: boolean
    isActive?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeacherOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "employeeCode" | "employmentStatus" | "isActive" | "organizationId" | "createdAt" | "updatedAt", ExtArgs["result"]["teacher"]>
  export type TeacherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    profile?: boolean | Teacher$profileArgs<ExtArgs>
    TeachingAssignment?: boolean | Teacher$TeachingAssignmentArgs<ExtArgs>
    Section?: boolean | Teacher$SectionArgs<ExtArgs>
    _count?: boolean | TeacherCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeacherIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type TeacherIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $TeacherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Teacher"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      organization: Prisma.$OrganizationPayload<ExtArgs>
      profile: Prisma.$TeacherProfilePayload<ExtArgs> | null
      TeachingAssignment: Prisma.$TeachingAssignmentPayload<ExtArgs>[]
      Section: Prisma.$SectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      employeeCode: string | null
      employmentStatus: $Enums.EmploymentStatus
      isActive: boolean
      organizationId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["teacher"]>
    composites: {}
  }

  type TeacherGetPayload<S extends boolean | null | undefined | TeacherDefaultArgs> = $Result.GetResult<Prisma.$TeacherPayload, S>

  type TeacherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeacherFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeacherCountAggregateInputType | true
    }

  export interface TeacherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Teacher'], meta: { name: 'Teacher' } }
    /**
     * Find zero or one Teacher that matches the filter.
     * @param {TeacherFindUniqueArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeacherFindUniqueArgs>(args: SelectSubset<T, TeacherFindUniqueArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Teacher that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeacherFindUniqueOrThrowArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeacherFindUniqueOrThrowArgs>(args: SelectSubset<T, TeacherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teacher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindFirstArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeacherFindFirstArgs>(args?: SelectSubset<T, TeacherFindFirstArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teacher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindFirstOrThrowArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeacherFindFirstOrThrowArgs>(args?: SelectSubset<T, TeacherFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teachers
     * const teachers = await prisma.teacher.findMany()
     * 
     * // Get first 10 Teachers
     * const teachers = await prisma.teacher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherWithIdOnly = await prisma.teacher.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeacherFindManyArgs>(args?: SelectSubset<T, TeacherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Teacher.
     * @param {TeacherCreateArgs} args - Arguments to create a Teacher.
     * @example
     * // Create one Teacher
     * const Teacher = await prisma.teacher.create({
     *   data: {
     *     // ... data to create a Teacher
     *   }
     * })
     * 
     */
    create<T extends TeacherCreateArgs>(args: SelectSubset<T, TeacherCreateArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teachers.
     * @param {TeacherCreateManyArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teacher = await prisma.teacher.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeacherCreateManyArgs>(args?: SelectSubset<T, TeacherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teachers and returns the data saved in the database.
     * @param {TeacherCreateManyAndReturnArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teacher = await prisma.teacher.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teachers and only return the `id`
     * const teacherWithIdOnly = await prisma.teacher.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeacherCreateManyAndReturnArgs>(args?: SelectSubset<T, TeacherCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Teacher.
     * @param {TeacherDeleteArgs} args - Arguments to delete one Teacher.
     * @example
     * // Delete one Teacher
     * const Teacher = await prisma.teacher.delete({
     *   where: {
     *     // ... filter to delete one Teacher
     *   }
     * })
     * 
     */
    delete<T extends TeacherDeleteArgs>(args: SelectSubset<T, TeacherDeleteArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Teacher.
     * @param {TeacherUpdateArgs} args - Arguments to update one Teacher.
     * @example
     * // Update one Teacher
     * const teacher = await prisma.teacher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeacherUpdateArgs>(args: SelectSubset<T, TeacherUpdateArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teachers.
     * @param {TeacherDeleteManyArgs} args - Arguments to filter Teachers to delete.
     * @example
     * // Delete a few Teachers
     * const { count } = await prisma.teacher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeacherDeleteManyArgs>(args?: SelectSubset<T, TeacherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teachers
     * const teacher = await prisma.teacher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeacherUpdateManyArgs>(args: SelectSubset<T, TeacherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers and returns the data updated in the database.
     * @param {TeacherUpdateManyAndReturnArgs} args - Arguments to update many Teachers.
     * @example
     * // Update many Teachers
     * const teacher = await prisma.teacher.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teachers and only return the `id`
     * const teacherWithIdOnly = await prisma.teacher.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeacherUpdateManyAndReturnArgs>(args: SelectSubset<T, TeacherUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Teacher.
     * @param {TeacherUpsertArgs} args - Arguments to update or create a Teacher.
     * @example
     * // Update or create a Teacher
     * const teacher = await prisma.teacher.upsert({
     *   create: {
     *     // ... data to create a Teacher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teacher we want to update
     *   }
     * })
     */
    upsert<T extends TeacherUpsertArgs>(args: SelectSubset<T, TeacherUpsertArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherCountArgs} args - Arguments to filter Teachers to count.
     * @example
     * // Count the number of Teachers
     * const count = await prisma.teacher.count({
     *   where: {
     *     // ... the filter for the Teachers we want to count
     *   }
     * })
    **/
    count<T extends TeacherCountArgs>(
      args?: Subset<T, TeacherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherAggregateArgs>(args: Subset<T, TeacherAggregateArgs>): Prisma.PrismaPromise<GetTeacherAggregateType<T>>

    /**
     * Group by Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherGroupByArgs['orderBy'] }
        : { orderBy?: TeacherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Teacher model
   */
  readonly fields: TeacherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Teacher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeacherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    profile<T extends Teacher$profileArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$profileArgs<ExtArgs>>): Prisma__TeacherProfileClient<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    TeachingAssignment<T extends Teacher$TeachingAssignmentArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$TeachingAssignmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeachingAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Section<T extends Teacher$SectionArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$SectionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Teacher model
   */
  interface TeacherFieldRefs {
    readonly id: FieldRef<"Teacher", 'String'>
    readonly userId: FieldRef<"Teacher", 'String'>
    readonly employeeCode: FieldRef<"Teacher", 'String'>
    readonly employmentStatus: FieldRef<"Teacher", 'EmploymentStatus'>
    readonly isActive: FieldRef<"Teacher", 'Boolean'>
    readonly organizationId: FieldRef<"Teacher", 'String'>
    readonly createdAt: FieldRef<"Teacher", 'DateTime'>
    readonly updatedAt: FieldRef<"Teacher", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Teacher findUnique
   */
  export type TeacherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher findUniqueOrThrow
   */
  export type TeacherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher findFirst
   */
  export type TeacherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher findFirstOrThrow
   */
  export type TeacherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher findMany
   */
  export type TeacherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teachers to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher create
   */
  export type TeacherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The data needed to create a Teacher.
     */
    data: XOR<TeacherCreateInput, TeacherUncheckedCreateInput>
  }

  /**
   * Teacher createMany
   */
  export type TeacherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teachers.
     */
    data: TeacherCreateManyInput | TeacherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Teacher createManyAndReturn
   */
  export type TeacherCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * The data used to create many Teachers.
     */
    data: TeacherCreateManyInput | TeacherCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Teacher update
   */
  export type TeacherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The data needed to update a Teacher.
     */
    data: XOR<TeacherUpdateInput, TeacherUncheckedUpdateInput>
    /**
     * Choose, which Teacher to update.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher updateMany
   */
  export type TeacherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teachers.
     */
    data: XOR<TeacherUpdateManyMutationInput, TeacherUncheckedUpdateManyInput>
    /**
     * Filter which Teachers to update
     */
    where?: TeacherWhereInput
    /**
     * Limit how many Teachers to update.
     */
    limit?: number
  }

  /**
   * Teacher updateManyAndReturn
   */
  export type TeacherUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * The data used to update Teachers.
     */
    data: XOR<TeacherUpdateManyMutationInput, TeacherUncheckedUpdateManyInput>
    /**
     * Filter which Teachers to update
     */
    where?: TeacherWhereInput
    /**
     * Limit how many Teachers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Teacher upsert
   */
  export type TeacherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The filter to search for the Teacher to update in case it exists.
     */
    where: TeacherWhereUniqueInput
    /**
     * In case the Teacher found by the `where` argument doesn't exist, create a new Teacher with this data.
     */
    create: XOR<TeacherCreateInput, TeacherUncheckedCreateInput>
    /**
     * In case the Teacher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherUpdateInput, TeacherUncheckedUpdateInput>
  }

  /**
   * Teacher delete
   */
  export type TeacherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter which Teacher to delete.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher deleteMany
   */
  export type TeacherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teachers to delete
     */
    where?: TeacherWhereInput
    /**
     * Limit how many Teachers to delete.
     */
    limit?: number
  }

  /**
   * Teacher.profile
   */
  export type Teacher$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherProfile
     */
    omit?: TeacherProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileInclude<ExtArgs> | null
    where?: TeacherProfileWhereInput
  }

  /**
   * Teacher.TeachingAssignment
   */
  export type Teacher$TeachingAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingAssignment
     */
    select?: TeachingAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeachingAssignment
     */
    omit?: TeachingAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingAssignmentInclude<ExtArgs> | null
    where?: TeachingAssignmentWhereInput
    orderBy?: TeachingAssignmentOrderByWithRelationInput | TeachingAssignmentOrderByWithRelationInput[]
    cursor?: TeachingAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeachingAssignmentScalarFieldEnum | TeachingAssignmentScalarFieldEnum[]
  }

  /**
   * Teacher.Section
   */
  export type Teacher$SectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    where?: SectionWhereInput
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    cursor?: SectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Teacher without action
   */
  export type TeacherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
  }


  /**
   * Model TeacherProfile
   */

  export type AggregateTeacherProfile = {
    _count: TeacherProfileCountAggregateOutputType | null
    _avg: TeacherProfileAvgAggregateOutputType | null
    _sum: TeacherProfileSumAggregateOutputType | null
    _min: TeacherProfileMinAggregateOutputType | null
    _max: TeacherProfileMaxAggregateOutputType | null
  }

  export type TeacherProfileAvgAggregateOutputType = {
    experienceInYears: number | null
  }

  export type TeacherProfileSumAggregateOutputType = {
    experienceInYears: number | null
  }

  export type TeacherProfileMinAggregateOutputType = {
    id: string | null
    teacherId: string | null
    contactEmail: string | null
    contactPhone: string | null
    address: string | null
    city: string | null
    state: string | null
    dateOfBirth: Date | null
    qualification: string | null
    experienceInYears: number | null
    resumeUrl: string | null
    joinedAt: Date | null
    bio: string | null
    teachingPhilosophy: string | null
    idProofUrl: string | null
    linkedinPortfolio: string | null
  }

  export type TeacherProfileMaxAggregateOutputType = {
    id: string | null
    teacherId: string | null
    contactEmail: string | null
    contactPhone: string | null
    address: string | null
    city: string | null
    state: string | null
    dateOfBirth: Date | null
    qualification: string | null
    experienceInYears: number | null
    resumeUrl: string | null
    joinedAt: Date | null
    bio: string | null
    teachingPhilosophy: string | null
    idProofUrl: string | null
    linkedinPortfolio: string | null
  }

  export type TeacherProfileCountAggregateOutputType = {
    id: number
    teacherId: number
    contactEmail: number
    contactPhone: number
    address: number
    city: number
    state: number
    dateOfBirth: number
    qualification: number
    experienceInYears: number
    resumeUrl: number
    joinedAt: number
    bio: number
    teachingPhilosophy: number
    specializedSubjects: number
    preferredGrades: number
    idProofUrl: number
    linkedinPortfolio: number
    languagesKnown: number
    certificateUrls: number
    _all: number
  }


  export type TeacherProfileAvgAggregateInputType = {
    experienceInYears?: true
  }

  export type TeacherProfileSumAggregateInputType = {
    experienceInYears?: true
  }

  export type TeacherProfileMinAggregateInputType = {
    id?: true
    teacherId?: true
    contactEmail?: true
    contactPhone?: true
    address?: true
    city?: true
    state?: true
    dateOfBirth?: true
    qualification?: true
    experienceInYears?: true
    resumeUrl?: true
    joinedAt?: true
    bio?: true
    teachingPhilosophy?: true
    idProofUrl?: true
    linkedinPortfolio?: true
  }

  export type TeacherProfileMaxAggregateInputType = {
    id?: true
    teacherId?: true
    contactEmail?: true
    contactPhone?: true
    address?: true
    city?: true
    state?: true
    dateOfBirth?: true
    qualification?: true
    experienceInYears?: true
    resumeUrl?: true
    joinedAt?: true
    bio?: true
    teachingPhilosophy?: true
    idProofUrl?: true
    linkedinPortfolio?: true
  }

  export type TeacherProfileCountAggregateInputType = {
    id?: true
    teacherId?: true
    contactEmail?: true
    contactPhone?: true
    address?: true
    city?: true
    state?: true
    dateOfBirth?: true
    qualification?: true
    experienceInYears?: true
    resumeUrl?: true
    joinedAt?: true
    bio?: true
    teachingPhilosophy?: true
    specializedSubjects?: true
    preferredGrades?: true
    idProofUrl?: true
    linkedinPortfolio?: true
    languagesKnown?: true
    certificateUrls?: true
    _all?: true
  }

  export type TeacherProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherProfile to aggregate.
     */
    where?: TeacherProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherProfiles to fetch.
     */
    orderBy?: TeacherProfileOrderByWithRelationInput | TeacherProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeacherProfiles
    **/
    _count?: true | TeacherProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeacherProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeacherProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherProfileMaxAggregateInputType
  }

  export type GetTeacherProfileAggregateType<T extends TeacherProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacherProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacherProfile[P]>
      : GetScalarType<T[P], AggregateTeacherProfile[P]>
  }




  export type TeacherProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherProfileWhereInput
    orderBy?: TeacherProfileOrderByWithAggregationInput | TeacherProfileOrderByWithAggregationInput[]
    by: TeacherProfileScalarFieldEnum[] | TeacherProfileScalarFieldEnum
    having?: TeacherProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherProfileCountAggregateInputType | true
    _avg?: TeacherProfileAvgAggregateInputType
    _sum?: TeacherProfileSumAggregateInputType
    _min?: TeacherProfileMinAggregateInputType
    _max?: TeacherProfileMaxAggregateInputType
  }

  export type TeacherProfileGroupByOutputType = {
    id: string
    teacherId: string
    contactEmail: string
    contactPhone: string
    address: string
    city: string | null
    state: string | null
    dateOfBirth: Date
    qualification: string
    experienceInYears: number
    resumeUrl: string | null
    joinedAt: Date
    bio: string | null
    teachingPhilosophy: string | null
    specializedSubjects: string[]
    preferredGrades: string[]
    idProofUrl: string
    linkedinPortfolio: string | null
    languagesKnown: string[]
    certificateUrls: string[]
    _count: TeacherProfileCountAggregateOutputType | null
    _avg: TeacherProfileAvgAggregateOutputType | null
    _sum: TeacherProfileSumAggregateOutputType | null
    _min: TeacherProfileMinAggregateOutputType | null
    _max: TeacherProfileMaxAggregateOutputType | null
  }

  type GetTeacherProfileGroupByPayload<T extends TeacherProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherProfileGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherProfileGroupByOutputType[P]>
        }
      >
    >


  export type TeacherProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    dateOfBirth?: boolean
    qualification?: boolean
    experienceInYears?: boolean
    resumeUrl?: boolean
    joinedAt?: boolean
    bio?: boolean
    teachingPhilosophy?: boolean
    specializedSubjects?: boolean
    preferredGrades?: boolean
    idProofUrl?: boolean
    linkedinPortfolio?: boolean
    languagesKnown?: boolean
    certificateUrls?: boolean
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherProfile"]>

  export type TeacherProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    dateOfBirth?: boolean
    qualification?: boolean
    experienceInYears?: boolean
    resumeUrl?: boolean
    joinedAt?: boolean
    bio?: boolean
    teachingPhilosophy?: boolean
    specializedSubjects?: boolean
    preferredGrades?: boolean
    idProofUrl?: boolean
    linkedinPortfolio?: boolean
    languagesKnown?: boolean
    certificateUrls?: boolean
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherProfile"]>

  export type TeacherProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    dateOfBirth?: boolean
    qualification?: boolean
    experienceInYears?: boolean
    resumeUrl?: boolean
    joinedAt?: boolean
    bio?: boolean
    teachingPhilosophy?: boolean
    specializedSubjects?: boolean
    preferredGrades?: boolean
    idProofUrl?: boolean
    linkedinPortfolio?: boolean
    languagesKnown?: boolean
    certificateUrls?: boolean
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherProfile"]>

  export type TeacherProfileSelectScalar = {
    id?: boolean
    teacherId?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    dateOfBirth?: boolean
    qualification?: boolean
    experienceInYears?: boolean
    resumeUrl?: boolean
    joinedAt?: boolean
    bio?: boolean
    teachingPhilosophy?: boolean
    specializedSubjects?: boolean
    preferredGrades?: boolean
    idProofUrl?: boolean
    linkedinPortfolio?: boolean
    languagesKnown?: boolean
    certificateUrls?: boolean
  }

  export type TeacherProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teacherId" | "contactEmail" | "contactPhone" | "address" | "city" | "state" | "dateOfBirth" | "qualification" | "experienceInYears" | "resumeUrl" | "joinedAt" | "bio" | "teachingPhilosophy" | "specializedSubjects" | "preferredGrades" | "idProofUrl" | "linkedinPortfolio" | "languagesKnown" | "certificateUrls", ExtArgs["result"]["teacherProfile"]>
  export type TeacherProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }
  export type TeacherProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }
  export type TeacherProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }

  export type $TeacherProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeacherProfile"
    objects: {
      teacher: Prisma.$TeacherPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teacherId: string
      contactEmail: string
      contactPhone: string
      address: string
      city: string | null
      state: string | null
      dateOfBirth: Date
      qualification: string
      experienceInYears: number
      resumeUrl: string | null
      joinedAt: Date
      bio: string | null
      teachingPhilosophy: string | null
      specializedSubjects: string[]
      preferredGrades: string[]
      idProofUrl: string
      linkedinPortfolio: string | null
      languagesKnown: string[]
      certificateUrls: string[]
    }, ExtArgs["result"]["teacherProfile"]>
    composites: {}
  }

  type TeacherProfileGetPayload<S extends boolean | null | undefined | TeacherProfileDefaultArgs> = $Result.GetResult<Prisma.$TeacherProfilePayload, S>

  type TeacherProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeacherProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeacherProfileCountAggregateInputType | true
    }

  export interface TeacherProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeacherProfile'], meta: { name: 'TeacherProfile' } }
    /**
     * Find zero or one TeacherProfile that matches the filter.
     * @param {TeacherProfileFindUniqueArgs} args - Arguments to find a TeacherProfile
     * @example
     * // Get one TeacherProfile
     * const teacherProfile = await prisma.teacherProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeacherProfileFindUniqueArgs>(args: SelectSubset<T, TeacherProfileFindUniqueArgs<ExtArgs>>): Prisma__TeacherProfileClient<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeacherProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeacherProfileFindUniqueOrThrowArgs} args - Arguments to find a TeacherProfile
     * @example
     * // Get one TeacherProfile
     * const teacherProfile = await prisma.teacherProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeacherProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, TeacherProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeacherProfileClient<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeacherProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherProfileFindFirstArgs} args - Arguments to find a TeacherProfile
     * @example
     * // Get one TeacherProfile
     * const teacherProfile = await prisma.teacherProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeacherProfileFindFirstArgs>(args?: SelectSubset<T, TeacherProfileFindFirstArgs<ExtArgs>>): Prisma__TeacherProfileClient<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeacherProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherProfileFindFirstOrThrowArgs} args - Arguments to find a TeacherProfile
     * @example
     * // Get one TeacherProfile
     * const teacherProfile = await prisma.teacherProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeacherProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, TeacherProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeacherProfileClient<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeacherProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeacherProfiles
     * const teacherProfiles = await prisma.teacherProfile.findMany()
     * 
     * // Get first 10 TeacherProfiles
     * const teacherProfiles = await prisma.teacherProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherProfileWithIdOnly = await prisma.teacherProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeacherProfileFindManyArgs>(args?: SelectSubset<T, TeacherProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeacherProfile.
     * @param {TeacherProfileCreateArgs} args - Arguments to create a TeacherProfile.
     * @example
     * // Create one TeacherProfile
     * const TeacherProfile = await prisma.teacherProfile.create({
     *   data: {
     *     // ... data to create a TeacherProfile
     *   }
     * })
     * 
     */
    create<T extends TeacherProfileCreateArgs>(args: SelectSubset<T, TeacherProfileCreateArgs<ExtArgs>>): Prisma__TeacherProfileClient<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeacherProfiles.
     * @param {TeacherProfileCreateManyArgs} args - Arguments to create many TeacherProfiles.
     * @example
     * // Create many TeacherProfiles
     * const teacherProfile = await prisma.teacherProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeacherProfileCreateManyArgs>(args?: SelectSubset<T, TeacherProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeacherProfiles and returns the data saved in the database.
     * @param {TeacherProfileCreateManyAndReturnArgs} args - Arguments to create many TeacherProfiles.
     * @example
     * // Create many TeacherProfiles
     * const teacherProfile = await prisma.teacherProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeacherProfiles and only return the `id`
     * const teacherProfileWithIdOnly = await prisma.teacherProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeacherProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, TeacherProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TeacherProfile.
     * @param {TeacherProfileDeleteArgs} args - Arguments to delete one TeacherProfile.
     * @example
     * // Delete one TeacherProfile
     * const TeacherProfile = await prisma.teacherProfile.delete({
     *   where: {
     *     // ... filter to delete one TeacherProfile
     *   }
     * })
     * 
     */
    delete<T extends TeacherProfileDeleteArgs>(args: SelectSubset<T, TeacherProfileDeleteArgs<ExtArgs>>): Prisma__TeacherProfileClient<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeacherProfile.
     * @param {TeacherProfileUpdateArgs} args - Arguments to update one TeacherProfile.
     * @example
     * // Update one TeacherProfile
     * const teacherProfile = await prisma.teacherProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeacherProfileUpdateArgs>(args: SelectSubset<T, TeacherProfileUpdateArgs<ExtArgs>>): Prisma__TeacherProfileClient<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeacherProfiles.
     * @param {TeacherProfileDeleteManyArgs} args - Arguments to filter TeacherProfiles to delete.
     * @example
     * // Delete a few TeacherProfiles
     * const { count } = await prisma.teacherProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeacherProfileDeleteManyArgs>(args?: SelectSubset<T, TeacherProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeacherProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeacherProfiles
     * const teacherProfile = await prisma.teacherProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeacherProfileUpdateManyArgs>(args: SelectSubset<T, TeacherProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeacherProfiles and returns the data updated in the database.
     * @param {TeacherProfileUpdateManyAndReturnArgs} args - Arguments to update many TeacherProfiles.
     * @example
     * // Update many TeacherProfiles
     * const teacherProfile = await prisma.teacherProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TeacherProfiles and only return the `id`
     * const teacherProfileWithIdOnly = await prisma.teacherProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeacherProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, TeacherProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TeacherProfile.
     * @param {TeacherProfileUpsertArgs} args - Arguments to update or create a TeacherProfile.
     * @example
     * // Update or create a TeacherProfile
     * const teacherProfile = await prisma.teacherProfile.upsert({
     *   create: {
     *     // ... data to create a TeacherProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeacherProfile we want to update
     *   }
     * })
     */
    upsert<T extends TeacherProfileUpsertArgs>(args: SelectSubset<T, TeacherProfileUpsertArgs<ExtArgs>>): Prisma__TeacherProfileClient<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TeacherProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherProfileCountArgs} args - Arguments to filter TeacherProfiles to count.
     * @example
     * // Count the number of TeacherProfiles
     * const count = await prisma.teacherProfile.count({
     *   where: {
     *     // ... the filter for the TeacherProfiles we want to count
     *   }
     * })
    **/
    count<T extends TeacherProfileCountArgs>(
      args?: Subset<T, TeacherProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeacherProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherProfileAggregateArgs>(args: Subset<T, TeacherProfileAggregateArgs>): Prisma.PrismaPromise<GetTeacherProfileAggregateType<T>>

    /**
     * Group by TeacherProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherProfileGroupByArgs['orderBy'] }
        : { orderBy?: TeacherProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeacherProfile model
   */
  readonly fields: TeacherProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeacherProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeacherProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teacher<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeacherProfile model
   */
  interface TeacherProfileFieldRefs {
    readonly id: FieldRef<"TeacherProfile", 'String'>
    readonly teacherId: FieldRef<"TeacherProfile", 'String'>
    readonly contactEmail: FieldRef<"TeacherProfile", 'String'>
    readonly contactPhone: FieldRef<"TeacherProfile", 'String'>
    readonly address: FieldRef<"TeacherProfile", 'String'>
    readonly city: FieldRef<"TeacherProfile", 'String'>
    readonly state: FieldRef<"TeacherProfile", 'String'>
    readonly dateOfBirth: FieldRef<"TeacherProfile", 'DateTime'>
    readonly qualification: FieldRef<"TeacherProfile", 'String'>
    readonly experienceInYears: FieldRef<"TeacherProfile", 'Int'>
    readonly resumeUrl: FieldRef<"TeacherProfile", 'String'>
    readonly joinedAt: FieldRef<"TeacherProfile", 'DateTime'>
    readonly bio: FieldRef<"TeacherProfile", 'String'>
    readonly teachingPhilosophy: FieldRef<"TeacherProfile", 'String'>
    readonly specializedSubjects: FieldRef<"TeacherProfile", 'String[]'>
    readonly preferredGrades: FieldRef<"TeacherProfile", 'String[]'>
    readonly idProofUrl: FieldRef<"TeacherProfile", 'String'>
    readonly linkedinPortfolio: FieldRef<"TeacherProfile", 'String'>
    readonly languagesKnown: FieldRef<"TeacherProfile", 'String[]'>
    readonly certificateUrls: FieldRef<"TeacherProfile", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * TeacherProfile findUnique
   */
  export type TeacherProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherProfile
     */
    omit?: TeacherProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileInclude<ExtArgs> | null
    /**
     * Filter, which TeacherProfile to fetch.
     */
    where: TeacherProfileWhereUniqueInput
  }

  /**
   * TeacherProfile findUniqueOrThrow
   */
  export type TeacherProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherProfile
     */
    omit?: TeacherProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileInclude<ExtArgs> | null
    /**
     * Filter, which TeacherProfile to fetch.
     */
    where: TeacherProfileWhereUniqueInput
  }

  /**
   * TeacherProfile findFirst
   */
  export type TeacherProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherProfile
     */
    omit?: TeacherProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileInclude<ExtArgs> | null
    /**
     * Filter, which TeacherProfile to fetch.
     */
    where?: TeacherProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherProfiles to fetch.
     */
    orderBy?: TeacherProfileOrderByWithRelationInput | TeacherProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherProfiles.
     */
    cursor?: TeacherProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherProfiles.
     */
    distinct?: TeacherProfileScalarFieldEnum | TeacherProfileScalarFieldEnum[]
  }

  /**
   * TeacherProfile findFirstOrThrow
   */
  export type TeacherProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherProfile
     */
    omit?: TeacherProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileInclude<ExtArgs> | null
    /**
     * Filter, which TeacherProfile to fetch.
     */
    where?: TeacherProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherProfiles to fetch.
     */
    orderBy?: TeacherProfileOrderByWithRelationInput | TeacherProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherProfiles.
     */
    cursor?: TeacherProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherProfiles.
     */
    distinct?: TeacherProfileScalarFieldEnum | TeacherProfileScalarFieldEnum[]
  }

  /**
   * TeacherProfile findMany
   */
  export type TeacherProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherProfile
     */
    omit?: TeacherProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileInclude<ExtArgs> | null
    /**
     * Filter, which TeacherProfiles to fetch.
     */
    where?: TeacherProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherProfiles to fetch.
     */
    orderBy?: TeacherProfileOrderByWithRelationInput | TeacherProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeacherProfiles.
     */
    cursor?: TeacherProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherProfiles.
     */
    skip?: number
    distinct?: TeacherProfileScalarFieldEnum | TeacherProfileScalarFieldEnum[]
  }

  /**
   * TeacherProfile create
   */
  export type TeacherProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherProfile
     */
    omit?: TeacherProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a TeacherProfile.
     */
    data: XOR<TeacherProfileCreateInput, TeacherProfileUncheckedCreateInput>
  }

  /**
   * TeacherProfile createMany
   */
  export type TeacherProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeacherProfiles.
     */
    data: TeacherProfileCreateManyInput | TeacherProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeacherProfile createManyAndReturn
   */
  export type TeacherProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherProfile
     */
    omit?: TeacherProfileOmit<ExtArgs> | null
    /**
     * The data used to create many TeacherProfiles.
     */
    data: TeacherProfileCreateManyInput | TeacherProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeacherProfile update
   */
  export type TeacherProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherProfile
     */
    omit?: TeacherProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a TeacherProfile.
     */
    data: XOR<TeacherProfileUpdateInput, TeacherProfileUncheckedUpdateInput>
    /**
     * Choose, which TeacherProfile to update.
     */
    where: TeacherProfileWhereUniqueInput
  }

  /**
   * TeacherProfile updateMany
   */
  export type TeacherProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeacherProfiles.
     */
    data: XOR<TeacherProfileUpdateManyMutationInput, TeacherProfileUncheckedUpdateManyInput>
    /**
     * Filter which TeacherProfiles to update
     */
    where?: TeacherProfileWhereInput
    /**
     * Limit how many TeacherProfiles to update.
     */
    limit?: number
  }

  /**
   * TeacherProfile updateManyAndReturn
   */
  export type TeacherProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherProfile
     */
    omit?: TeacherProfileOmit<ExtArgs> | null
    /**
     * The data used to update TeacherProfiles.
     */
    data: XOR<TeacherProfileUpdateManyMutationInput, TeacherProfileUncheckedUpdateManyInput>
    /**
     * Filter which TeacherProfiles to update
     */
    where?: TeacherProfileWhereInput
    /**
     * Limit how many TeacherProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeacherProfile upsert
   */
  export type TeacherProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherProfile
     */
    omit?: TeacherProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the TeacherProfile to update in case it exists.
     */
    where: TeacherProfileWhereUniqueInput
    /**
     * In case the TeacherProfile found by the `where` argument doesn't exist, create a new TeacherProfile with this data.
     */
    create: XOR<TeacherProfileCreateInput, TeacherProfileUncheckedCreateInput>
    /**
     * In case the TeacherProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherProfileUpdateInput, TeacherProfileUncheckedUpdateInput>
  }

  /**
   * TeacherProfile delete
   */
  export type TeacherProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherProfile
     */
    omit?: TeacherProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileInclude<ExtArgs> | null
    /**
     * Filter which TeacherProfile to delete.
     */
    where: TeacherProfileWhereUniqueInput
  }

  /**
   * TeacherProfile deleteMany
   */
  export type TeacherProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherProfiles to delete
     */
    where?: TeacherProfileWhereInput
    /**
     * Limit how many TeacherProfiles to delete.
     */
    limit?: number
  }

  /**
   * TeacherProfile without action
   */
  export type TeacherProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherProfile
     */
    omit?: TeacherProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileInclude<ExtArgs> | null
  }


  /**
   * Model Subject
   */

  export type AggregateSubject = {
    _count: SubjectCountAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  export type SubjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    organizationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    organizationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubjectCountAggregateOutputType = {
    id: number
    name: number
    code: number
    description: number
    organizationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubjectMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubjectMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubjectCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subject to aggregate.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subjects
    **/
    _count?: true | SubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectMaxAggregateInputType
  }

  export type GetSubjectAggregateType<T extends SubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubject[P]>
      : GetScalarType<T[P], AggregateSubject[P]>
  }




  export type SubjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithAggregationInput | SubjectOrderByWithAggregationInput[]
    by: SubjectScalarFieldEnum[] | SubjectScalarFieldEnum
    having?: SubjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectCountAggregateInputType | true
    _min?: SubjectMinAggregateInputType
    _max?: SubjectMaxAggregateInputType
  }

  export type SubjectGroupByOutputType = {
    id: string
    name: string
    code: string
    description: string
    organizationId: string
    createdAt: Date
    updatedAt: Date
    _count: SubjectCountAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  type GetSubjectGroupByPayload<T extends SubjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectGroupByOutputType[P]>
        }
      >
    >


  export type SubjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    teachingAssignments?: boolean | Subject$teachingAssignmentsArgs<ExtArgs>
    exam?: boolean | Subject$examArgs<ExtArgs>
    examResult?: boolean | Subject$examResultArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "description" | "organizationId" | "createdAt" | "updatedAt", ExtArgs["result"]["subject"]>
  export type SubjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    teachingAssignments?: boolean | Subject$teachingAssignmentsArgs<ExtArgs>
    exam?: boolean | Subject$examArgs<ExtArgs>
    examResult?: boolean | Subject$examResultArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type SubjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $SubjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subject"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      teachingAssignments: Prisma.$TeachingAssignmentPayload<ExtArgs>[]
      exam: Prisma.$ExamPayload<ExtArgs>[]
      examResult: Prisma.$ExamResultPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      description: string
      organizationId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subject"]>
    composites: {}
  }

  type SubjectGetPayload<S extends boolean | null | undefined | SubjectDefaultArgs> = $Result.GetResult<Prisma.$SubjectPayload, S>

  type SubjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubjectCountAggregateInputType | true
    }

  export interface SubjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subject'], meta: { name: 'Subject' } }
    /**
     * Find zero or one Subject that matches the filter.
     * @param {SubjectFindUniqueArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubjectFindUniqueArgs>(args: SelectSubset<T, SubjectFindUniqueArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubjectFindUniqueOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubjectFindUniqueOrThrowArgs>(args: SelectSubset<T, SubjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubjectFindFirstArgs>(args?: SelectSubset<T, SubjectFindFirstArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubjectFindFirstOrThrowArgs>(args?: SelectSubset<T, SubjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subjects
     * const subjects = await prisma.subject.findMany()
     * 
     * // Get first 10 Subjects
     * const subjects = await prisma.subject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subjectWithIdOnly = await prisma.subject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubjectFindManyArgs>(args?: SelectSubset<T, SubjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subject.
     * @param {SubjectCreateArgs} args - Arguments to create a Subject.
     * @example
     * // Create one Subject
     * const Subject = await prisma.subject.create({
     *   data: {
     *     // ... data to create a Subject
     *   }
     * })
     * 
     */
    create<T extends SubjectCreateArgs>(args: SelectSubset<T, SubjectCreateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subjects.
     * @param {SubjectCreateManyArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubjectCreateManyArgs>(args?: SelectSubset<T, SubjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subjects and returns the data saved in the database.
     * @param {SubjectCreateManyAndReturnArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subjects and only return the `id`
     * const subjectWithIdOnly = await prisma.subject.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubjectCreateManyAndReturnArgs>(args?: SelectSubset<T, SubjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subject.
     * @param {SubjectDeleteArgs} args - Arguments to delete one Subject.
     * @example
     * // Delete one Subject
     * const Subject = await prisma.subject.delete({
     *   where: {
     *     // ... filter to delete one Subject
     *   }
     * })
     * 
     */
    delete<T extends SubjectDeleteArgs>(args: SelectSubset<T, SubjectDeleteArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subject.
     * @param {SubjectUpdateArgs} args - Arguments to update one Subject.
     * @example
     * // Update one Subject
     * const subject = await prisma.subject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubjectUpdateArgs>(args: SelectSubset<T, SubjectUpdateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subjects.
     * @param {SubjectDeleteManyArgs} args - Arguments to filter Subjects to delete.
     * @example
     * // Delete a few Subjects
     * const { count } = await prisma.subject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubjectDeleteManyArgs>(args?: SelectSubset<T, SubjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubjectUpdateManyArgs>(args: SelectSubset<T, SubjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects and returns the data updated in the database.
     * @param {SubjectUpdateManyAndReturnArgs} args - Arguments to update many Subjects.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subjects and only return the `id`
     * const subjectWithIdOnly = await prisma.subject.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubjectUpdateManyAndReturnArgs>(args: SelectSubset<T, SubjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subject.
     * @param {SubjectUpsertArgs} args - Arguments to update or create a Subject.
     * @example
     * // Update or create a Subject
     * const subject = await prisma.subject.upsert({
     *   create: {
     *     // ... data to create a Subject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subject we want to update
     *   }
     * })
     */
    upsert<T extends SubjectUpsertArgs>(args: SelectSubset<T, SubjectUpsertArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectCountArgs} args - Arguments to filter Subjects to count.
     * @example
     * // Count the number of Subjects
     * const count = await prisma.subject.count({
     *   where: {
     *     // ... the filter for the Subjects we want to count
     *   }
     * })
    **/
    count<T extends SubjectCountArgs>(
      args?: Subset<T, SubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectAggregateArgs>(args: Subset<T, SubjectAggregateArgs>): Prisma.PrismaPromise<GetSubjectAggregateType<T>>

    /**
     * Group by Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubjectGroupByArgs['orderBy'] }
        : { orderBy?: SubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subject model
   */
  readonly fields: SubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    teachingAssignments<T extends Subject$teachingAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Subject$teachingAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeachingAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exam<T extends Subject$examArgs<ExtArgs> = {}>(args?: Subset<T, Subject$examArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    examResult<T extends Subject$examResultArgs<ExtArgs> = {}>(args?: Subset<T, Subject$examResultArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subject model
   */
  interface SubjectFieldRefs {
    readonly id: FieldRef<"Subject", 'String'>
    readonly name: FieldRef<"Subject", 'String'>
    readonly code: FieldRef<"Subject", 'String'>
    readonly description: FieldRef<"Subject", 'String'>
    readonly organizationId: FieldRef<"Subject", 'String'>
    readonly createdAt: FieldRef<"Subject", 'DateTime'>
    readonly updatedAt: FieldRef<"Subject", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subject findUnique
   */
  export type SubjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findUniqueOrThrow
   */
  export type SubjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findFirst
   */
  export type SubjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findFirstOrThrow
   */
  export type SubjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findMany
   */
  export type SubjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subjects to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject create
   */
  export type SubjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Subject.
     */
    data: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
  }

  /**
   * Subject createMany
   */
  export type SubjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subjects.
     */
    data: SubjectCreateManyInput | SubjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subject createManyAndReturn
   */
  export type SubjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * The data used to create many Subjects.
     */
    data: SubjectCreateManyInput | SubjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subject update
   */
  export type SubjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Subject.
     */
    data: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
    /**
     * Choose, which Subject to update.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject updateMany
   */
  export type SubjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subjects.
     */
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyInput>
    /**
     * Filter which Subjects to update
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to update.
     */
    limit?: number
  }

  /**
   * Subject updateManyAndReturn
   */
  export type SubjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * The data used to update Subjects.
     */
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyInput>
    /**
     * Filter which Subjects to update
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subject upsert
   */
  export type SubjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Subject to update in case it exists.
     */
    where: SubjectWhereUniqueInput
    /**
     * In case the Subject found by the `where` argument doesn't exist, create a new Subject with this data.
     */
    create: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
    /**
     * In case the Subject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
  }

  /**
   * Subject delete
   */
  export type SubjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter which Subject to delete.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject deleteMany
   */
  export type SubjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subjects to delete
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to delete.
     */
    limit?: number
  }

  /**
   * Subject.teachingAssignments
   */
  export type Subject$teachingAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingAssignment
     */
    select?: TeachingAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeachingAssignment
     */
    omit?: TeachingAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingAssignmentInclude<ExtArgs> | null
    where?: TeachingAssignmentWhereInput
    orderBy?: TeachingAssignmentOrderByWithRelationInput | TeachingAssignmentOrderByWithRelationInput[]
    cursor?: TeachingAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeachingAssignmentScalarFieldEnum | TeachingAssignmentScalarFieldEnum[]
  }

  /**
   * Subject.exam
   */
  export type Subject$examArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    cursor?: ExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Subject.examResult
   */
  export type Subject$examResultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamResult
     */
    select?: ExamResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamResult
     */
    omit?: ExamResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamResultInclude<ExtArgs> | null
    where?: ExamResultWhereInput
    orderBy?: ExamResultOrderByWithRelationInput | ExamResultOrderByWithRelationInput[]
    cursor?: ExamResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamResultScalarFieldEnum | ExamResultScalarFieldEnum[]
  }

  /**
   * Subject without action
   */
  export type SubjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
  }


  /**
   * Model TeachingAssignment
   */

  export type AggregateTeachingAssignment = {
    _count: TeachingAssignmentCountAggregateOutputType | null
    _min: TeachingAssignmentMinAggregateOutputType | null
    _max: TeachingAssignmentMaxAggregateOutputType | null
  }

  export type TeachingAssignmentMinAggregateOutputType = {
    id: string | null
    teacherId: string | null
    subjectId: string | null
    gradeId: string | null
    sectionId: string | null
    organizationId: string | null
    academicYear: string | null
    status: $Enums.AssignmentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    academicYearId: string | null
  }

  export type TeachingAssignmentMaxAggregateOutputType = {
    id: string | null
    teacherId: string | null
    subjectId: string | null
    gradeId: string | null
    sectionId: string | null
    organizationId: string | null
    academicYear: string | null
    status: $Enums.AssignmentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    academicYearId: string | null
  }

  export type TeachingAssignmentCountAggregateOutputType = {
    id: number
    teacherId: number
    subjectId: number
    gradeId: number
    sectionId: number
    organizationId: number
    academicYear: number
    status: number
    createdAt: number
    updatedAt: number
    academicYearId: number
    _all: number
  }


  export type TeachingAssignmentMinAggregateInputType = {
    id?: true
    teacherId?: true
    subjectId?: true
    gradeId?: true
    sectionId?: true
    organizationId?: true
    academicYear?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    academicYearId?: true
  }

  export type TeachingAssignmentMaxAggregateInputType = {
    id?: true
    teacherId?: true
    subjectId?: true
    gradeId?: true
    sectionId?: true
    organizationId?: true
    academicYear?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    academicYearId?: true
  }

  export type TeachingAssignmentCountAggregateInputType = {
    id?: true
    teacherId?: true
    subjectId?: true
    gradeId?: true
    sectionId?: true
    organizationId?: true
    academicYear?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    academicYearId?: true
    _all?: true
  }

  export type TeachingAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeachingAssignment to aggregate.
     */
    where?: TeachingAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeachingAssignments to fetch.
     */
    orderBy?: TeachingAssignmentOrderByWithRelationInput | TeachingAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeachingAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeachingAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeachingAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeachingAssignments
    **/
    _count?: true | TeachingAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeachingAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeachingAssignmentMaxAggregateInputType
  }

  export type GetTeachingAssignmentAggregateType<T extends TeachingAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateTeachingAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeachingAssignment[P]>
      : GetScalarType<T[P], AggregateTeachingAssignment[P]>
  }




  export type TeachingAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeachingAssignmentWhereInput
    orderBy?: TeachingAssignmentOrderByWithAggregationInput | TeachingAssignmentOrderByWithAggregationInput[]
    by: TeachingAssignmentScalarFieldEnum[] | TeachingAssignmentScalarFieldEnum
    having?: TeachingAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeachingAssignmentCountAggregateInputType | true
    _min?: TeachingAssignmentMinAggregateInputType
    _max?: TeachingAssignmentMaxAggregateInputType
  }

  export type TeachingAssignmentGroupByOutputType = {
    id: string
    teacherId: string
    subjectId: string
    gradeId: string
    sectionId: string
    organizationId: string
    academicYear: string | null
    status: $Enums.AssignmentStatus
    createdAt: Date
    updatedAt: Date
    academicYearId: string | null
    _count: TeachingAssignmentCountAggregateOutputType | null
    _min: TeachingAssignmentMinAggregateOutputType | null
    _max: TeachingAssignmentMaxAggregateOutputType | null
  }

  type GetTeachingAssignmentGroupByPayload<T extends TeachingAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeachingAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeachingAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeachingAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], TeachingAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type TeachingAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    subjectId?: boolean
    gradeId?: boolean
    sectionId?: boolean
    organizationId?: boolean
    academicYear?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicYearId?: boolean
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    grade?: boolean | GradeDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    AcademicYear?: boolean | TeachingAssignment$AcademicYearArgs<ExtArgs>
  }, ExtArgs["result"]["teachingAssignment"]>

  export type TeachingAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    subjectId?: boolean
    gradeId?: boolean
    sectionId?: boolean
    organizationId?: boolean
    academicYear?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicYearId?: boolean
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    grade?: boolean | GradeDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    AcademicYear?: boolean | TeachingAssignment$AcademicYearArgs<ExtArgs>
  }, ExtArgs["result"]["teachingAssignment"]>

  export type TeachingAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    subjectId?: boolean
    gradeId?: boolean
    sectionId?: boolean
    organizationId?: boolean
    academicYear?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicYearId?: boolean
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    grade?: boolean | GradeDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    AcademicYear?: boolean | TeachingAssignment$AcademicYearArgs<ExtArgs>
  }, ExtArgs["result"]["teachingAssignment"]>

  export type TeachingAssignmentSelectScalar = {
    id?: boolean
    teacherId?: boolean
    subjectId?: boolean
    gradeId?: boolean
    sectionId?: boolean
    organizationId?: boolean
    academicYear?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicYearId?: boolean
  }

  export type TeachingAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teacherId" | "subjectId" | "gradeId" | "sectionId" | "organizationId" | "academicYear" | "status" | "createdAt" | "updatedAt" | "academicYearId", ExtArgs["result"]["teachingAssignment"]>
  export type TeachingAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    grade?: boolean | GradeDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    AcademicYear?: boolean | TeachingAssignment$AcademicYearArgs<ExtArgs>
  }
  export type TeachingAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    grade?: boolean | GradeDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    AcademicYear?: boolean | TeachingAssignment$AcademicYearArgs<ExtArgs>
  }
  export type TeachingAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    grade?: boolean | GradeDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    AcademicYear?: boolean | TeachingAssignment$AcademicYearArgs<ExtArgs>
  }

  export type $TeachingAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeachingAssignment"
    objects: {
      teacher: Prisma.$TeacherPayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs>
      grade: Prisma.$GradePayload<ExtArgs>
      section: Prisma.$SectionPayload<ExtArgs>
      organization: Prisma.$OrganizationPayload<ExtArgs>
      AcademicYear: Prisma.$AcademicYearPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teacherId: string
      subjectId: string
      gradeId: string
      sectionId: string
      organizationId: string
      academicYear: string | null
      status: $Enums.AssignmentStatus
      createdAt: Date
      updatedAt: Date
      academicYearId: string | null
    }, ExtArgs["result"]["teachingAssignment"]>
    composites: {}
  }

  type TeachingAssignmentGetPayload<S extends boolean | null | undefined | TeachingAssignmentDefaultArgs> = $Result.GetResult<Prisma.$TeachingAssignmentPayload, S>

  type TeachingAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeachingAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeachingAssignmentCountAggregateInputType | true
    }

  export interface TeachingAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeachingAssignment'], meta: { name: 'TeachingAssignment' } }
    /**
     * Find zero or one TeachingAssignment that matches the filter.
     * @param {TeachingAssignmentFindUniqueArgs} args - Arguments to find a TeachingAssignment
     * @example
     * // Get one TeachingAssignment
     * const teachingAssignment = await prisma.teachingAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeachingAssignmentFindUniqueArgs>(args: SelectSubset<T, TeachingAssignmentFindUniqueArgs<ExtArgs>>): Prisma__TeachingAssignmentClient<$Result.GetResult<Prisma.$TeachingAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeachingAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeachingAssignmentFindUniqueOrThrowArgs} args - Arguments to find a TeachingAssignment
     * @example
     * // Get one TeachingAssignment
     * const teachingAssignment = await prisma.teachingAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeachingAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, TeachingAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeachingAssignmentClient<$Result.GetResult<Prisma.$TeachingAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeachingAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachingAssignmentFindFirstArgs} args - Arguments to find a TeachingAssignment
     * @example
     * // Get one TeachingAssignment
     * const teachingAssignment = await prisma.teachingAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeachingAssignmentFindFirstArgs>(args?: SelectSubset<T, TeachingAssignmentFindFirstArgs<ExtArgs>>): Prisma__TeachingAssignmentClient<$Result.GetResult<Prisma.$TeachingAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeachingAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachingAssignmentFindFirstOrThrowArgs} args - Arguments to find a TeachingAssignment
     * @example
     * // Get one TeachingAssignment
     * const teachingAssignment = await prisma.teachingAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeachingAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, TeachingAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeachingAssignmentClient<$Result.GetResult<Prisma.$TeachingAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeachingAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachingAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeachingAssignments
     * const teachingAssignments = await prisma.teachingAssignment.findMany()
     * 
     * // Get first 10 TeachingAssignments
     * const teachingAssignments = await prisma.teachingAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teachingAssignmentWithIdOnly = await prisma.teachingAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeachingAssignmentFindManyArgs>(args?: SelectSubset<T, TeachingAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeachingAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeachingAssignment.
     * @param {TeachingAssignmentCreateArgs} args - Arguments to create a TeachingAssignment.
     * @example
     * // Create one TeachingAssignment
     * const TeachingAssignment = await prisma.teachingAssignment.create({
     *   data: {
     *     // ... data to create a TeachingAssignment
     *   }
     * })
     * 
     */
    create<T extends TeachingAssignmentCreateArgs>(args: SelectSubset<T, TeachingAssignmentCreateArgs<ExtArgs>>): Prisma__TeachingAssignmentClient<$Result.GetResult<Prisma.$TeachingAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeachingAssignments.
     * @param {TeachingAssignmentCreateManyArgs} args - Arguments to create many TeachingAssignments.
     * @example
     * // Create many TeachingAssignments
     * const teachingAssignment = await prisma.teachingAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeachingAssignmentCreateManyArgs>(args?: SelectSubset<T, TeachingAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeachingAssignments and returns the data saved in the database.
     * @param {TeachingAssignmentCreateManyAndReturnArgs} args - Arguments to create many TeachingAssignments.
     * @example
     * // Create many TeachingAssignments
     * const teachingAssignment = await prisma.teachingAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeachingAssignments and only return the `id`
     * const teachingAssignmentWithIdOnly = await prisma.teachingAssignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeachingAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, TeachingAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeachingAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TeachingAssignment.
     * @param {TeachingAssignmentDeleteArgs} args - Arguments to delete one TeachingAssignment.
     * @example
     * // Delete one TeachingAssignment
     * const TeachingAssignment = await prisma.teachingAssignment.delete({
     *   where: {
     *     // ... filter to delete one TeachingAssignment
     *   }
     * })
     * 
     */
    delete<T extends TeachingAssignmentDeleteArgs>(args: SelectSubset<T, TeachingAssignmentDeleteArgs<ExtArgs>>): Prisma__TeachingAssignmentClient<$Result.GetResult<Prisma.$TeachingAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeachingAssignment.
     * @param {TeachingAssignmentUpdateArgs} args - Arguments to update one TeachingAssignment.
     * @example
     * // Update one TeachingAssignment
     * const teachingAssignment = await prisma.teachingAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeachingAssignmentUpdateArgs>(args: SelectSubset<T, TeachingAssignmentUpdateArgs<ExtArgs>>): Prisma__TeachingAssignmentClient<$Result.GetResult<Prisma.$TeachingAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeachingAssignments.
     * @param {TeachingAssignmentDeleteManyArgs} args - Arguments to filter TeachingAssignments to delete.
     * @example
     * // Delete a few TeachingAssignments
     * const { count } = await prisma.teachingAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeachingAssignmentDeleteManyArgs>(args?: SelectSubset<T, TeachingAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeachingAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachingAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeachingAssignments
     * const teachingAssignment = await prisma.teachingAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeachingAssignmentUpdateManyArgs>(args: SelectSubset<T, TeachingAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeachingAssignments and returns the data updated in the database.
     * @param {TeachingAssignmentUpdateManyAndReturnArgs} args - Arguments to update many TeachingAssignments.
     * @example
     * // Update many TeachingAssignments
     * const teachingAssignment = await prisma.teachingAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TeachingAssignments and only return the `id`
     * const teachingAssignmentWithIdOnly = await prisma.teachingAssignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeachingAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, TeachingAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeachingAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TeachingAssignment.
     * @param {TeachingAssignmentUpsertArgs} args - Arguments to update or create a TeachingAssignment.
     * @example
     * // Update or create a TeachingAssignment
     * const teachingAssignment = await prisma.teachingAssignment.upsert({
     *   create: {
     *     // ... data to create a TeachingAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeachingAssignment we want to update
     *   }
     * })
     */
    upsert<T extends TeachingAssignmentUpsertArgs>(args: SelectSubset<T, TeachingAssignmentUpsertArgs<ExtArgs>>): Prisma__TeachingAssignmentClient<$Result.GetResult<Prisma.$TeachingAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TeachingAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachingAssignmentCountArgs} args - Arguments to filter TeachingAssignments to count.
     * @example
     * // Count the number of TeachingAssignments
     * const count = await prisma.teachingAssignment.count({
     *   where: {
     *     // ... the filter for the TeachingAssignments we want to count
     *   }
     * })
    **/
    count<T extends TeachingAssignmentCountArgs>(
      args?: Subset<T, TeachingAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeachingAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeachingAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachingAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeachingAssignmentAggregateArgs>(args: Subset<T, TeachingAssignmentAggregateArgs>): Prisma.PrismaPromise<GetTeachingAssignmentAggregateType<T>>

    /**
     * Group by TeachingAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachingAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeachingAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeachingAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: TeachingAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeachingAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeachingAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeachingAssignment model
   */
  readonly fields: TeachingAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeachingAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeachingAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teacher<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    grade<T extends GradeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GradeDefaultArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    section<T extends SectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SectionDefaultArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    AcademicYear<T extends TeachingAssignment$AcademicYearArgs<ExtArgs> = {}>(args?: Subset<T, TeachingAssignment$AcademicYearArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeachingAssignment model
   */
  interface TeachingAssignmentFieldRefs {
    readonly id: FieldRef<"TeachingAssignment", 'String'>
    readonly teacherId: FieldRef<"TeachingAssignment", 'String'>
    readonly subjectId: FieldRef<"TeachingAssignment", 'String'>
    readonly gradeId: FieldRef<"TeachingAssignment", 'String'>
    readonly sectionId: FieldRef<"TeachingAssignment", 'String'>
    readonly organizationId: FieldRef<"TeachingAssignment", 'String'>
    readonly academicYear: FieldRef<"TeachingAssignment", 'String'>
    readonly status: FieldRef<"TeachingAssignment", 'AssignmentStatus'>
    readonly createdAt: FieldRef<"TeachingAssignment", 'DateTime'>
    readonly updatedAt: FieldRef<"TeachingAssignment", 'DateTime'>
    readonly academicYearId: FieldRef<"TeachingAssignment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TeachingAssignment findUnique
   */
  export type TeachingAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingAssignment
     */
    select?: TeachingAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeachingAssignment
     */
    omit?: TeachingAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TeachingAssignment to fetch.
     */
    where: TeachingAssignmentWhereUniqueInput
  }

  /**
   * TeachingAssignment findUniqueOrThrow
   */
  export type TeachingAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingAssignment
     */
    select?: TeachingAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeachingAssignment
     */
    omit?: TeachingAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TeachingAssignment to fetch.
     */
    where: TeachingAssignmentWhereUniqueInput
  }

  /**
   * TeachingAssignment findFirst
   */
  export type TeachingAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingAssignment
     */
    select?: TeachingAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeachingAssignment
     */
    omit?: TeachingAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TeachingAssignment to fetch.
     */
    where?: TeachingAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeachingAssignments to fetch.
     */
    orderBy?: TeachingAssignmentOrderByWithRelationInput | TeachingAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeachingAssignments.
     */
    cursor?: TeachingAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeachingAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeachingAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeachingAssignments.
     */
    distinct?: TeachingAssignmentScalarFieldEnum | TeachingAssignmentScalarFieldEnum[]
  }

  /**
   * TeachingAssignment findFirstOrThrow
   */
  export type TeachingAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingAssignment
     */
    select?: TeachingAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeachingAssignment
     */
    omit?: TeachingAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TeachingAssignment to fetch.
     */
    where?: TeachingAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeachingAssignments to fetch.
     */
    orderBy?: TeachingAssignmentOrderByWithRelationInput | TeachingAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeachingAssignments.
     */
    cursor?: TeachingAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeachingAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeachingAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeachingAssignments.
     */
    distinct?: TeachingAssignmentScalarFieldEnum | TeachingAssignmentScalarFieldEnum[]
  }

  /**
   * TeachingAssignment findMany
   */
  export type TeachingAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingAssignment
     */
    select?: TeachingAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeachingAssignment
     */
    omit?: TeachingAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TeachingAssignments to fetch.
     */
    where?: TeachingAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeachingAssignments to fetch.
     */
    orderBy?: TeachingAssignmentOrderByWithRelationInput | TeachingAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeachingAssignments.
     */
    cursor?: TeachingAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeachingAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeachingAssignments.
     */
    skip?: number
    distinct?: TeachingAssignmentScalarFieldEnum | TeachingAssignmentScalarFieldEnum[]
  }

  /**
   * TeachingAssignment create
   */
  export type TeachingAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingAssignment
     */
    select?: TeachingAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeachingAssignment
     */
    omit?: TeachingAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a TeachingAssignment.
     */
    data: XOR<TeachingAssignmentCreateInput, TeachingAssignmentUncheckedCreateInput>
  }

  /**
   * TeachingAssignment createMany
   */
  export type TeachingAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeachingAssignments.
     */
    data: TeachingAssignmentCreateManyInput | TeachingAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeachingAssignment createManyAndReturn
   */
  export type TeachingAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingAssignment
     */
    select?: TeachingAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeachingAssignment
     */
    omit?: TeachingAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many TeachingAssignments.
     */
    data: TeachingAssignmentCreateManyInput | TeachingAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeachingAssignment update
   */
  export type TeachingAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingAssignment
     */
    select?: TeachingAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeachingAssignment
     */
    omit?: TeachingAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a TeachingAssignment.
     */
    data: XOR<TeachingAssignmentUpdateInput, TeachingAssignmentUncheckedUpdateInput>
    /**
     * Choose, which TeachingAssignment to update.
     */
    where: TeachingAssignmentWhereUniqueInput
  }

  /**
   * TeachingAssignment updateMany
   */
  export type TeachingAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeachingAssignments.
     */
    data: XOR<TeachingAssignmentUpdateManyMutationInput, TeachingAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which TeachingAssignments to update
     */
    where?: TeachingAssignmentWhereInput
    /**
     * Limit how many TeachingAssignments to update.
     */
    limit?: number
  }

  /**
   * TeachingAssignment updateManyAndReturn
   */
  export type TeachingAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingAssignment
     */
    select?: TeachingAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeachingAssignment
     */
    omit?: TeachingAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update TeachingAssignments.
     */
    data: XOR<TeachingAssignmentUpdateManyMutationInput, TeachingAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which TeachingAssignments to update
     */
    where?: TeachingAssignmentWhereInput
    /**
     * Limit how many TeachingAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeachingAssignment upsert
   */
  export type TeachingAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingAssignment
     */
    select?: TeachingAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeachingAssignment
     */
    omit?: TeachingAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the TeachingAssignment to update in case it exists.
     */
    where: TeachingAssignmentWhereUniqueInput
    /**
     * In case the TeachingAssignment found by the `where` argument doesn't exist, create a new TeachingAssignment with this data.
     */
    create: XOR<TeachingAssignmentCreateInput, TeachingAssignmentUncheckedCreateInput>
    /**
     * In case the TeachingAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeachingAssignmentUpdateInput, TeachingAssignmentUncheckedUpdateInput>
  }

  /**
   * TeachingAssignment delete
   */
  export type TeachingAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingAssignment
     */
    select?: TeachingAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeachingAssignment
     */
    omit?: TeachingAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingAssignmentInclude<ExtArgs> | null
    /**
     * Filter which TeachingAssignment to delete.
     */
    where: TeachingAssignmentWhereUniqueInput
  }

  /**
   * TeachingAssignment deleteMany
   */
  export type TeachingAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeachingAssignments to delete
     */
    where?: TeachingAssignmentWhereInput
    /**
     * Limit how many TeachingAssignments to delete.
     */
    limit?: number
  }

  /**
   * TeachingAssignment.AcademicYear
   */
  export type TeachingAssignment$AcademicYearArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    where?: AcademicYearWhereInput
  }

  /**
   * TeachingAssignment without action
   */
  export type TeachingAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachingAssignment
     */
    select?: TeachingAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeachingAssignment
     */
    omit?: TeachingAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachingAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    middleName: string | null
    motherName: string | null
    fullName: string | null
    dateOfBirth: Date | null
    profileImage: string | null
    rollNumber: string | null
    phoneNumber: string | null
    whatsAppNumber: string | null
    email: string | null
    emergencyContact: string | null
    gender: $Enums.Gender | null
    sectionId: string | null
    gradeId: string | null
    organizationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    middleName: string | null
    motherName: string | null
    fullName: string | null
    dateOfBirth: Date | null
    profileImage: string | null
    rollNumber: string | null
    phoneNumber: string | null
    whatsAppNumber: string | null
    email: string | null
    emergencyContact: string | null
    gender: $Enums.Gender | null
    sectionId: string | null
    gradeId: string | null
    organizationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    userId: number
    firstName: number
    lastName: number
    middleName: number
    motherName: number
    fullName: number
    dateOfBirth: number
    profileImage: number
    rollNumber: number
    phoneNumber: number
    whatsAppNumber: number
    email: number
    emergencyContact: number
    gender: number
    sectionId: number
    gradeId: number
    organizationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentMinAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    middleName?: true
    motherName?: true
    fullName?: true
    dateOfBirth?: true
    profileImage?: true
    rollNumber?: true
    phoneNumber?: true
    whatsAppNumber?: true
    email?: true
    emergencyContact?: true
    gender?: true
    sectionId?: true
    gradeId?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    middleName?: true
    motherName?: true
    fullName?: true
    dateOfBirth?: true
    profileImage?: true
    rollNumber?: true
    phoneNumber?: true
    whatsAppNumber?: true
    email?: true
    emergencyContact?: true
    gender?: true
    sectionId?: true
    gradeId?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    middleName?: true
    motherName?: true
    fullName?: true
    dateOfBirth?: true
    profileImage?: true
    rollNumber?: true
    phoneNumber?: true
    whatsAppNumber?: true
    email?: true
    emergencyContact?: true
    gender?: true
    sectionId?: true
    gradeId?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithAggregationInput | StudentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    id: string
    userId: string
    firstName: string
    lastName: string
    middleName: string | null
    motherName: string | null
    fullName: string | null
    dateOfBirth: Date
    profileImage: string | null
    rollNumber: string
    phoneNumber: string
    whatsAppNumber: string
    email: string
    emergencyContact: string
    gender: $Enums.Gender
    sectionId: string
    gradeId: string
    organizationId: string
    createdAt: Date
    updatedAt: Date
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    middleName?: boolean
    motherName?: boolean
    fullName?: boolean
    dateOfBirth?: boolean
    profileImage?: boolean
    rollNumber?: boolean
    phoneNumber?: boolean
    whatsAppNumber?: boolean
    email?: boolean
    emergencyContact?: boolean
    gender?: boolean
    sectionId?: boolean
    gradeId?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    grade?: boolean | GradeDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    Fee?: boolean | Student$FeeArgs<ExtArgs>
    parents?: boolean | Student$parentsArgs<ExtArgs>
    StudentAttendance?: boolean | Student$StudentAttendanceArgs<ExtArgs>
    StudentDocument?: boolean | Student$StudentDocumentArgs<ExtArgs>
    NotificationLog?: boolean | Student$NotificationLogArgs<ExtArgs>
    reportCard?: boolean | Student$reportCardArgs<ExtArgs>
    hallTicket?: boolean | Student$hallTicketArgs<ExtArgs>
    examResult?: boolean | Student$examResultArgs<ExtArgs>
    examEnrollment?: boolean | Student$examEnrollmentArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    middleName?: boolean
    motherName?: boolean
    fullName?: boolean
    dateOfBirth?: boolean
    profileImage?: boolean
    rollNumber?: boolean
    phoneNumber?: boolean
    whatsAppNumber?: boolean
    email?: boolean
    emergencyContact?: boolean
    gender?: boolean
    sectionId?: boolean
    gradeId?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    grade?: boolean | GradeDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    middleName?: boolean
    motherName?: boolean
    fullName?: boolean
    dateOfBirth?: boolean
    profileImage?: boolean
    rollNumber?: boolean
    phoneNumber?: boolean
    whatsAppNumber?: boolean
    email?: boolean
    emergencyContact?: boolean
    gender?: boolean
    sectionId?: boolean
    gradeId?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    grade?: boolean | GradeDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectScalar = {
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    middleName?: boolean
    motherName?: boolean
    fullName?: boolean
    dateOfBirth?: boolean
    profileImage?: boolean
    rollNumber?: boolean
    phoneNumber?: boolean
    whatsAppNumber?: boolean
    email?: boolean
    emergencyContact?: boolean
    gender?: boolean
    sectionId?: boolean
    gradeId?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "firstName" | "lastName" | "middleName" | "motherName" | "fullName" | "dateOfBirth" | "profileImage" | "rollNumber" | "phoneNumber" | "whatsAppNumber" | "email" | "emergencyContact" | "gender" | "sectionId" | "gradeId" | "organizationId" | "createdAt" | "updatedAt", ExtArgs["result"]["student"]>
  export type StudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    grade?: boolean | GradeDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    Fee?: boolean | Student$FeeArgs<ExtArgs>
    parents?: boolean | Student$parentsArgs<ExtArgs>
    StudentAttendance?: boolean | Student$StudentAttendanceArgs<ExtArgs>
    StudentDocument?: boolean | Student$StudentDocumentArgs<ExtArgs>
    NotificationLog?: boolean | Student$NotificationLogArgs<ExtArgs>
    reportCard?: boolean | Student$reportCardArgs<ExtArgs>
    hallTicket?: boolean | Student$hallTicketArgs<ExtArgs>
    examResult?: boolean | Student$examResultArgs<ExtArgs>
    examEnrollment?: boolean | Student$examEnrollmentArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    grade?: boolean | GradeDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type StudentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    grade?: boolean | GradeDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $StudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Student"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      section: Prisma.$SectionPayload<ExtArgs>
      grade: Prisma.$GradePayload<ExtArgs>
      organization: Prisma.$OrganizationPayload<ExtArgs>
      Fee: Prisma.$FeePayload<ExtArgs>[]
      parents: Prisma.$ParentStudentPayload<ExtArgs>[]
      StudentAttendance: Prisma.$StudentAttendancePayload<ExtArgs>[]
      StudentDocument: Prisma.$StudentDocumentPayload<ExtArgs>[]
      NotificationLog: Prisma.$NotificationLogPayload<ExtArgs>[]
      reportCard: Prisma.$ReportCardPayload<ExtArgs>[]
      hallTicket: Prisma.$HallTicketPayload<ExtArgs>[]
      examResult: Prisma.$ExamResultPayload<ExtArgs>[]
      examEnrollment: Prisma.$ExamEnrollmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      firstName: string
      lastName: string
      middleName: string | null
      motherName: string | null
      fullName: string | null
      dateOfBirth: Date
      profileImage: string | null
      rollNumber: string
      phoneNumber: string
      whatsAppNumber: string
      email: string
      emergencyContact: string
      gender: $Enums.Gender
      sectionId: string
      gradeId: string
      organizationId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type StudentGetPayload<S extends boolean | null | undefined | StudentDefaultArgs> = $Result.GetResult<Prisma.$StudentPayload, S>

  type StudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Student'], meta: { name: 'Student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFindUniqueArgs>(args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFindFirstArgs>(args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentFindManyArgs>(args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends StudentCreateArgs>(args: SelectSubset<T, StudentCreateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Students.
     * @param {StudentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentCreateManyArgs>(args?: SelectSubset<T, StudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Students and returns the data saved in the database.
     * @param {StudentCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends StudentDeleteArgs>(args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentUpdateArgs>(args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentDeleteManyArgs>(args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentUpdateManyArgs>(args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students and returns the data updated in the database.
     * @param {StudentUpdateManyAndReturnArgs} args - Arguments to update many Students.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends StudentUpsertArgs>(args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Student model
   */
  readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    section<T extends SectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SectionDefaultArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    grade<T extends GradeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GradeDefaultArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Fee<T extends Student$FeeArgs<ExtArgs> = {}>(args?: Subset<T, Student$FeeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parents<T extends Student$parentsArgs<ExtArgs> = {}>(args?: Subset<T, Student$parentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentStudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StudentAttendance<T extends Student$StudentAttendanceArgs<ExtArgs> = {}>(args?: Subset<T, Student$StudentAttendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StudentDocument<T extends Student$StudentDocumentArgs<ExtArgs> = {}>(args?: Subset<T, Student$StudentDocumentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    NotificationLog<T extends Student$NotificationLogArgs<ExtArgs> = {}>(args?: Subset<T, Student$NotificationLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reportCard<T extends Student$reportCardArgs<ExtArgs> = {}>(args?: Subset<T, Student$reportCardArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    hallTicket<T extends Student$hallTicketArgs<ExtArgs> = {}>(args?: Subset<T, Student$hallTicketArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HallTicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    examResult<T extends Student$examResultArgs<ExtArgs> = {}>(args?: Subset<T, Student$examResultArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    examEnrollment<T extends Student$examEnrollmentArgs<ExtArgs> = {}>(args?: Subset<T, Student$examEnrollmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Student model
   */
  interface StudentFieldRefs {
    readonly id: FieldRef<"Student", 'String'>
    readonly userId: FieldRef<"Student", 'String'>
    readonly firstName: FieldRef<"Student", 'String'>
    readonly lastName: FieldRef<"Student", 'String'>
    readonly middleName: FieldRef<"Student", 'String'>
    readonly motherName: FieldRef<"Student", 'String'>
    readonly fullName: FieldRef<"Student", 'String'>
    readonly dateOfBirth: FieldRef<"Student", 'DateTime'>
    readonly profileImage: FieldRef<"Student", 'String'>
    readonly rollNumber: FieldRef<"Student", 'String'>
    readonly phoneNumber: FieldRef<"Student", 'String'>
    readonly whatsAppNumber: FieldRef<"Student", 'String'>
    readonly email: FieldRef<"Student", 'String'>
    readonly emergencyContact: FieldRef<"Student", 'String'>
    readonly gender: FieldRef<"Student", 'Gender'>
    readonly sectionId: FieldRef<"Student", 'String'>
    readonly gradeId: FieldRef<"Student", 'String'>
    readonly organizationId: FieldRef<"Student", 'String'>
    readonly createdAt: FieldRef<"Student", 'DateTime'>
    readonly updatedAt: FieldRef<"Student", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findMany
   */
  export type StudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student create
   */
  export type StudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }

  /**
   * Student createMany
   */
  export type StudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Student createManyAndReturn
   */
  export type StudentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student update
   */
  export type StudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
  }

  /**
   * Student updateManyAndReturn
   */
  export type StudentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student upsert
   */
  export type StudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }

  /**
   * Student delete
   */
  export type StudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to delete.
     */
    limit?: number
  }

  /**
   * Student.Fee
   */
  export type Student$FeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fee
     */
    omit?: FeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeInclude<ExtArgs> | null
    where?: FeeWhereInput
    orderBy?: FeeOrderByWithRelationInput | FeeOrderByWithRelationInput[]
    cursor?: FeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeeScalarFieldEnum | FeeScalarFieldEnum[]
  }

  /**
   * Student.parents
   */
  export type Student$parentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentStudent
     */
    select?: ParentStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParentStudent
     */
    omit?: ParentStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentStudentInclude<ExtArgs> | null
    where?: ParentStudentWhereInput
    orderBy?: ParentStudentOrderByWithRelationInput | ParentStudentOrderByWithRelationInput[]
    cursor?: ParentStudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParentStudentScalarFieldEnum | ParentStudentScalarFieldEnum[]
  }

  /**
   * Student.StudentAttendance
   */
  export type Student$StudentAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    where?: StudentAttendanceWhereInput
    orderBy?: StudentAttendanceOrderByWithRelationInput | StudentAttendanceOrderByWithRelationInput[]
    cursor?: StudentAttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentAttendanceScalarFieldEnum | StudentAttendanceScalarFieldEnum[]
  }

  /**
   * Student.StudentDocument
   */
  export type Student$StudentDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentDocument
     */
    omit?: StudentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentInclude<ExtArgs> | null
    where?: StudentDocumentWhereInput
    orderBy?: StudentDocumentOrderByWithRelationInput | StudentDocumentOrderByWithRelationInput[]
    cursor?: StudentDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentDocumentScalarFieldEnum | StudentDocumentScalarFieldEnum[]
  }

  /**
   * Student.NotificationLog
   */
  export type Student$NotificationLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    where?: NotificationLogWhereInput
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    cursor?: NotificationLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * Student.reportCard
   */
  export type Student$reportCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportCard
     */
    omit?: ReportCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardInclude<ExtArgs> | null
    where?: ReportCardWhereInput
    orderBy?: ReportCardOrderByWithRelationInput | ReportCardOrderByWithRelationInput[]
    cursor?: ReportCardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportCardScalarFieldEnum | ReportCardScalarFieldEnum[]
  }

  /**
   * Student.hallTicket
   */
  export type Student$hallTicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HallTicket
     */
    select?: HallTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HallTicket
     */
    omit?: HallTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallTicketInclude<ExtArgs> | null
    where?: HallTicketWhereInput
    orderBy?: HallTicketOrderByWithRelationInput | HallTicketOrderByWithRelationInput[]
    cursor?: HallTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HallTicketScalarFieldEnum | HallTicketScalarFieldEnum[]
  }

  /**
   * Student.examResult
   */
  export type Student$examResultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamResult
     */
    select?: ExamResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamResult
     */
    omit?: ExamResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamResultInclude<ExtArgs> | null
    where?: ExamResultWhereInput
    orderBy?: ExamResultOrderByWithRelationInput | ExamResultOrderByWithRelationInput[]
    cursor?: ExamResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamResultScalarFieldEnum | ExamResultScalarFieldEnum[]
  }

  /**
   * Student.examEnrollment
   */
  export type Student$examEnrollmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamEnrollment
     */
    select?: ExamEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamEnrollment
     */
    omit?: ExamEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamEnrollmentInclude<ExtArgs> | null
    where?: ExamEnrollmentWhereInput
    orderBy?: ExamEnrollmentOrderByWithRelationInput | ExamEnrollmentOrderByWithRelationInput[]
    cursor?: ExamEnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamEnrollmentScalarFieldEnum | ExamEnrollmentScalarFieldEnum[]
  }

  /**
   * Student without action
   */
  export type StudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
  }


  /**
   * Model Parent
   */

  export type AggregateParent = {
    _count: ParentCountAggregateOutputType | null
    _min: ParentMinAggregateOutputType | null
    _max: ParentMaxAggregateOutputType | null
  }

  export type ParentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phoneNumber: string | null
    whatsAppNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phoneNumber: string | null
    whatsAppNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParentCountAggregateOutputType = {
    id: number
    userId: number
    firstName: number
    lastName: number
    email: number
    phoneNumber: number
    whatsAppNumber: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ParentMinAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    email?: true
    phoneNumber?: true
    whatsAppNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParentMaxAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    email?: true
    phoneNumber?: true
    whatsAppNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParentCountAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    email?: true
    phoneNumber?: true
    whatsAppNumber?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ParentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parent to aggregate.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parents
    **/
    _count?: true | ParentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParentMaxAggregateInputType
  }

  export type GetParentAggregateType<T extends ParentAggregateArgs> = {
        [P in keyof T & keyof AggregateParent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParent[P]>
      : GetScalarType<T[P], AggregateParent[P]>
  }




  export type ParentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentWhereInput
    orderBy?: ParentOrderByWithAggregationInput | ParentOrderByWithAggregationInput[]
    by: ParentScalarFieldEnum[] | ParentScalarFieldEnum
    having?: ParentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParentCountAggregateInputType | true
    _min?: ParentMinAggregateInputType
    _max?: ParentMaxAggregateInputType
  }

  export type ParentGroupByOutputType = {
    id: string
    userId: string | null
    firstName: string
    lastName: string
    email: string
    phoneNumber: string
    whatsAppNumber: string
    createdAt: Date
    updatedAt: Date
    _count: ParentCountAggregateOutputType | null
    _min: ParentMinAggregateOutputType | null
    _max: ParentMaxAggregateOutputType | null
  }

  type GetParentGroupByPayload<T extends ParentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParentGroupByOutputType[P]>
            : GetScalarType<T[P], ParentGroupByOutputType[P]>
        }
      >
    >


  export type ParentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phoneNumber?: boolean
    whatsAppNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Parent$userArgs<ExtArgs>
    students?: boolean | Parent$studentsArgs<ExtArgs>
    NotificationLog?: boolean | Parent$NotificationLogArgs<ExtArgs>
    _count?: boolean | ParentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parent"]>

  export type ParentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phoneNumber?: boolean
    whatsAppNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Parent$userArgs<ExtArgs>
  }, ExtArgs["result"]["parent"]>

  export type ParentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phoneNumber?: boolean
    whatsAppNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Parent$userArgs<ExtArgs>
  }, ExtArgs["result"]["parent"]>

  export type ParentSelectScalar = {
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phoneNumber?: boolean
    whatsAppNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ParentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "firstName" | "lastName" | "email" | "phoneNumber" | "whatsAppNumber" | "createdAt" | "updatedAt", ExtArgs["result"]["parent"]>
  export type ParentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Parent$userArgs<ExtArgs>
    students?: boolean | Parent$studentsArgs<ExtArgs>
    NotificationLog?: boolean | Parent$NotificationLogArgs<ExtArgs>
    _count?: boolean | ParentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ParentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Parent$userArgs<ExtArgs>
  }
  export type ParentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Parent$userArgs<ExtArgs>
  }

  export type $ParentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Parent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      students: Prisma.$ParentStudentPayload<ExtArgs>[]
      NotificationLog: Prisma.$NotificationLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      firstName: string
      lastName: string
      email: string
      phoneNumber: string
      whatsAppNumber: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["parent"]>
    composites: {}
  }

  type ParentGetPayload<S extends boolean | null | undefined | ParentDefaultArgs> = $Result.GetResult<Prisma.$ParentPayload, S>

  type ParentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParentCountAggregateInputType | true
    }

  export interface ParentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Parent'], meta: { name: 'Parent' } }
    /**
     * Find zero or one Parent that matches the filter.
     * @param {ParentFindUniqueArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParentFindUniqueArgs>(args: SelectSubset<T, ParentFindUniqueArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Parent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParentFindUniqueOrThrowArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParentFindUniqueOrThrowArgs>(args: SelectSubset<T, ParentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindFirstArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParentFindFirstArgs>(args?: SelectSubset<T, ParentFindFirstArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindFirstOrThrowArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParentFindFirstOrThrowArgs>(args?: SelectSubset<T, ParentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Parents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parents
     * const parents = await prisma.parent.findMany()
     * 
     * // Get first 10 Parents
     * const parents = await prisma.parent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parentWithIdOnly = await prisma.parent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParentFindManyArgs>(args?: SelectSubset<T, ParentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Parent.
     * @param {ParentCreateArgs} args - Arguments to create a Parent.
     * @example
     * // Create one Parent
     * const Parent = await prisma.parent.create({
     *   data: {
     *     // ... data to create a Parent
     *   }
     * })
     * 
     */
    create<T extends ParentCreateArgs>(args: SelectSubset<T, ParentCreateArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Parents.
     * @param {ParentCreateManyArgs} args - Arguments to create many Parents.
     * @example
     * // Create many Parents
     * const parent = await prisma.parent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParentCreateManyArgs>(args?: SelectSubset<T, ParentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Parents and returns the data saved in the database.
     * @param {ParentCreateManyAndReturnArgs} args - Arguments to create many Parents.
     * @example
     * // Create many Parents
     * const parent = await prisma.parent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Parents and only return the `id`
     * const parentWithIdOnly = await prisma.parent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParentCreateManyAndReturnArgs>(args?: SelectSubset<T, ParentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Parent.
     * @param {ParentDeleteArgs} args - Arguments to delete one Parent.
     * @example
     * // Delete one Parent
     * const Parent = await prisma.parent.delete({
     *   where: {
     *     // ... filter to delete one Parent
     *   }
     * })
     * 
     */
    delete<T extends ParentDeleteArgs>(args: SelectSubset<T, ParentDeleteArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Parent.
     * @param {ParentUpdateArgs} args - Arguments to update one Parent.
     * @example
     * // Update one Parent
     * const parent = await prisma.parent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParentUpdateArgs>(args: SelectSubset<T, ParentUpdateArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Parents.
     * @param {ParentDeleteManyArgs} args - Arguments to filter Parents to delete.
     * @example
     * // Delete a few Parents
     * const { count } = await prisma.parent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParentDeleteManyArgs>(args?: SelectSubset<T, ParentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parents
     * const parent = await prisma.parent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParentUpdateManyArgs>(args: SelectSubset<T, ParentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parents and returns the data updated in the database.
     * @param {ParentUpdateManyAndReturnArgs} args - Arguments to update many Parents.
     * @example
     * // Update many Parents
     * const parent = await prisma.parent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Parents and only return the `id`
     * const parentWithIdOnly = await prisma.parent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ParentUpdateManyAndReturnArgs>(args: SelectSubset<T, ParentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Parent.
     * @param {ParentUpsertArgs} args - Arguments to update or create a Parent.
     * @example
     * // Update or create a Parent
     * const parent = await prisma.parent.upsert({
     *   create: {
     *     // ... data to create a Parent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parent we want to update
     *   }
     * })
     */
    upsert<T extends ParentUpsertArgs>(args: SelectSubset<T, ParentUpsertArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentCountArgs} args - Arguments to filter Parents to count.
     * @example
     * // Count the number of Parents
     * const count = await prisma.parent.count({
     *   where: {
     *     // ... the filter for the Parents we want to count
     *   }
     * })
    **/
    count<T extends ParentCountArgs>(
      args?: Subset<T, ParentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParentAggregateArgs>(args: Subset<T, ParentAggregateArgs>): Prisma.PrismaPromise<GetParentAggregateType<T>>

    /**
     * Group by Parent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParentGroupByArgs['orderBy'] }
        : { orderBy?: ParentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Parent model
   */
  readonly fields: ParentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Parent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Parent$userArgs<ExtArgs> = {}>(args?: Subset<T, Parent$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    students<T extends Parent$studentsArgs<ExtArgs> = {}>(args?: Subset<T, Parent$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentStudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    NotificationLog<T extends Parent$NotificationLogArgs<ExtArgs> = {}>(args?: Subset<T, Parent$NotificationLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Parent model
   */
  interface ParentFieldRefs {
    readonly id: FieldRef<"Parent", 'String'>
    readonly userId: FieldRef<"Parent", 'String'>
    readonly firstName: FieldRef<"Parent", 'String'>
    readonly lastName: FieldRef<"Parent", 'String'>
    readonly email: FieldRef<"Parent", 'String'>
    readonly phoneNumber: FieldRef<"Parent", 'String'>
    readonly whatsAppNumber: FieldRef<"Parent", 'String'>
    readonly createdAt: FieldRef<"Parent", 'DateTime'>
    readonly updatedAt: FieldRef<"Parent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Parent findUnique
   */
  export type ParentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent findUniqueOrThrow
   */
  export type ParentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent findFirst
   */
  export type ParentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parents.
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parents.
     */
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Parent findFirstOrThrow
   */
  export type ParentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parents.
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parents.
     */
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Parent findMany
   */
  export type ParentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parents to fetch.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parents.
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Parent create
   */
  export type ParentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * The data needed to create a Parent.
     */
    data: XOR<ParentCreateInput, ParentUncheckedCreateInput>
  }

  /**
   * Parent createMany
   */
  export type ParentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Parents.
     */
    data: ParentCreateManyInput | ParentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Parent createManyAndReturn
   */
  export type ParentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * The data used to create many Parents.
     */
    data: ParentCreateManyInput | ParentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Parent update
   */
  export type ParentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * The data needed to update a Parent.
     */
    data: XOR<ParentUpdateInput, ParentUncheckedUpdateInput>
    /**
     * Choose, which Parent to update.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent updateMany
   */
  export type ParentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Parents.
     */
    data: XOR<ParentUpdateManyMutationInput, ParentUncheckedUpdateManyInput>
    /**
     * Filter which Parents to update
     */
    where?: ParentWhereInput
    /**
     * Limit how many Parents to update.
     */
    limit?: number
  }

  /**
   * Parent updateManyAndReturn
   */
  export type ParentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * The data used to update Parents.
     */
    data: XOR<ParentUpdateManyMutationInput, ParentUncheckedUpdateManyInput>
    /**
     * Filter which Parents to update
     */
    where?: ParentWhereInput
    /**
     * Limit how many Parents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Parent upsert
   */
  export type ParentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * The filter to search for the Parent to update in case it exists.
     */
    where: ParentWhereUniqueInput
    /**
     * In case the Parent found by the `where` argument doesn't exist, create a new Parent with this data.
     */
    create: XOR<ParentCreateInput, ParentUncheckedCreateInput>
    /**
     * In case the Parent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParentUpdateInput, ParentUncheckedUpdateInput>
  }

  /**
   * Parent delete
   */
  export type ParentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter which Parent to delete.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent deleteMany
   */
  export type ParentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parents to delete
     */
    where?: ParentWhereInput
    /**
     * Limit how many Parents to delete.
     */
    limit?: number
  }

  /**
   * Parent.user
   */
  export type Parent$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Parent.students
   */
  export type Parent$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentStudent
     */
    select?: ParentStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParentStudent
     */
    omit?: ParentStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentStudentInclude<ExtArgs> | null
    where?: ParentStudentWhereInput
    orderBy?: ParentStudentOrderByWithRelationInput | ParentStudentOrderByWithRelationInput[]
    cursor?: ParentStudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParentStudentScalarFieldEnum | ParentStudentScalarFieldEnum[]
  }

  /**
   * Parent.NotificationLog
   */
  export type Parent$NotificationLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    where?: NotificationLogWhereInput
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    cursor?: NotificationLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * Parent without action
   */
  export type ParentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
  }


  /**
   * Model ParentStudent
   */

  export type AggregateParentStudent = {
    _count: ParentStudentCountAggregateOutputType | null
    _min: ParentStudentMinAggregateOutputType | null
    _max: ParentStudentMaxAggregateOutputType | null
  }

  export type ParentStudentMinAggregateOutputType = {
    id: string | null
    relationship: string | null
    studentId: string | null
    parentId: string | null
    isPrimary: boolean | null
  }

  export type ParentStudentMaxAggregateOutputType = {
    id: string | null
    relationship: string | null
    studentId: string | null
    parentId: string | null
    isPrimary: boolean | null
  }

  export type ParentStudentCountAggregateOutputType = {
    id: number
    relationship: number
    studentId: number
    parentId: number
    isPrimary: number
    _all: number
  }


  export type ParentStudentMinAggregateInputType = {
    id?: true
    relationship?: true
    studentId?: true
    parentId?: true
    isPrimary?: true
  }

  export type ParentStudentMaxAggregateInputType = {
    id?: true
    relationship?: true
    studentId?: true
    parentId?: true
    isPrimary?: true
  }

  export type ParentStudentCountAggregateInputType = {
    id?: true
    relationship?: true
    studentId?: true
    parentId?: true
    isPrimary?: true
    _all?: true
  }

  export type ParentStudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParentStudent to aggregate.
     */
    where?: ParentStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParentStudents to fetch.
     */
    orderBy?: ParentStudentOrderByWithRelationInput | ParentStudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParentStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParentStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParentStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ParentStudents
    **/
    _count?: true | ParentStudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParentStudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParentStudentMaxAggregateInputType
  }

  export type GetParentStudentAggregateType<T extends ParentStudentAggregateArgs> = {
        [P in keyof T & keyof AggregateParentStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParentStudent[P]>
      : GetScalarType<T[P], AggregateParentStudent[P]>
  }




  export type ParentStudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentStudentWhereInput
    orderBy?: ParentStudentOrderByWithAggregationInput | ParentStudentOrderByWithAggregationInput[]
    by: ParentStudentScalarFieldEnum[] | ParentStudentScalarFieldEnum
    having?: ParentStudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParentStudentCountAggregateInputType | true
    _min?: ParentStudentMinAggregateInputType
    _max?: ParentStudentMaxAggregateInputType
  }

  export type ParentStudentGroupByOutputType = {
    id: string
    relationship: string
    studentId: string
    parentId: string
    isPrimary: boolean | null
    _count: ParentStudentCountAggregateOutputType | null
    _min: ParentStudentMinAggregateOutputType | null
    _max: ParentStudentMaxAggregateOutputType | null
  }

  type GetParentStudentGroupByPayload<T extends ParentStudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParentStudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParentStudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParentStudentGroupByOutputType[P]>
            : GetScalarType<T[P], ParentStudentGroupByOutputType[P]>
        }
      >
    >


  export type ParentStudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    relationship?: boolean
    studentId?: boolean
    parentId?: boolean
    isPrimary?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    parent?: boolean | ParentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parentStudent"]>

  export type ParentStudentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    relationship?: boolean
    studentId?: boolean
    parentId?: boolean
    isPrimary?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    parent?: boolean | ParentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parentStudent"]>

  export type ParentStudentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    relationship?: boolean
    studentId?: boolean
    parentId?: boolean
    isPrimary?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    parent?: boolean | ParentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parentStudent"]>

  export type ParentStudentSelectScalar = {
    id?: boolean
    relationship?: boolean
    studentId?: boolean
    parentId?: boolean
    isPrimary?: boolean
  }

  export type ParentStudentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "relationship" | "studentId" | "parentId" | "isPrimary", ExtArgs["result"]["parentStudent"]>
  export type ParentStudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    parent?: boolean | ParentDefaultArgs<ExtArgs>
  }
  export type ParentStudentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    parent?: boolean | ParentDefaultArgs<ExtArgs>
  }
  export type ParentStudentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    parent?: boolean | ParentDefaultArgs<ExtArgs>
  }

  export type $ParentStudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ParentStudent"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      parent: Prisma.$ParentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      relationship: string
      studentId: string
      parentId: string
      isPrimary: boolean | null
    }, ExtArgs["result"]["parentStudent"]>
    composites: {}
  }

  type ParentStudentGetPayload<S extends boolean | null | undefined | ParentStudentDefaultArgs> = $Result.GetResult<Prisma.$ParentStudentPayload, S>

  type ParentStudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParentStudentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParentStudentCountAggregateInputType | true
    }

  export interface ParentStudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ParentStudent'], meta: { name: 'ParentStudent' } }
    /**
     * Find zero or one ParentStudent that matches the filter.
     * @param {ParentStudentFindUniqueArgs} args - Arguments to find a ParentStudent
     * @example
     * // Get one ParentStudent
     * const parentStudent = await prisma.parentStudent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParentStudentFindUniqueArgs>(args: SelectSubset<T, ParentStudentFindUniqueArgs<ExtArgs>>): Prisma__ParentStudentClient<$Result.GetResult<Prisma.$ParentStudentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ParentStudent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParentStudentFindUniqueOrThrowArgs} args - Arguments to find a ParentStudent
     * @example
     * // Get one ParentStudent
     * const parentStudent = await prisma.parentStudent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParentStudentFindUniqueOrThrowArgs>(args: SelectSubset<T, ParentStudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParentStudentClient<$Result.GetResult<Prisma.$ParentStudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParentStudent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentStudentFindFirstArgs} args - Arguments to find a ParentStudent
     * @example
     * // Get one ParentStudent
     * const parentStudent = await prisma.parentStudent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParentStudentFindFirstArgs>(args?: SelectSubset<T, ParentStudentFindFirstArgs<ExtArgs>>): Prisma__ParentStudentClient<$Result.GetResult<Prisma.$ParentStudentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParentStudent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentStudentFindFirstOrThrowArgs} args - Arguments to find a ParentStudent
     * @example
     * // Get one ParentStudent
     * const parentStudent = await prisma.parentStudent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParentStudentFindFirstOrThrowArgs>(args?: SelectSubset<T, ParentStudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParentStudentClient<$Result.GetResult<Prisma.$ParentStudentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ParentStudents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentStudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ParentStudents
     * const parentStudents = await prisma.parentStudent.findMany()
     * 
     * // Get first 10 ParentStudents
     * const parentStudents = await prisma.parentStudent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parentStudentWithIdOnly = await prisma.parentStudent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParentStudentFindManyArgs>(args?: SelectSubset<T, ParentStudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentStudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ParentStudent.
     * @param {ParentStudentCreateArgs} args - Arguments to create a ParentStudent.
     * @example
     * // Create one ParentStudent
     * const ParentStudent = await prisma.parentStudent.create({
     *   data: {
     *     // ... data to create a ParentStudent
     *   }
     * })
     * 
     */
    create<T extends ParentStudentCreateArgs>(args: SelectSubset<T, ParentStudentCreateArgs<ExtArgs>>): Prisma__ParentStudentClient<$Result.GetResult<Prisma.$ParentStudentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ParentStudents.
     * @param {ParentStudentCreateManyArgs} args - Arguments to create many ParentStudents.
     * @example
     * // Create many ParentStudents
     * const parentStudent = await prisma.parentStudent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParentStudentCreateManyArgs>(args?: SelectSubset<T, ParentStudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ParentStudents and returns the data saved in the database.
     * @param {ParentStudentCreateManyAndReturnArgs} args - Arguments to create many ParentStudents.
     * @example
     * // Create many ParentStudents
     * const parentStudent = await prisma.parentStudent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ParentStudents and only return the `id`
     * const parentStudentWithIdOnly = await prisma.parentStudent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParentStudentCreateManyAndReturnArgs>(args?: SelectSubset<T, ParentStudentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentStudentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ParentStudent.
     * @param {ParentStudentDeleteArgs} args - Arguments to delete one ParentStudent.
     * @example
     * // Delete one ParentStudent
     * const ParentStudent = await prisma.parentStudent.delete({
     *   where: {
     *     // ... filter to delete one ParentStudent
     *   }
     * })
     * 
     */
    delete<T extends ParentStudentDeleteArgs>(args: SelectSubset<T, ParentStudentDeleteArgs<ExtArgs>>): Prisma__ParentStudentClient<$Result.GetResult<Prisma.$ParentStudentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ParentStudent.
     * @param {ParentStudentUpdateArgs} args - Arguments to update one ParentStudent.
     * @example
     * // Update one ParentStudent
     * const parentStudent = await prisma.parentStudent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParentStudentUpdateArgs>(args: SelectSubset<T, ParentStudentUpdateArgs<ExtArgs>>): Prisma__ParentStudentClient<$Result.GetResult<Prisma.$ParentStudentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ParentStudents.
     * @param {ParentStudentDeleteManyArgs} args - Arguments to filter ParentStudents to delete.
     * @example
     * // Delete a few ParentStudents
     * const { count } = await prisma.parentStudent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParentStudentDeleteManyArgs>(args?: SelectSubset<T, ParentStudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParentStudents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentStudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ParentStudents
     * const parentStudent = await prisma.parentStudent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParentStudentUpdateManyArgs>(args: SelectSubset<T, ParentStudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParentStudents and returns the data updated in the database.
     * @param {ParentStudentUpdateManyAndReturnArgs} args - Arguments to update many ParentStudents.
     * @example
     * // Update many ParentStudents
     * const parentStudent = await prisma.parentStudent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ParentStudents and only return the `id`
     * const parentStudentWithIdOnly = await prisma.parentStudent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ParentStudentUpdateManyAndReturnArgs>(args: SelectSubset<T, ParentStudentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentStudentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ParentStudent.
     * @param {ParentStudentUpsertArgs} args - Arguments to update or create a ParentStudent.
     * @example
     * // Update or create a ParentStudent
     * const parentStudent = await prisma.parentStudent.upsert({
     *   create: {
     *     // ... data to create a ParentStudent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ParentStudent we want to update
     *   }
     * })
     */
    upsert<T extends ParentStudentUpsertArgs>(args: SelectSubset<T, ParentStudentUpsertArgs<ExtArgs>>): Prisma__ParentStudentClient<$Result.GetResult<Prisma.$ParentStudentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ParentStudents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentStudentCountArgs} args - Arguments to filter ParentStudents to count.
     * @example
     * // Count the number of ParentStudents
     * const count = await prisma.parentStudent.count({
     *   where: {
     *     // ... the filter for the ParentStudents we want to count
     *   }
     * })
    **/
    count<T extends ParentStudentCountArgs>(
      args?: Subset<T, ParentStudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParentStudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ParentStudent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentStudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParentStudentAggregateArgs>(args: Subset<T, ParentStudentAggregateArgs>): Prisma.PrismaPromise<GetParentStudentAggregateType<T>>

    /**
     * Group by ParentStudent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentStudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParentStudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParentStudentGroupByArgs['orderBy'] }
        : { orderBy?: ParentStudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParentStudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParentStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ParentStudent model
   */
  readonly fields: ParentStudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ParentStudent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParentStudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends ParentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParentDefaultArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ParentStudent model
   */
  interface ParentStudentFieldRefs {
    readonly id: FieldRef<"ParentStudent", 'String'>
    readonly relationship: FieldRef<"ParentStudent", 'String'>
    readonly studentId: FieldRef<"ParentStudent", 'String'>
    readonly parentId: FieldRef<"ParentStudent", 'String'>
    readonly isPrimary: FieldRef<"ParentStudent", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ParentStudent findUnique
   */
  export type ParentStudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentStudent
     */
    select?: ParentStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParentStudent
     */
    omit?: ParentStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentStudentInclude<ExtArgs> | null
    /**
     * Filter, which ParentStudent to fetch.
     */
    where: ParentStudentWhereUniqueInput
  }

  /**
   * ParentStudent findUniqueOrThrow
   */
  export type ParentStudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentStudent
     */
    select?: ParentStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParentStudent
     */
    omit?: ParentStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentStudentInclude<ExtArgs> | null
    /**
     * Filter, which ParentStudent to fetch.
     */
    where: ParentStudentWhereUniqueInput
  }

  /**
   * ParentStudent findFirst
   */
  export type ParentStudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentStudent
     */
    select?: ParentStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParentStudent
     */
    omit?: ParentStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentStudentInclude<ExtArgs> | null
    /**
     * Filter, which ParentStudent to fetch.
     */
    where?: ParentStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParentStudents to fetch.
     */
    orderBy?: ParentStudentOrderByWithRelationInput | ParentStudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParentStudents.
     */
    cursor?: ParentStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParentStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParentStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParentStudents.
     */
    distinct?: ParentStudentScalarFieldEnum | ParentStudentScalarFieldEnum[]
  }

  /**
   * ParentStudent findFirstOrThrow
   */
  export type ParentStudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentStudent
     */
    select?: ParentStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParentStudent
     */
    omit?: ParentStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentStudentInclude<ExtArgs> | null
    /**
     * Filter, which ParentStudent to fetch.
     */
    where?: ParentStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParentStudents to fetch.
     */
    orderBy?: ParentStudentOrderByWithRelationInput | ParentStudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParentStudents.
     */
    cursor?: ParentStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParentStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParentStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParentStudents.
     */
    distinct?: ParentStudentScalarFieldEnum | ParentStudentScalarFieldEnum[]
  }

  /**
   * ParentStudent findMany
   */
  export type ParentStudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentStudent
     */
    select?: ParentStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParentStudent
     */
    omit?: ParentStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentStudentInclude<ExtArgs> | null
    /**
     * Filter, which ParentStudents to fetch.
     */
    where?: ParentStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParentStudents to fetch.
     */
    orderBy?: ParentStudentOrderByWithRelationInput | ParentStudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ParentStudents.
     */
    cursor?: ParentStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParentStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParentStudents.
     */
    skip?: number
    distinct?: ParentStudentScalarFieldEnum | ParentStudentScalarFieldEnum[]
  }

  /**
   * ParentStudent create
   */
  export type ParentStudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentStudent
     */
    select?: ParentStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParentStudent
     */
    omit?: ParentStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentStudentInclude<ExtArgs> | null
    /**
     * The data needed to create a ParentStudent.
     */
    data: XOR<ParentStudentCreateInput, ParentStudentUncheckedCreateInput>
  }

  /**
   * ParentStudent createMany
   */
  export type ParentStudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ParentStudents.
     */
    data: ParentStudentCreateManyInput | ParentStudentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ParentStudent createManyAndReturn
   */
  export type ParentStudentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentStudent
     */
    select?: ParentStudentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ParentStudent
     */
    omit?: ParentStudentOmit<ExtArgs> | null
    /**
     * The data used to create many ParentStudents.
     */
    data: ParentStudentCreateManyInput | ParentStudentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentStudentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParentStudent update
   */
  export type ParentStudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentStudent
     */
    select?: ParentStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParentStudent
     */
    omit?: ParentStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentStudentInclude<ExtArgs> | null
    /**
     * The data needed to update a ParentStudent.
     */
    data: XOR<ParentStudentUpdateInput, ParentStudentUncheckedUpdateInput>
    /**
     * Choose, which ParentStudent to update.
     */
    where: ParentStudentWhereUniqueInput
  }

  /**
   * ParentStudent updateMany
   */
  export type ParentStudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ParentStudents.
     */
    data: XOR<ParentStudentUpdateManyMutationInput, ParentStudentUncheckedUpdateManyInput>
    /**
     * Filter which ParentStudents to update
     */
    where?: ParentStudentWhereInput
    /**
     * Limit how many ParentStudents to update.
     */
    limit?: number
  }

  /**
   * ParentStudent updateManyAndReturn
   */
  export type ParentStudentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentStudent
     */
    select?: ParentStudentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ParentStudent
     */
    omit?: ParentStudentOmit<ExtArgs> | null
    /**
     * The data used to update ParentStudents.
     */
    data: XOR<ParentStudentUpdateManyMutationInput, ParentStudentUncheckedUpdateManyInput>
    /**
     * Filter which ParentStudents to update
     */
    where?: ParentStudentWhereInput
    /**
     * Limit how many ParentStudents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentStudentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParentStudent upsert
   */
  export type ParentStudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentStudent
     */
    select?: ParentStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParentStudent
     */
    omit?: ParentStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentStudentInclude<ExtArgs> | null
    /**
     * The filter to search for the ParentStudent to update in case it exists.
     */
    where: ParentStudentWhereUniqueInput
    /**
     * In case the ParentStudent found by the `where` argument doesn't exist, create a new ParentStudent with this data.
     */
    create: XOR<ParentStudentCreateInput, ParentStudentUncheckedCreateInput>
    /**
     * In case the ParentStudent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParentStudentUpdateInput, ParentStudentUncheckedUpdateInput>
  }

  /**
   * ParentStudent delete
   */
  export type ParentStudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentStudent
     */
    select?: ParentStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParentStudent
     */
    omit?: ParentStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentStudentInclude<ExtArgs> | null
    /**
     * Filter which ParentStudent to delete.
     */
    where: ParentStudentWhereUniqueInput
  }

  /**
   * ParentStudent deleteMany
   */
  export type ParentStudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParentStudents to delete
     */
    where?: ParentStudentWhereInput
    /**
     * Limit how many ParentStudents to delete.
     */
    limit?: number
  }

  /**
   * ParentStudent without action
   */
  export type ParentStudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentStudent
     */
    select?: ParentStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParentStudent
     */
    omit?: ParentStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentStudentInclude<ExtArgs> | null
  }


  /**
   * Model StudentAttendance
   */

  export type AggregateStudentAttendance = {
    _count: StudentAttendanceCountAggregateOutputType | null
    _min: StudentAttendanceMinAggregateOutputType | null
    _max: StudentAttendanceMaxAggregateOutputType | null
  }

  export type StudentAttendanceMinAggregateOutputType = {
    id: string | null
    date: Date | null
    status: $Enums.AttendanceStatus | null
    note: string | null
    recordedBy: string | null
    studentId: string | null
    present: boolean | null
    sectionId: string | null
    academicYearId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentAttendanceMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    status: $Enums.AttendanceStatus | null
    note: string | null
    recordedBy: string | null
    studentId: string | null
    present: boolean | null
    sectionId: string | null
    academicYearId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentAttendanceCountAggregateOutputType = {
    id: number
    date: number
    status: number
    note: number
    recordedBy: number
    studentId: number
    present: number
    sectionId: number
    academicYearId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentAttendanceMinAggregateInputType = {
    id?: true
    date?: true
    status?: true
    note?: true
    recordedBy?: true
    studentId?: true
    present?: true
    sectionId?: true
    academicYearId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentAttendanceMaxAggregateInputType = {
    id?: true
    date?: true
    status?: true
    note?: true
    recordedBy?: true
    studentId?: true
    present?: true
    sectionId?: true
    academicYearId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentAttendanceCountAggregateInputType = {
    id?: true
    date?: true
    status?: true
    note?: true
    recordedBy?: true
    studentId?: true
    present?: true
    sectionId?: true
    academicYearId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentAttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentAttendance to aggregate.
     */
    where?: StudentAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAttendances to fetch.
     */
    orderBy?: StudentAttendanceOrderByWithRelationInput | StudentAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentAttendances
    **/
    _count?: true | StudentAttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentAttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentAttendanceMaxAggregateInputType
  }

  export type GetStudentAttendanceAggregateType<T extends StudentAttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentAttendance[P]>
      : GetScalarType<T[P], AggregateStudentAttendance[P]>
  }




  export type StudentAttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentAttendanceWhereInput
    orderBy?: StudentAttendanceOrderByWithAggregationInput | StudentAttendanceOrderByWithAggregationInput[]
    by: StudentAttendanceScalarFieldEnum[] | StudentAttendanceScalarFieldEnum
    having?: StudentAttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentAttendanceCountAggregateInputType | true
    _min?: StudentAttendanceMinAggregateInputType
    _max?: StudentAttendanceMaxAggregateInputType
  }

  export type StudentAttendanceGroupByOutputType = {
    id: string
    date: Date
    status: $Enums.AttendanceStatus
    note: string | null
    recordedBy: string
    studentId: string
    present: boolean
    sectionId: string
    academicYearId: string | null
    createdAt: Date
    updatedAt: Date
    _count: StudentAttendanceCountAggregateOutputType | null
    _min: StudentAttendanceMinAggregateOutputType | null
    _max: StudentAttendanceMaxAggregateOutputType | null
  }

  type GetStudentAttendanceGroupByPayload<T extends StudentAttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentAttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentAttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentAttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], StudentAttendanceGroupByOutputType[P]>
        }
      >
    >


  export type StudentAttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    status?: boolean
    note?: boolean
    recordedBy?: boolean
    studentId?: boolean
    present?: boolean
    sectionId?: boolean
    academicYearId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    section?: boolean | SectionDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicYear?: boolean | StudentAttendance$academicYearArgs<ExtArgs>
  }, ExtArgs["result"]["studentAttendance"]>

  export type StudentAttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    status?: boolean
    note?: boolean
    recordedBy?: boolean
    studentId?: boolean
    present?: boolean
    sectionId?: boolean
    academicYearId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    section?: boolean | SectionDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicYear?: boolean | StudentAttendance$academicYearArgs<ExtArgs>
  }, ExtArgs["result"]["studentAttendance"]>

  export type StudentAttendanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    status?: boolean
    note?: boolean
    recordedBy?: boolean
    studentId?: boolean
    present?: boolean
    sectionId?: boolean
    academicYearId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    section?: boolean | SectionDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicYear?: boolean | StudentAttendance$academicYearArgs<ExtArgs>
  }, ExtArgs["result"]["studentAttendance"]>

  export type StudentAttendanceSelectScalar = {
    id?: boolean
    date?: boolean
    status?: boolean
    note?: boolean
    recordedBy?: boolean
    studentId?: boolean
    present?: boolean
    sectionId?: boolean
    academicYearId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentAttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "status" | "note" | "recordedBy" | "studentId" | "present" | "sectionId" | "academicYearId" | "createdAt" | "updatedAt", ExtArgs["result"]["studentAttendance"]>
  export type StudentAttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | SectionDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicYear?: boolean | StudentAttendance$academicYearArgs<ExtArgs>
  }
  export type StudentAttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | SectionDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicYear?: boolean | StudentAttendance$academicYearArgs<ExtArgs>
  }
  export type StudentAttendanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | SectionDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicYear?: boolean | StudentAttendance$academicYearArgs<ExtArgs>
  }

  export type $StudentAttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentAttendance"
    objects: {
      section: Prisma.$SectionPayload<ExtArgs>
      student: Prisma.$StudentPayload<ExtArgs>
      academicYear: Prisma.$AcademicYearPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      status: $Enums.AttendanceStatus
      note: string | null
      recordedBy: string
      studentId: string
      present: boolean
      sectionId: string
      academicYearId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentAttendance"]>
    composites: {}
  }

  type StudentAttendanceGetPayload<S extends boolean | null | undefined | StudentAttendanceDefaultArgs> = $Result.GetResult<Prisma.$StudentAttendancePayload, S>

  type StudentAttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentAttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentAttendanceCountAggregateInputType | true
    }

  export interface StudentAttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentAttendance'], meta: { name: 'StudentAttendance' } }
    /**
     * Find zero or one StudentAttendance that matches the filter.
     * @param {StudentAttendanceFindUniqueArgs} args - Arguments to find a StudentAttendance
     * @example
     * // Get one StudentAttendance
     * const studentAttendance = await prisma.studentAttendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentAttendanceFindUniqueArgs>(args: SelectSubset<T, StudentAttendanceFindUniqueArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentAttendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentAttendanceFindUniqueOrThrowArgs} args - Arguments to find a StudentAttendance
     * @example
     * // Get one StudentAttendance
     * const studentAttendance = await prisma.studentAttendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentAttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentAttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentAttendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceFindFirstArgs} args - Arguments to find a StudentAttendance
     * @example
     * // Get one StudentAttendance
     * const studentAttendance = await prisma.studentAttendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentAttendanceFindFirstArgs>(args?: SelectSubset<T, StudentAttendanceFindFirstArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentAttendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceFindFirstOrThrowArgs} args - Arguments to find a StudentAttendance
     * @example
     * // Get one StudentAttendance
     * const studentAttendance = await prisma.studentAttendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentAttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentAttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentAttendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentAttendances
     * const studentAttendances = await prisma.studentAttendance.findMany()
     * 
     * // Get first 10 StudentAttendances
     * const studentAttendances = await prisma.studentAttendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentAttendanceWithIdOnly = await prisma.studentAttendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentAttendanceFindManyArgs>(args?: SelectSubset<T, StudentAttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentAttendance.
     * @param {StudentAttendanceCreateArgs} args - Arguments to create a StudentAttendance.
     * @example
     * // Create one StudentAttendance
     * const StudentAttendance = await prisma.studentAttendance.create({
     *   data: {
     *     // ... data to create a StudentAttendance
     *   }
     * })
     * 
     */
    create<T extends StudentAttendanceCreateArgs>(args: SelectSubset<T, StudentAttendanceCreateArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentAttendances.
     * @param {StudentAttendanceCreateManyArgs} args - Arguments to create many StudentAttendances.
     * @example
     * // Create many StudentAttendances
     * const studentAttendance = await prisma.studentAttendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentAttendanceCreateManyArgs>(args?: SelectSubset<T, StudentAttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentAttendances and returns the data saved in the database.
     * @param {StudentAttendanceCreateManyAndReturnArgs} args - Arguments to create many StudentAttendances.
     * @example
     * // Create many StudentAttendances
     * const studentAttendance = await prisma.studentAttendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentAttendances and only return the `id`
     * const studentAttendanceWithIdOnly = await prisma.studentAttendance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentAttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentAttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudentAttendance.
     * @param {StudentAttendanceDeleteArgs} args - Arguments to delete one StudentAttendance.
     * @example
     * // Delete one StudentAttendance
     * const StudentAttendance = await prisma.studentAttendance.delete({
     *   where: {
     *     // ... filter to delete one StudentAttendance
     *   }
     * })
     * 
     */
    delete<T extends StudentAttendanceDeleteArgs>(args: SelectSubset<T, StudentAttendanceDeleteArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentAttendance.
     * @param {StudentAttendanceUpdateArgs} args - Arguments to update one StudentAttendance.
     * @example
     * // Update one StudentAttendance
     * const studentAttendance = await prisma.studentAttendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentAttendanceUpdateArgs>(args: SelectSubset<T, StudentAttendanceUpdateArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentAttendances.
     * @param {StudentAttendanceDeleteManyArgs} args - Arguments to filter StudentAttendances to delete.
     * @example
     * // Delete a few StudentAttendances
     * const { count } = await prisma.studentAttendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentAttendanceDeleteManyArgs>(args?: SelectSubset<T, StudentAttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentAttendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentAttendances
     * const studentAttendance = await prisma.studentAttendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentAttendanceUpdateManyArgs>(args: SelectSubset<T, StudentAttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentAttendances and returns the data updated in the database.
     * @param {StudentAttendanceUpdateManyAndReturnArgs} args - Arguments to update many StudentAttendances.
     * @example
     * // Update many StudentAttendances
     * const studentAttendance = await prisma.studentAttendance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentAttendances and only return the `id`
     * const studentAttendanceWithIdOnly = await prisma.studentAttendance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentAttendanceUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentAttendanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudentAttendance.
     * @param {StudentAttendanceUpsertArgs} args - Arguments to update or create a StudentAttendance.
     * @example
     * // Update or create a StudentAttendance
     * const studentAttendance = await prisma.studentAttendance.upsert({
     *   create: {
     *     // ... data to create a StudentAttendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentAttendance we want to update
     *   }
     * })
     */
    upsert<T extends StudentAttendanceUpsertArgs>(args: SelectSubset<T, StudentAttendanceUpsertArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentAttendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceCountArgs} args - Arguments to filter StudentAttendances to count.
     * @example
     * // Count the number of StudentAttendances
     * const count = await prisma.studentAttendance.count({
     *   where: {
     *     // ... the filter for the StudentAttendances we want to count
     *   }
     * })
    **/
    count<T extends StudentAttendanceCountArgs>(
      args?: Subset<T, StudentAttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentAttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentAttendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAttendanceAggregateArgs>(args: Subset<T, StudentAttendanceAggregateArgs>): Prisma.PrismaPromise<GetStudentAttendanceAggregateType<T>>

    /**
     * Group by StudentAttendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentAttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentAttendanceGroupByArgs['orderBy'] }
        : { orderBy?: StudentAttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentAttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentAttendance model
   */
  readonly fields: StudentAttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentAttendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentAttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    section<T extends SectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SectionDefaultArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    academicYear<T extends StudentAttendance$academicYearArgs<ExtArgs> = {}>(args?: Subset<T, StudentAttendance$academicYearArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentAttendance model
   */
  interface StudentAttendanceFieldRefs {
    readonly id: FieldRef<"StudentAttendance", 'String'>
    readonly date: FieldRef<"StudentAttendance", 'DateTime'>
    readonly status: FieldRef<"StudentAttendance", 'AttendanceStatus'>
    readonly note: FieldRef<"StudentAttendance", 'String'>
    readonly recordedBy: FieldRef<"StudentAttendance", 'String'>
    readonly studentId: FieldRef<"StudentAttendance", 'String'>
    readonly present: FieldRef<"StudentAttendance", 'Boolean'>
    readonly sectionId: FieldRef<"StudentAttendance", 'String'>
    readonly academicYearId: FieldRef<"StudentAttendance", 'String'>
    readonly createdAt: FieldRef<"StudentAttendance", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentAttendance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentAttendance findUnique
   */
  export type StudentAttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StudentAttendance to fetch.
     */
    where: StudentAttendanceWhereUniqueInput
  }

  /**
   * StudentAttendance findUniqueOrThrow
   */
  export type StudentAttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StudentAttendance to fetch.
     */
    where: StudentAttendanceWhereUniqueInput
  }

  /**
   * StudentAttendance findFirst
   */
  export type StudentAttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StudentAttendance to fetch.
     */
    where?: StudentAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAttendances to fetch.
     */
    orderBy?: StudentAttendanceOrderByWithRelationInput | StudentAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentAttendances.
     */
    cursor?: StudentAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentAttendances.
     */
    distinct?: StudentAttendanceScalarFieldEnum | StudentAttendanceScalarFieldEnum[]
  }

  /**
   * StudentAttendance findFirstOrThrow
   */
  export type StudentAttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StudentAttendance to fetch.
     */
    where?: StudentAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAttendances to fetch.
     */
    orderBy?: StudentAttendanceOrderByWithRelationInput | StudentAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentAttendances.
     */
    cursor?: StudentAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentAttendances.
     */
    distinct?: StudentAttendanceScalarFieldEnum | StudentAttendanceScalarFieldEnum[]
  }

  /**
   * StudentAttendance findMany
   */
  export type StudentAttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StudentAttendances to fetch.
     */
    where?: StudentAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAttendances to fetch.
     */
    orderBy?: StudentAttendanceOrderByWithRelationInput | StudentAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentAttendances.
     */
    cursor?: StudentAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAttendances.
     */
    skip?: number
    distinct?: StudentAttendanceScalarFieldEnum | StudentAttendanceScalarFieldEnum[]
  }

  /**
   * StudentAttendance create
   */
  export type StudentAttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentAttendance.
     */
    data: XOR<StudentAttendanceCreateInput, StudentAttendanceUncheckedCreateInput>
  }

  /**
   * StudentAttendance createMany
   */
  export type StudentAttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentAttendances.
     */
    data: StudentAttendanceCreateManyInput | StudentAttendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentAttendance createManyAndReturn
   */
  export type StudentAttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * The data used to create many StudentAttendances.
     */
    data: StudentAttendanceCreateManyInput | StudentAttendanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentAttendance update
   */
  export type StudentAttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentAttendance.
     */
    data: XOR<StudentAttendanceUpdateInput, StudentAttendanceUncheckedUpdateInput>
    /**
     * Choose, which StudentAttendance to update.
     */
    where: StudentAttendanceWhereUniqueInput
  }

  /**
   * StudentAttendance updateMany
   */
  export type StudentAttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentAttendances.
     */
    data: XOR<StudentAttendanceUpdateManyMutationInput, StudentAttendanceUncheckedUpdateManyInput>
    /**
     * Filter which StudentAttendances to update
     */
    where?: StudentAttendanceWhereInput
    /**
     * Limit how many StudentAttendances to update.
     */
    limit?: number
  }

  /**
   * StudentAttendance updateManyAndReturn
   */
  export type StudentAttendanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * The data used to update StudentAttendances.
     */
    data: XOR<StudentAttendanceUpdateManyMutationInput, StudentAttendanceUncheckedUpdateManyInput>
    /**
     * Filter which StudentAttendances to update
     */
    where?: StudentAttendanceWhereInput
    /**
     * Limit how many StudentAttendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentAttendance upsert
   */
  export type StudentAttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentAttendance to update in case it exists.
     */
    where: StudentAttendanceWhereUniqueInput
    /**
     * In case the StudentAttendance found by the `where` argument doesn't exist, create a new StudentAttendance with this data.
     */
    create: XOR<StudentAttendanceCreateInput, StudentAttendanceUncheckedCreateInput>
    /**
     * In case the StudentAttendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentAttendanceUpdateInput, StudentAttendanceUncheckedUpdateInput>
  }

  /**
   * StudentAttendance delete
   */
  export type StudentAttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * Filter which StudentAttendance to delete.
     */
    where: StudentAttendanceWhereUniqueInput
  }

  /**
   * StudentAttendance deleteMany
   */
  export type StudentAttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentAttendances to delete
     */
    where?: StudentAttendanceWhereInput
    /**
     * Limit how many StudentAttendances to delete.
     */
    limit?: number
  }

  /**
   * StudentAttendance.academicYear
   */
  export type StudentAttendance$academicYearArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    where?: AcademicYearWhereInput
  }

  /**
   * StudentAttendance without action
   */
  export type StudentAttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
  }


  /**
   * Model StudentDocument
   */

  export type AggregateStudentDocument = {
    _count: StudentDocumentCountAggregateOutputType | null
    _avg: StudentDocumentAvgAggregateOutputType | null
    _sum: StudentDocumentSumAggregateOutputType | null
    _min: StudentDocumentMinAggregateOutputType | null
    _max: StudentDocumentMaxAggregateOutputType | null
  }

  export type StudentDocumentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type StudentDocumentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type StudentDocumentMinAggregateOutputType = {
    id: string | null
    type: $Enums.DocumentType | null
    fileName: string | null
    fileSize: number | null
    fileType: string | null
    documentUrl: string | null
    studentId: string | null
    verified: boolean | null
    verifiedBy: string | null
    verifiedAt: Date | null
    rejected: boolean | null
    rejectedBy: string | null
    rejectedAt: Date | null
    rejectReason: string | null
    uploadedBy: string | null
    uploadedAt: Date | null
    note: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    organizationId: string | null
  }

  export type StudentDocumentMaxAggregateOutputType = {
    id: string | null
    type: $Enums.DocumentType | null
    fileName: string | null
    fileSize: number | null
    fileType: string | null
    documentUrl: string | null
    studentId: string | null
    verified: boolean | null
    verifiedBy: string | null
    verifiedAt: Date | null
    rejected: boolean | null
    rejectedBy: string | null
    rejectedAt: Date | null
    rejectReason: string | null
    uploadedBy: string | null
    uploadedAt: Date | null
    note: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    organizationId: string | null
  }

  export type StudentDocumentCountAggregateOutputType = {
    id: number
    type: number
    fileName: number
    fileSize: number
    fileType: number
    documentUrl: number
    studentId: number
    verified: number
    verifiedBy: number
    verifiedAt: number
    rejected: number
    rejectedBy: number
    rejectedAt: number
    rejectReason: number
    uploadedBy: number
    uploadedAt: number
    note: number
    isDeleted: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    organizationId: number
    _all: number
  }


  export type StudentDocumentAvgAggregateInputType = {
    fileSize?: true
  }

  export type StudentDocumentSumAggregateInputType = {
    fileSize?: true
  }

  export type StudentDocumentMinAggregateInputType = {
    id?: true
    type?: true
    fileName?: true
    fileSize?: true
    fileType?: true
    documentUrl?: true
    studentId?: true
    verified?: true
    verifiedBy?: true
    verifiedAt?: true
    rejected?: true
    rejectedBy?: true
    rejectedAt?: true
    rejectReason?: true
    uploadedBy?: true
    uploadedAt?: true
    note?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    organizationId?: true
  }

  export type StudentDocumentMaxAggregateInputType = {
    id?: true
    type?: true
    fileName?: true
    fileSize?: true
    fileType?: true
    documentUrl?: true
    studentId?: true
    verified?: true
    verifiedBy?: true
    verifiedAt?: true
    rejected?: true
    rejectedBy?: true
    rejectedAt?: true
    rejectReason?: true
    uploadedBy?: true
    uploadedAt?: true
    note?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    organizationId?: true
  }

  export type StudentDocumentCountAggregateInputType = {
    id?: true
    type?: true
    fileName?: true
    fileSize?: true
    fileType?: true
    documentUrl?: true
    studentId?: true
    verified?: true
    verifiedBy?: true
    verifiedAt?: true
    rejected?: true
    rejectedBy?: true
    rejectedAt?: true
    rejectReason?: true
    uploadedBy?: true
    uploadedAt?: true
    note?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    organizationId?: true
    _all?: true
  }

  export type StudentDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentDocument to aggregate.
     */
    where?: StudentDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentDocuments to fetch.
     */
    orderBy?: StudentDocumentOrderByWithRelationInput | StudentDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentDocuments
    **/
    _count?: true | StudentDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentDocumentMaxAggregateInputType
  }

  export type GetStudentDocumentAggregateType<T extends StudentDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentDocument[P]>
      : GetScalarType<T[P], AggregateStudentDocument[P]>
  }




  export type StudentDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentDocumentWhereInput
    orderBy?: StudentDocumentOrderByWithAggregationInput | StudentDocumentOrderByWithAggregationInput[]
    by: StudentDocumentScalarFieldEnum[] | StudentDocumentScalarFieldEnum
    having?: StudentDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentDocumentCountAggregateInputType | true
    _avg?: StudentDocumentAvgAggregateInputType
    _sum?: StudentDocumentSumAggregateInputType
    _min?: StudentDocumentMinAggregateInputType
    _max?: StudentDocumentMaxAggregateInputType
  }

  export type StudentDocumentGroupByOutputType = {
    id: string
    type: $Enums.DocumentType
    fileName: string | null
    fileSize: number | null
    fileType: string | null
    documentUrl: string
    studentId: string
    verified: boolean
    verifiedBy: string | null
    verifiedAt: Date | null
    rejected: boolean
    rejectedBy: string | null
    rejectedAt: Date | null
    rejectReason: string | null
    uploadedBy: string | null
    uploadedAt: Date
    note: string | null
    isDeleted: boolean
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    organizationId: string
    _count: StudentDocumentCountAggregateOutputType | null
    _avg: StudentDocumentAvgAggregateOutputType | null
    _sum: StudentDocumentSumAggregateOutputType | null
    _min: StudentDocumentMinAggregateOutputType | null
    _max: StudentDocumentMaxAggregateOutputType | null
  }

  type GetStudentDocumentGroupByPayload<T extends StudentDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentDocumentGroupByOutputType[P]>
        }
      >
    >


  export type StudentDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    fileName?: boolean
    fileSize?: boolean
    fileType?: boolean
    documentUrl?: boolean
    studentId?: boolean
    verified?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    rejected?: boolean
    rejectedBy?: boolean
    rejectedAt?: boolean
    rejectReason?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    note?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizationId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    Organization?: boolean | StudentDocument$OrganizationArgs<ExtArgs>
  }, ExtArgs["result"]["studentDocument"]>

  export type StudentDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    fileName?: boolean
    fileSize?: boolean
    fileType?: boolean
    documentUrl?: boolean
    studentId?: boolean
    verified?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    rejected?: boolean
    rejectedBy?: boolean
    rejectedAt?: boolean
    rejectReason?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    note?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizationId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    Organization?: boolean | StudentDocument$OrganizationArgs<ExtArgs>
  }, ExtArgs["result"]["studentDocument"]>

  export type StudentDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    fileName?: boolean
    fileSize?: boolean
    fileType?: boolean
    documentUrl?: boolean
    studentId?: boolean
    verified?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    rejected?: boolean
    rejectedBy?: boolean
    rejectedAt?: boolean
    rejectReason?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    note?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizationId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    Organization?: boolean | StudentDocument$OrganizationArgs<ExtArgs>
  }, ExtArgs["result"]["studentDocument"]>

  export type StudentDocumentSelectScalar = {
    id?: boolean
    type?: boolean
    fileName?: boolean
    fileSize?: boolean
    fileType?: boolean
    documentUrl?: boolean
    studentId?: boolean
    verified?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    rejected?: boolean
    rejectedBy?: boolean
    rejectedAt?: boolean
    rejectReason?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    note?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizationId?: boolean
  }

  export type StudentDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "fileName" | "fileSize" | "fileType" | "documentUrl" | "studentId" | "verified" | "verifiedBy" | "verifiedAt" | "rejected" | "rejectedBy" | "rejectedAt" | "rejectReason" | "uploadedBy" | "uploadedAt" | "note" | "isDeleted" | "deletedAt" | "createdAt" | "updatedAt" | "organizationId", ExtArgs["result"]["studentDocument"]>
  export type StudentDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    Organization?: boolean | StudentDocument$OrganizationArgs<ExtArgs>
  }
  export type StudentDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    Organization?: boolean | StudentDocument$OrganizationArgs<ExtArgs>
  }
  export type StudentDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    Organization?: boolean | StudentDocument$OrganizationArgs<ExtArgs>
  }

  export type $StudentDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentDocument"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      Organization: Prisma.$OrganizationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.DocumentType
      fileName: string | null
      fileSize: number | null
      fileType: string | null
      documentUrl: string
      studentId: string
      verified: boolean
      verifiedBy: string | null
      verifiedAt: Date | null
      rejected: boolean
      rejectedBy: string | null
      rejectedAt: Date | null
      rejectReason: string | null
      uploadedBy: string | null
      uploadedAt: Date
      note: string | null
      isDeleted: boolean
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
      organizationId: string
    }, ExtArgs["result"]["studentDocument"]>
    composites: {}
  }

  type StudentDocumentGetPayload<S extends boolean | null | undefined | StudentDocumentDefaultArgs> = $Result.GetResult<Prisma.$StudentDocumentPayload, S>

  type StudentDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentDocumentCountAggregateInputType | true
    }

  export interface StudentDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentDocument'], meta: { name: 'StudentDocument' } }
    /**
     * Find zero or one StudentDocument that matches the filter.
     * @param {StudentDocumentFindUniqueArgs} args - Arguments to find a StudentDocument
     * @example
     * // Get one StudentDocument
     * const studentDocument = await prisma.studentDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentDocumentFindUniqueArgs>(args: SelectSubset<T, StudentDocumentFindUniqueArgs<ExtArgs>>): Prisma__StudentDocumentClient<$Result.GetResult<Prisma.$StudentDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentDocumentFindUniqueOrThrowArgs} args - Arguments to find a StudentDocument
     * @example
     * // Get one StudentDocument
     * const studentDocument = await prisma.studentDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentDocumentClient<$Result.GetResult<Prisma.$StudentDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentDocumentFindFirstArgs} args - Arguments to find a StudentDocument
     * @example
     * // Get one StudentDocument
     * const studentDocument = await prisma.studentDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentDocumentFindFirstArgs>(args?: SelectSubset<T, StudentDocumentFindFirstArgs<ExtArgs>>): Prisma__StudentDocumentClient<$Result.GetResult<Prisma.$StudentDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentDocumentFindFirstOrThrowArgs} args - Arguments to find a StudentDocument
     * @example
     * // Get one StudentDocument
     * const studentDocument = await prisma.studentDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentDocumentClient<$Result.GetResult<Prisma.$StudentDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentDocuments
     * const studentDocuments = await prisma.studentDocument.findMany()
     * 
     * // Get first 10 StudentDocuments
     * const studentDocuments = await prisma.studentDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentDocumentWithIdOnly = await prisma.studentDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentDocumentFindManyArgs>(args?: SelectSubset<T, StudentDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentDocument.
     * @param {StudentDocumentCreateArgs} args - Arguments to create a StudentDocument.
     * @example
     * // Create one StudentDocument
     * const StudentDocument = await prisma.studentDocument.create({
     *   data: {
     *     // ... data to create a StudentDocument
     *   }
     * })
     * 
     */
    create<T extends StudentDocumentCreateArgs>(args: SelectSubset<T, StudentDocumentCreateArgs<ExtArgs>>): Prisma__StudentDocumentClient<$Result.GetResult<Prisma.$StudentDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentDocuments.
     * @param {StudentDocumentCreateManyArgs} args - Arguments to create many StudentDocuments.
     * @example
     * // Create many StudentDocuments
     * const studentDocument = await prisma.studentDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentDocumentCreateManyArgs>(args?: SelectSubset<T, StudentDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentDocuments and returns the data saved in the database.
     * @param {StudentDocumentCreateManyAndReturnArgs} args - Arguments to create many StudentDocuments.
     * @example
     * // Create many StudentDocuments
     * const studentDocument = await prisma.studentDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentDocuments and only return the `id`
     * const studentDocumentWithIdOnly = await prisma.studentDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudentDocument.
     * @param {StudentDocumentDeleteArgs} args - Arguments to delete one StudentDocument.
     * @example
     * // Delete one StudentDocument
     * const StudentDocument = await prisma.studentDocument.delete({
     *   where: {
     *     // ... filter to delete one StudentDocument
     *   }
     * })
     * 
     */
    delete<T extends StudentDocumentDeleteArgs>(args: SelectSubset<T, StudentDocumentDeleteArgs<ExtArgs>>): Prisma__StudentDocumentClient<$Result.GetResult<Prisma.$StudentDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentDocument.
     * @param {StudentDocumentUpdateArgs} args - Arguments to update one StudentDocument.
     * @example
     * // Update one StudentDocument
     * const studentDocument = await prisma.studentDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentDocumentUpdateArgs>(args: SelectSubset<T, StudentDocumentUpdateArgs<ExtArgs>>): Prisma__StudentDocumentClient<$Result.GetResult<Prisma.$StudentDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentDocuments.
     * @param {StudentDocumentDeleteManyArgs} args - Arguments to filter StudentDocuments to delete.
     * @example
     * // Delete a few StudentDocuments
     * const { count } = await prisma.studentDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentDocumentDeleteManyArgs>(args?: SelectSubset<T, StudentDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentDocuments
     * const studentDocument = await prisma.studentDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentDocumentUpdateManyArgs>(args: SelectSubset<T, StudentDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentDocuments and returns the data updated in the database.
     * @param {StudentDocumentUpdateManyAndReturnArgs} args - Arguments to update many StudentDocuments.
     * @example
     * // Update many StudentDocuments
     * const studentDocument = await prisma.studentDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentDocuments and only return the `id`
     * const studentDocumentWithIdOnly = await prisma.studentDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudentDocument.
     * @param {StudentDocumentUpsertArgs} args - Arguments to update or create a StudentDocument.
     * @example
     * // Update or create a StudentDocument
     * const studentDocument = await prisma.studentDocument.upsert({
     *   create: {
     *     // ... data to create a StudentDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentDocument we want to update
     *   }
     * })
     */
    upsert<T extends StudentDocumentUpsertArgs>(args: SelectSubset<T, StudentDocumentUpsertArgs<ExtArgs>>): Prisma__StudentDocumentClient<$Result.GetResult<Prisma.$StudentDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentDocumentCountArgs} args - Arguments to filter StudentDocuments to count.
     * @example
     * // Count the number of StudentDocuments
     * const count = await prisma.studentDocument.count({
     *   where: {
     *     // ... the filter for the StudentDocuments we want to count
     *   }
     * })
    **/
    count<T extends StudentDocumentCountArgs>(
      args?: Subset<T, StudentDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentDocumentAggregateArgs>(args: Subset<T, StudentDocumentAggregateArgs>): Prisma.PrismaPromise<GetStudentDocumentAggregateType<T>>

    /**
     * Group by StudentDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentDocumentGroupByArgs['orderBy'] }
        : { orderBy?: StudentDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentDocument model
   */
  readonly fields: StudentDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Organization<T extends StudentDocument$OrganizationArgs<ExtArgs> = {}>(args?: Subset<T, StudentDocument$OrganizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentDocument model
   */
  interface StudentDocumentFieldRefs {
    readonly id: FieldRef<"StudentDocument", 'String'>
    readonly type: FieldRef<"StudentDocument", 'DocumentType'>
    readonly fileName: FieldRef<"StudentDocument", 'String'>
    readonly fileSize: FieldRef<"StudentDocument", 'Int'>
    readonly fileType: FieldRef<"StudentDocument", 'String'>
    readonly documentUrl: FieldRef<"StudentDocument", 'String'>
    readonly studentId: FieldRef<"StudentDocument", 'String'>
    readonly verified: FieldRef<"StudentDocument", 'Boolean'>
    readonly verifiedBy: FieldRef<"StudentDocument", 'String'>
    readonly verifiedAt: FieldRef<"StudentDocument", 'DateTime'>
    readonly rejected: FieldRef<"StudentDocument", 'Boolean'>
    readonly rejectedBy: FieldRef<"StudentDocument", 'String'>
    readonly rejectedAt: FieldRef<"StudentDocument", 'DateTime'>
    readonly rejectReason: FieldRef<"StudentDocument", 'String'>
    readonly uploadedBy: FieldRef<"StudentDocument", 'String'>
    readonly uploadedAt: FieldRef<"StudentDocument", 'DateTime'>
    readonly note: FieldRef<"StudentDocument", 'String'>
    readonly isDeleted: FieldRef<"StudentDocument", 'Boolean'>
    readonly deletedAt: FieldRef<"StudentDocument", 'DateTime'>
    readonly createdAt: FieldRef<"StudentDocument", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentDocument", 'DateTime'>
    readonly organizationId: FieldRef<"StudentDocument", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StudentDocument findUnique
   */
  export type StudentDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentDocument
     */
    omit?: StudentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentInclude<ExtArgs> | null
    /**
     * Filter, which StudentDocument to fetch.
     */
    where: StudentDocumentWhereUniqueInput
  }

  /**
   * StudentDocument findUniqueOrThrow
   */
  export type StudentDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentDocument
     */
    omit?: StudentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentInclude<ExtArgs> | null
    /**
     * Filter, which StudentDocument to fetch.
     */
    where: StudentDocumentWhereUniqueInput
  }

  /**
   * StudentDocument findFirst
   */
  export type StudentDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentDocument
     */
    omit?: StudentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentInclude<ExtArgs> | null
    /**
     * Filter, which StudentDocument to fetch.
     */
    where?: StudentDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentDocuments to fetch.
     */
    orderBy?: StudentDocumentOrderByWithRelationInput | StudentDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentDocuments.
     */
    cursor?: StudentDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentDocuments.
     */
    distinct?: StudentDocumentScalarFieldEnum | StudentDocumentScalarFieldEnum[]
  }

  /**
   * StudentDocument findFirstOrThrow
   */
  export type StudentDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentDocument
     */
    omit?: StudentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentInclude<ExtArgs> | null
    /**
     * Filter, which StudentDocument to fetch.
     */
    where?: StudentDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentDocuments to fetch.
     */
    orderBy?: StudentDocumentOrderByWithRelationInput | StudentDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentDocuments.
     */
    cursor?: StudentDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentDocuments.
     */
    distinct?: StudentDocumentScalarFieldEnum | StudentDocumentScalarFieldEnum[]
  }

  /**
   * StudentDocument findMany
   */
  export type StudentDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentDocument
     */
    omit?: StudentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentInclude<ExtArgs> | null
    /**
     * Filter, which StudentDocuments to fetch.
     */
    where?: StudentDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentDocuments to fetch.
     */
    orderBy?: StudentDocumentOrderByWithRelationInput | StudentDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentDocuments.
     */
    cursor?: StudentDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentDocuments.
     */
    skip?: number
    distinct?: StudentDocumentScalarFieldEnum | StudentDocumentScalarFieldEnum[]
  }

  /**
   * StudentDocument create
   */
  export type StudentDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentDocument
     */
    omit?: StudentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentDocument.
     */
    data: XOR<StudentDocumentCreateInput, StudentDocumentUncheckedCreateInput>
  }

  /**
   * StudentDocument createMany
   */
  export type StudentDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentDocuments.
     */
    data: StudentDocumentCreateManyInput | StudentDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentDocument createManyAndReturn
   */
  export type StudentDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentDocument
     */
    omit?: StudentDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many StudentDocuments.
     */
    data: StudentDocumentCreateManyInput | StudentDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentDocument update
   */
  export type StudentDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentDocument
     */
    omit?: StudentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentDocument.
     */
    data: XOR<StudentDocumentUpdateInput, StudentDocumentUncheckedUpdateInput>
    /**
     * Choose, which StudentDocument to update.
     */
    where: StudentDocumentWhereUniqueInput
  }

  /**
   * StudentDocument updateMany
   */
  export type StudentDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentDocuments.
     */
    data: XOR<StudentDocumentUpdateManyMutationInput, StudentDocumentUncheckedUpdateManyInput>
    /**
     * Filter which StudentDocuments to update
     */
    where?: StudentDocumentWhereInput
    /**
     * Limit how many StudentDocuments to update.
     */
    limit?: number
  }

  /**
   * StudentDocument updateManyAndReturn
   */
  export type StudentDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentDocument
     */
    omit?: StudentDocumentOmit<ExtArgs> | null
    /**
     * The data used to update StudentDocuments.
     */
    data: XOR<StudentDocumentUpdateManyMutationInput, StudentDocumentUncheckedUpdateManyInput>
    /**
     * Filter which StudentDocuments to update
     */
    where?: StudentDocumentWhereInput
    /**
     * Limit how many StudentDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentDocument upsert
   */
  export type StudentDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentDocument
     */
    omit?: StudentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentDocument to update in case it exists.
     */
    where: StudentDocumentWhereUniqueInput
    /**
     * In case the StudentDocument found by the `where` argument doesn't exist, create a new StudentDocument with this data.
     */
    create: XOR<StudentDocumentCreateInput, StudentDocumentUncheckedCreateInput>
    /**
     * In case the StudentDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentDocumentUpdateInput, StudentDocumentUncheckedUpdateInput>
  }

  /**
   * StudentDocument delete
   */
  export type StudentDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentDocument
     */
    omit?: StudentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentInclude<ExtArgs> | null
    /**
     * Filter which StudentDocument to delete.
     */
    where: StudentDocumentWhereUniqueInput
  }

  /**
   * StudentDocument deleteMany
   */
  export type StudentDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentDocuments to delete
     */
    where?: StudentDocumentWhereInput
    /**
     * Limit how many StudentDocuments to delete.
     */
    limit?: number
  }

  /**
   * StudentDocument.Organization
   */
  export type StudentDocument$OrganizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * StudentDocument without action
   */
  export type StudentDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentDocument
     */
    omit?: StudentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentInclude<ExtArgs> | null
  }


  /**
   * Model Fee
   */

  export type AggregateFee = {
    _count: FeeCountAggregateOutputType | null
    _avg: FeeAvgAggregateOutputType | null
    _sum: FeeSumAggregateOutputType | null
    _min: FeeMinAggregateOutputType | null
    _max: FeeMaxAggregateOutputType | null
  }

  export type FeeAvgAggregateOutputType = {
    totalFee: number | null
    paidAmount: number | null
    pendingAmount: number | null
  }

  export type FeeSumAggregateOutputType = {
    totalFee: number | null
    paidAmount: number | null
    pendingAmount: number | null
  }

  export type FeeMinAggregateOutputType = {
    id: string | null
    totalFee: number | null
    paidAmount: number | null
    pendingAmount: number | null
    dueDate: Date | null
    status: $Enums.FeeStatus | null
    studentId: string | null
    feeCategoryId: string | null
    organizationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeeMaxAggregateOutputType = {
    id: string | null
    totalFee: number | null
    paidAmount: number | null
    pendingAmount: number | null
    dueDate: Date | null
    status: $Enums.FeeStatus | null
    studentId: string | null
    feeCategoryId: string | null
    organizationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeeCountAggregateOutputType = {
    id: number
    totalFee: number
    paidAmount: number
    pendingAmount: number
    dueDate: number
    status: number
    studentId: number
    feeCategoryId: number
    organizationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeeAvgAggregateInputType = {
    totalFee?: true
    paidAmount?: true
    pendingAmount?: true
  }

  export type FeeSumAggregateInputType = {
    totalFee?: true
    paidAmount?: true
    pendingAmount?: true
  }

  export type FeeMinAggregateInputType = {
    id?: true
    totalFee?: true
    paidAmount?: true
    pendingAmount?: true
    dueDate?: true
    status?: true
    studentId?: true
    feeCategoryId?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeeMaxAggregateInputType = {
    id?: true
    totalFee?: true
    paidAmount?: true
    pendingAmount?: true
    dueDate?: true
    status?: true
    studentId?: true
    feeCategoryId?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeeCountAggregateInputType = {
    id?: true
    totalFee?: true
    paidAmount?: true
    pendingAmount?: true
    dueDate?: true
    status?: true
    studentId?: true
    feeCategoryId?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fee to aggregate.
     */
    where?: FeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fees to fetch.
     */
    orderBy?: FeeOrderByWithRelationInput | FeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fees
    **/
    _count?: true | FeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeeMaxAggregateInputType
  }

  export type GetFeeAggregateType<T extends FeeAggregateArgs> = {
        [P in keyof T & keyof AggregateFee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFee[P]>
      : GetScalarType<T[P], AggregateFee[P]>
  }




  export type FeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeWhereInput
    orderBy?: FeeOrderByWithAggregationInput | FeeOrderByWithAggregationInput[]
    by: FeeScalarFieldEnum[] | FeeScalarFieldEnum
    having?: FeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeeCountAggregateInputType | true
    _avg?: FeeAvgAggregateInputType
    _sum?: FeeSumAggregateInputType
    _min?: FeeMinAggregateInputType
    _max?: FeeMaxAggregateInputType
  }

  export type FeeGroupByOutputType = {
    id: string
    totalFee: number
    paidAmount: number
    pendingAmount: number | null
    dueDate: Date
    status: $Enums.FeeStatus
    studentId: string
    feeCategoryId: string
    organizationId: string
    createdAt: Date
    updatedAt: Date
    _count: FeeCountAggregateOutputType | null
    _avg: FeeAvgAggregateOutputType | null
    _sum: FeeSumAggregateOutputType | null
    _min: FeeMinAggregateOutputType | null
    _max: FeeMaxAggregateOutputType | null
  }

  type GetFeeGroupByPayload<T extends FeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeeGroupByOutputType[P]>
            : GetScalarType<T[P], FeeGroupByOutputType[P]>
        }
      >
    >


  export type FeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    totalFee?: boolean
    paidAmount?: boolean
    pendingAmount?: boolean
    dueDate?: boolean
    status?: boolean
    studentId?: boolean
    feeCategoryId?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    feeCategory?: boolean | FeeCategoryDefaultArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    payments?: boolean | Fee$paymentsArgs<ExtArgs>
    _count?: boolean | FeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fee"]>

  export type FeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    totalFee?: boolean
    paidAmount?: boolean
    pendingAmount?: boolean
    dueDate?: boolean
    status?: boolean
    studentId?: boolean
    feeCategoryId?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    feeCategory?: boolean | FeeCategoryDefaultArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fee"]>

  export type FeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    totalFee?: boolean
    paidAmount?: boolean
    pendingAmount?: boolean
    dueDate?: boolean
    status?: boolean
    studentId?: boolean
    feeCategoryId?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    feeCategory?: boolean | FeeCategoryDefaultArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fee"]>

  export type FeeSelectScalar = {
    id?: boolean
    totalFee?: boolean
    paidAmount?: boolean
    pendingAmount?: boolean
    dueDate?: boolean
    status?: boolean
    studentId?: boolean
    feeCategoryId?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "totalFee" | "paidAmount" | "pendingAmount" | "dueDate" | "status" | "studentId" | "feeCategoryId" | "organizationId" | "createdAt" | "updatedAt", ExtArgs["result"]["fee"]>
  export type FeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    feeCategory?: boolean | FeeCategoryDefaultArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    payments?: boolean | Fee$paymentsArgs<ExtArgs>
    _count?: boolean | FeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    feeCategory?: boolean | FeeCategoryDefaultArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type FeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    feeCategory?: boolean | FeeCategoryDefaultArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $FeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Fee"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      feeCategory: Prisma.$FeeCategoryPayload<ExtArgs>
      Organization: Prisma.$OrganizationPayload<ExtArgs>
      payments: Prisma.$FeePaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      totalFee: number
      paidAmount: number
      pendingAmount: number | null
      dueDate: Date
      status: $Enums.FeeStatus
      studentId: string
      feeCategoryId: string
      organizationId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fee"]>
    composites: {}
  }

  type FeeGetPayload<S extends boolean | null | undefined | FeeDefaultArgs> = $Result.GetResult<Prisma.$FeePayload, S>

  type FeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeeCountAggregateInputType | true
    }

  export interface FeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Fee'], meta: { name: 'Fee' } }
    /**
     * Find zero or one Fee that matches the filter.
     * @param {FeeFindUniqueArgs} args - Arguments to find a Fee
     * @example
     * // Get one Fee
     * const fee = await prisma.fee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeeFindUniqueArgs>(args: SelectSubset<T, FeeFindUniqueArgs<ExtArgs>>): Prisma__FeeClient<$Result.GetResult<Prisma.$FeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Fee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeeFindUniqueOrThrowArgs} args - Arguments to find a Fee
     * @example
     * // Get one Fee
     * const fee = await prisma.fee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeeFindUniqueOrThrowArgs>(args: SelectSubset<T, FeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeeClient<$Result.GetResult<Prisma.$FeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeFindFirstArgs} args - Arguments to find a Fee
     * @example
     * // Get one Fee
     * const fee = await prisma.fee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeeFindFirstArgs>(args?: SelectSubset<T, FeeFindFirstArgs<ExtArgs>>): Prisma__FeeClient<$Result.GetResult<Prisma.$FeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeFindFirstOrThrowArgs} args - Arguments to find a Fee
     * @example
     * // Get one Fee
     * const fee = await prisma.fee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeeFindFirstOrThrowArgs>(args?: SelectSubset<T, FeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeeClient<$Result.GetResult<Prisma.$FeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Fees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fees
     * const fees = await prisma.fee.findMany()
     * 
     * // Get first 10 Fees
     * const fees = await prisma.fee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feeWithIdOnly = await prisma.fee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeeFindManyArgs>(args?: SelectSubset<T, FeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Fee.
     * @param {FeeCreateArgs} args - Arguments to create a Fee.
     * @example
     * // Create one Fee
     * const Fee = await prisma.fee.create({
     *   data: {
     *     // ... data to create a Fee
     *   }
     * })
     * 
     */
    create<T extends FeeCreateArgs>(args: SelectSubset<T, FeeCreateArgs<ExtArgs>>): Prisma__FeeClient<$Result.GetResult<Prisma.$FeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Fees.
     * @param {FeeCreateManyArgs} args - Arguments to create many Fees.
     * @example
     * // Create many Fees
     * const fee = await prisma.fee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeeCreateManyArgs>(args?: SelectSubset<T, FeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Fees and returns the data saved in the database.
     * @param {FeeCreateManyAndReturnArgs} args - Arguments to create many Fees.
     * @example
     * // Create many Fees
     * const fee = await prisma.fee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Fees and only return the `id`
     * const feeWithIdOnly = await prisma.fee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeeCreateManyAndReturnArgs>(args?: SelectSubset<T, FeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Fee.
     * @param {FeeDeleteArgs} args - Arguments to delete one Fee.
     * @example
     * // Delete one Fee
     * const Fee = await prisma.fee.delete({
     *   where: {
     *     // ... filter to delete one Fee
     *   }
     * })
     * 
     */
    delete<T extends FeeDeleteArgs>(args: SelectSubset<T, FeeDeleteArgs<ExtArgs>>): Prisma__FeeClient<$Result.GetResult<Prisma.$FeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Fee.
     * @param {FeeUpdateArgs} args - Arguments to update one Fee.
     * @example
     * // Update one Fee
     * const fee = await prisma.fee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeeUpdateArgs>(args: SelectSubset<T, FeeUpdateArgs<ExtArgs>>): Prisma__FeeClient<$Result.GetResult<Prisma.$FeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Fees.
     * @param {FeeDeleteManyArgs} args - Arguments to filter Fees to delete.
     * @example
     * // Delete a few Fees
     * const { count } = await prisma.fee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeeDeleteManyArgs>(args?: SelectSubset<T, FeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fees
     * const fee = await prisma.fee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeeUpdateManyArgs>(args: SelectSubset<T, FeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fees and returns the data updated in the database.
     * @param {FeeUpdateManyAndReturnArgs} args - Arguments to update many Fees.
     * @example
     * // Update many Fees
     * const fee = await prisma.fee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Fees and only return the `id`
     * const feeWithIdOnly = await prisma.fee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeeUpdateManyAndReturnArgs>(args: SelectSubset<T, FeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Fee.
     * @param {FeeUpsertArgs} args - Arguments to update or create a Fee.
     * @example
     * // Update or create a Fee
     * const fee = await prisma.fee.upsert({
     *   create: {
     *     // ... data to create a Fee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fee we want to update
     *   }
     * })
     */
    upsert<T extends FeeUpsertArgs>(args: SelectSubset<T, FeeUpsertArgs<ExtArgs>>): Prisma__FeeClient<$Result.GetResult<Prisma.$FeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Fees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeCountArgs} args - Arguments to filter Fees to count.
     * @example
     * // Count the number of Fees
     * const count = await prisma.fee.count({
     *   where: {
     *     // ... the filter for the Fees we want to count
     *   }
     * })
    **/
    count<T extends FeeCountArgs>(
      args?: Subset<T, FeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeeAggregateArgs>(args: Subset<T, FeeAggregateArgs>): Prisma.PrismaPromise<GetFeeAggregateType<T>>

    /**
     * Group by Fee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeeGroupByArgs['orderBy'] }
        : { orderBy?: FeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Fee model
   */
  readonly fields: FeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Fee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    feeCategory<T extends FeeCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeeCategoryDefaultArgs<ExtArgs>>): Prisma__FeeCategoryClient<$Result.GetResult<Prisma.$FeeCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payments<T extends Fee$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Fee$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Fee model
   */
  interface FeeFieldRefs {
    readonly id: FieldRef<"Fee", 'String'>
    readonly totalFee: FieldRef<"Fee", 'Float'>
    readonly paidAmount: FieldRef<"Fee", 'Float'>
    readonly pendingAmount: FieldRef<"Fee", 'Float'>
    readonly dueDate: FieldRef<"Fee", 'DateTime'>
    readonly status: FieldRef<"Fee", 'FeeStatus'>
    readonly studentId: FieldRef<"Fee", 'String'>
    readonly feeCategoryId: FieldRef<"Fee", 'String'>
    readonly organizationId: FieldRef<"Fee", 'String'>
    readonly createdAt: FieldRef<"Fee", 'DateTime'>
    readonly updatedAt: FieldRef<"Fee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Fee findUnique
   */
  export type FeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fee
     */
    omit?: FeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeInclude<ExtArgs> | null
    /**
     * Filter, which Fee to fetch.
     */
    where: FeeWhereUniqueInput
  }

  /**
   * Fee findUniqueOrThrow
   */
  export type FeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fee
     */
    omit?: FeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeInclude<ExtArgs> | null
    /**
     * Filter, which Fee to fetch.
     */
    where: FeeWhereUniqueInput
  }

  /**
   * Fee findFirst
   */
  export type FeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fee
     */
    omit?: FeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeInclude<ExtArgs> | null
    /**
     * Filter, which Fee to fetch.
     */
    where?: FeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fees to fetch.
     */
    orderBy?: FeeOrderByWithRelationInput | FeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fees.
     */
    cursor?: FeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fees.
     */
    distinct?: FeeScalarFieldEnum | FeeScalarFieldEnum[]
  }

  /**
   * Fee findFirstOrThrow
   */
  export type FeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fee
     */
    omit?: FeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeInclude<ExtArgs> | null
    /**
     * Filter, which Fee to fetch.
     */
    where?: FeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fees to fetch.
     */
    orderBy?: FeeOrderByWithRelationInput | FeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fees.
     */
    cursor?: FeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fees.
     */
    distinct?: FeeScalarFieldEnum | FeeScalarFieldEnum[]
  }

  /**
   * Fee findMany
   */
  export type FeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fee
     */
    omit?: FeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeInclude<ExtArgs> | null
    /**
     * Filter, which Fees to fetch.
     */
    where?: FeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fees to fetch.
     */
    orderBy?: FeeOrderByWithRelationInput | FeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fees.
     */
    cursor?: FeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fees.
     */
    skip?: number
    distinct?: FeeScalarFieldEnum | FeeScalarFieldEnum[]
  }

  /**
   * Fee create
   */
  export type FeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fee
     */
    omit?: FeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Fee.
     */
    data: XOR<FeeCreateInput, FeeUncheckedCreateInput>
  }

  /**
   * Fee createMany
   */
  export type FeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Fees.
     */
    data: FeeCreateManyInput | FeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Fee createManyAndReturn
   */
  export type FeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fee
     */
    omit?: FeeOmit<ExtArgs> | null
    /**
     * The data used to create many Fees.
     */
    data: FeeCreateManyInput | FeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Fee update
   */
  export type FeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fee
     */
    omit?: FeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Fee.
     */
    data: XOR<FeeUpdateInput, FeeUncheckedUpdateInput>
    /**
     * Choose, which Fee to update.
     */
    where: FeeWhereUniqueInput
  }

  /**
   * Fee updateMany
   */
  export type FeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Fees.
     */
    data: XOR<FeeUpdateManyMutationInput, FeeUncheckedUpdateManyInput>
    /**
     * Filter which Fees to update
     */
    where?: FeeWhereInput
    /**
     * Limit how many Fees to update.
     */
    limit?: number
  }

  /**
   * Fee updateManyAndReturn
   */
  export type FeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fee
     */
    omit?: FeeOmit<ExtArgs> | null
    /**
     * The data used to update Fees.
     */
    data: XOR<FeeUpdateManyMutationInput, FeeUncheckedUpdateManyInput>
    /**
     * Filter which Fees to update
     */
    where?: FeeWhereInput
    /**
     * Limit how many Fees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Fee upsert
   */
  export type FeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fee
     */
    omit?: FeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Fee to update in case it exists.
     */
    where: FeeWhereUniqueInput
    /**
     * In case the Fee found by the `where` argument doesn't exist, create a new Fee with this data.
     */
    create: XOR<FeeCreateInput, FeeUncheckedCreateInput>
    /**
     * In case the Fee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeeUpdateInput, FeeUncheckedUpdateInput>
  }

  /**
   * Fee delete
   */
  export type FeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fee
     */
    omit?: FeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeInclude<ExtArgs> | null
    /**
     * Filter which Fee to delete.
     */
    where: FeeWhereUniqueInput
  }

  /**
   * Fee deleteMany
   */
  export type FeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fees to delete
     */
    where?: FeeWhereInput
    /**
     * Limit how many Fees to delete.
     */
    limit?: number
  }

  /**
   * Fee.payments
   */
  export type Fee$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeePayment
     */
    omit?: FeePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
    where?: FeePaymentWhereInput
    orderBy?: FeePaymentOrderByWithRelationInput | FeePaymentOrderByWithRelationInput[]
    cursor?: FeePaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeePaymentScalarFieldEnum | FeePaymentScalarFieldEnum[]
  }

  /**
   * Fee without action
   */
  export type FeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fee
     */
    omit?: FeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeInclude<ExtArgs> | null
  }


  /**
   * Model FeePayment
   */

  export type AggregateFeePayment = {
    _count: FeePaymentCountAggregateOutputType | null
    _avg: FeePaymentAvgAggregateOutputType | null
    _sum: FeePaymentSumAggregateOutputType | null
    _min: FeePaymentMinAggregateOutputType | null
    _max: FeePaymentMaxAggregateOutputType | null
  }

  export type FeePaymentAvgAggregateOutputType = {
    amount: number | null
    platformFee: number | null
  }

  export type FeePaymentSumAggregateOutputType = {
    amount: number | null
    platformFee: number | null
  }

  export type FeePaymentMinAggregateOutputType = {
    id: string | null
    feeId: string | null
    amount: number | null
    status: $Enums.PaymentStatus | null
    paymentMethod: $Enums.PaymentMethod | null
    paymentDate: Date | null
    receiptNumber: string | null
    note: string | null
    transactionId: string | null
    payerId: string | null
    platformFee: number | null
    recordedBy: string | null
    organizationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeePaymentMaxAggregateOutputType = {
    id: string | null
    feeId: string | null
    amount: number | null
    status: $Enums.PaymentStatus | null
    paymentMethod: $Enums.PaymentMethod | null
    paymentDate: Date | null
    receiptNumber: string | null
    note: string | null
    transactionId: string | null
    payerId: string | null
    platformFee: number | null
    recordedBy: string | null
    organizationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeePaymentCountAggregateOutputType = {
    id: number
    feeId: number
    amount: number
    status: number
    paymentMethod: number
    paymentDate: number
    receiptNumber: number
    note: number
    transactionId: number
    payerId: number
    platformFee: number
    recordedBy: number
    organizationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeePaymentAvgAggregateInputType = {
    amount?: true
    platformFee?: true
  }

  export type FeePaymentSumAggregateInputType = {
    amount?: true
    platformFee?: true
  }

  export type FeePaymentMinAggregateInputType = {
    id?: true
    feeId?: true
    amount?: true
    status?: true
    paymentMethod?: true
    paymentDate?: true
    receiptNumber?: true
    note?: true
    transactionId?: true
    payerId?: true
    platformFee?: true
    recordedBy?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeePaymentMaxAggregateInputType = {
    id?: true
    feeId?: true
    amount?: true
    status?: true
    paymentMethod?: true
    paymentDate?: true
    receiptNumber?: true
    note?: true
    transactionId?: true
    payerId?: true
    platformFee?: true
    recordedBy?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeePaymentCountAggregateInputType = {
    id?: true
    feeId?: true
    amount?: true
    status?: true
    paymentMethod?: true
    paymentDate?: true
    receiptNumber?: true
    note?: true
    transactionId?: true
    payerId?: true
    platformFee?: true
    recordedBy?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeePaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeePayment to aggregate.
     */
    where?: FeePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeePayments to fetch.
     */
    orderBy?: FeePaymentOrderByWithRelationInput | FeePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeePayments
    **/
    _count?: true | FeePaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeePaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeePaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeePaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeePaymentMaxAggregateInputType
  }

  export type GetFeePaymentAggregateType<T extends FeePaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateFeePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeePayment[P]>
      : GetScalarType<T[P], AggregateFeePayment[P]>
  }




  export type FeePaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeePaymentWhereInput
    orderBy?: FeePaymentOrderByWithAggregationInput | FeePaymentOrderByWithAggregationInput[]
    by: FeePaymentScalarFieldEnum[] | FeePaymentScalarFieldEnum
    having?: FeePaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeePaymentCountAggregateInputType | true
    _avg?: FeePaymentAvgAggregateInputType
    _sum?: FeePaymentSumAggregateInputType
    _min?: FeePaymentMinAggregateInputType
    _max?: FeePaymentMaxAggregateInputType
  }

  export type FeePaymentGroupByOutputType = {
    id: string
    feeId: string
    amount: number
    status: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    paymentDate: Date
    receiptNumber: string
    note: string | null
    transactionId: string | null
    payerId: string
    platformFee: number | null
    recordedBy: string | null
    organizationId: string
    createdAt: Date
    updatedAt: Date
    _count: FeePaymentCountAggregateOutputType | null
    _avg: FeePaymentAvgAggregateOutputType | null
    _sum: FeePaymentSumAggregateOutputType | null
    _min: FeePaymentMinAggregateOutputType | null
    _max: FeePaymentMaxAggregateOutputType | null
  }

  type GetFeePaymentGroupByPayload<T extends FeePaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeePaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeePaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeePaymentGroupByOutputType[P]>
            : GetScalarType<T[P], FeePaymentGroupByOutputType[P]>
        }
      >
    >


  export type FeePaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feeId?: boolean
    amount?: boolean
    status?: boolean
    paymentMethod?: boolean
    paymentDate?: boolean
    receiptNumber?: boolean
    note?: boolean
    transactionId?: boolean
    payerId?: boolean
    platformFee?: boolean
    recordedBy?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fee?: boolean | FeeDefaultArgs<ExtArgs>
    payer?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feePayment"]>

  export type FeePaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feeId?: boolean
    amount?: boolean
    status?: boolean
    paymentMethod?: boolean
    paymentDate?: boolean
    receiptNumber?: boolean
    note?: boolean
    transactionId?: boolean
    payerId?: boolean
    platformFee?: boolean
    recordedBy?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fee?: boolean | FeeDefaultArgs<ExtArgs>
    payer?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feePayment"]>

  export type FeePaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feeId?: boolean
    amount?: boolean
    status?: boolean
    paymentMethod?: boolean
    paymentDate?: boolean
    receiptNumber?: boolean
    note?: boolean
    transactionId?: boolean
    payerId?: boolean
    platformFee?: boolean
    recordedBy?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fee?: boolean | FeeDefaultArgs<ExtArgs>
    payer?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feePayment"]>

  export type FeePaymentSelectScalar = {
    id?: boolean
    feeId?: boolean
    amount?: boolean
    status?: boolean
    paymentMethod?: boolean
    paymentDate?: boolean
    receiptNumber?: boolean
    note?: boolean
    transactionId?: boolean
    payerId?: boolean
    platformFee?: boolean
    recordedBy?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeePaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "feeId" | "amount" | "status" | "paymentMethod" | "paymentDate" | "receiptNumber" | "note" | "transactionId" | "payerId" | "platformFee" | "recordedBy" | "organizationId" | "createdAt" | "updatedAt", ExtArgs["result"]["feePayment"]>
  export type FeePaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fee?: boolean | FeeDefaultArgs<ExtArgs>
    payer?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type FeePaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fee?: boolean | FeeDefaultArgs<ExtArgs>
    payer?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type FeePaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fee?: boolean | FeeDefaultArgs<ExtArgs>
    payer?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $FeePaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeePayment"
    objects: {
      fee: Prisma.$FeePayload<ExtArgs>
      payer: Prisma.$UserPayload<ExtArgs>
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      feeId: string
      amount: number
      status: $Enums.PaymentStatus
      paymentMethod: $Enums.PaymentMethod
      paymentDate: Date
      receiptNumber: string
      note: string | null
      transactionId: string | null
      payerId: string
      platformFee: number | null
      recordedBy: string | null
      organizationId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["feePayment"]>
    composites: {}
  }

  type FeePaymentGetPayload<S extends boolean | null | undefined | FeePaymentDefaultArgs> = $Result.GetResult<Prisma.$FeePaymentPayload, S>

  type FeePaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeePaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeePaymentCountAggregateInputType | true
    }

  export interface FeePaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeePayment'], meta: { name: 'FeePayment' } }
    /**
     * Find zero or one FeePayment that matches the filter.
     * @param {FeePaymentFindUniqueArgs} args - Arguments to find a FeePayment
     * @example
     * // Get one FeePayment
     * const feePayment = await prisma.feePayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeePaymentFindUniqueArgs>(args: SelectSubset<T, FeePaymentFindUniqueArgs<ExtArgs>>): Prisma__FeePaymentClient<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeePayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeePaymentFindUniqueOrThrowArgs} args - Arguments to find a FeePayment
     * @example
     * // Get one FeePayment
     * const feePayment = await prisma.feePayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeePaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, FeePaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeePaymentClient<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeePayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeePaymentFindFirstArgs} args - Arguments to find a FeePayment
     * @example
     * // Get one FeePayment
     * const feePayment = await prisma.feePayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeePaymentFindFirstArgs>(args?: SelectSubset<T, FeePaymentFindFirstArgs<ExtArgs>>): Prisma__FeePaymentClient<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeePayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeePaymentFindFirstOrThrowArgs} args - Arguments to find a FeePayment
     * @example
     * // Get one FeePayment
     * const feePayment = await prisma.feePayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeePaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, FeePaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeePaymentClient<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeePayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeePaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeePayments
     * const feePayments = await prisma.feePayment.findMany()
     * 
     * // Get first 10 FeePayments
     * const feePayments = await prisma.feePayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feePaymentWithIdOnly = await prisma.feePayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeePaymentFindManyArgs>(args?: SelectSubset<T, FeePaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeePayment.
     * @param {FeePaymentCreateArgs} args - Arguments to create a FeePayment.
     * @example
     * // Create one FeePayment
     * const FeePayment = await prisma.feePayment.create({
     *   data: {
     *     // ... data to create a FeePayment
     *   }
     * })
     * 
     */
    create<T extends FeePaymentCreateArgs>(args: SelectSubset<T, FeePaymentCreateArgs<ExtArgs>>): Prisma__FeePaymentClient<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeePayments.
     * @param {FeePaymentCreateManyArgs} args - Arguments to create many FeePayments.
     * @example
     * // Create many FeePayments
     * const feePayment = await prisma.feePayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeePaymentCreateManyArgs>(args?: SelectSubset<T, FeePaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeePayments and returns the data saved in the database.
     * @param {FeePaymentCreateManyAndReturnArgs} args - Arguments to create many FeePayments.
     * @example
     * // Create many FeePayments
     * const feePayment = await prisma.feePayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeePayments and only return the `id`
     * const feePaymentWithIdOnly = await prisma.feePayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeePaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, FeePaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeePayment.
     * @param {FeePaymentDeleteArgs} args - Arguments to delete one FeePayment.
     * @example
     * // Delete one FeePayment
     * const FeePayment = await prisma.feePayment.delete({
     *   where: {
     *     // ... filter to delete one FeePayment
     *   }
     * })
     * 
     */
    delete<T extends FeePaymentDeleteArgs>(args: SelectSubset<T, FeePaymentDeleteArgs<ExtArgs>>): Prisma__FeePaymentClient<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeePayment.
     * @param {FeePaymentUpdateArgs} args - Arguments to update one FeePayment.
     * @example
     * // Update one FeePayment
     * const feePayment = await prisma.feePayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeePaymentUpdateArgs>(args: SelectSubset<T, FeePaymentUpdateArgs<ExtArgs>>): Prisma__FeePaymentClient<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeePayments.
     * @param {FeePaymentDeleteManyArgs} args - Arguments to filter FeePayments to delete.
     * @example
     * // Delete a few FeePayments
     * const { count } = await prisma.feePayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeePaymentDeleteManyArgs>(args?: SelectSubset<T, FeePaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeePayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeePaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeePayments
     * const feePayment = await prisma.feePayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeePaymentUpdateManyArgs>(args: SelectSubset<T, FeePaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeePayments and returns the data updated in the database.
     * @param {FeePaymentUpdateManyAndReturnArgs} args - Arguments to update many FeePayments.
     * @example
     * // Update many FeePayments
     * const feePayment = await prisma.feePayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeePayments and only return the `id`
     * const feePaymentWithIdOnly = await prisma.feePayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeePaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, FeePaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeePayment.
     * @param {FeePaymentUpsertArgs} args - Arguments to update or create a FeePayment.
     * @example
     * // Update or create a FeePayment
     * const feePayment = await prisma.feePayment.upsert({
     *   create: {
     *     // ... data to create a FeePayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeePayment we want to update
     *   }
     * })
     */
    upsert<T extends FeePaymentUpsertArgs>(args: SelectSubset<T, FeePaymentUpsertArgs<ExtArgs>>): Prisma__FeePaymentClient<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeePayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeePaymentCountArgs} args - Arguments to filter FeePayments to count.
     * @example
     * // Count the number of FeePayments
     * const count = await prisma.feePayment.count({
     *   where: {
     *     // ... the filter for the FeePayments we want to count
     *   }
     * })
    **/
    count<T extends FeePaymentCountArgs>(
      args?: Subset<T, FeePaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeePaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeePayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeePaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeePaymentAggregateArgs>(args: Subset<T, FeePaymentAggregateArgs>): Prisma.PrismaPromise<GetFeePaymentAggregateType<T>>

    /**
     * Group by FeePayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeePaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeePaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeePaymentGroupByArgs['orderBy'] }
        : { orderBy?: FeePaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeePaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeePaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeePayment model
   */
  readonly fields: FeePaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeePayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeePaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fee<T extends FeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeeDefaultArgs<ExtArgs>>): Prisma__FeeClient<$Result.GetResult<Prisma.$FeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeePayment model
   */
  interface FeePaymentFieldRefs {
    readonly id: FieldRef<"FeePayment", 'String'>
    readonly feeId: FieldRef<"FeePayment", 'String'>
    readonly amount: FieldRef<"FeePayment", 'Float'>
    readonly status: FieldRef<"FeePayment", 'PaymentStatus'>
    readonly paymentMethod: FieldRef<"FeePayment", 'PaymentMethod'>
    readonly paymentDate: FieldRef<"FeePayment", 'DateTime'>
    readonly receiptNumber: FieldRef<"FeePayment", 'String'>
    readonly note: FieldRef<"FeePayment", 'String'>
    readonly transactionId: FieldRef<"FeePayment", 'String'>
    readonly payerId: FieldRef<"FeePayment", 'String'>
    readonly platformFee: FieldRef<"FeePayment", 'Float'>
    readonly recordedBy: FieldRef<"FeePayment", 'String'>
    readonly organizationId: FieldRef<"FeePayment", 'String'>
    readonly createdAt: FieldRef<"FeePayment", 'DateTime'>
    readonly updatedAt: FieldRef<"FeePayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeePayment findUnique
   */
  export type FeePaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeePayment
     */
    omit?: FeePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * Filter, which FeePayment to fetch.
     */
    where: FeePaymentWhereUniqueInput
  }

  /**
   * FeePayment findUniqueOrThrow
   */
  export type FeePaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeePayment
     */
    omit?: FeePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * Filter, which FeePayment to fetch.
     */
    where: FeePaymentWhereUniqueInput
  }

  /**
   * FeePayment findFirst
   */
  export type FeePaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeePayment
     */
    omit?: FeePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * Filter, which FeePayment to fetch.
     */
    where?: FeePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeePayments to fetch.
     */
    orderBy?: FeePaymentOrderByWithRelationInput | FeePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeePayments.
     */
    cursor?: FeePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeePayments.
     */
    distinct?: FeePaymentScalarFieldEnum | FeePaymentScalarFieldEnum[]
  }

  /**
   * FeePayment findFirstOrThrow
   */
  export type FeePaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeePayment
     */
    omit?: FeePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * Filter, which FeePayment to fetch.
     */
    where?: FeePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeePayments to fetch.
     */
    orderBy?: FeePaymentOrderByWithRelationInput | FeePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeePayments.
     */
    cursor?: FeePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeePayments.
     */
    distinct?: FeePaymentScalarFieldEnum | FeePaymentScalarFieldEnum[]
  }

  /**
   * FeePayment findMany
   */
  export type FeePaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeePayment
     */
    omit?: FeePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * Filter, which FeePayments to fetch.
     */
    where?: FeePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeePayments to fetch.
     */
    orderBy?: FeePaymentOrderByWithRelationInput | FeePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeePayments.
     */
    cursor?: FeePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeePayments.
     */
    skip?: number
    distinct?: FeePaymentScalarFieldEnum | FeePaymentScalarFieldEnum[]
  }

  /**
   * FeePayment create
   */
  export type FeePaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeePayment
     */
    omit?: FeePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a FeePayment.
     */
    data: XOR<FeePaymentCreateInput, FeePaymentUncheckedCreateInput>
  }

  /**
   * FeePayment createMany
   */
  export type FeePaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeePayments.
     */
    data: FeePaymentCreateManyInput | FeePaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeePayment createManyAndReturn
   */
  export type FeePaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeePayment
     */
    omit?: FeePaymentOmit<ExtArgs> | null
    /**
     * The data used to create many FeePayments.
     */
    data: FeePaymentCreateManyInput | FeePaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeePayment update
   */
  export type FeePaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeePayment
     */
    omit?: FeePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a FeePayment.
     */
    data: XOR<FeePaymentUpdateInput, FeePaymentUncheckedUpdateInput>
    /**
     * Choose, which FeePayment to update.
     */
    where: FeePaymentWhereUniqueInput
  }

  /**
   * FeePayment updateMany
   */
  export type FeePaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeePayments.
     */
    data: XOR<FeePaymentUpdateManyMutationInput, FeePaymentUncheckedUpdateManyInput>
    /**
     * Filter which FeePayments to update
     */
    where?: FeePaymentWhereInput
    /**
     * Limit how many FeePayments to update.
     */
    limit?: number
  }

  /**
   * FeePayment updateManyAndReturn
   */
  export type FeePaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeePayment
     */
    omit?: FeePaymentOmit<ExtArgs> | null
    /**
     * The data used to update FeePayments.
     */
    data: XOR<FeePaymentUpdateManyMutationInput, FeePaymentUncheckedUpdateManyInput>
    /**
     * Filter which FeePayments to update
     */
    where?: FeePaymentWhereInput
    /**
     * Limit how many FeePayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeePayment upsert
   */
  export type FeePaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeePayment
     */
    omit?: FeePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the FeePayment to update in case it exists.
     */
    where: FeePaymentWhereUniqueInput
    /**
     * In case the FeePayment found by the `where` argument doesn't exist, create a new FeePayment with this data.
     */
    create: XOR<FeePaymentCreateInput, FeePaymentUncheckedCreateInput>
    /**
     * In case the FeePayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeePaymentUpdateInput, FeePaymentUncheckedUpdateInput>
  }

  /**
   * FeePayment delete
   */
  export type FeePaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeePayment
     */
    omit?: FeePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * Filter which FeePayment to delete.
     */
    where: FeePaymentWhereUniqueInput
  }

  /**
   * FeePayment deleteMany
   */
  export type FeePaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeePayments to delete
     */
    where?: FeePaymentWhereInput
    /**
     * Limit how many FeePayments to delete.
     */
    limit?: number
  }

  /**
   * FeePayment without action
   */
  export type FeePaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeePayment
     */
    omit?: FeePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
  }


  /**
   * Model ScheduledJob
   */

  export type AggregateScheduledJob = {
    _count: ScheduledJobCountAggregateOutputType | null
    _min: ScheduledJobMinAggregateOutputType | null
    _max: ScheduledJobMaxAggregateOutputType | null
  }

  export type ScheduledJobMinAggregateOutputType = {
    id: string | null
    type: $Enums.scheduledJobType | null
    scheduledAt: Date | null
    status: string | null
    error: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    organizationId: string | null
  }

  export type ScheduledJobMaxAggregateOutputType = {
    id: string | null
    type: $Enums.scheduledJobType | null
    scheduledAt: Date | null
    status: string | null
    error: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    organizationId: string | null
  }

  export type ScheduledJobCountAggregateOutputType = {
    id: number
    data: number
    type: number
    scheduledAt: number
    channels: number
    status: number
    result: number
    error: number
    createdBy: number
    createdAt: number
    updatedAt: number
    organizationId: number
    _all: number
  }


  export type ScheduledJobMinAggregateInputType = {
    id?: true
    type?: true
    scheduledAt?: true
    status?: true
    error?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    organizationId?: true
  }

  export type ScheduledJobMaxAggregateInputType = {
    id?: true
    type?: true
    scheduledAt?: true
    status?: true
    error?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    organizationId?: true
  }

  export type ScheduledJobCountAggregateInputType = {
    id?: true
    data?: true
    type?: true
    scheduledAt?: true
    channels?: true
    status?: true
    result?: true
    error?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    organizationId?: true
    _all?: true
  }

  export type ScheduledJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledJob to aggregate.
     */
    where?: ScheduledJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledJobs to fetch.
     */
    orderBy?: ScheduledJobOrderByWithRelationInput | ScheduledJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduledJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScheduledJobs
    **/
    _count?: true | ScheduledJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduledJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduledJobMaxAggregateInputType
  }

  export type GetScheduledJobAggregateType<T extends ScheduledJobAggregateArgs> = {
        [P in keyof T & keyof AggregateScheduledJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScheduledJob[P]>
      : GetScalarType<T[P], AggregateScheduledJob[P]>
  }




  export type ScheduledJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledJobWhereInput
    orderBy?: ScheduledJobOrderByWithAggregationInput | ScheduledJobOrderByWithAggregationInput[]
    by: ScheduledJobScalarFieldEnum[] | ScheduledJobScalarFieldEnum
    having?: ScheduledJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduledJobCountAggregateInputType | true
    _min?: ScheduledJobMinAggregateInputType
    _max?: ScheduledJobMaxAggregateInputType
  }

  export type ScheduledJobGroupByOutputType = {
    id: string
    data: JsonValue
    type: $Enums.scheduledJobType
    scheduledAt: Date
    channels: $Enums.NotificationChannel[]
    status: string
    result: JsonValue | null
    error: string | null
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    organizationId: string
    _count: ScheduledJobCountAggregateOutputType | null
    _min: ScheduledJobMinAggregateOutputType | null
    _max: ScheduledJobMaxAggregateOutputType | null
  }

  type GetScheduledJobGroupByPayload<T extends ScheduledJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduledJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduledJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduledJobGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduledJobGroupByOutputType[P]>
        }
      >
    >


  export type ScheduledJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    data?: boolean
    type?: boolean
    scheduledAt?: boolean
    channels?: boolean
    status?: boolean
    result?: boolean
    error?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizationId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduledJob"]>

  export type ScheduledJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    data?: boolean
    type?: boolean
    scheduledAt?: boolean
    channels?: boolean
    status?: boolean
    result?: boolean
    error?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizationId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduledJob"]>

  export type ScheduledJobSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    data?: boolean
    type?: boolean
    scheduledAt?: boolean
    channels?: boolean
    status?: boolean
    result?: boolean
    error?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizationId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduledJob"]>

  export type ScheduledJobSelectScalar = {
    id?: boolean
    data?: boolean
    type?: boolean
    scheduledAt?: boolean
    channels?: boolean
    status?: boolean
    result?: boolean
    error?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizationId?: boolean
  }

  export type ScheduledJobOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "data" | "type" | "scheduledAt" | "channels" | "status" | "result" | "error" | "createdBy" | "createdAt" | "updatedAt" | "organizationId", ExtArgs["result"]["scheduledJob"]>
  export type ScheduledJobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type ScheduledJobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type ScheduledJobIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $ScheduledJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScheduledJob"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      data: Prisma.JsonValue
      type: $Enums.scheduledJobType
      scheduledAt: Date
      channels: $Enums.NotificationChannel[]
      status: string
      result: Prisma.JsonValue | null
      error: string | null
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
      organizationId: string
    }, ExtArgs["result"]["scheduledJob"]>
    composites: {}
  }

  type ScheduledJobGetPayload<S extends boolean | null | undefined | ScheduledJobDefaultArgs> = $Result.GetResult<Prisma.$ScheduledJobPayload, S>

  type ScheduledJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScheduledJobFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScheduledJobCountAggregateInputType | true
    }

  export interface ScheduledJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScheduledJob'], meta: { name: 'ScheduledJob' } }
    /**
     * Find zero or one ScheduledJob that matches the filter.
     * @param {ScheduledJobFindUniqueArgs} args - Arguments to find a ScheduledJob
     * @example
     * // Get one ScheduledJob
     * const scheduledJob = await prisma.scheduledJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduledJobFindUniqueArgs>(args: SelectSubset<T, ScheduledJobFindUniqueArgs<ExtArgs>>): Prisma__ScheduledJobClient<$Result.GetResult<Prisma.$ScheduledJobPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScheduledJob that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScheduledJobFindUniqueOrThrowArgs} args - Arguments to find a ScheduledJob
     * @example
     * // Get one ScheduledJob
     * const scheduledJob = await prisma.scheduledJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduledJobFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduledJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduledJobClient<$Result.GetResult<Prisma.$ScheduledJobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduledJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledJobFindFirstArgs} args - Arguments to find a ScheduledJob
     * @example
     * // Get one ScheduledJob
     * const scheduledJob = await prisma.scheduledJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduledJobFindFirstArgs>(args?: SelectSubset<T, ScheduledJobFindFirstArgs<ExtArgs>>): Prisma__ScheduledJobClient<$Result.GetResult<Prisma.$ScheduledJobPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduledJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledJobFindFirstOrThrowArgs} args - Arguments to find a ScheduledJob
     * @example
     * // Get one ScheduledJob
     * const scheduledJob = await prisma.scheduledJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduledJobFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduledJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduledJobClient<$Result.GetResult<Prisma.$ScheduledJobPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScheduledJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScheduledJobs
     * const scheduledJobs = await prisma.scheduledJob.findMany()
     * 
     * // Get first 10 ScheduledJobs
     * const scheduledJobs = await prisma.scheduledJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduledJobWithIdOnly = await prisma.scheduledJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduledJobFindManyArgs>(args?: SelectSubset<T, ScheduledJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledJobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScheduledJob.
     * @param {ScheduledJobCreateArgs} args - Arguments to create a ScheduledJob.
     * @example
     * // Create one ScheduledJob
     * const ScheduledJob = await prisma.scheduledJob.create({
     *   data: {
     *     // ... data to create a ScheduledJob
     *   }
     * })
     * 
     */
    create<T extends ScheduledJobCreateArgs>(args: SelectSubset<T, ScheduledJobCreateArgs<ExtArgs>>): Prisma__ScheduledJobClient<$Result.GetResult<Prisma.$ScheduledJobPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScheduledJobs.
     * @param {ScheduledJobCreateManyArgs} args - Arguments to create many ScheduledJobs.
     * @example
     * // Create many ScheduledJobs
     * const scheduledJob = await prisma.scheduledJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduledJobCreateManyArgs>(args?: SelectSubset<T, ScheduledJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScheduledJobs and returns the data saved in the database.
     * @param {ScheduledJobCreateManyAndReturnArgs} args - Arguments to create many ScheduledJobs.
     * @example
     * // Create many ScheduledJobs
     * const scheduledJob = await prisma.scheduledJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScheduledJobs and only return the `id`
     * const scheduledJobWithIdOnly = await prisma.scheduledJob.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduledJobCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduledJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledJobPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ScheduledJob.
     * @param {ScheduledJobDeleteArgs} args - Arguments to delete one ScheduledJob.
     * @example
     * // Delete one ScheduledJob
     * const ScheduledJob = await prisma.scheduledJob.delete({
     *   where: {
     *     // ... filter to delete one ScheduledJob
     *   }
     * })
     * 
     */
    delete<T extends ScheduledJobDeleteArgs>(args: SelectSubset<T, ScheduledJobDeleteArgs<ExtArgs>>): Prisma__ScheduledJobClient<$Result.GetResult<Prisma.$ScheduledJobPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScheduledJob.
     * @param {ScheduledJobUpdateArgs} args - Arguments to update one ScheduledJob.
     * @example
     * // Update one ScheduledJob
     * const scheduledJob = await prisma.scheduledJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduledJobUpdateArgs>(args: SelectSubset<T, ScheduledJobUpdateArgs<ExtArgs>>): Prisma__ScheduledJobClient<$Result.GetResult<Prisma.$ScheduledJobPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScheduledJobs.
     * @param {ScheduledJobDeleteManyArgs} args - Arguments to filter ScheduledJobs to delete.
     * @example
     * // Delete a few ScheduledJobs
     * const { count } = await prisma.scheduledJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduledJobDeleteManyArgs>(args?: SelectSubset<T, ScheduledJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduledJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScheduledJobs
     * const scheduledJob = await prisma.scheduledJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduledJobUpdateManyArgs>(args: SelectSubset<T, ScheduledJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduledJobs and returns the data updated in the database.
     * @param {ScheduledJobUpdateManyAndReturnArgs} args - Arguments to update many ScheduledJobs.
     * @example
     * // Update many ScheduledJobs
     * const scheduledJob = await prisma.scheduledJob.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ScheduledJobs and only return the `id`
     * const scheduledJobWithIdOnly = await prisma.scheduledJob.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScheduledJobUpdateManyAndReturnArgs>(args: SelectSubset<T, ScheduledJobUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledJobPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ScheduledJob.
     * @param {ScheduledJobUpsertArgs} args - Arguments to update or create a ScheduledJob.
     * @example
     * // Update or create a ScheduledJob
     * const scheduledJob = await prisma.scheduledJob.upsert({
     *   create: {
     *     // ... data to create a ScheduledJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScheduledJob we want to update
     *   }
     * })
     */
    upsert<T extends ScheduledJobUpsertArgs>(args: SelectSubset<T, ScheduledJobUpsertArgs<ExtArgs>>): Prisma__ScheduledJobClient<$Result.GetResult<Prisma.$ScheduledJobPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ScheduledJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledJobCountArgs} args - Arguments to filter ScheduledJobs to count.
     * @example
     * // Count the number of ScheduledJobs
     * const count = await prisma.scheduledJob.count({
     *   where: {
     *     // ... the filter for the ScheduledJobs we want to count
     *   }
     * })
    **/
    count<T extends ScheduledJobCountArgs>(
      args?: Subset<T, ScheduledJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduledJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScheduledJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduledJobAggregateArgs>(args: Subset<T, ScheduledJobAggregateArgs>): Prisma.PrismaPromise<GetScheduledJobAggregateType<T>>

    /**
     * Group by ScheduledJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduledJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduledJobGroupByArgs['orderBy'] }
        : { orderBy?: ScheduledJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduledJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduledJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScheduledJob model
   */
  readonly fields: ScheduledJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScheduledJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduledJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScheduledJob model
   */
  interface ScheduledJobFieldRefs {
    readonly id: FieldRef<"ScheduledJob", 'String'>
    readonly data: FieldRef<"ScheduledJob", 'Json'>
    readonly type: FieldRef<"ScheduledJob", 'scheduledJobType'>
    readonly scheduledAt: FieldRef<"ScheduledJob", 'DateTime'>
    readonly channels: FieldRef<"ScheduledJob", 'NotificationChannel[]'>
    readonly status: FieldRef<"ScheduledJob", 'String'>
    readonly result: FieldRef<"ScheduledJob", 'Json'>
    readonly error: FieldRef<"ScheduledJob", 'String'>
    readonly createdBy: FieldRef<"ScheduledJob", 'String'>
    readonly createdAt: FieldRef<"ScheduledJob", 'DateTime'>
    readonly updatedAt: FieldRef<"ScheduledJob", 'DateTime'>
    readonly organizationId: FieldRef<"ScheduledJob", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ScheduledJob findUnique
   */
  export type ScheduledJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledJob
     */
    select?: ScheduledJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledJob
     */
    omit?: ScheduledJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledJobInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledJob to fetch.
     */
    where: ScheduledJobWhereUniqueInput
  }

  /**
   * ScheduledJob findUniqueOrThrow
   */
  export type ScheduledJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledJob
     */
    select?: ScheduledJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledJob
     */
    omit?: ScheduledJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledJobInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledJob to fetch.
     */
    where: ScheduledJobWhereUniqueInput
  }

  /**
   * ScheduledJob findFirst
   */
  export type ScheduledJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledJob
     */
    select?: ScheduledJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledJob
     */
    omit?: ScheduledJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledJobInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledJob to fetch.
     */
    where?: ScheduledJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledJobs to fetch.
     */
    orderBy?: ScheduledJobOrderByWithRelationInput | ScheduledJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledJobs.
     */
    cursor?: ScheduledJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledJobs.
     */
    distinct?: ScheduledJobScalarFieldEnum | ScheduledJobScalarFieldEnum[]
  }

  /**
   * ScheduledJob findFirstOrThrow
   */
  export type ScheduledJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledJob
     */
    select?: ScheduledJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledJob
     */
    omit?: ScheduledJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledJobInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledJob to fetch.
     */
    where?: ScheduledJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledJobs to fetch.
     */
    orderBy?: ScheduledJobOrderByWithRelationInput | ScheduledJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledJobs.
     */
    cursor?: ScheduledJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledJobs.
     */
    distinct?: ScheduledJobScalarFieldEnum | ScheduledJobScalarFieldEnum[]
  }

  /**
   * ScheduledJob findMany
   */
  export type ScheduledJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledJob
     */
    select?: ScheduledJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledJob
     */
    omit?: ScheduledJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledJobInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledJobs to fetch.
     */
    where?: ScheduledJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledJobs to fetch.
     */
    orderBy?: ScheduledJobOrderByWithRelationInput | ScheduledJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScheduledJobs.
     */
    cursor?: ScheduledJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledJobs.
     */
    skip?: number
    distinct?: ScheduledJobScalarFieldEnum | ScheduledJobScalarFieldEnum[]
  }

  /**
   * ScheduledJob create
   */
  export type ScheduledJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledJob
     */
    select?: ScheduledJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledJob
     */
    omit?: ScheduledJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledJobInclude<ExtArgs> | null
    /**
     * The data needed to create a ScheduledJob.
     */
    data: XOR<ScheduledJobCreateInput, ScheduledJobUncheckedCreateInput>
  }

  /**
   * ScheduledJob createMany
   */
  export type ScheduledJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScheduledJobs.
     */
    data: ScheduledJobCreateManyInput | ScheduledJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScheduledJob createManyAndReturn
   */
  export type ScheduledJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledJob
     */
    select?: ScheduledJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledJob
     */
    omit?: ScheduledJobOmit<ExtArgs> | null
    /**
     * The data used to create many ScheduledJobs.
     */
    data: ScheduledJobCreateManyInput | ScheduledJobCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledJobIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduledJob update
   */
  export type ScheduledJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledJob
     */
    select?: ScheduledJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledJob
     */
    omit?: ScheduledJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledJobInclude<ExtArgs> | null
    /**
     * The data needed to update a ScheduledJob.
     */
    data: XOR<ScheduledJobUpdateInput, ScheduledJobUncheckedUpdateInput>
    /**
     * Choose, which ScheduledJob to update.
     */
    where: ScheduledJobWhereUniqueInput
  }

  /**
   * ScheduledJob updateMany
   */
  export type ScheduledJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScheduledJobs.
     */
    data: XOR<ScheduledJobUpdateManyMutationInput, ScheduledJobUncheckedUpdateManyInput>
    /**
     * Filter which ScheduledJobs to update
     */
    where?: ScheduledJobWhereInput
    /**
     * Limit how many ScheduledJobs to update.
     */
    limit?: number
  }

  /**
   * ScheduledJob updateManyAndReturn
   */
  export type ScheduledJobUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledJob
     */
    select?: ScheduledJobSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledJob
     */
    omit?: ScheduledJobOmit<ExtArgs> | null
    /**
     * The data used to update ScheduledJobs.
     */
    data: XOR<ScheduledJobUpdateManyMutationInput, ScheduledJobUncheckedUpdateManyInput>
    /**
     * Filter which ScheduledJobs to update
     */
    where?: ScheduledJobWhereInput
    /**
     * Limit how many ScheduledJobs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledJobIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduledJob upsert
   */
  export type ScheduledJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledJob
     */
    select?: ScheduledJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledJob
     */
    omit?: ScheduledJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledJobInclude<ExtArgs> | null
    /**
     * The filter to search for the ScheduledJob to update in case it exists.
     */
    where: ScheduledJobWhereUniqueInput
    /**
     * In case the ScheduledJob found by the `where` argument doesn't exist, create a new ScheduledJob with this data.
     */
    create: XOR<ScheduledJobCreateInput, ScheduledJobUncheckedCreateInput>
    /**
     * In case the ScheduledJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduledJobUpdateInput, ScheduledJobUncheckedUpdateInput>
  }

  /**
   * ScheduledJob delete
   */
  export type ScheduledJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledJob
     */
    select?: ScheduledJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledJob
     */
    omit?: ScheduledJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledJobInclude<ExtArgs> | null
    /**
     * Filter which ScheduledJob to delete.
     */
    where: ScheduledJobWhereUniqueInput
  }

  /**
   * ScheduledJob deleteMany
   */
  export type ScheduledJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledJobs to delete
     */
    where?: ScheduledJobWhereInput
    /**
     * Limit how many ScheduledJobs to delete.
     */
    limit?: number
  }

  /**
   * ScheduledJob without action
   */
  export type ScheduledJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledJob
     */
    select?: ScheduledJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledJob
     */
    omit?: ScheduledJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledJobInclude<ExtArgs> | null
  }


  /**
   * Model FeeCategory
   */

  export type AggregateFeeCategory = {
    _count: FeeCategoryCountAggregateOutputType | null
    _min: FeeCategoryMinAggregateOutputType | null
    _max: FeeCategoryMaxAggregateOutputType | null
  }

  export type FeeCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    organizationId: string | null
  }

  export type FeeCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    organizationId: string | null
  }

  export type FeeCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    organizationId: number
    _all: number
  }


  export type FeeCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    organizationId?: true
  }

  export type FeeCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    organizationId?: true
  }

  export type FeeCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    organizationId?: true
    _all?: true
  }

  export type FeeCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeeCategory to aggregate.
     */
    where?: FeeCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeCategories to fetch.
     */
    orderBy?: FeeCategoryOrderByWithRelationInput | FeeCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeeCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeeCategories
    **/
    _count?: true | FeeCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeeCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeeCategoryMaxAggregateInputType
  }

  export type GetFeeCategoryAggregateType<T extends FeeCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateFeeCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeeCategory[P]>
      : GetScalarType<T[P], AggregateFeeCategory[P]>
  }




  export type FeeCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeCategoryWhereInput
    orderBy?: FeeCategoryOrderByWithAggregationInput | FeeCategoryOrderByWithAggregationInput[]
    by: FeeCategoryScalarFieldEnum[] | FeeCategoryScalarFieldEnum
    having?: FeeCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeeCategoryCountAggregateInputType | true
    _min?: FeeCategoryMinAggregateInputType
    _max?: FeeCategoryMaxAggregateInputType
  }

  export type FeeCategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    organizationId: string
    _count: FeeCategoryCountAggregateOutputType | null
    _min: FeeCategoryMinAggregateOutputType | null
    _max: FeeCategoryMaxAggregateOutputType | null
  }

  type GetFeeCategoryGroupByPayload<T extends FeeCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeeCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeeCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeeCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], FeeCategoryGroupByOutputType[P]>
        }
      >
    >


  export type FeeCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizationId?: boolean
    fees?: boolean | FeeCategory$feesArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    _count?: boolean | FeeCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feeCategory"]>

  export type FeeCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizationId?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feeCategory"]>

  export type FeeCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizationId?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feeCategory"]>

  export type FeeCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizationId?: boolean
  }

  export type FeeCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt" | "organizationId", ExtArgs["result"]["feeCategory"]>
  export type FeeCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fees?: boolean | FeeCategory$feesArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    _count?: boolean | FeeCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FeeCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type FeeCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $FeeCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeeCategory"
    objects: {
      fees: Prisma.$FeePayload<ExtArgs>[]
      Organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
      organizationId: string
    }, ExtArgs["result"]["feeCategory"]>
    composites: {}
  }

  type FeeCategoryGetPayload<S extends boolean | null | undefined | FeeCategoryDefaultArgs> = $Result.GetResult<Prisma.$FeeCategoryPayload, S>

  type FeeCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeeCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeeCategoryCountAggregateInputType | true
    }

  export interface FeeCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeeCategory'], meta: { name: 'FeeCategory' } }
    /**
     * Find zero or one FeeCategory that matches the filter.
     * @param {FeeCategoryFindUniqueArgs} args - Arguments to find a FeeCategory
     * @example
     * // Get one FeeCategory
     * const feeCategory = await prisma.feeCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeeCategoryFindUniqueArgs>(args: SelectSubset<T, FeeCategoryFindUniqueArgs<ExtArgs>>): Prisma__FeeCategoryClient<$Result.GetResult<Prisma.$FeeCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeeCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeeCategoryFindUniqueOrThrowArgs} args - Arguments to find a FeeCategory
     * @example
     * // Get one FeeCategory
     * const feeCategory = await prisma.feeCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeeCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, FeeCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeeCategoryClient<$Result.GetResult<Prisma.$FeeCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeeCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeCategoryFindFirstArgs} args - Arguments to find a FeeCategory
     * @example
     * // Get one FeeCategory
     * const feeCategory = await prisma.feeCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeeCategoryFindFirstArgs>(args?: SelectSubset<T, FeeCategoryFindFirstArgs<ExtArgs>>): Prisma__FeeCategoryClient<$Result.GetResult<Prisma.$FeeCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeeCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeCategoryFindFirstOrThrowArgs} args - Arguments to find a FeeCategory
     * @example
     * // Get one FeeCategory
     * const feeCategory = await prisma.feeCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeeCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, FeeCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeeCategoryClient<$Result.GetResult<Prisma.$FeeCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeeCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeeCategories
     * const feeCategories = await prisma.feeCategory.findMany()
     * 
     * // Get first 10 FeeCategories
     * const feeCategories = await prisma.feeCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feeCategoryWithIdOnly = await prisma.feeCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeeCategoryFindManyArgs>(args?: SelectSubset<T, FeeCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeeCategory.
     * @param {FeeCategoryCreateArgs} args - Arguments to create a FeeCategory.
     * @example
     * // Create one FeeCategory
     * const FeeCategory = await prisma.feeCategory.create({
     *   data: {
     *     // ... data to create a FeeCategory
     *   }
     * })
     * 
     */
    create<T extends FeeCategoryCreateArgs>(args: SelectSubset<T, FeeCategoryCreateArgs<ExtArgs>>): Prisma__FeeCategoryClient<$Result.GetResult<Prisma.$FeeCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeeCategories.
     * @param {FeeCategoryCreateManyArgs} args - Arguments to create many FeeCategories.
     * @example
     * // Create many FeeCategories
     * const feeCategory = await prisma.feeCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeeCategoryCreateManyArgs>(args?: SelectSubset<T, FeeCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeeCategories and returns the data saved in the database.
     * @param {FeeCategoryCreateManyAndReturnArgs} args - Arguments to create many FeeCategories.
     * @example
     * // Create many FeeCategories
     * const feeCategory = await prisma.feeCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeeCategories and only return the `id`
     * const feeCategoryWithIdOnly = await prisma.feeCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeeCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, FeeCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeeCategory.
     * @param {FeeCategoryDeleteArgs} args - Arguments to delete one FeeCategory.
     * @example
     * // Delete one FeeCategory
     * const FeeCategory = await prisma.feeCategory.delete({
     *   where: {
     *     // ... filter to delete one FeeCategory
     *   }
     * })
     * 
     */
    delete<T extends FeeCategoryDeleteArgs>(args: SelectSubset<T, FeeCategoryDeleteArgs<ExtArgs>>): Prisma__FeeCategoryClient<$Result.GetResult<Prisma.$FeeCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeeCategory.
     * @param {FeeCategoryUpdateArgs} args - Arguments to update one FeeCategory.
     * @example
     * // Update one FeeCategory
     * const feeCategory = await prisma.feeCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeeCategoryUpdateArgs>(args: SelectSubset<T, FeeCategoryUpdateArgs<ExtArgs>>): Prisma__FeeCategoryClient<$Result.GetResult<Prisma.$FeeCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeeCategories.
     * @param {FeeCategoryDeleteManyArgs} args - Arguments to filter FeeCategories to delete.
     * @example
     * // Delete a few FeeCategories
     * const { count } = await prisma.feeCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeeCategoryDeleteManyArgs>(args?: SelectSubset<T, FeeCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeeCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeeCategories
     * const feeCategory = await prisma.feeCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeeCategoryUpdateManyArgs>(args: SelectSubset<T, FeeCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeeCategories and returns the data updated in the database.
     * @param {FeeCategoryUpdateManyAndReturnArgs} args - Arguments to update many FeeCategories.
     * @example
     * // Update many FeeCategories
     * const feeCategory = await prisma.feeCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeeCategories and only return the `id`
     * const feeCategoryWithIdOnly = await prisma.feeCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeeCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, FeeCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeeCategory.
     * @param {FeeCategoryUpsertArgs} args - Arguments to update or create a FeeCategory.
     * @example
     * // Update or create a FeeCategory
     * const feeCategory = await prisma.feeCategory.upsert({
     *   create: {
     *     // ... data to create a FeeCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeeCategory we want to update
     *   }
     * })
     */
    upsert<T extends FeeCategoryUpsertArgs>(args: SelectSubset<T, FeeCategoryUpsertArgs<ExtArgs>>): Prisma__FeeCategoryClient<$Result.GetResult<Prisma.$FeeCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeeCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeCategoryCountArgs} args - Arguments to filter FeeCategories to count.
     * @example
     * // Count the number of FeeCategories
     * const count = await prisma.feeCategory.count({
     *   where: {
     *     // ... the filter for the FeeCategories we want to count
     *   }
     * })
    **/
    count<T extends FeeCategoryCountArgs>(
      args?: Subset<T, FeeCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeeCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeeCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeeCategoryAggregateArgs>(args: Subset<T, FeeCategoryAggregateArgs>): Prisma.PrismaPromise<GetFeeCategoryAggregateType<T>>

    /**
     * Group by FeeCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeeCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeeCategoryGroupByArgs['orderBy'] }
        : { orderBy?: FeeCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeeCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeeCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeeCategory model
   */
  readonly fields: FeeCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeeCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeeCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fees<T extends FeeCategory$feesArgs<ExtArgs> = {}>(args?: Subset<T, FeeCategory$feesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeeCategory model
   */
  interface FeeCategoryFieldRefs {
    readonly id: FieldRef<"FeeCategory", 'String'>
    readonly name: FieldRef<"FeeCategory", 'String'>
    readonly description: FieldRef<"FeeCategory", 'String'>
    readonly createdAt: FieldRef<"FeeCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"FeeCategory", 'DateTime'>
    readonly organizationId: FieldRef<"FeeCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FeeCategory findUnique
   */
  export type FeeCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeCategory
     */
    select?: FeeCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeCategory
     */
    omit?: FeeCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeCategoryInclude<ExtArgs> | null
    /**
     * Filter, which FeeCategory to fetch.
     */
    where: FeeCategoryWhereUniqueInput
  }

  /**
   * FeeCategory findUniqueOrThrow
   */
  export type FeeCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeCategory
     */
    select?: FeeCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeCategory
     */
    omit?: FeeCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeCategoryInclude<ExtArgs> | null
    /**
     * Filter, which FeeCategory to fetch.
     */
    where: FeeCategoryWhereUniqueInput
  }

  /**
   * FeeCategory findFirst
   */
  export type FeeCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeCategory
     */
    select?: FeeCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeCategory
     */
    omit?: FeeCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeCategoryInclude<ExtArgs> | null
    /**
     * Filter, which FeeCategory to fetch.
     */
    where?: FeeCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeCategories to fetch.
     */
    orderBy?: FeeCategoryOrderByWithRelationInput | FeeCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeeCategories.
     */
    cursor?: FeeCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeeCategories.
     */
    distinct?: FeeCategoryScalarFieldEnum | FeeCategoryScalarFieldEnum[]
  }

  /**
   * FeeCategory findFirstOrThrow
   */
  export type FeeCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeCategory
     */
    select?: FeeCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeCategory
     */
    omit?: FeeCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeCategoryInclude<ExtArgs> | null
    /**
     * Filter, which FeeCategory to fetch.
     */
    where?: FeeCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeCategories to fetch.
     */
    orderBy?: FeeCategoryOrderByWithRelationInput | FeeCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeeCategories.
     */
    cursor?: FeeCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeeCategories.
     */
    distinct?: FeeCategoryScalarFieldEnum | FeeCategoryScalarFieldEnum[]
  }

  /**
   * FeeCategory findMany
   */
  export type FeeCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeCategory
     */
    select?: FeeCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeCategory
     */
    omit?: FeeCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeCategoryInclude<ExtArgs> | null
    /**
     * Filter, which FeeCategories to fetch.
     */
    where?: FeeCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeCategories to fetch.
     */
    orderBy?: FeeCategoryOrderByWithRelationInput | FeeCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeeCategories.
     */
    cursor?: FeeCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeCategories.
     */
    skip?: number
    distinct?: FeeCategoryScalarFieldEnum | FeeCategoryScalarFieldEnum[]
  }

  /**
   * FeeCategory create
   */
  export type FeeCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeCategory
     */
    select?: FeeCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeCategory
     */
    omit?: FeeCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a FeeCategory.
     */
    data: XOR<FeeCategoryCreateInput, FeeCategoryUncheckedCreateInput>
  }

  /**
   * FeeCategory createMany
   */
  export type FeeCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeeCategories.
     */
    data: FeeCategoryCreateManyInput | FeeCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeeCategory createManyAndReturn
   */
  export type FeeCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeCategory
     */
    select?: FeeCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeeCategory
     */
    omit?: FeeCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many FeeCategories.
     */
    data: FeeCategoryCreateManyInput | FeeCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeeCategory update
   */
  export type FeeCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeCategory
     */
    select?: FeeCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeCategory
     */
    omit?: FeeCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a FeeCategory.
     */
    data: XOR<FeeCategoryUpdateInput, FeeCategoryUncheckedUpdateInput>
    /**
     * Choose, which FeeCategory to update.
     */
    where: FeeCategoryWhereUniqueInput
  }

  /**
   * FeeCategory updateMany
   */
  export type FeeCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeeCategories.
     */
    data: XOR<FeeCategoryUpdateManyMutationInput, FeeCategoryUncheckedUpdateManyInput>
    /**
     * Filter which FeeCategories to update
     */
    where?: FeeCategoryWhereInput
    /**
     * Limit how many FeeCategories to update.
     */
    limit?: number
  }

  /**
   * FeeCategory updateManyAndReturn
   */
  export type FeeCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeCategory
     */
    select?: FeeCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeeCategory
     */
    omit?: FeeCategoryOmit<ExtArgs> | null
    /**
     * The data used to update FeeCategories.
     */
    data: XOR<FeeCategoryUpdateManyMutationInput, FeeCategoryUncheckedUpdateManyInput>
    /**
     * Filter which FeeCategories to update
     */
    where?: FeeCategoryWhereInput
    /**
     * Limit how many FeeCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeeCategory upsert
   */
  export type FeeCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeCategory
     */
    select?: FeeCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeCategory
     */
    omit?: FeeCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the FeeCategory to update in case it exists.
     */
    where: FeeCategoryWhereUniqueInput
    /**
     * In case the FeeCategory found by the `where` argument doesn't exist, create a new FeeCategory with this data.
     */
    create: XOR<FeeCategoryCreateInput, FeeCategoryUncheckedCreateInput>
    /**
     * In case the FeeCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeeCategoryUpdateInput, FeeCategoryUncheckedUpdateInput>
  }

  /**
   * FeeCategory delete
   */
  export type FeeCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeCategory
     */
    select?: FeeCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeCategory
     */
    omit?: FeeCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeCategoryInclude<ExtArgs> | null
    /**
     * Filter which FeeCategory to delete.
     */
    where: FeeCategoryWhereUniqueInput
  }

  /**
   * FeeCategory deleteMany
   */
  export type FeeCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeeCategories to delete
     */
    where?: FeeCategoryWhereInput
    /**
     * Limit how many FeeCategories to delete.
     */
    limit?: number
  }

  /**
   * FeeCategory.fees
   */
  export type FeeCategory$feesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fee
     */
    omit?: FeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeInclude<ExtArgs> | null
    where?: FeeWhereInput
    orderBy?: FeeOrderByWithRelationInput | FeeOrderByWithRelationInput[]
    cursor?: FeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeeScalarFieldEnum | FeeScalarFieldEnum[]
  }

  /**
   * FeeCategory without action
   */
  export type FeeCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeCategory
     */
    select?: FeeCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeCategory
     */
    omit?: FeeCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeCategoryInclude<ExtArgs> | null
  }


  /**
   * Model AcademicCalendar
   */

  export type AggregateAcademicCalendar = {
    _count: AcademicCalendarCountAggregateOutputType | null
    _min: AcademicCalendarMinAggregateOutputType | null
    _max: AcademicCalendarMaxAggregateOutputType | null
  }

  export type AcademicCalendarMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    type: $Enums.CalendarEventType | null
    reason: string | null
    isRecurring: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    academicYearId: string | null
  }

  export type AcademicCalendarMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    type: $Enums.CalendarEventType | null
    reason: string | null
    isRecurring: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    academicYearId: string | null
  }

  export type AcademicCalendarCountAggregateOutputType = {
    id: number
    organizationId: number
    name: number
    startDate: number
    endDate: number
    type: number
    reason: number
    isRecurring: number
    createdBy: number
    createdAt: number
    updatedAt: number
    academicYearId: number
    _all: number
  }


  export type AcademicCalendarMinAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    startDate?: true
    endDate?: true
    type?: true
    reason?: true
    isRecurring?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    academicYearId?: true
  }

  export type AcademicCalendarMaxAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    startDate?: true
    endDate?: true
    type?: true
    reason?: true
    isRecurring?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    academicYearId?: true
  }

  export type AcademicCalendarCountAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    startDate?: true
    endDate?: true
    type?: true
    reason?: true
    isRecurring?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    academicYearId?: true
    _all?: true
  }

  export type AcademicCalendarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicCalendar to aggregate.
     */
    where?: AcademicCalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicCalendars to fetch.
     */
    orderBy?: AcademicCalendarOrderByWithRelationInput | AcademicCalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcademicCalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicCalendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicCalendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AcademicCalendars
    **/
    _count?: true | AcademicCalendarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcademicCalendarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcademicCalendarMaxAggregateInputType
  }

  export type GetAcademicCalendarAggregateType<T extends AcademicCalendarAggregateArgs> = {
        [P in keyof T & keyof AggregateAcademicCalendar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademicCalendar[P]>
      : GetScalarType<T[P], AggregateAcademicCalendar[P]>
  }




  export type AcademicCalendarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicCalendarWhereInput
    orderBy?: AcademicCalendarOrderByWithAggregationInput | AcademicCalendarOrderByWithAggregationInput[]
    by: AcademicCalendarScalarFieldEnum[] | AcademicCalendarScalarFieldEnum
    having?: AcademicCalendarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcademicCalendarCountAggregateInputType | true
    _min?: AcademicCalendarMinAggregateInputType
    _max?: AcademicCalendarMaxAggregateInputType
  }

  export type AcademicCalendarGroupByOutputType = {
    id: string
    organizationId: string
    name: string
    startDate: Date
    endDate: Date
    type: $Enums.CalendarEventType
    reason: string | null
    isRecurring: boolean
    createdBy: string
    createdAt: Date
    updatedAt: Date
    academicYearId: string | null
    _count: AcademicCalendarCountAggregateOutputType | null
    _min: AcademicCalendarMinAggregateOutputType | null
    _max: AcademicCalendarMaxAggregateOutputType | null
  }

  type GetAcademicCalendarGroupByPayload<T extends AcademicCalendarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcademicCalendarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcademicCalendarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcademicCalendarGroupByOutputType[P]>
            : GetScalarType<T[P], AcademicCalendarGroupByOutputType[P]>
        }
      >
    >


  export type AcademicCalendarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    type?: boolean
    reason?: boolean
    isRecurring?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicYearId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicCalendar$academicYearArgs<ExtArgs>
  }, ExtArgs["result"]["academicCalendar"]>

  export type AcademicCalendarSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    type?: boolean
    reason?: boolean
    isRecurring?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicYearId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicCalendar$academicYearArgs<ExtArgs>
  }, ExtArgs["result"]["academicCalendar"]>

  export type AcademicCalendarSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    type?: boolean
    reason?: boolean
    isRecurring?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicYearId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicCalendar$academicYearArgs<ExtArgs>
  }, ExtArgs["result"]["academicCalendar"]>

  export type AcademicCalendarSelectScalar = {
    id?: boolean
    organizationId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    type?: boolean
    reason?: boolean
    isRecurring?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicYearId?: boolean
  }

  export type AcademicCalendarOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "name" | "startDate" | "endDate" | "type" | "reason" | "isRecurring" | "createdBy" | "createdAt" | "updatedAt" | "academicYearId", ExtArgs["result"]["academicCalendar"]>
  export type AcademicCalendarInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicCalendar$academicYearArgs<ExtArgs>
  }
  export type AcademicCalendarIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicCalendar$academicYearArgs<ExtArgs>
  }
  export type AcademicCalendarIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicCalendar$academicYearArgs<ExtArgs>
  }

  export type $AcademicCalendarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AcademicCalendar"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      academicYear: Prisma.$AcademicYearPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      name: string
      startDate: Date
      endDate: Date
      type: $Enums.CalendarEventType
      reason: string | null
      isRecurring: boolean
      createdBy: string
      createdAt: Date
      updatedAt: Date
      academicYearId: string | null
    }, ExtArgs["result"]["academicCalendar"]>
    composites: {}
  }

  type AcademicCalendarGetPayload<S extends boolean | null | undefined | AcademicCalendarDefaultArgs> = $Result.GetResult<Prisma.$AcademicCalendarPayload, S>

  type AcademicCalendarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AcademicCalendarFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AcademicCalendarCountAggregateInputType | true
    }

  export interface AcademicCalendarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AcademicCalendar'], meta: { name: 'AcademicCalendar' } }
    /**
     * Find zero or one AcademicCalendar that matches the filter.
     * @param {AcademicCalendarFindUniqueArgs} args - Arguments to find a AcademicCalendar
     * @example
     * // Get one AcademicCalendar
     * const academicCalendar = await prisma.academicCalendar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AcademicCalendarFindUniqueArgs>(args: SelectSubset<T, AcademicCalendarFindUniqueArgs<ExtArgs>>): Prisma__AcademicCalendarClient<$Result.GetResult<Prisma.$AcademicCalendarPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AcademicCalendar that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AcademicCalendarFindUniqueOrThrowArgs} args - Arguments to find a AcademicCalendar
     * @example
     * // Get one AcademicCalendar
     * const academicCalendar = await prisma.academicCalendar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AcademicCalendarFindUniqueOrThrowArgs>(args: SelectSubset<T, AcademicCalendarFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AcademicCalendarClient<$Result.GetResult<Prisma.$AcademicCalendarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicCalendar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicCalendarFindFirstArgs} args - Arguments to find a AcademicCalendar
     * @example
     * // Get one AcademicCalendar
     * const academicCalendar = await prisma.academicCalendar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AcademicCalendarFindFirstArgs>(args?: SelectSubset<T, AcademicCalendarFindFirstArgs<ExtArgs>>): Prisma__AcademicCalendarClient<$Result.GetResult<Prisma.$AcademicCalendarPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicCalendar that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicCalendarFindFirstOrThrowArgs} args - Arguments to find a AcademicCalendar
     * @example
     * // Get one AcademicCalendar
     * const academicCalendar = await prisma.academicCalendar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AcademicCalendarFindFirstOrThrowArgs>(args?: SelectSubset<T, AcademicCalendarFindFirstOrThrowArgs<ExtArgs>>): Prisma__AcademicCalendarClient<$Result.GetResult<Prisma.$AcademicCalendarPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AcademicCalendars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicCalendarFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcademicCalendars
     * const academicCalendars = await prisma.academicCalendar.findMany()
     * 
     * // Get first 10 AcademicCalendars
     * const academicCalendars = await prisma.academicCalendar.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const academicCalendarWithIdOnly = await prisma.academicCalendar.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AcademicCalendarFindManyArgs>(args?: SelectSubset<T, AcademicCalendarFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicCalendarPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AcademicCalendar.
     * @param {AcademicCalendarCreateArgs} args - Arguments to create a AcademicCalendar.
     * @example
     * // Create one AcademicCalendar
     * const AcademicCalendar = await prisma.academicCalendar.create({
     *   data: {
     *     // ... data to create a AcademicCalendar
     *   }
     * })
     * 
     */
    create<T extends AcademicCalendarCreateArgs>(args: SelectSubset<T, AcademicCalendarCreateArgs<ExtArgs>>): Prisma__AcademicCalendarClient<$Result.GetResult<Prisma.$AcademicCalendarPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AcademicCalendars.
     * @param {AcademicCalendarCreateManyArgs} args - Arguments to create many AcademicCalendars.
     * @example
     * // Create many AcademicCalendars
     * const academicCalendar = await prisma.academicCalendar.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AcademicCalendarCreateManyArgs>(args?: SelectSubset<T, AcademicCalendarCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AcademicCalendars and returns the data saved in the database.
     * @param {AcademicCalendarCreateManyAndReturnArgs} args - Arguments to create many AcademicCalendars.
     * @example
     * // Create many AcademicCalendars
     * const academicCalendar = await prisma.academicCalendar.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AcademicCalendars and only return the `id`
     * const academicCalendarWithIdOnly = await prisma.academicCalendar.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AcademicCalendarCreateManyAndReturnArgs>(args?: SelectSubset<T, AcademicCalendarCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicCalendarPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AcademicCalendar.
     * @param {AcademicCalendarDeleteArgs} args - Arguments to delete one AcademicCalendar.
     * @example
     * // Delete one AcademicCalendar
     * const AcademicCalendar = await prisma.academicCalendar.delete({
     *   where: {
     *     // ... filter to delete one AcademicCalendar
     *   }
     * })
     * 
     */
    delete<T extends AcademicCalendarDeleteArgs>(args: SelectSubset<T, AcademicCalendarDeleteArgs<ExtArgs>>): Prisma__AcademicCalendarClient<$Result.GetResult<Prisma.$AcademicCalendarPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AcademicCalendar.
     * @param {AcademicCalendarUpdateArgs} args - Arguments to update one AcademicCalendar.
     * @example
     * // Update one AcademicCalendar
     * const academicCalendar = await prisma.academicCalendar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AcademicCalendarUpdateArgs>(args: SelectSubset<T, AcademicCalendarUpdateArgs<ExtArgs>>): Prisma__AcademicCalendarClient<$Result.GetResult<Prisma.$AcademicCalendarPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AcademicCalendars.
     * @param {AcademicCalendarDeleteManyArgs} args - Arguments to filter AcademicCalendars to delete.
     * @example
     * // Delete a few AcademicCalendars
     * const { count } = await prisma.academicCalendar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AcademicCalendarDeleteManyArgs>(args?: SelectSubset<T, AcademicCalendarDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicCalendars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicCalendarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcademicCalendars
     * const academicCalendar = await prisma.academicCalendar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AcademicCalendarUpdateManyArgs>(args: SelectSubset<T, AcademicCalendarUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicCalendars and returns the data updated in the database.
     * @param {AcademicCalendarUpdateManyAndReturnArgs} args - Arguments to update many AcademicCalendars.
     * @example
     * // Update many AcademicCalendars
     * const academicCalendar = await prisma.academicCalendar.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AcademicCalendars and only return the `id`
     * const academicCalendarWithIdOnly = await prisma.academicCalendar.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AcademicCalendarUpdateManyAndReturnArgs>(args: SelectSubset<T, AcademicCalendarUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicCalendarPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AcademicCalendar.
     * @param {AcademicCalendarUpsertArgs} args - Arguments to update or create a AcademicCalendar.
     * @example
     * // Update or create a AcademicCalendar
     * const academicCalendar = await prisma.academicCalendar.upsert({
     *   create: {
     *     // ... data to create a AcademicCalendar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcademicCalendar we want to update
     *   }
     * })
     */
    upsert<T extends AcademicCalendarUpsertArgs>(args: SelectSubset<T, AcademicCalendarUpsertArgs<ExtArgs>>): Prisma__AcademicCalendarClient<$Result.GetResult<Prisma.$AcademicCalendarPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AcademicCalendars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicCalendarCountArgs} args - Arguments to filter AcademicCalendars to count.
     * @example
     * // Count the number of AcademicCalendars
     * const count = await prisma.academicCalendar.count({
     *   where: {
     *     // ... the filter for the AcademicCalendars we want to count
     *   }
     * })
    **/
    count<T extends AcademicCalendarCountArgs>(
      args?: Subset<T, AcademicCalendarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcademicCalendarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AcademicCalendar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicCalendarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcademicCalendarAggregateArgs>(args: Subset<T, AcademicCalendarAggregateArgs>): Prisma.PrismaPromise<GetAcademicCalendarAggregateType<T>>

    /**
     * Group by AcademicCalendar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicCalendarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcademicCalendarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcademicCalendarGroupByArgs['orderBy'] }
        : { orderBy?: AcademicCalendarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcademicCalendarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcademicCalendarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AcademicCalendar model
   */
  readonly fields: AcademicCalendarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcademicCalendar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcademicCalendarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    academicYear<T extends AcademicCalendar$academicYearArgs<ExtArgs> = {}>(args?: Subset<T, AcademicCalendar$academicYearArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AcademicCalendar model
   */
  interface AcademicCalendarFieldRefs {
    readonly id: FieldRef<"AcademicCalendar", 'String'>
    readonly organizationId: FieldRef<"AcademicCalendar", 'String'>
    readonly name: FieldRef<"AcademicCalendar", 'String'>
    readonly startDate: FieldRef<"AcademicCalendar", 'DateTime'>
    readonly endDate: FieldRef<"AcademicCalendar", 'DateTime'>
    readonly type: FieldRef<"AcademicCalendar", 'CalendarEventType'>
    readonly reason: FieldRef<"AcademicCalendar", 'String'>
    readonly isRecurring: FieldRef<"AcademicCalendar", 'Boolean'>
    readonly createdBy: FieldRef<"AcademicCalendar", 'String'>
    readonly createdAt: FieldRef<"AcademicCalendar", 'DateTime'>
    readonly updatedAt: FieldRef<"AcademicCalendar", 'DateTime'>
    readonly academicYearId: FieldRef<"AcademicCalendar", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AcademicCalendar findUnique
   */
  export type AcademicCalendarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCalendar
     */
    select?: AcademicCalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicCalendar
     */
    omit?: AcademicCalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCalendarInclude<ExtArgs> | null
    /**
     * Filter, which AcademicCalendar to fetch.
     */
    where: AcademicCalendarWhereUniqueInput
  }

  /**
   * AcademicCalendar findUniqueOrThrow
   */
  export type AcademicCalendarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCalendar
     */
    select?: AcademicCalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicCalendar
     */
    omit?: AcademicCalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCalendarInclude<ExtArgs> | null
    /**
     * Filter, which AcademicCalendar to fetch.
     */
    where: AcademicCalendarWhereUniqueInput
  }

  /**
   * AcademicCalendar findFirst
   */
  export type AcademicCalendarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCalendar
     */
    select?: AcademicCalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicCalendar
     */
    omit?: AcademicCalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCalendarInclude<ExtArgs> | null
    /**
     * Filter, which AcademicCalendar to fetch.
     */
    where?: AcademicCalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicCalendars to fetch.
     */
    orderBy?: AcademicCalendarOrderByWithRelationInput | AcademicCalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicCalendars.
     */
    cursor?: AcademicCalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicCalendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicCalendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicCalendars.
     */
    distinct?: AcademicCalendarScalarFieldEnum | AcademicCalendarScalarFieldEnum[]
  }

  /**
   * AcademicCalendar findFirstOrThrow
   */
  export type AcademicCalendarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCalendar
     */
    select?: AcademicCalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicCalendar
     */
    omit?: AcademicCalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCalendarInclude<ExtArgs> | null
    /**
     * Filter, which AcademicCalendar to fetch.
     */
    where?: AcademicCalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicCalendars to fetch.
     */
    orderBy?: AcademicCalendarOrderByWithRelationInput | AcademicCalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicCalendars.
     */
    cursor?: AcademicCalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicCalendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicCalendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicCalendars.
     */
    distinct?: AcademicCalendarScalarFieldEnum | AcademicCalendarScalarFieldEnum[]
  }

  /**
   * AcademicCalendar findMany
   */
  export type AcademicCalendarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCalendar
     */
    select?: AcademicCalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicCalendar
     */
    omit?: AcademicCalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCalendarInclude<ExtArgs> | null
    /**
     * Filter, which AcademicCalendars to fetch.
     */
    where?: AcademicCalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicCalendars to fetch.
     */
    orderBy?: AcademicCalendarOrderByWithRelationInput | AcademicCalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AcademicCalendars.
     */
    cursor?: AcademicCalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicCalendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicCalendars.
     */
    skip?: number
    distinct?: AcademicCalendarScalarFieldEnum | AcademicCalendarScalarFieldEnum[]
  }

  /**
   * AcademicCalendar create
   */
  export type AcademicCalendarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCalendar
     */
    select?: AcademicCalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicCalendar
     */
    omit?: AcademicCalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCalendarInclude<ExtArgs> | null
    /**
     * The data needed to create a AcademicCalendar.
     */
    data: XOR<AcademicCalendarCreateInput, AcademicCalendarUncheckedCreateInput>
  }

  /**
   * AcademicCalendar createMany
   */
  export type AcademicCalendarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AcademicCalendars.
     */
    data: AcademicCalendarCreateManyInput | AcademicCalendarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AcademicCalendar createManyAndReturn
   */
  export type AcademicCalendarCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCalendar
     */
    select?: AcademicCalendarSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicCalendar
     */
    omit?: AcademicCalendarOmit<ExtArgs> | null
    /**
     * The data used to create many AcademicCalendars.
     */
    data: AcademicCalendarCreateManyInput | AcademicCalendarCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCalendarIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AcademicCalendar update
   */
  export type AcademicCalendarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCalendar
     */
    select?: AcademicCalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicCalendar
     */
    omit?: AcademicCalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCalendarInclude<ExtArgs> | null
    /**
     * The data needed to update a AcademicCalendar.
     */
    data: XOR<AcademicCalendarUpdateInput, AcademicCalendarUncheckedUpdateInput>
    /**
     * Choose, which AcademicCalendar to update.
     */
    where: AcademicCalendarWhereUniqueInput
  }

  /**
   * AcademicCalendar updateMany
   */
  export type AcademicCalendarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AcademicCalendars.
     */
    data: XOR<AcademicCalendarUpdateManyMutationInput, AcademicCalendarUncheckedUpdateManyInput>
    /**
     * Filter which AcademicCalendars to update
     */
    where?: AcademicCalendarWhereInput
    /**
     * Limit how many AcademicCalendars to update.
     */
    limit?: number
  }

  /**
   * AcademicCalendar updateManyAndReturn
   */
  export type AcademicCalendarUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCalendar
     */
    select?: AcademicCalendarSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicCalendar
     */
    omit?: AcademicCalendarOmit<ExtArgs> | null
    /**
     * The data used to update AcademicCalendars.
     */
    data: XOR<AcademicCalendarUpdateManyMutationInput, AcademicCalendarUncheckedUpdateManyInput>
    /**
     * Filter which AcademicCalendars to update
     */
    where?: AcademicCalendarWhereInput
    /**
     * Limit how many AcademicCalendars to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCalendarIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AcademicCalendar upsert
   */
  export type AcademicCalendarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCalendar
     */
    select?: AcademicCalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicCalendar
     */
    omit?: AcademicCalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCalendarInclude<ExtArgs> | null
    /**
     * The filter to search for the AcademicCalendar to update in case it exists.
     */
    where: AcademicCalendarWhereUniqueInput
    /**
     * In case the AcademicCalendar found by the `where` argument doesn't exist, create a new AcademicCalendar with this data.
     */
    create: XOR<AcademicCalendarCreateInput, AcademicCalendarUncheckedCreateInput>
    /**
     * In case the AcademicCalendar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcademicCalendarUpdateInput, AcademicCalendarUncheckedUpdateInput>
  }

  /**
   * AcademicCalendar delete
   */
  export type AcademicCalendarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCalendar
     */
    select?: AcademicCalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicCalendar
     */
    omit?: AcademicCalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCalendarInclude<ExtArgs> | null
    /**
     * Filter which AcademicCalendar to delete.
     */
    where: AcademicCalendarWhereUniqueInput
  }

  /**
   * AcademicCalendar deleteMany
   */
  export type AcademicCalendarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicCalendars to delete
     */
    where?: AcademicCalendarWhereInput
    /**
     * Limit how many AcademicCalendars to delete.
     */
    limit?: number
  }

  /**
   * AcademicCalendar.academicYear
   */
  export type AcademicCalendar$academicYearArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    where?: AcademicYearWhereInput
  }

  /**
   * AcademicCalendar without action
   */
  export type AcademicCalendarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCalendar
     */
    select?: AcademicCalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicCalendar
     */
    omit?: AcademicCalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCalendarInclude<ExtArgs> | null
  }


  /**
   * Model AnonymousComplaint
   */

  export type AggregateAnonymousComplaint = {
    _count: AnonymousComplaintCountAggregateOutputType | null
    _min: AnonymousComplaintMinAggregateOutputType | null
    _max: AnonymousComplaintMaxAggregateOutputType | null
  }

  export type AnonymousComplaintMinAggregateOutputType = {
    id: string | null
    trackingId: string | null
    category: string | null
    severity: $Enums.Severity | null
    subject: string | null
    description: string | null
    submittedAt: Date | null
    currentStatus: $Enums.ComplaintStatus | null
    organizationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    academicYearId: string | null
  }

  export type AnonymousComplaintMaxAggregateOutputType = {
    id: string | null
    trackingId: string | null
    category: string | null
    severity: $Enums.Severity | null
    subject: string | null
    description: string | null
    submittedAt: Date | null
    currentStatus: $Enums.ComplaintStatus | null
    organizationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    academicYearId: string | null
  }

  export type AnonymousComplaintCountAggregateOutputType = {
    id: number
    trackingId: number
    category: number
    severity: number
    subject: number
    description: number
    evidenceUrls: number
    submittedAt: number
    currentStatus: number
    organizationId: number
    createdAt: number
    updatedAt: number
    academicYearId: number
    _all: number
  }


  export type AnonymousComplaintMinAggregateInputType = {
    id?: true
    trackingId?: true
    category?: true
    severity?: true
    subject?: true
    description?: true
    submittedAt?: true
    currentStatus?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
    academicYearId?: true
  }

  export type AnonymousComplaintMaxAggregateInputType = {
    id?: true
    trackingId?: true
    category?: true
    severity?: true
    subject?: true
    description?: true
    submittedAt?: true
    currentStatus?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
    academicYearId?: true
  }

  export type AnonymousComplaintCountAggregateInputType = {
    id?: true
    trackingId?: true
    category?: true
    severity?: true
    subject?: true
    description?: true
    evidenceUrls?: true
    submittedAt?: true
    currentStatus?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
    academicYearId?: true
    _all?: true
  }

  export type AnonymousComplaintAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnonymousComplaint to aggregate.
     */
    where?: AnonymousComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnonymousComplaints to fetch.
     */
    orderBy?: AnonymousComplaintOrderByWithRelationInput | AnonymousComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnonymousComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnonymousComplaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnonymousComplaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnonymousComplaints
    **/
    _count?: true | AnonymousComplaintCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnonymousComplaintMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnonymousComplaintMaxAggregateInputType
  }

  export type GetAnonymousComplaintAggregateType<T extends AnonymousComplaintAggregateArgs> = {
        [P in keyof T & keyof AggregateAnonymousComplaint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnonymousComplaint[P]>
      : GetScalarType<T[P], AggregateAnonymousComplaint[P]>
  }




  export type AnonymousComplaintGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnonymousComplaintWhereInput
    orderBy?: AnonymousComplaintOrderByWithAggregationInput | AnonymousComplaintOrderByWithAggregationInput[]
    by: AnonymousComplaintScalarFieldEnum[] | AnonymousComplaintScalarFieldEnum
    having?: AnonymousComplaintScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnonymousComplaintCountAggregateInputType | true
    _min?: AnonymousComplaintMinAggregateInputType
    _max?: AnonymousComplaintMaxAggregateInputType
  }

  export type AnonymousComplaintGroupByOutputType = {
    id: string
    trackingId: string
    category: string
    severity: $Enums.Severity
    subject: string
    description: string
    evidenceUrls: string[]
    submittedAt: Date
    currentStatus: $Enums.ComplaintStatus
    organizationId: string
    createdAt: Date
    updatedAt: Date
    academicYearId: string | null
    _count: AnonymousComplaintCountAggregateOutputType | null
    _min: AnonymousComplaintMinAggregateOutputType | null
    _max: AnonymousComplaintMaxAggregateOutputType | null
  }

  type GetAnonymousComplaintGroupByPayload<T extends AnonymousComplaintGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnonymousComplaintGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnonymousComplaintGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnonymousComplaintGroupByOutputType[P]>
            : GetScalarType<T[P], AnonymousComplaintGroupByOutputType[P]>
        }
      >
    >


  export type AnonymousComplaintSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trackingId?: boolean
    category?: boolean
    severity?: boolean
    subject?: boolean
    description?: boolean
    evidenceUrls?: boolean
    submittedAt?: boolean
    currentStatus?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicYearId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    ComplaintStatusTimeline?: boolean | AnonymousComplaint$ComplaintStatusTimelineArgs<ExtArgs>
    academicYear?: boolean | AnonymousComplaint$academicYearArgs<ExtArgs>
    _count?: boolean | AnonymousComplaintCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["anonymousComplaint"]>

  export type AnonymousComplaintSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trackingId?: boolean
    category?: boolean
    severity?: boolean
    subject?: boolean
    description?: boolean
    evidenceUrls?: boolean
    submittedAt?: boolean
    currentStatus?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicYearId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    academicYear?: boolean | AnonymousComplaint$academicYearArgs<ExtArgs>
  }, ExtArgs["result"]["anonymousComplaint"]>

  export type AnonymousComplaintSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trackingId?: boolean
    category?: boolean
    severity?: boolean
    subject?: boolean
    description?: boolean
    evidenceUrls?: boolean
    submittedAt?: boolean
    currentStatus?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicYearId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    academicYear?: boolean | AnonymousComplaint$academicYearArgs<ExtArgs>
  }, ExtArgs["result"]["anonymousComplaint"]>

  export type AnonymousComplaintSelectScalar = {
    id?: boolean
    trackingId?: boolean
    category?: boolean
    severity?: boolean
    subject?: boolean
    description?: boolean
    evidenceUrls?: boolean
    submittedAt?: boolean
    currentStatus?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicYearId?: boolean
  }

  export type AnonymousComplaintOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "trackingId" | "category" | "severity" | "subject" | "description" | "evidenceUrls" | "submittedAt" | "currentStatus" | "organizationId" | "createdAt" | "updatedAt" | "academicYearId", ExtArgs["result"]["anonymousComplaint"]>
  export type AnonymousComplaintInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    ComplaintStatusTimeline?: boolean | AnonymousComplaint$ComplaintStatusTimelineArgs<ExtArgs>
    academicYear?: boolean | AnonymousComplaint$academicYearArgs<ExtArgs>
    _count?: boolean | AnonymousComplaintCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AnonymousComplaintIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    academicYear?: boolean | AnonymousComplaint$academicYearArgs<ExtArgs>
  }
  export type AnonymousComplaintIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    academicYear?: boolean | AnonymousComplaint$academicYearArgs<ExtArgs>
  }

  export type $AnonymousComplaintPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnonymousComplaint"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      ComplaintStatusTimeline: Prisma.$ComplaintStatusTimelinePayload<ExtArgs>[]
      academicYear: Prisma.$AcademicYearPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trackingId: string
      category: string
      severity: $Enums.Severity
      subject: string
      description: string
      evidenceUrls: string[]
      submittedAt: Date
      currentStatus: $Enums.ComplaintStatus
      organizationId: string
      createdAt: Date
      updatedAt: Date
      academicYearId: string | null
    }, ExtArgs["result"]["anonymousComplaint"]>
    composites: {}
  }

  type AnonymousComplaintGetPayload<S extends boolean | null | undefined | AnonymousComplaintDefaultArgs> = $Result.GetResult<Prisma.$AnonymousComplaintPayload, S>

  type AnonymousComplaintCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnonymousComplaintFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnonymousComplaintCountAggregateInputType | true
    }

  export interface AnonymousComplaintDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnonymousComplaint'], meta: { name: 'AnonymousComplaint' } }
    /**
     * Find zero or one AnonymousComplaint that matches the filter.
     * @param {AnonymousComplaintFindUniqueArgs} args - Arguments to find a AnonymousComplaint
     * @example
     * // Get one AnonymousComplaint
     * const anonymousComplaint = await prisma.anonymousComplaint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnonymousComplaintFindUniqueArgs>(args: SelectSubset<T, AnonymousComplaintFindUniqueArgs<ExtArgs>>): Prisma__AnonymousComplaintClient<$Result.GetResult<Prisma.$AnonymousComplaintPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnonymousComplaint that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnonymousComplaintFindUniqueOrThrowArgs} args - Arguments to find a AnonymousComplaint
     * @example
     * // Get one AnonymousComplaint
     * const anonymousComplaint = await prisma.anonymousComplaint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnonymousComplaintFindUniqueOrThrowArgs>(args: SelectSubset<T, AnonymousComplaintFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnonymousComplaintClient<$Result.GetResult<Prisma.$AnonymousComplaintPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnonymousComplaint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnonymousComplaintFindFirstArgs} args - Arguments to find a AnonymousComplaint
     * @example
     * // Get one AnonymousComplaint
     * const anonymousComplaint = await prisma.anonymousComplaint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnonymousComplaintFindFirstArgs>(args?: SelectSubset<T, AnonymousComplaintFindFirstArgs<ExtArgs>>): Prisma__AnonymousComplaintClient<$Result.GetResult<Prisma.$AnonymousComplaintPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnonymousComplaint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnonymousComplaintFindFirstOrThrowArgs} args - Arguments to find a AnonymousComplaint
     * @example
     * // Get one AnonymousComplaint
     * const anonymousComplaint = await prisma.anonymousComplaint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnonymousComplaintFindFirstOrThrowArgs>(args?: SelectSubset<T, AnonymousComplaintFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnonymousComplaintClient<$Result.GetResult<Prisma.$AnonymousComplaintPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnonymousComplaints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnonymousComplaintFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnonymousComplaints
     * const anonymousComplaints = await prisma.anonymousComplaint.findMany()
     * 
     * // Get first 10 AnonymousComplaints
     * const anonymousComplaints = await prisma.anonymousComplaint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const anonymousComplaintWithIdOnly = await prisma.anonymousComplaint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnonymousComplaintFindManyArgs>(args?: SelectSubset<T, AnonymousComplaintFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnonymousComplaintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnonymousComplaint.
     * @param {AnonymousComplaintCreateArgs} args - Arguments to create a AnonymousComplaint.
     * @example
     * // Create one AnonymousComplaint
     * const AnonymousComplaint = await prisma.anonymousComplaint.create({
     *   data: {
     *     // ... data to create a AnonymousComplaint
     *   }
     * })
     * 
     */
    create<T extends AnonymousComplaintCreateArgs>(args: SelectSubset<T, AnonymousComplaintCreateArgs<ExtArgs>>): Prisma__AnonymousComplaintClient<$Result.GetResult<Prisma.$AnonymousComplaintPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnonymousComplaints.
     * @param {AnonymousComplaintCreateManyArgs} args - Arguments to create many AnonymousComplaints.
     * @example
     * // Create many AnonymousComplaints
     * const anonymousComplaint = await prisma.anonymousComplaint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnonymousComplaintCreateManyArgs>(args?: SelectSubset<T, AnonymousComplaintCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnonymousComplaints and returns the data saved in the database.
     * @param {AnonymousComplaintCreateManyAndReturnArgs} args - Arguments to create many AnonymousComplaints.
     * @example
     * // Create many AnonymousComplaints
     * const anonymousComplaint = await prisma.anonymousComplaint.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnonymousComplaints and only return the `id`
     * const anonymousComplaintWithIdOnly = await prisma.anonymousComplaint.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnonymousComplaintCreateManyAndReturnArgs>(args?: SelectSubset<T, AnonymousComplaintCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnonymousComplaintPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AnonymousComplaint.
     * @param {AnonymousComplaintDeleteArgs} args - Arguments to delete one AnonymousComplaint.
     * @example
     * // Delete one AnonymousComplaint
     * const AnonymousComplaint = await prisma.anonymousComplaint.delete({
     *   where: {
     *     // ... filter to delete one AnonymousComplaint
     *   }
     * })
     * 
     */
    delete<T extends AnonymousComplaintDeleteArgs>(args: SelectSubset<T, AnonymousComplaintDeleteArgs<ExtArgs>>): Prisma__AnonymousComplaintClient<$Result.GetResult<Prisma.$AnonymousComplaintPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnonymousComplaint.
     * @param {AnonymousComplaintUpdateArgs} args - Arguments to update one AnonymousComplaint.
     * @example
     * // Update one AnonymousComplaint
     * const anonymousComplaint = await prisma.anonymousComplaint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnonymousComplaintUpdateArgs>(args: SelectSubset<T, AnonymousComplaintUpdateArgs<ExtArgs>>): Prisma__AnonymousComplaintClient<$Result.GetResult<Prisma.$AnonymousComplaintPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnonymousComplaints.
     * @param {AnonymousComplaintDeleteManyArgs} args - Arguments to filter AnonymousComplaints to delete.
     * @example
     * // Delete a few AnonymousComplaints
     * const { count } = await prisma.anonymousComplaint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnonymousComplaintDeleteManyArgs>(args?: SelectSubset<T, AnonymousComplaintDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnonymousComplaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnonymousComplaintUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnonymousComplaints
     * const anonymousComplaint = await prisma.anonymousComplaint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnonymousComplaintUpdateManyArgs>(args: SelectSubset<T, AnonymousComplaintUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnonymousComplaints and returns the data updated in the database.
     * @param {AnonymousComplaintUpdateManyAndReturnArgs} args - Arguments to update many AnonymousComplaints.
     * @example
     * // Update many AnonymousComplaints
     * const anonymousComplaint = await prisma.anonymousComplaint.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AnonymousComplaints and only return the `id`
     * const anonymousComplaintWithIdOnly = await prisma.anonymousComplaint.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnonymousComplaintUpdateManyAndReturnArgs>(args: SelectSubset<T, AnonymousComplaintUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnonymousComplaintPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AnonymousComplaint.
     * @param {AnonymousComplaintUpsertArgs} args - Arguments to update or create a AnonymousComplaint.
     * @example
     * // Update or create a AnonymousComplaint
     * const anonymousComplaint = await prisma.anonymousComplaint.upsert({
     *   create: {
     *     // ... data to create a AnonymousComplaint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnonymousComplaint we want to update
     *   }
     * })
     */
    upsert<T extends AnonymousComplaintUpsertArgs>(args: SelectSubset<T, AnonymousComplaintUpsertArgs<ExtArgs>>): Prisma__AnonymousComplaintClient<$Result.GetResult<Prisma.$AnonymousComplaintPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnonymousComplaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnonymousComplaintCountArgs} args - Arguments to filter AnonymousComplaints to count.
     * @example
     * // Count the number of AnonymousComplaints
     * const count = await prisma.anonymousComplaint.count({
     *   where: {
     *     // ... the filter for the AnonymousComplaints we want to count
     *   }
     * })
    **/
    count<T extends AnonymousComplaintCountArgs>(
      args?: Subset<T, AnonymousComplaintCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnonymousComplaintCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnonymousComplaint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnonymousComplaintAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnonymousComplaintAggregateArgs>(args: Subset<T, AnonymousComplaintAggregateArgs>): Prisma.PrismaPromise<GetAnonymousComplaintAggregateType<T>>

    /**
     * Group by AnonymousComplaint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnonymousComplaintGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnonymousComplaintGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnonymousComplaintGroupByArgs['orderBy'] }
        : { orderBy?: AnonymousComplaintGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnonymousComplaintGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnonymousComplaintGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnonymousComplaint model
   */
  readonly fields: AnonymousComplaintFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnonymousComplaint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnonymousComplaintClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ComplaintStatusTimeline<T extends AnonymousComplaint$ComplaintStatusTimelineArgs<ExtArgs> = {}>(args?: Subset<T, AnonymousComplaint$ComplaintStatusTimelineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintStatusTimelinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    academicYear<T extends AnonymousComplaint$academicYearArgs<ExtArgs> = {}>(args?: Subset<T, AnonymousComplaint$academicYearArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnonymousComplaint model
   */
  interface AnonymousComplaintFieldRefs {
    readonly id: FieldRef<"AnonymousComplaint", 'String'>
    readonly trackingId: FieldRef<"AnonymousComplaint", 'String'>
    readonly category: FieldRef<"AnonymousComplaint", 'String'>
    readonly severity: FieldRef<"AnonymousComplaint", 'Severity'>
    readonly subject: FieldRef<"AnonymousComplaint", 'String'>
    readonly description: FieldRef<"AnonymousComplaint", 'String'>
    readonly evidenceUrls: FieldRef<"AnonymousComplaint", 'String[]'>
    readonly submittedAt: FieldRef<"AnonymousComplaint", 'DateTime'>
    readonly currentStatus: FieldRef<"AnonymousComplaint", 'ComplaintStatus'>
    readonly organizationId: FieldRef<"AnonymousComplaint", 'String'>
    readonly createdAt: FieldRef<"AnonymousComplaint", 'DateTime'>
    readonly updatedAt: FieldRef<"AnonymousComplaint", 'DateTime'>
    readonly academicYearId: FieldRef<"AnonymousComplaint", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AnonymousComplaint findUnique
   */
  export type AnonymousComplaintFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousComplaint
     */
    select?: AnonymousComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnonymousComplaint
     */
    omit?: AnonymousComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousComplaintInclude<ExtArgs> | null
    /**
     * Filter, which AnonymousComplaint to fetch.
     */
    where: AnonymousComplaintWhereUniqueInput
  }

  /**
   * AnonymousComplaint findUniqueOrThrow
   */
  export type AnonymousComplaintFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousComplaint
     */
    select?: AnonymousComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnonymousComplaint
     */
    omit?: AnonymousComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousComplaintInclude<ExtArgs> | null
    /**
     * Filter, which AnonymousComplaint to fetch.
     */
    where: AnonymousComplaintWhereUniqueInput
  }

  /**
   * AnonymousComplaint findFirst
   */
  export type AnonymousComplaintFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousComplaint
     */
    select?: AnonymousComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnonymousComplaint
     */
    omit?: AnonymousComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousComplaintInclude<ExtArgs> | null
    /**
     * Filter, which AnonymousComplaint to fetch.
     */
    where?: AnonymousComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnonymousComplaints to fetch.
     */
    orderBy?: AnonymousComplaintOrderByWithRelationInput | AnonymousComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnonymousComplaints.
     */
    cursor?: AnonymousComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnonymousComplaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnonymousComplaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnonymousComplaints.
     */
    distinct?: AnonymousComplaintScalarFieldEnum | AnonymousComplaintScalarFieldEnum[]
  }

  /**
   * AnonymousComplaint findFirstOrThrow
   */
  export type AnonymousComplaintFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousComplaint
     */
    select?: AnonymousComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnonymousComplaint
     */
    omit?: AnonymousComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousComplaintInclude<ExtArgs> | null
    /**
     * Filter, which AnonymousComplaint to fetch.
     */
    where?: AnonymousComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnonymousComplaints to fetch.
     */
    orderBy?: AnonymousComplaintOrderByWithRelationInput | AnonymousComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnonymousComplaints.
     */
    cursor?: AnonymousComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnonymousComplaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnonymousComplaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnonymousComplaints.
     */
    distinct?: AnonymousComplaintScalarFieldEnum | AnonymousComplaintScalarFieldEnum[]
  }

  /**
   * AnonymousComplaint findMany
   */
  export type AnonymousComplaintFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousComplaint
     */
    select?: AnonymousComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnonymousComplaint
     */
    omit?: AnonymousComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousComplaintInclude<ExtArgs> | null
    /**
     * Filter, which AnonymousComplaints to fetch.
     */
    where?: AnonymousComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnonymousComplaints to fetch.
     */
    orderBy?: AnonymousComplaintOrderByWithRelationInput | AnonymousComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnonymousComplaints.
     */
    cursor?: AnonymousComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnonymousComplaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnonymousComplaints.
     */
    skip?: number
    distinct?: AnonymousComplaintScalarFieldEnum | AnonymousComplaintScalarFieldEnum[]
  }

  /**
   * AnonymousComplaint create
   */
  export type AnonymousComplaintCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousComplaint
     */
    select?: AnonymousComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnonymousComplaint
     */
    omit?: AnonymousComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousComplaintInclude<ExtArgs> | null
    /**
     * The data needed to create a AnonymousComplaint.
     */
    data: XOR<AnonymousComplaintCreateInput, AnonymousComplaintUncheckedCreateInput>
  }

  /**
   * AnonymousComplaint createMany
   */
  export type AnonymousComplaintCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnonymousComplaints.
     */
    data: AnonymousComplaintCreateManyInput | AnonymousComplaintCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnonymousComplaint createManyAndReturn
   */
  export type AnonymousComplaintCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousComplaint
     */
    select?: AnonymousComplaintSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnonymousComplaint
     */
    omit?: AnonymousComplaintOmit<ExtArgs> | null
    /**
     * The data used to create many AnonymousComplaints.
     */
    data: AnonymousComplaintCreateManyInput | AnonymousComplaintCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousComplaintIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnonymousComplaint update
   */
  export type AnonymousComplaintUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousComplaint
     */
    select?: AnonymousComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnonymousComplaint
     */
    omit?: AnonymousComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousComplaintInclude<ExtArgs> | null
    /**
     * The data needed to update a AnonymousComplaint.
     */
    data: XOR<AnonymousComplaintUpdateInput, AnonymousComplaintUncheckedUpdateInput>
    /**
     * Choose, which AnonymousComplaint to update.
     */
    where: AnonymousComplaintWhereUniqueInput
  }

  /**
   * AnonymousComplaint updateMany
   */
  export type AnonymousComplaintUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnonymousComplaints.
     */
    data: XOR<AnonymousComplaintUpdateManyMutationInput, AnonymousComplaintUncheckedUpdateManyInput>
    /**
     * Filter which AnonymousComplaints to update
     */
    where?: AnonymousComplaintWhereInput
    /**
     * Limit how many AnonymousComplaints to update.
     */
    limit?: number
  }

  /**
   * AnonymousComplaint updateManyAndReturn
   */
  export type AnonymousComplaintUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousComplaint
     */
    select?: AnonymousComplaintSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnonymousComplaint
     */
    omit?: AnonymousComplaintOmit<ExtArgs> | null
    /**
     * The data used to update AnonymousComplaints.
     */
    data: XOR<AnonymousComplaintUpdateManyMutationInput, AnonymousComplaintUncheckedUpdateManyInput>
    /**
     * Filter which AnonymousComplaints to update
     */
    where?: AnonymousComplaintWhereInput
    /**
     * Limit how many AnonymousComplaints to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousComplaintIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnonymousComplaint upsert
   */
  export type AnonymousComplaintUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousComplaint
     */
    select?: AnonymousComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnonymousComplaint
     */
    omit?: AnonymousComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousComplaintInclude<ExtArgs> | null
    /**
     * The filter to search for the AnonymousComplaint to update in case it exists.
     */
    where: AnonymousComplaintWhereUniqueInput
    /**
     * In case the AnonymousComplaint found by the `where` argument doesn't exist, create a new AnonymousComplaint with this data.
     */
    create: XOR<AnonymousComplaintCreateInput, AnonymousComplaintUncheckedCreateInput>
    /**
     * In case the AnonymousComplaint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnonymousComplaintUpdateInput, AnonymousComplaintUncheckedUpdateInput>
  }

  /**
   * AnonymousComplaint delete
   */
  export type AnonymousComplaintDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousComplaint
     */
    select?: AnonymousComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnonymousComplaint
     */
    omit?: AnonymousComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousComplaintInclude<ExtArgs> | null
    /**
     * Filter which AnonymousComplaint to delete.
     */
    where: AnonymousComplaintWhereUniqueInput
  }

  /**
   * AnonymousComplaint deleteMany
   */
  export type AnonymousComplaintDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnonymousComplaints to delete
     */
    where?: AnonymousComplaintWhereInput
    /**
     * Limit how many AnonymousComplaints to delete.
     */
    limit?: number
  }

  /**
   * AnonymousComplaint.ComplaintStatusTimeline
   */
  export type AnonymousComplaint$ComplaintStatusTimelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintStatusTimeline
     */
    select?: ComplaintStatusTimelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintStatusTimeline
     */
    omit?: ComplaintStatusTimelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintStatusTimelineInclude<ExtArgs> | null
    where?: ComplaintStatusTimelineWhereInput
    orderBy?: ComplaintStatusTimelineOrderByWithRelationInput | ComplaintStatusTimelineOrderByWithRelationInput[]
    cursor?: ComplaintStatusTimelineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintStatusTimelineScalarFieldEnum | ComplaintStatusTimelineScalarFieldEnum[]
  }

  /**
   * AnonymousComplaint.academicYear
   */
  export type AnonymousComplaint$academicYearArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    where?: AcademicYearWhereInput
  }

  /**
   * AnonymousComplaint without action
   */
  export type AnonymousComplaintDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousComplaint
     */
    select?: AnonymousComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnonymousComplaint
     */
    omit?: AnonymousComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousComplaintInclude<ExtArgs> | null
  }


  /**
   * Model ComplaintStatusTimeline
   */

  export type AggregateComplaintStatusTimeline = {
    _count: ComplaintStatusTimelineCountAggregateOutputType | null
    _min: ComplaintStatusTimelineMinAggregateOutputType | null
    _max: ComplaintStatusTimelineMaxAggregateOutputType | null
  }

  export type ComplaintStatusTimelineMinAggregateOutputType = {
    id: string | null
    complaintId: string | null
    note: string | null
    status: $Enums.ComplaintStatus | null
    changedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComplaintStatusTimelineMaxAggregateOutputType = {
    id: string | null
    complaintId: string | null
    note: string | null
    status: $Enums.ComplaintStatus | null
    changedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComplaintStatusTimelineCountAggregateOutputType = {
    id: number
    complaintId: number
    note: number
    status: number
    changedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ComplaintStatusTimelineMinAggregateInputType = {
    id?: true
    complaintId?: true
    note?: true
    status?: true
    changedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComplaintStatusTimelineMaxAggregateInputType = {
    id?: true
    complaintId?: true
    note?: true
    status?: true
    changedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComplaintStatusTimelineCountAggregateInputType = {
    id?: true
    complaintId?: true
    note?: true
    status?: true
    changedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ComplaintStatusTimelineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplaintStatusTimeline to aggregate.
     */
    where?: ComplaintStatusTimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplaintStatusTimelines to fetch.
     */
    orderBy?: ComplaintStatusTimelineOrderByWithRelationInput | ComplaintStatusTimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComplaintStatusTimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplaintStatusTimelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplaintStatusTimelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ComplaintStatusTimelines
    **/
    _count?: true | ComplaintStatusTimelineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplaintStatusTimelineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplaintStatusTimelineMaxAggregateInputType
  }

  export type GetComplaintStatusTimelineAggregateType<T extends ComplaintStatusTimelineAggregateArgs> = {
        [P in keyof T & keyof AggregateComplaintStatusTimeline]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplaintStatusTimeline[P]>
      : GetScalarType<T[P], AggregateComplaintStatusTimeline[P]>
  }




  export type ComplaintStatusTimelineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintStatusTimelineWhereInput
    orderBy?: ComplaintStatusTimelineOrderByWithAggregationInput | ComplaintStatusTimelineOrderByWithAggregationInput[]
    by: ComplaintStatusTimelineScalarFieldEnum[] | ComplaintStatusTimelineScalarFieldEnum
    having?: ComplaintStatusTimelineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplaintStatusTimelineCountAggregateInputType | true
    _min?: ComplaintStatusTimelineMinAggregateInputType
    _max?: ComplaintStatusTimelineMaxAggregateInputType
  }

  export type ComplaintStatusTimelineGroupByOutputType = {
    id: string
    complaintId: string
    note: string | null
    status: $Enums.ComplaintStatus
    changedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: ComplaintStatusTimelineCountAggregateOutputType | null
    _min: ComplaintStatusTimelineMinAggregateOutputType | null
    _max: ComplaintStatusTimelineMaxAggregateOutputType | null
  }

  type GetComplaintStatusTimelineGroupByPayload<T extends ComplaintStatusTimelineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComplaintStatusTimelineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplaintStatusTimelineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplaintStatusTimelineGroupByOutputType[P]>
            : GetScalarType<T[P], ComplaintStatusTimelineGroupByOutputType[P]>
        }
      >
    >


  export type ComplaintStatusTimelineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    complaintId?: boolean
    note?: boolean
    status?: boolean
    changedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    complaint?: boolean | AnonymousComplaintDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complaintStatusTimeline"]>

  export type ComplaintStatusTimelineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    complaintId?: boolean
    note?: boolean
    status?: boolean
    changedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    complaint?: boolean | AnonymousComplaintDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complaintStatusTimeline"]>

  export type ComplaintStatusTimelineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    complaintId?: boolean
    note?: boolean
    status?: boolean
    changedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    complaint?: boolean | AnonymousComplaintDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complaintStatusTimeline"]>

  export type ComplaintStatusTimelineSelectScalar = {
    id?: boolean
    complaintId?: boolean
    note?: boolean
    status?: boolean
    changedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ComplaintStatusTimelineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "complaintId" | "note" | "status" | "changedBy" | "createdAt" | "updatedAt", ExtArgs["result"]["complaintStatusTimeline"]>
  export type ComplaintStatusTimelineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    complaint?: boolean | AnonymousComplaintDefaultArgs<ExtArgs>
  }
  export type ComplaintStatusTimelineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    complaint?: boolean | AnonymousComplaintDefaultArgs<ExtArgs>
  }
  export type ComplaintStatusTimelineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    complaint?: boolean | AnonymousComplaintDefaultArgs<ExtArgs>
  }

  export type $ComplaintStatusTimelinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ComplaintStatusTimeline"
    objects: {
      complaint: Prisma.$AnonymousComplaintPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      complaintId: string
      note: string | null
      status: $Enums.ComplaintStatus
      changedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["complaintStatusTimeline"]>
    composites: {}
  }

  type ComplaintStatusTimelineGetPayload<S extends boolean | null | undefined | ComplaintStatusTimelineDefaultArgs> = $Result.GetResult<Prisma.$ComplaintStatusTimelinePayload, S>

  type ComplaintStatusTimelineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComplaintStatusTimelineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComplaintStatusTimelineCountAggregateInputType | true
    }

  export interface ComplaintStatusTimelineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ComplaintStatusTimeline'], meta: { name: 'ComplaintStatusTimeline' } }
    /**
     * Find zero or one ComplaintStatusTimeline that matches the filter.
     * @param {ComplaintStatusTimelineFindUniqueArgs} args - Arguments to find a ComplaintStatusTimeline
     * @example
     * // Get one ComplaintStatusTimeline
     * const complaintStatusTimeline = await prisma.complaintStatusTimeline.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComplaintStatusTimelineFindUniqueArgs>(args: SelectSubset<T, ComplaintStatusTimelineFindUniqueArgs<ExtArgs>>): Prisma__ComplaintStatusTimelineClient<$Result.GetResult<Prisma.$ComplaintStatusTimelinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ComplaintStatusTimeline that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComplaintStatusTimelineFindUniqueOrThrowArgs} args - Arguments to find a ComplaintStatusTimeline
     * @example
     * // Get one ComplaintStatusTimeline
     * const complaintStatusTimeline = await prisma.complaintStatusTimeline.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComplaintStatusTimelineFindUniqueOrThrowArgs>(args: SelectSubset<T, ComplaintStatusTimelineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComplaintStatusTimelineClient<$Result.GetResult<Prisma.$ComplaintStatusTimelinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComplaintStatusTimeline that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintStatusTimelineFindFirstArgs} args - Arguments to find a ComplaintStatusTimeline
     * @example
     * // Get one ComplaintStatusTimeline
     * const complaintStatusTimeline = await prisma.complaintStatusTimeline.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComplaintStatusTimelineFindFirstArgs>(args?: SelectSubset<T, ComplaintStatusTimelineFindFirstArgs<ExtArgs>>): Prisma__ComplaintStatusTimelineClient<$Result.GetResult<Prisma.$ComplaintStatusTimelinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComplaintStatusTimeline that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintStatusTimelineFindFirstOrThrowArgs} args - Arguments to find a ComplaintStatusTimeline
     * @example
     * // Get one ComplaintStatusTimeline
     * const complaintStatusTimeline = await prisma.complaintStatusTimeline.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComplaintStatusTimelineFindFirstOrThrowArgs>(args?: SelectSubset<T, ComplaintStatusTimelineFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComplaintStatusTimelineClient<$Result.GetResult<Prisma.$ComplaintStatusTimelinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ComplaintStatusTimelines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintStatusTimelineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComplaintStatusTimelines
     * const complaintStatusTimelines = await prisma.complaintStatusTimeline.findMany()
     * 
     * // Get first 10 ComplaintStatusTimelines
     * const complaintStatusTimelines = await prisma.complaintStatusTimeline.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const complaintStatusTimelineWithIdOnly = await prisma.complaintStatusTimeline.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComplaintStatusTimelineFindManyArgs>(args?: SelectSubset<T, ComplaintStatusTimelineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintStatusTimelinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ComplaintStatusTimeline.
     * @param {ComplaintStatusTimelineCreateArgs} args - Arguments to create a ComplaintStatusTimeline.
     * @example
     * // Create one ComplaintStatusTimeline
     * const ComplaintStatusTimeline = await prisma.complaintStatusTimeline.create({
     *   data: {
     *     // ... data to create a ComplaintStatusTimeline
     *   }
     * })
     * 
     */
    create<T extends ComplaintStatusTimelineCreateArgs>(args: SelectSubset<T, ComplaintStatusTimelineCreateArgs<ExtArgs>>): Prisma__ComplaintStatusTimelineClient<$Result.GetResult<Prisma.$ComplaintStatusTimelinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ComplaintStatusTimelines.
     * @param {ComplaintStatusTimelineCreateManyArgs} args - Arguments to create many ComplaintStatusTimelines.
     * @example
     * // Create many ComplaintStatusTimelines
     * const complaintStatusTimeline = await prisma.complaintStatusTimeline.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComplaintStatusTimelineCreateManyArgs>(args?: SelectSubset<T, ComplaintStatusTimelineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ComplaintStatusTimelines and returns the data saved in the database.
     * @param {ComplaintStatusTimelineCreateManyAndReturnArgs} args - Arguments to create many ComplaintStatusTimelines.
     * @example
     * // Create many ComplaintStatusTimelines
     * const complaintStatusTimeline = await prisma.complaintStatusTimeline.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ComplaintStatusTimelines and only return the `id`
     * const complaintStatusTimelineWithIdOnly = await prisma.complaintStatusTimeline.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComplaintStatusTimelineCreateManyAndReturnArgs>(args?: SelectSubset<T, ComplaintStatusTimelineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintStatusTimelinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ComplaintStatusTimeline.
     * @param {ComplaintStatusTimelineDeleteArgs} args - Arguments to delete one ComplaintStatusTimeline.
     * @example
     * // Delete one ComplaintStatusTimeline
     * const ComplaintStatusTimeline = await prisma.complaintStatusTimeline.delete({
     *   where: {
     *     // ... filter to delete one ComplaintStatusTimeline
     *   }
     * })
     * 
     */
    delete<T extends ComplaintStatusTimelineDeleteArgs>(args: SelectSubset<T, ComplaintStatusTimelineDeleteArgs<ExtArgs>>): Prisma__ComplaintStatusTimelineClient<$Result.GetResult<Prisma.$ComplaintStatusTimelinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ComplaintStatusTimeline.
     * @param {ComplaintStatusTimelineUpdateArgs} args - Arguments to update one ComplaintStatusTimeline.
     * @example
     * // Update one ComplaintStatusTimeline
     * const complaintStatusTimeline = await prisma.complaintStatusTimeline.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComplaintStatusTimelineUpdateArgs>(args: SelectSubset<T, ComplaintStatusTimelineUpdateArgs<ExtArgs>>): Prisma__ComplaintStatusTimelineClient<$Result.GetResult<Prisma.$ComplaintStatusTimelinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ComplaintStatusTimelines.
     * @param {ComplaintStatusTimelineDeleteManyArgs} args - Arguments to filter ComplaintStatusTimelines to delete.
     * @example
     * // Delete a few ComplaintStatusTimelines
     * const { count } = await prisma.complaintStatusTimeline.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComplaintStatusTimelineDeleteManyArgs>(args?: SelectSubset<T, ComplaintStatusTimelineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComplaintStatusTimelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintStatusTimelineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComplaintStatusTimelines
     * const complaintStatusTimeline = await prisma.complaintStatusTimeline.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComplaintStatusTimelineUpdateManyArgs>(args: SelectSubset<T, ComplaintStatusTimelineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComplaintStatusTimelines and returns the data updated in the database.
     * @param {ComplaintStatusTimelineUpdateManyAndReturnArgs} args - Arguments to update many ComplaintStatusTimelines.
     * @example
     * // Update many ComplaintStatusTimelines
     * const complaintStatusTimeline = await prisma.complaintStatusTimeline.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ComplaintStatusTimelines and only return the `id`
     * const complaintStatusTimelineWithIdOnly = await prisma.complaintStatusTimeline.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ComplaintStatusTimelineUpdateManyAndReturnArgs>(args: SelectSubset<T, ComplaintStatusTimelineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintStatusTimelinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ComplaintStatusTimeline.
     * @param {ComplaintStatusTimelineUpsertArgs} args - Arguments to update or create a ComplaintStatusTimeline.
     * @example
     * // Update or create a ComplaintStatusTimeline
     * const complaintStatusTimeline = await prisma.complaintStatusTimeline.upsert({
     *   create: {
     *     // ... data to create a ComplaintStatusTimeline
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComplaintStatusTimeline we want to update
     *   }
     * })
     */
    upsert<T extends ComplaintStatusTimelineUpsertArgs>(args: SelectSubset<T, ComplaintStatusTimelineUpsertArgs<ExtArgs>>): Prisma__ComplaintStatusTimelineClient<$Result.GetResult<Prisma.$ComplaintStatusTimelinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ComplaintStatusTimelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintStatusTimelineCountArgs} args - Arguments to filter ComplaintStatusTimelines to count.
     * @example
     * // Count the number of ComplaintStatusTimelines
     * const count = await prisma.complaintStatusTimeline.count({
     *   where: {
     *     // ... the filter for the ComplaintStatusTimelines we want to count
     *   }
     * })
    **/
    count<T extends ComplaintStatusTimelineCountArgs>(
      args?: Subset<T, ComplaintStatusTimelineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplaintStatusTimelineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComplaintStatusTimeline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintStatusTimelineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplaintStatusTimelineAggregateArgs>(args: Subset<T, ComplaintStatusTimelineAggregateArgs>): Prisma.PrismaPromise<GetComplaintStatusTimelineAggregateType<T>>

    /**
     * Group by ComplaintStatusTimeline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintStatusTimelineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComplaintStatusTimelineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComplaintStatusTimelineGroupByArgs['orderBy'] }
        : { orderBy?: ComplaintStatusTimelineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComplaintStatusTimelineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplaintStatusTimelineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ComplaintStatusTimeline model
   */
  readonly fields: ComplaintStatusTimelineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComplaintStatusTimeline.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComplaintStatusTimelineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    complaint<T extends AnonymousComplaintDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AnonymousComplaintDefaultArgs<ExtArgs>>): Prisma__AnonymousComplaintClient<$Result.GetResult<Prisma.$AnonymousComplaintPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ComplaintStatusTimeline model
   */
  interface ComplaintStatusTimelineFieldRefs {
    readonly id: FieldRef<"ComplaintStatusTimeline", 'String'>
    readonly complaintId: FieldRef<"ComplaintStatusTimeline", 'String'>
    readonly note: FieldRef<"ComplaintStatusTimeline", 'String'>
    readonly status: FieldRef<"ComplaintStatusTimeline", 'ComplaintStatus'>
    readonly changedBy: FieldRef<"ComplaintStatusTimeline", 'String'>
    readonly createdAt: FieldRef<"ComplaintStatusTimeline", 'DateTime'>
    readonly updatedAt: FieldRef<"ComplaintStatusTimeline", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ComplaintStatusTimeline findUnique
   */
  export type ComplaintStatusTimelineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintStatusTimeline
     */
    select?: ComplaintStatusTimelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintStatusTimeline
     */
    omit?: ComplaintStatusTimelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintStatusTimelineInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintStatusTimeline to fetch.
     */
    where: ComplaintStatusTimelineWhereUniqueInput
  }

  /**
   * ComplaintStatusTimeline findUniqueOrThrow
   */
  export type ComplaintStatusTimelineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintStatusTimeline
     */
    select?: ComplaintStatusTimelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintStatusTimeline
     */
    omit?: ComplaintStatusTimelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintStatusTimelineInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintStatusTimeline to fetch.
     */
    where: ComplaintStatusTimelineWhereUniqueInput
  }

  /**
   * ComplaintStatusTimeline findFirst
   */
  export type ComplaintStatusTimelineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintStatusTimeline
     */
    select?: ComplaintStatusTimelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintStatusTimeline
     */
    omit?: ComplaintStatusTimelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintStatusTimelineInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintStatusTimeline to fetch.
     */
    where?: ComplaintStatusTimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplaintStatusTimelines to fetch.
     */
    orderBy?: ComplaintStatusTimelineOrderByWithRelationInput | ComplaintStatusTimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplaintStatusTimelines.
     */
    cursor?: ComplaintStatusTimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplaintStatusTimelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplaintStatusTimelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplaintStatusTimelines.
     */
    distinct?: ComplaintStatusTimelineScalarFieldEnum | ComplaintStatusTimelineScalarFieldEnum[]
  }

  /**
   * ComplaintStatusTimeline findFirstOrThrow
   */
  export type ComplaintStatusTimelineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintStatusTimeline
     */
    select?: ComplaintStatusTimelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintStatusTimeline
     */
    omit?: ComplaintStatusTimelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintStatusTimelineInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintStatusTimeline to fetch.
     */
    where?: ComplaintStatusTimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplaintStatusTimelines to fetch.
     */
    orderBy?: ComplaintStatusTimelineOrderByWithRelationInput | ComplaintStatusTimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplaintStatusTimelines.
     */
    cursor?: ComplaintStatusTimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplaintStatusTimelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplaintStatusTimelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplaintStatusTimelines.
     */
    distinct?: ComplaintStatusTimelineScalarFieldEnum | ComplaintStatusTimelineScalarFieldEnum[]
  }

  /**
   * ComplaintStatusTimeline findMany
   */
  export type ComplaintStatusTimelineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintStatusTimeline
     */
    select?: ComplaintStatusTimelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintStatusTimeline
     */
    omit?: ComplaintStatusTimelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintStatusTimelineInclude<ExtArgs> | null
    /**
     * Filter, which ComplaintStatusTimelines to fetch.
     */
    where?: ComplaintStatusTimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplaintStatusTimelines to fetch.
     */
    orderBy?: ComplaintStatusTimelineOrderByWithRelationInput | ComplaintStatusTimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ComplaintStatusTimelines.
     */
    cursor?: ComplaintStatusTimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplaintStatusTimelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplaintStatusTimelines.
     */
    skip?: number
    distinct?: ComplaintStatusTimelineScalarFieldEnum | ComplaintStatusTimelineScalarFieldEnum[]
  }

  /**
   * ComplaintStatusTimeline create
   */
  export type ComplaintStatusTimelineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintStatusTimeline
     */
    select?: ComplaintStatusTimelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintStatusTimeline
     */
    omit?: ComplaintStatusTimelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintStatusTimelineInclude<ExtArgs> | null
    /**
     * The data needed to create a ComplaintStatusTimeline.
     */
    data: XOR<ComplaintStatusTimelineCreateInput, ComplaintStatusTimelineUncheckedCreateInput>
  }

  /**
   * ComplaintStatusTimeline createMany
   */
  export type ComplaintStatusTimelineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ComplaintStatusTimelines.
     */
    data: ComplaintStatusTimelineCreateManyInput | ComplaintStatusTimelineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComplaintStatusTimeline createManyAndReturn
   */
  export type ComplaintStatusTimelineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintStatusTimeline
     */
    select?: ComplaintStatusTimelineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintStatusTimeline
     */
    omit?: ComplaintStatusTimelineOmit<ExtArgs> | null
    /**
     * The data used to create many ComplaintStatusTimelines.
     */
    data: ComplaintStatusTimelineCreateManyInput | ComplaintStatusTimelineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintStatusTimelineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ComplaintStatusTimeline update
   */
  export type ComplaintStatusTimelineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintStatusTimeline
     */
    select?: ComplaintStatusTimelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintStatusTimeline
     */
    omit?: ComplaintStatusTimelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintStatusTimelineInclude<ExtArgs> | null
    /**
     * The data needed to update a ComplaintStatusTimeline.
     */
    data: XOR<ComplaintStatusTimelineUpdateInput, ComplaintStatusTimelineUncheckedUpdateInput>
    /**
     * Choose, which ComplaintStatusTimeline to update.
     */
    where: ComplaintStatusTimelineWhereUniqueInput
  }

  /**
   * ComplaintStatusTimeline updateMany
   */
  export type ComplaintStatusTimelineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ComplaintStatusTimelines.
     */
    data: XOR<ComplaintStatusTimelineUpdateManyMutationInput, ComplaintStatusTimelineUncheckedUpdateManyInput>
    /**
     * Filter which ComplaintStatusTimelines to update
     */
    where?: ComplaintStatusTimelineWhereInput
    /**
     * Limit how many ComplaintStatusTimelines to update.
     */
    limit?: number
  }

  /**
   * ComplaintStatusTimeline updateManyAndReturn
   */
  export type ComplaintStatusTimelineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintStatusTimeline
     */
    select?: ComplaintStatusTimelineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintStatusTimeline
     */
    omit?: ComplaintStatusTimelineOmit<ExtArgs> | null
    /**
     * The data used to update ComplaintStatusTimelines.
     */
    data: XOR<ComplaintStatusTimelineUpdateManyMutationInput, ComplaintStatusTimelineUncheckedUpdateManyInput>
    /**
     * Filter which ComplaintStatusTimelines to update
     */
    where?: ComplaintStatusTimelineWhereInput
    /**
     * Limit how many ComplaintStatusTimelines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintStatusTimelineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ComplaintStatusTimeline upsert
   */
  export type ComplaintStatusTimelineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintStatusTimeline
     */
    select?: ComplaintStatusTimelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintStatusTimeline
     */
    omit?: ComplaintStatusTimelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintStatusTimelineInclude<ExtArgs> | null
    /**
     * The filter to search for the ComplaintStatusTimeline to update in case it exists.
     */
    where: ComplaintStatusTimelineWhereUniqueInput
    /**
     * In case the ComplaintStatusTimeline found by the `where` argument doesn't exist, create a new ComplaintStatusTimeline with this data.
     */
    create: XOR<ComplaintStatusTimelineCreateInput, ComplaintStatusTimelineUncheckedCreateInput>
    /**
     * In case the ComplaintStatusTimeline was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComplaintStatusTimelineUpdateInput, ComplaintStatusTimelineUncheckedUpdateInput>
  }

  /**
   * ComplaintStatusTimeline delete
   */
  export type ComplaintStatusTimelineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintStatusTimeline
     */
    select?: ComplaintStatusTimelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintStatusTimeline
     */
    omit?: ComplaintStatusTimelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintStatusTimelineInclude<ExtArgs> | null
    /**
     * Filter which ComplaintStatusTimeline to delete.
     */
    where: ComplaintStatusTimelineWhereUniqueInput
  }

  /**
   * ComplaintStatusTimeline deleteMany
   */
  export type ComplaintStatusTimelineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplaintStatusTimelines to delete
     */
    where?: ComplaintStatusTimelineWhereInput
    /**
     * Limit how many ComplaintStatusTimelines to delete.
     */
    limit?: number
  }

  /**
   * ComplaintStatusTimeline without action
   */
  export type ComplaintStatusTimelineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplaintStatusTimeline
     */
    select?: ComplaintStatusTimelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplaintStatusTimeline
     */
    omit?: ComplaintStatusTimelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintStatusTimelineInclude<ExtArgs> | null
  }


  /**
   * Model Notice
   */

  export type AggregateNotice = {
    _count: NoticeCountAggregateOutputType | null
    _min: NoticeMinAggregateOutputType | null
    _max: NoticeMaxAggregateOutputType | null
  }

  export type NoticeMinAggregateOutputType = {
    id: string | null
    noticeType: string | null
    title: string | null
    startDate: Date | null
    endDate: Date | null
    content: string | null
    summary: string | null
    isNoticeApproved: boolean | null
    isDraft: boolean | null
    isPublished: boolean | null
    emailNotification: boolean | null
    pushNotification: boolean | null
    WhatsAppNotification: boolean | null
    smsNotification: boolean | null
    publishedBy: string | null
    organizationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    academicYearId: string | null
  }

  export type NoticeMaxAggregateOutputType = {
    id: string | null
    noticeType: string | null
    title: string | null
    startDate: Date | null
    endDate: Date | null
    content: string | null
    summary: string | null
    isNoticeApproved: boolean | null
    isDraft: boolean | null
    isPublished: boolean | null
    emailNotification: boolean | null
    pushNotification: boolean | null
    WhatsAppNotification: boolean | null
    smsNotification: boolean | null
    publishedBy: string | null
    organizationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    academicYearId: string | null
  }

  export type NoticeCountAggregateOutputType = {
    id: number
    noticeType: number
    title: number
    startDate: number
    endDate: number
    content: number
    summary: number
    isNoticeApproved: number
    isDraft: number
    isPublished: number
    emailNotification: number
    pushNotification: number
    WhatsAppNotification: number
    smsNotification: number
    targetAudience: number
    attachments: number
    publishedBy: number
    organizationId: number
    createdAt: number
    updatedAt: number
    academicYearId: number
    _all: number
  }


  export type NoticeMinAggregateInputType = {
    id?: true
    noticeType?: true
    title?: true
    startDate?: true
    endDate?: true
    content?: true
    summary?: true
    isNoticeApproved?: true
    isDraft?: true
    isPublished?: true
    emailNotification?: true
    pushNotification?: true
    WhatsAppNotification?: true
    smsNotification?: true
    publishedBy?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
    academicYearId?: true
  }

  export type NoticeMaxAggregateInputType = {
    id?: true
    noticeType?: true
    title?: true
    startDate?: true
    endDate?: true
    content?: true
    summary?: true
    isNoticeApproved?: true
    isDraft?: true
    isPublished?: true
    emailNotification?: true
    pushNotification?: true
    WhatsAppNotification?: true
    smsNotification?: true
    publishedBy?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
    academicYearId?: true
  }

  export type NoticeCountAggregateInputType = {
    id?: true
    noticeType?: true
    title?: true
    startDate?: true
    endDate?: true
    content?: true
    summary?: true
    isNoticeApproved?: true
    isDraft?: true
    isPublished?: true
    emailNotification?: true
    pushNotification?: true
    WhatsAppNotification?: true
    smsNotification?: true
    targetAudience?: true
    attachments?: true
    publishedBy?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
    academicYearId?: true
    _all?: true
  }

  export type NoticeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notice to aggregate.
     */
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     */
    orderBy?: NoticeOrderByWithRelationInput | NoticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notices
    **/
    _count?: true | NoticeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoticeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoticeMaxAggregateInputType
  }

  export type GetNoticeAggregateType<T extends NoticeAggregateArgs> = {
        [P in keyof T & keyof AggregateNotice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotice[P]>
      : GetScalarType<T[P], AggregateNotice[P]>
  }




  export type NoticeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoticeWhereInput
    orderBy?: NoticeOrderByWithAggregationInput | NoticeOrderByWithAggregationInput[]
    by: NoticeScalarFieldEnum[] | NoticeScalarFieldEnum
    having?: NoticeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoticeCountAggregateInputType | true
    _min?: NoticeMinAggregateInputType
    _max?: NoticeMaxAggregateInputType
  }

  export type NoticeGroupByOutputType = {
    id: string
    noticeType: string
    title: string
    startDate: Date
    endDate: Date
    content: string
    summary: string | null
    isNoticeApproved: boolean
    isDraft: boolean
    isPublished: boolean
    emailNotification: boolean
    pushNotification: boolean
    WhatsAppNotification: boolean
    smsNotification: boolean
    targetAudience: string[]
    attachments: JsonValue | null
    publishedBy: string
    organizationId: string
    createdAt: Date
    updatedAt: Date
    academicYearId: string | null
    _count: NoticeCountAggregateOutputType | null
    _min: NoticeMinAggregateOutputType | null
    _max: NoticeMaxAggregateOutputType | null
  }

  type GetNoticeGroupByPayload<T extends NoticeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoticeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoticeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoticeGroupByOutputType[P]>
            : GetScalarType<T[P], NoticeGroupByOutputType[P]>
        }
      >
    >


  export type NoticeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    noticeType?: boolean
    title?: boolean
    startDate?: boolean
    endDate?: boolean
    content?: boolean
    summary?: boolean
    isNoticeApproved?: boolean
    isDraft?: boolean
    isPublished?: boolean
    emailNotification?: boolean
    pushNotification?: boolean
    WhatsAppNotification?: boolean
    smsNotification?: boolean
    targetAudience?: boolean
    attachments?: boolean
    publishedBy?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicYearId?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    academicYear?: boolean | Notice$academicYearArgs<ExtArgs>
  }, ExtArgs["result"]["notice"]>

  export type NoticeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    noticeType?: boolean
    title?: boolean
    startDate?: boolean
    endDate?: boolean
    content?: boolean
    summary?: boolean
    isNoticeApproved?: boolean
    isDraft?: boolean
    isPublished?: boolean
    emailNotification?: boolean
    pushNotification?: boolean
    WhatsAppNotification?: boolean
    smsNotification?: boolean
    targetAudience?: boolean
    attachments?: boolean
    publishedBy?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicYearId?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    academicYear?: boolean | Notice$academicYearArgs<ExtArgs>
  }, ExtArgs["result"]["notice"]>

  export type NoticeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    noticeType?: boolean
    title?: boolean
    startDate?: boolean
    endDate?: boolean
    content?: boolean
    summary?: boolean
    isNoticeApproved?: boolean
    isDraft?: boolean
    isPublished?: boolean
    emailNotification?: boolean
    pushNotification?: boolean
    WhatsAppNotification?: boolean
    smsNotification?: boolean
    targetAudience?: boolean
    attachments?: boolean
    publishedBy?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicYearId?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    academicYear?: boolean | Notice$academicYearArgs<ExtArgs>
  }, ExtArgs["result"]["notice"]>

  export type NoticeSelectScalar = {
    id?: boolean
    noticeType?: boolean
    title?: boolean
    startDate?: boolean
    endDate?: boolean
    content?: boolean
    summary?: boolean
    isNoticeApproved?: boolean
    isDraft?: boolean
    isPublished?: boolean
    emailNotification?: boolean
    pushNotification?: boolean
    WhatsAppNotification?: boolean
    smsNotification?: boolean
    targetAudience?: boolean
    attachments?: boolean
    publishedBy?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicYearId?: boolean
  }

  export type NoticeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "noticeType" | "title" | "startDate" | "endDate" | "content" | "summary" | "isNoticeApproved" | "isDraft" | "isPublished" | "emailNotification" | "pushNotification" | "WhatsAppNotification" | "smsNotification" | "targetAudience" | "attachments" | "publishedBy" | "organizationId" | "createdAt" | "updatedAt" | "academicYearId", ExtArgs["result"]["notice"]>
  export type NoticeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    academicYear?: boolean | Notice$academicYearArgs<ExtArgs>
  }
  export type NoticeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    academicYear?: boolean | Notice$academicYearArgs<ExtArgs>
  }
  export type NoticeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    academicYear?: boolean | Notice$academicYearArgs<ExtArgs>
  }

  export type $NoticePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notice"
    objects: {
      Organization: Prisma.$OrganizationPayload<ExtArgs>
      academicYear: Prisma.$AcademicYearPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      noticeType: string
      title: string
      startDate: Date
      endDate: Date
      content: string
      summary: string | null
      isNoticeApproved: boolean
      isDraft: boolean
      isPublished: boolean
      emailNotification: boolean
      pushNotification: boolean
      WhatsAppNotification: boolean
      smsNotification: boolean
      targetAudience: string[]
      attachments: Prisma.JsonValue | null
      publishedBy: string
      organizationId: string
      createdAt: Date
      updatedAt: Date
      academicYearId: string | null
    }, ExtArgs["result"]["notice"]>
    composites: {}
  }

  type NoticeGetPayload<S extends boolean | null | undefined | NoticeDefaultArgs> = $Result.GetResult<Prisma.$NoticePayload, S>

  type NoticeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NoticeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NoticeCountAggregateInputType | true
    }

  export interface NoticeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notice'], meta: { name: 'Notice' } }
    /**
     * Find zero or one Notice that matches the filter.
     * @param {NoticeFindUniqueArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NoticeFindUniqueArgs>(args: SelectSubset<T, NoticeFindUniqueArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NoticeFindUniqueOrThrowArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NoticeFindUniqueOrThrowArgs>(args: SelectSubset<T, NoticeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeFindFirstArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NoticeFindFirstArgs>(args?: SelectSubset<T, NoticeFindFirstArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeFindFirstOrThrowArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NoticeFindFirstOrThrowArgs>(args?: SelectSubset<T, NoticeFindFirstOrThrowArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notices
     * const notices = await prisma.notice.findMany()
     * 
     * // Get first 10 Notices
     * const notices = await prisma.notice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noticeWithIdOnly = await prisma.notice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NoticeFindManyArgs>(args?: SelectSubset<T, NoticeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notice.
     * @param {NoticeCreateArgs} args - Arguments to create a Notice.
     * @example
     * // Create one Notice
     * const Notice = await prisma.notice.create({
     *   data: {
     *     // ... data to create a Notice
     *   }
     * })
     * 
     */
    create<T extends NoticeCreateArgs>(args: SelectSubset<T, NoticeCreateArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notices.
     * @param {NoticeCreateManyArgs} args - Arguments to create many Notices.
     * @example
     * // Create many Notices
     * const notice = await prisma.notice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NoticeCreateManyArgs>(args?: SelectSubset<T, NoticeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notices and returns the data saved in the database.
     * @param {NoticeCreateManyAndReturnArgs} args - Arguments to create many Notices.
     * @example
     * // Create many Notices
     * const notice = await prisma.notice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notices and only return the `id`
     * const noticeWithIdOnly = await prisma.notice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NoticeCreateManyAndReturnArgs>(args?: SelectSubset<T, NoticeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notice.
     * @param {NoticeDeleteArgs} args - Arguments to delete one Notice.
     * @example
     * // Delete one Notice
     * const Notice = await prisma.notice.delete({
     *   where: {
     *     // ... filter to delete one Notice
     *   }
     * })
     * 
     */
    delete<T extends NoticeDeleteArgs>(args: SelectSubset<T, NoticeDeleteArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notice.
     * @param {NoticeUpdateArgs} args - Arguments to update one Notice.
     * @example
     * // Update one Notice
     * const notice = await prisma.notice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NoticeUpdateArgs>(args: SelectSubset<T, NoticeUpdateArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notices.
     * @param {NoticeDeleteManyArgs} args - Arguments to filter Notices to delete.
     * @example
     * // Delete a few Notices
     * const { count } = await prisma.notice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NoticeDeleteManyArgs>(args?: SelectSubset<T, NoticeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notices
     * const notice = await prisma.notice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NoticeUpdateManyArgs>(args: SelectSubset<T, NoticeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notices and returns the data updated in the database.
     * @param {NoticeUpdateManyAndReturnArgs} args - Arguments to update many Notices.
     * @example
     * // Update many Notices
     * const notice = await prisma.notice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notices and only return the `id`
     * const noticeWithIdOnly = await prisma.notice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NoticeUpdateManyAndReturnArgs>(args: SelectSubset<T, NoticeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notice.
     * @param {NoticeUpsertArgs} args - Arguments to update or create a Notice.
     * @example
     * // Update or create a Notice
     * const notice = await prisma.notice.upsert({
     *   create: {
     *     // ... data to create a Notice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notice we want to update
     *   }
     * })
     */
    upsert<T extends NoticeUpsertArgs>(args: SelectSubset<T, NoticeUpsertArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeCountArgs} args - Arguments to filter Notices to count.
     * @example
     * // Count the number of Notices
     * const count = await prisma.notice.count({
     *   where: {
     *     // ... the filter for the Notices we want to count
     *   }
     * })
    **/
    count<T extends NoticeCountArgs>(
      args?: Subset<T, NoticeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoticeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoticeAggregateArgs>(args: Subset<T, NoticeAggregateArgs>): Prisma.PrismaPromise<GetNoticeAggregateType<T>>

    /**
     * Group by Notice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoticeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoticeGroupByArgs['orderBy'] }
        : { orderBy?: NoticeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoticeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoticeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notice model
   */
  readonly fields: NoticeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NoticeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    academicYear<T extends Notice$academicYearArgs<ExtArgs> = {}>(args?: Subset<T, Notice$academicYearArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notice model
   */
  interface NoticeFieldRefs {
    readonly id: FieldRef<"Notice", 'String'>
    readonly noticeType: FieldRef<"Notice", 'String'>
    readonly title: FieldRef<"Notice", 'String'>
    readonly startDate: FieldRef<"Notice", 'DateTime'>
    readonly endDate: FieldRef<"Notice", 'DateTime'>
    readonly content: FieldRef<"Notice", 'String'>
    readonly summary: FieldRef<"Notice", 'String'>
    readonly isNoticeApproved: FieldRef<"Notice", 'Boolean'>
    readonly isDraft: FieldRef<"Notice", 'Boolean'>
    readonly isPublished: FieldRef<"Notice", 'Boolean'>
    readonly emailNotification: FieldRef<"Notice", 'Boolean'>
    readonly pushNotification: FieldRef<"Notice", 'Boolean'>
    readonly WhatsAppNotification: FieldRef<"Notice", 'Boolean'>
    readonly smsNotification: FieldRef<"Notice", 'Boolean'>
    readonly targetAudience: FieldRef<"Notice", 'String[]'>
    readonly attachments: FieldRef<"Notice", 'Json'>
    readonly publishedBy: FieldRef<"Notice", 'String'>
    readonly organizationId: FieldRef<"Notice", 'String'>
    readonly createdAt: FieldRef<"Notice", 'DateTime'>
    readonly updatedAt: FieldRef<"Notice", 'DateTime'>
    readonly academicYearId: FieldRef<"Notice", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Notice findUnique
   */
  export type NoticeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter, which Notice to fetch.
     */
    where: NoticeWhereUniqueInput
  }

  /**
   * Notice findUniqueOrThrow
   */
  export type NoticeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter, which Notice to fetch.
     */
    where: NoticeWhereUniqueInput
  }

  /**
   * Notice findFirst
   */
  export type NoticeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter, which Notice to fetch.
     */
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     */
    orderBy?: NoticeOrderByWithRelationInput | NoticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notices.
     */
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notices.
     */
    distinct?: NoticeScalarFieldEnum | NoticeScalarFieldEnum[]
  }

  /**
   * Notice findFirstOrThrow
   */
  export type NoticeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter, which Notice to fetch.
     */
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     */
    orderBy?: NoticeOrderByWithRelationInput | NoticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notices.
     */
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notices.
     */
    distinct?: NoticeScalarFieldEnum | NoticeScalarFieldEnum[]
  }

  /**
   * Notice findMany
   */
  export type NoticeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter, which Notices to fetch.
     */
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     */
    orderBy?: NoticeOrderByWithRelationInput | NoticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notices.
     */
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     */
    skip?: number
    distinct?: NoticeScalarFieldEnum | NoticeScalarFieldEnum[]
  }

  /**
   * Notice create
   */
  export type NoticeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * The data needed to create a Notice.
     */
    data: XOR<NoticeCreateInput, NoticeUncheckedCreateInput>
  }

  /**
   * Notice createMany
   */
  export type NoticeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notices.
     */
    data: NoticeCreateManyInput | NoticeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notice createManyAndReturn
   */
  export type NoticeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * The data used to create many Notices.
     */
    data: NoticeCreateManyInput | NoticeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notice update
   */
  export type NoticeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * The data needed to update a Notice.
     */
    data: XOR<NoticeUpdateInput, NoticeUncheckedUpdateInput>
    /**
     * Choose, which Notice to update.
     */
    where: NoticeWhereUniqueInput
  }

  /**
   * Notice updateMany
   */
  export type NoticeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notices.
     */
    data: XOR<NoticeUpdateManyMutationInput, NoticeUncheckedUpdateManyInput>
    /**
     * Filter which Notices to update
     */
    where?: NoticeWhereInput
    /**
     * Limit how many Notices to update.
     */
    limit?: number
  }

  /**
   * Notice updateManyAndReturn
   */
  export type NoticeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * The data used to update Notices.
     */
    data: XOR<NoticeUpdateManyMutationInput, NoticeUncheckedUpdateManyInput>
    /**
     * Filter which Notices to update
     */
    where?: NoticeWhereInput
    /**
     * Limit how many Notices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notice upsert
   */
  export type NoticeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * The filter to search for the Notice to update in case it exists.
     */
    where: NoticeWhereUniqueInput
    /**
     * In case the Notice found by the `where` argument doesn't exist, create a new Notice with this data.
     */
    create: XOR<NoticeCreateInput, NoticeUncheckedCreateInput>
    /**
     * In case the Notice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoticeUpdateInput, NoticeUncheckedUpdateInput>
  }

  /**
   * Notice delete
   */
  export type NoticeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter which Notice to delete.
     */
    where: NoticeWhereUniqueInput
  }

  /**
   * Notice deleteMany
   */
  export type NoticeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notices to delete
     */
    where?: NoticeWhereInput
    /**
     * Limit how many Notices to delete.
     */
    limit?: number
  }

  /**
   * Notice.academicYear
   */
  export type Notice$academicYearArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    where?: AcademicYearWhereInput
  }

  /**
   * Notice without action
   */
  export type NoticeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
  }


  /**
   * Model NotificationLog
   */

  export type AggregateNotificationLog = {
    _count: NotificationLogCountAggregateOutputType | null
    _avg: NotificationLogAvgAggregateOutputType | null
    _sum: NotificationLogSumAggregateOutputType | null
    _min: NotificationLogMinAggregateOutputType | null
    _max: NotificationLogMaxAggregateOutputType | null
  }

  export type NotificationLogAvgAggregateOutputType = {
    units: number | null
    cost: number | null
  }

  export type NotificationLogSumAggregateOutputType = {
    units: number | null
    cost: number | null
  }

  export type NotificationLogMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    userId: string | null
    parentId: string | null
    studentId: string | null
    channel: $Enums.NotificationChannel | null
    status: $Enums.NotificationStatus | null
    notificationType: $Enums.NotificationType | null
    units: number | null
    cost: number | null
    sentAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationLogMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    userId: string | null
    parentId: string | null
    studentId: string | null
    channel: $Enums.NotificationChannel | null
    status: $Enums.NotificationStatus | null
    notificationType: $Enums.NotificationType | null
    units: number | null
    cost: number | null
    sentAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationLogCountAggregateOutputType = {
    id: number
    organizationId: number
    userId: number
    parentId: number
    studentId: number
    channel: number
    status: number
    notificationType: number
    units: number
    cost: number
    sentAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationLogAvgAggregateInputType = {
    units?: true
    cost?: true
  }

  export type NotificationLogSumAggregateInputType = {
    units?: true
    cost?: true
  }

  export type NotificationLogMinAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    parentId?: true
    studentId?: true
    channel?: true
    status?: true
    notificationType?: true
    units?: true
    cost?: true
    sentAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationLogMaxAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    parentId?: true
    studentId?: true
    channel?: true
    status?: true
    notificationType?: true
    units?: true
    cost?: true
    sentAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationLogCountAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    parentId?: true
    studentId?: true
    channel?: true
    status?: true
    notificationType?: true
    units?: true
    cost?: true
    sentAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationLog to aggregate.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationLogs
    **/
    _count?: true | NotificationLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationLogMaxAggregateInputType
  }

  export type GetNotificationLogAggregateType<T extends NotificationLogAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationLog[P]>
      : GetScalarType<T[P], AggregateNotificationLog[P]>
  }




  export type NotificationLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationLogWhereInput
    orderBy?: NotificationLogOrderByWithAggregationInput | NotificationLogOrderByWithAggregationInput[]
    by: NotificationLogScalarFieldEnum[] | NotificationLogScalarFieldEnum
    having?: NotificationLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationLogCountAggregateInputType | true
    _avg?: NotificationLogAvgAggregateInputType
    _sum?: NotificationLogSumAggregateInputType
    _min?: NotificationLogMinAggregateInputType
    _max?: NotificationLogMaxAggregateInputType
  }

  export type NotificationLogGroupByOutputType = {
    id: string
    organizationId: string
    userId: string | null
    parentId: string | null
    studentId: string | null
    channel: $Enums.NotificationChannel
    status: $Enums.NotificationStatus
    notificationType: $Enums.NotificationType
    units: number
    cost: number
    sentAt: Date
    createdAt: Date
    updatedAt: Date
    _count: NotificationLogCountAggregateOutputType | null
    _avg: NotificationLogAvgAggregateOutputType | null
    _sum: NotificationLogSumAggregateOutputType | null
    _min: NotificationLogMinAggregateOutputType | null
    _max: NotificationLogMaxAggregateOutputType | null
  }

  type GetNotificationLogGroupByPayload<T extends NotificationLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationLogGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationLogGroupByOutputType[P]>
        }
      >
    >


  export type NotificationLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    parentId?: boolean
    studentId?: boolean
    channel?: boolean
    status?: boolean
    notificationType?: boolean
    units?: boolean
    cost?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | NotificationLog$userArgs<ExtArgs>
    parent?: boolean | NotificationLog$parentArgs<ExtArgs>
    student?: boolean | NotificationLog$studentArgs<ExtArgs>
  }, ExtArgs["result"]["notificationLog"]>

  export type NotificationLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    parentId?: boolean
    studentId?: boolean
    channel?: boolean
    status?: boolean
    notificationType?: boolean
    units?: boolean
    cost?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | NotificationLog$userArgs<ExtArgs>
    parent?: boolean | NotificationLog$parentArgs<ExtArgs>
    student?: boolean | NotificationLog$studentArgs<ExtArgs>
  }, ExtArgs["result"]["notificationLog"]>

  export type NotificationLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    parentId?: boolean
    studentId?: boolean
    channel?: boolean
    status?: boolean
    notificationType?: boolean
    units?: boolean
    cost?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | NotificationLog$userArgs<ExtArgs>
    parent?: boolean | NotificationLog$parentArgs<ExtArgs>
    student?: boolean | NotificationLog$studentArgs<ExtArgs>
  }, ExtArgs["result"]["notificationLog"]>

  export type NotificationLogSelectScalar = {
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    parentId?: boolean
    studentId?: boolean
    channel?: boolean
    status?: boolean
    notificationType?: boolean
    units?: boolean
    cost?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "userId" | "parentId" | "studentId" | "channel" | "status" | "notificationType" | "units" | "cost" | "sentAt" | "createdAt" | "updatedAt", ExtArgs["result"]["notificationLog"]>
  export type NotificationLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | NotificationLog$userArgs<ExtArgs>
    parent?: boolean | NotificationLog$parentArgs<ExtArgs>
    student?: boolean | NotificationLog$studentArgs<ExtArgs>
  }
  export type NotificationLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | NotificationLog$userArgs<ExtArgs>
    parent?: boolean | NotificationLog$parentArgs<ExtArgs>
    student?: boolean | NotificationLog$studentArgs<ExtArgs>
  }
  export type NotificationLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | NotificationLog$userArgs<ExtArgs>
    parent?: boolean | NotificationLog$parentArgs<ExtArgs>
    student?: boolean | NotificationLog$studentArgs<ExtArgs>
  }

  export type $NotificationLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationLog"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
      parent: Prisma.$ParentPayload<ExtArgs> | null
      student: Prisma.$StudentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      userId: string | null
      parentId: string | null
      studentId: string | null
      channel: $Enums.NotificationChannel
      status: $Enums.NotificationStatus
      notificationType: $Enums.NotificationType
      units: number
      cost: number
      sentAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationLog"]>
    composites: {}
  }

  type NotificationLogGetPayload<S extends boolean | null | undefined | NotificationLogDefaultArgs> = $Result.GetResult<Prisma.$NotificationLogPayload, S>

  type NotificationLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationLogCountAggregateInputType | true
    }

  export interface NotificationLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationLog'], meta: { name: 'NotificationLog' } }
    /**
     * Find zero or one NotificationLog that matches the filter.
     * @param {NotificationLogFindUniqueArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationLogFindUniqueArgs>(args: SelectSubset<T, NotificationLogFindUniqueArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationLogFindUniqueOrThrowArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationLogFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindFirstArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationLogFindFirstArgs>(args?: SelectSubset<T, NotificationLogFindFirstArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindFirstOrThrowArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationLogFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationLogs
     * const notificationLogs = await prisma.notificationLog.findMany()
     * 
     * // Get first 10 NotificationLogs
     * const notificationLogs = await prisma.notificationLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationLogWithIdOnly = await prisma.notificationLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationLogFindManyArgs>(args?: SelectSubset<T, NotificationLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationLog.
     * @param {NotificationLogCreateArgs} args - Arguments to create a NotificationLog.
     * @example
     * // Create one NotificationLog
     * const NotificationLog = await prisma.notificationLog.create({
     *   data: {
     *     // ... data to create a NotificationLog
     *   }
     * })
     * 
     */
    create<T extends NotificationLogCreateArgs>(args: SelectSubset<T, NotificationLogCreateArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationLogs.
     * @param {NotificationLogCreateManyArgs} args - Arguments to create many NotificationLogs.
     * @example
     * // Create many NotificationLogs
     * const notificationLog = await prisma.notificationLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationLogCreateManyArgs>(args?: SelectSubset<T, NotificationLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationLogs and returns the data saved in the database.
     * @param {NotificationLogCreateManyAndReturnArgs} args - Arguments to create many NotificationLogs.
     * @example
     * // Create many NotificationLogs
     * const notificationLog = await prisma.notificationLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationLogs and only return the `id`
     * const notificationLogWithIdOnly = await prisma.notificationLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationLogCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationLog.
     * @param {NotificationLogDeleteArgs} args - Arguments to delete one NotificationLog.
     * @example
     * // Delete one NotificationLog
     * const NotificationLog = await prisma.notificationLog.delete({
     *   where: {
     *     // ... filter to delete one NotificationLog
     *   }
     * })
     * 
     */
    delete<T extends NotificationLogDeleteArgs>(args: SelectSubset<T, NotificationLogDeleteArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationLog.
     * @param {NotificationLogUpdateArgs} args - Arguments to update one NotificationLog.
     * @example
     * // Update one NotificationLog
     * const notificationLog = await prisma.notificationLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationLogUpdateArgs>(args: SelectSubset<T, NotificationLogUpdateArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationLogs.
     * @param {NotificationLogDeleteManyArgs} args - Arguments to filter NotificationLogs to delete.
     * @example
     * // Delete a few NotificationLogs
     * const { count } = await prisma.notificationLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationLogDeleteManyArgs>(args?: SelectSubset<T, NotificationLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationLogs
     * const notificationLog = await prisma.notificationLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationLogUpdateManyArgs>(args: SelectSubset<T, NotificationLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationLogs and returns the data updated in the database.
     * @param {NotificationLogUpdateManyAndReturnArgs} args - Arguments to update many NotificationLogs.
     * @example
     * // Update many NotificationLogs
     * const notificationLog = await prisma.notificationLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationLogs and only return the `id`
     * const notificationLogWithIdOnly = await prisma.notificationLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationLogUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationLog.
     * @param {NotificationLogUpsertArgs} args - Arguments to update or create a NotificationLog.
     * @example
     * // Update or create a NotificationLog
     * const notificationLog = await prisma.notificationLog.upsert({
     *   create: {
     *     // ... data to create a NotificationLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationLog we want to update
     *   }
     * })
     */
    upsert<T extends NotificationLogUpsertArgs>(args: SelectSubset<T, NotificationLogUpsertArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogCountArgs} args - Arguments to filter NotificationLogs to count.
     * @example
     * // Count the number of NotificationLogs
     * const count = await prisma.notificationLog.count({
     *   where: {
     *     // ... the filter for the NotificationLogs we want to count
     *   }
     * })
    **/
    count<T extends NotificationLogCountArgs>(
      args?: Subset<T, NotificationLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationLogAggregateArgs>(args: Subset<T, NotificationLogAggregateArgs>): Prisma.PrismaPromise<GetNotificationLogAggregateType<T>>

    /**
     * Group by NotificationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationLogGroupByArgs['orderBy'] }
        : { orderBy?: NotificationLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationLog model
   */
  readonly fields: NotificationLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends NotificationLog$userArgs<ExtArgs> = {}>(args?: Subset<T, NotificationLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    parent<T extends NotificationLog$parentArgs<ExtArgs> = {}>(args?: Subset<T, NotificationLog$parentArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    student<T extends NotificationLog$studentArgs<ExtArgs> = {}>(args?: Subset<T, NotificationLog$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationLog model
   */
  interface NotificationLogFieldRefs {
    readonly id: FieldRef<"NotificationLog", 'String'>
    readonly organizationId: FieldRef<"NotificationLog", 'String'>
    readonly userId: FieldRef<"NotificationLog", 'String'>
    readonly parentId: FieldRef<"NotificationLog", 'String'>
    readonly studentId: FieldRef<"NotificationLog", 'String'>
    readonly channel: FieldRef<"NotificationLog", 'NotificationChannel'>
    readonly status: FieldRef<"NotificationLog", 'NotificationStatus'>
    readonly notificationType: FieldRef<"NotificationLog", 'NotificationType'>
    readonly units: FieldRef<"NotificationLog", 'Int'>
    readonly cost: FieldRef<"NotificationLog", 'Float'>
    readonly sentAt: FieldRef<"NotificationLog", 'DateTime'>
    readonly createdAt: FieldRef<"NotificationLog", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationLog findUnique
   */
  export type NotificationLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog findUniqueOrThrow
   */
  export type NotificationLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog findFirst
   */
  export type NotificationLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationLogs.
     */
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * NotificationLog findFirstOrThrow
   */
  export type NotificationLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationLogs.
     */
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * NotificationLog findMany
   */
  export type NotificationLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLogs to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * NotificationLog create
   */
  export type NotificationLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationLog.
     */
    data: XOR<NotificationLogCreateInput, NotificationLogUncheckedCreateInput>
  }

  /**
   * NotificationLog createMany
   */
  export type NotificationLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationLogs.
     */
    data: NotificationLogCreateManyInput | NotificationLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationLog createManyAndReturn
   */
  export type NotificationLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationLogs.
     */
    data: NotificationLogCreateManyInput | NotificationLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationLog update
   */
  export type NotificationLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationLog.
     */
    data: XOR<NotificationLogUpdateInput, NotificationLogUncheckedUpdateInput>
    /**
     * Choose, which NotificationLog to update.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog updateMany
   */
  export type NotificationLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationLogs.
     */
    data: XOR<NotificationLogUpdateManyMutationInput, NotificationLogUncheckedUpdateManyInput>
    /**
     * Filter which NotificationLogs to update
     */
    where?: NotificationLogWhereInput
    /**
     * Limit how many NotificationLogs to update.
     */
    limit?: number
  }

  /**
   * NotificationLog updateManyAndReturn
   */
  export type NotificationLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * The data used to update NotificationLogs.
     */
    data: XOR<NotificationLogUpdateManyMutationInput, NotificationLogUncheckedUpdateManyInput>
    /**
     * Filter which NotificationLogs to update
     */
    where?: NotificationLogWhereInput
    /**
     * Limit how many NotificationLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationLog upsert
   */
  export type NotificationLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationLog to update in case it exists.
     */
    where: NotificationLogWhereUniqueInput
    /**
     * In case the NotificationLog found by the `where` argument doesn't exist, create a new NotificationLog with this data.
     */
    create: XOR<NotificationLogCreateInput, NotificationLogUncheckedCreateInput>
    /**
     * In case the NotificationLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationLogUpdateInput, NotificationLogUncheckedUpdateInput>
  }

  /**
   * NotificationLog delete
   */
  export type NotificationLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter which NotificationLog to delete.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog deleteMany
   */
  export type NotificationLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationLogs to delete
     */
    where?: NotificationLogWhereInput
    /**
     * Limit how many NotificationLogs to delete.
     */
    limit?: number
  }

  /**
   * NotificationLog.user
   */
  export type NotificationLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * NotificationLog.parent
   */
  export type NotificationLog$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    where?: ParentWhereInput
  }

  /**
   * NotificationLog.student
   */
  export type NotificationLog$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * NotificationLog without action
   */
  export type NotificationLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
  }


  /**
   * Model ExamSession
   */

  export type AggregateExamSession = {
    _count: ExamSessionCountAggregateOutputType | null
    _min: ExamSessionMinAggregateOutputType | null
    _max: ExamSessionMaxAggregateOutputType | null
  }

  export type ExamSessionMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    academicYearId: string | null
    startDate: Date | null
    endDate: Date | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamSessionMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    academicYearId: string | null
    startDate: Date | null
    endDate: Date | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamSessionCountAggregateOutputType = {
    id: number
    title: number
    description: number
    academicYearId: number
    startDate: number
    endDate: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExamSessionMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    academicYearId?: true
    startDate?: true
    endDate?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamSessionMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    academicYearId?: true
    startDate?: true
    endDate?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamSessionCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    academicYearId?: true
    startDate?: true
    endDate?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExamSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamSession to aggregate.
     */
    where?: ExamSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamSessions to fetch.
     */
    orderBy?: ExamSessionOrderByWithRelationInput | ExamSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExamSessions
    **/
    _count?: true | ExamSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamSessionMaxAggregateInputType
  }

  export type GetExamSessionAggregateType<T extends ExamSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateExamSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamSession[P]>
      : GetScalarType<T[P], AggregateExamSession[P]>
  }




  export type ExamSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamSessionWhereInput
    orderBy?: ExamSessionOrderByWithAggregationInput | ExamSessionOrderByWithAggregationInput[]
    by: ExamSessionScalarFieldEnum[] | ExamSessionScalarFieldEnum
    having?: ExamSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamSessionCountAggregateInputType | true
    _min?: ExamSessionMinAggregateInputType
    _max?: ExamSessionMaxAggregateInputType
  }

  export type ExamSessionGroupByOutputType = {
    id: string
    title: string
    description: string | null
    academicYearId: string
    startDate: Date
    endDate: Date
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: ExamSessionCountAggregateOutputType | null
    _min: ExamSessionMinAggregateOutputType | null
    _max: ExamSessionMaxAggregateOutputType | null
  }

  type GetExamSessionGroupByPayload<T extends ExamSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamSessionGroupByOutputType[P]>
            : GetScalarType<T[P], ExamSessionGroupByOutputType[P]>
        }
      >
    >


  export type ExamSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    academicYearId?: boolean
    startDate?: boolean
    endDate?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
    exams?: boolean | ExamSession$examsArgs<ExtArgs>
    reportCards?: boolean | ExamSession$reportCardsArgs<ExtArgs>
    hallTickets?: boolean | ExamSession$hallTicketsArgs<ExtArgs>
    _count?: boolean | ExamSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examSession"]>

  export type ExamSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    academicYearId?: boolean
    startDate?: boolean
    endDate?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examSession"]>

  export type ExamSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    academicYearId?: boolean
    startDate?: boolean
    endDate?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examSession"]>

  export type ExamSessionSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    academicYearId?: boolean
    startDate?: boolean
    endDate?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExamSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "academicYearId" | "startDate" | "endDate" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["examSession"]>
  export type ExamSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
    exams?: boolean | ExamSession$examsArgs<ExtArgs>
    reportCards?: boolean | ExamSession$reportCardsArgs<ExtArgs>
    hallTickets?: boolean | ExamSession$hallTicketsArgs<ExtArgs>
    _count?: boolean | ExamSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExamSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
  }
  export type ExamSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
  }

  export type $ExamSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExamSession"
    objects: {
      academicYear: Prisma.$AcademicYearPayload<ExtArgs>
      exams: Prisma.$ExamPayload<ExtArgs>[]
      reportCards: Prisma.$ReportCardPayload<ExtArgs>[]
      hallTickets: Prisma.$HallTicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      academicYearId: string
      startDate: Date
      endDate: Date
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["examSession"]>
    composites: {}
  }

  type ExamSessionGetPayload<S extends boolean | null | undefined | ExamSessionDefaultArgs> = $Result.GetResult<Prisma.$ExamSessionPayload, S>

  type ExamSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExamSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExamSessionCountAggregateInputType | true
    }

  export interface ExamSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExamSession'], meta: { name: 'ExamSession' } }
    /**
     * Find zero or one ExamSession that matches the filter.
     * @param {ExamSessionFindUniqueArgs} args - Arguments to find a ExamSession
     * @example
     * // Get one ExamSession
     * const examSession = await prisma.examSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamSessionFindUniqueArgs>(args: SelectSubset<T, ExamSessionFindUniqueArgs<ExtArgs>>): Prisma__ExamSessionClient<$Result.GetResult<Prisma.$ExamSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExamSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExamSessionFindUniqueOrThrowArgs} args - Arguments to find a ExamSession
     * @example
     * // Get one ExamSession
     * const examSession = await prisma.examSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamSessionClient<$Result.GetResult<Prisma.$ExamSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamSessionFindFirstArgs} args - Arguments to find a ExamSession
     * @example
     * // Get one ExamSession
     * const examSession = await prisma.examSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamSessionFindFirstArgs>(args?: SelectSubset<T, ExamSessionFindFirstArgs<ExtArgs>>): Prisma__ExamSessionClient<$Result.GetResult<Prisma.$ExamSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamSessionFindFirstOrThrowArgs} args - Arguments to find a ExamSession
     * @example
     * // Get one ExamSession
     * const examSession = await prisma.examSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamSessionClient<$Result.GetResult<Prisma.$ExamSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExamSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamSessions
     * const examSessions = await prisma.examSession.findMany()
     * 
     * // Get first 10 ExamSessions
     * const examSessions = await prisma.examSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examSessionWithIdOnly = await prisma.examSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamSessionFindManyArgs>(args?: SelectSubset<T, ExamSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExamSession.
     * @param {ExamSessionCreateArgs} args - Arguments to create a ExamSession.
     * @example
     * // Create one ExamSession
     * const ExamSession = await prisma.examSession.create({
     *   data: {
     *     // ... data to create a ExamSession
     *   }
     * })
     * 
     */
    create<T extends ExamSessionCreateArgs>(args: SelectSubset<T, ExamSessionCreateArgs<ExtArgs>>): Prisma__ExamSessionClient<$Result.GetResult<Prisma.$ExamSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExamSessions.
     * @param {ExamSessionCreateManyArgs} args - Arguments to create many ExamSessions.
     * @example
     * // Create many ExamSessions
     * const examSession = await prisma.examSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamSessionCreateManyArgs>(args?: SelectSubset<T, ExamSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExamSessions and returns the data saved in the database.
     * @param {ExamSessionCreateManyAndReturnArgs} args - Arguments to create many ExamSessions.
     * @example
     * // Create many ExamSessions
     * const examSession = await prisma.examSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExamSessions and only return the `id`
     * const examSessionWithIdOnly = await prisma.examSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExamSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, ExamSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExamSession.
     * @param {ExamSessionDeleteArgs} args - Arguments to delete one ExamSession.
     * @example
     * // Delete one ExamSession
     * const ExamSession = await prisma.examSession.delete({
     *   where: {
     *     // ... filter to delete one ExamSession
     *   }
     * })
     * 
     */
    delete<T extends ExamSessionDeleteArgs>(args: SelectSubset<T, ExamSessionDeleteArgs<ExtArgs>>): Prisma__ExamSessionClient<$Result.GetResult<Prisma.$ExamSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExamSession.
     * @param {ExamSessionUpdateArgs} args - Arguments to update one ExamSession.
     * @example
     * // Update one ExamSession
     * const examSession = await prisma.examSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamSessionUpdateArgs>(args: SelectSubset<T, ExamSessionUpdateArgs<ExtArgs>>): Prisma__ExamSessionClient<$Result.GetResult<Prisma.$ExamSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExamSessions.
     * @param {ExamSessionDeleteManyArgs} args - Arguments to filter ExamSessions to delete.
     * @example
     * // Delete a few ExamSessions
     * const { count } = await prisma.examSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamSessionDeleteManyArgs>(args?: SelectSubset<T, ExamSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamSessions
     * const examSession = await prisma.examSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamSessionUpdateManyArgs>(args: SelectSubset<T, ExamSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamSessions and returns the data updated in the database.
     * @param {ExamSessionUpdateManyAndReturnArgs} args - Arguments to update many ExamSessions.
     * @example
     * // Update many ExamSessions
     * const examSession = await prisma.examSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExamSessions and only return the `id`
     * const examSessionWithIdOnly = await prisma.examSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExamSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, ExamSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExamSession.
     * @param {ExamSessionUpsertArgs} args - Arguments to update or create a ExamSession.
     * @example
     * // Update or create a ExamSession
     * const examSession = await prisma.examSession.upsert({
     *   create: {
     *     // ... data to create a ExamSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamSession we want to update
     *   }
     * })
     */
    upsert<T extends ExamSessionUpsertArgs>(args: SelectSubset<T, ExamSessionUpsertArgs<ExtArgs>>): Prisma__ExamSessionClient<$Result.GetResult<Prisma.$ExamSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExamSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamSessionCountArgs} args - Arguments to filter ExamSessions to count.
     * @example
     * // Count the number of ExamSessions
     * const count = await prisma.examSession.count({
     *   where: {
     *     // ... the filter for the ExamSessions we want to count
     *   }
     * })
    **/
    count<T extends ExamSessionCountArgs>(
      args?: Subset<T, ExamSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamSessionAggregateArgs>(args: Subset<T, ExamSessionAggregateArgs>): Prisma.PrismaPromise<GetExamSessionAggregateType<T>>

    /**
     * Group by ExamSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamSessionGroupByArgs['orderBy'] }
        : { orderBy?: ExamSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExamSession model
   */
  readonly fields: ExamSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExamSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    academicYear<T extends AcademicYearDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicYearDefaultArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    exams<T extends ExamSession$examsArgs<ExtArgs> = {}>(args?: Subset<T, ExamSession$examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reportCards<T extends ExamSession$reportCardsArgs<ExtArgs> = {}>(args?: Subset<T, ExamSession$reportCardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    hallTickets<T extends ExamSession$hallTicketsArgs<ExtArgs> = {}>(args?: Subset<T, ExamSession$hallTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HallTicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExamSession model
   */
  interface ExamSessionFieldRefs {
    readonly id: FieldRef<"ExamSession", 'String'>
    readonly title: FieldRef<"ExamSession", 'String'>
    readonly description: FieldRef<"ExamSession", 'String'>
    readonly academicYearId: FieldRef<"ExamSession", 'String'>
    readonly startDate: FieldRef<"ExamSession", 'DateTime'>
    readonly endDate: FieldRef<"ExamSession", 'DateTime'>
    readonly createdBy: FieldRef<"ExamSession", 'String'>
    readonly createdAt: FieldRef<"ExamSession", 'DateTime'>
    readonly updatedAt: FieldRef<"ExamSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExamSession findUnique
   */
  export type ExamSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSession
     */
    select?: ExamSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamSession
     */
    omit?: ExamSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSessionInclude<ExtArgs> | null
    /**
     * Filter, which ExamSession to fetch.
     */
    where: ExamSessionWhereUniqueInput
  }

  /**
   * ExamSession findUniqueOrThrow
   */
  export type ExamSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSession
     */
    select?: ExamSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamSession
     */
    omit?: ExamSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSessionInclude<ExtArgs> | null
    /**
     * Filter, which ExamSession to fetch.
     */
    where: ExamSessionWhereUniqueInput
  }

  /**
   * ExamSession findFirst
   */
  export type ExamSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSession
     */
    select?: ExamSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamSession
     */
    omit?: ExamSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSessionInclude<ExtArgs> | null
    /**
     * Filter, which ExamSession to fetch.
     */
    where?: ExamSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamSessions to fetch.
     */
    orderBy?: ExamSessionOrderByWithRelationInput | ExamSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamSessions.
     */
    cursor?: ExamSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamSessions.
     */
    distinct?: ExamSessionScalarFieldEnum | ExamSessionScalarFieldEnum[]
  }

  /**
   * ExamSession findFirstOrThrow
   */
  export type ExamSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSession
     */
    select?: ExamSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamSession
     */
    omit?: ExamSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSessionInclude<ExtArgs> | null
    /**
     * Filter, which ExamSession to fetch.
     */
    where?: ExamSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamSessions to fetch.
     */
    orderBy?: ExamSessionOrderByWithRelationInput | ExamSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamSessions.
     */
    cursor?: ExamSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamSessions.
     */
    distinct?: ExamSessionScalarFieldEnum | ExamSessionScalarFieldEnum[]
  }

  /**
   * ExamSession findMany
   */
  export type ExamSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSession
     */
    select?: ExamSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamSession
     */
    omit?: ExamSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSessionInclude<ExtArgs> | null
    /**
     * Filter, which ExamSessions to fetch.
     */
    where?: ExamSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamSessions to fetch.
     */
    orderBy?: ExamSessionOrderByWithRelationInput | ExamSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExamSessions.
     */
    cursor?: ExamSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamSessions.
     */
    skip?: number
    distinct?: ExamSessionScalarFieldEnum | ExamSessionScalarFieldEnum[]
  }

  /**
   * ExamSession create
   */
  export type ExamSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSession
     */
    select?: ExamSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamSession
     */
    omit?: ExamSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a ExamSession.
     */
    data: XOR<ExamSessionCreateInput, ExamSessionUncheckedCreateInput>
  }

  /**
   * ExamSession createMany
   */
  export type ExamSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExamSessions.
     */
    data: ExamSessionCreateManyInput | ExamSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExamSession createManyAndReturn
   */
  export type ExamSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSession
     */
    select?: ExamSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamSession
     */
    omit?: ExamSessionOmit<ExtArgs> | null
    /**
     * The data used to create many ExamSessions.
     */
    data: ExamSessionCreateManyInput | ExamSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamSession update
   */
  export type ExamSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSession
     */
    select?: ExamSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamSession
     */
    omit?: ExamSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a ExamSession.
     */
    data: XOR<ExamSessionUpdateInput, ExamSessionUncheckedUpdateInput>
    /**
     * Choose, which ExamSession to update.
     */
    where: ExamSessionWhereUniqueInput
  }

  /**
   * ExamSession updateMany
   */
  export type ExamSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExamSessions.
     */
    data: XOR<ExamSessionUpdateManyMutationInput, ExamSessionUncheckedUpdateManyInput>
    /**
     * Filter which ExamSessions to update
     */
    where?: ExamSessionWhereInput
    /**
     * Limit how many ExamSessions to update.
     */
    limit?: number
  }

  /**
   * ExamSession updateManyAndReturn
   */
  export type ExamSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSession
     */
    select?: ExamSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamSession
     */
    omit?: ExamSessionOmit<ExtArgs> | null
    /**
     * The data used to update ExamSessions.
     */
    data: XOR<ExamSessionUpdateManyMutationInput, ExamSessionUncheckedUpdateManyInput>
    /**
     * Filter which ExamSessions to update
     */
    where?: ExamSessionWhereInput
    /**
     * Limit how many ExamSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamSession upsert
   */
  export type ExamSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSession
     */
    select?: ExamSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamSession
     */
    omit?: ExamSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the ExamSession to update in case it exists.
     */
    where: ExamSessionWhereUniqueInput
    /**
     * In case the ExamSession found by the `where` argument doesn't exist, create a new ExamSession with this data.
     */
    create: XOR<ExamSessionCreateInput, ExamSessionUncheckedCreateInput>
    /**
     * In case the ExamSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamSessionUpdateInput, ExamSessionUncheckedUpdateInput>
  }

  /**
   * ExamSession delete
   */
  export type ExamSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSession
     */
    select?: ExamSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamSession
     */
    omit?: ExamSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSessionInclude<ExtArgs> | null
    /**
     * Filter which ExamSession to delete.
     */
    where: ExamSessionWhereUniqueInput
  }

  /**
   * ExamSession deleteMany
   */
  export type ExamSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamSessions to delete
     */
    where?: ExamSessionWhereInput
    /**
     * Limit how many ExamSessions to delete.
     */
    limit?: number
  }

  /**
   * ExamSession.exams
   */
  export type ExamSession$examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    cursor?: ExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * ExamSession.reportCards
   */
  export type ExamSession$reportCardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportCard
     */
    omit?: ReportCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardInclude<ExtArgs> | null
    where?: ReportCardWhereInput
    orderBy?: ReportCardOrderByWithRelationInput | ReportCardOrderByWithRelationInput[]
    cursor?: ReportCardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportCardScalarFieldEnum | ReportCardScalarFieldEnum[]
  }

  /**
   * ExamSession.hallTickets
   */
  export type ExamSession$hallTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HallTicket
     */
    select?: HallTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HallTicket
     */
    omit?: HallTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallTicketInclude<ExtArgs> | null
    where?: HallTicketWhereInput
    orderBy?: HallTicketOrderByWithRelationInput | HallTicketOrderByWithRelationInput[]
    cursor?: HallTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HallTicketScalarFieldEnum | HallTicketScalarFieldEnum[]
  }

  /**
   * ExamSession without action
   */
  export type ExamSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSession
     */
    select?: ExamSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamSession
     */
    omit?: ExamSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSessionInclude<ExtArgs> | null
  }


  /**
   * Model Exam
   */

  export type AggregateExam = {
    _count: ExamCountAggregateOutputType | null
    _avg: ExamAvgAggregateOutputType | null
    _sum: ExamSumAggregateOutputType | null
    _min: ExamMinAggregateOutputType | null
    _max: ExamMaxAggregateOutputType | null
  }

  export type ExamAvgAggregateOutputType = {
    maxMarks: number | null
    passingMarks: number | null
    weightage: number | null
    durationInMinutes: number | null
  }

  export type ExamSumAggregateOutputType = {
    maxMarks: number | null
    passingMarks: number | null
    weightage: number | null
    durationInMinutes: number | null
  }

  export type ExamMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    examSessionId: string | null
    subjectId: string | null
    gradeId: string | null
    sectionId: string | null
    organizationId: string | null
    maxMarks: number | null
    passingMarks: number | null
    weightage: number | null
    evaluationType: $Enums.EvaluationType | null
    mode: $Enums.ExamMode | null
    status: $Enums.ExamStatus | null
    instructions: string | null
    durationInMinutes: number | null
    venueMapUrl: string | null
    venue: string | null
    isResultsPublished: boolean | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    examSessionId: string | null
    subjectId: string | null
    gradeId: string | null
    sectionId: string | null
    organizationId: string | null
    maxMarks: number | null
    passingMarks: number | null
    weightage: number | null
    evaluationType: $Enums.EvaluationType | null
    mode: $Enums.ExamMode | null
    status: $Enums.ExamStatus | null
    instructions: string | null
    durationInMinutes: number | null
    venueMapUrl: string | null
    venue: string | null
    isResultsPublished: boolean | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamCountAggregateOutputType = {
    id: number
    title: number
    description: number
    examSessionId: number
    subjectId: number
    gradeId: number
    sectionId: number
    organizationId: number
    maxMarks: number
    passingMarks: number
    weightage: number
    evaluationType: number
    mode: number
    status: number
    instructions: number
    durationInMinutes: number
    venueMapUrl: number
    venue: number
    isResultsPublished: number
    supervisors: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExamAvgAggregateInputType = {
    maxMarks?: true
    passingMarks?: true
    weightage?: true
    durationInMinutes?: true
  }

  export type ExamSumAggregateInputType = {
    maxMarks?: true
    passingMarks?: true
    weightage?: true
    durationInMinutes?: true
  }

  export type ExamMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    examSessionId?: true
    subjectId?: true
    gradeId?: true
    sectionId?: true
    organizationId?: true
    maxMarks?: true
    passingMarks?: true
    weightage?: true
    evaluationType?: true
    mode?: true
    status?: true
    instructions?: true
    durationInMinutes?: true
    venueMapUrl?: true
    venue?: true
    isResultsPublished?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    examSessionId?: true
    subjectId?: true
    gradeId?: true
    sectionId?: true
    organizationId?: true
    maxMarks?: true
    passingMarks?: true
    weightage?: true
    evaluationType?: true
    mode?: true
    status?: true
    instructions?: true
    durationInMinutes?: true
    venueMapUrl?: true
    venue?: true
    isResultsPublished?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    examSessionId?: true
    subjectId?: true
    gradeId?: true
    sectionId?: true
    organizationId?: true
    maxMarks?: true
    passingMarks?: true
    weightage?: true
    evaluationType?: true
    mode?: true
    status?: true
    instructions?: true
    durationInMinutes?: true
    venueMapUrl?: true
    venue?: true
    isResultsPublished?: true
    supervisors?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exam to aggregate.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exams
    **/
    _count?: true | ExamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamMaxAggregateInputType
  }

  export type GetExamAggregateType<T extends ExamAggregateArgs> = {
        [P in keyof T & keyof AggregateExam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExam[P]>
      : GetScalarType<T[P], AggregateExam[P]>
  }




  export type ExamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithAggregationInput | ExamOrderByWithAggregationInput[]
    by: ExamScalarFieldEnum[] | ExamScalarFieldEnum
    having?: ExamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamCountAggregateInputType | true
    _avg?: ExamAvgAggregateInputType
    _sum?: ExamSumAggregateInputType
    _min?: ExamMinAggregateInputType
    _max?: ExamMaxAggregateInputType
  }

  export type ExamGroupByOutputType = {
    id: string
    title: string
    description: string | null
    examSessionId: string
    subjectId: string
    gradeId: string
    sectionId: string
    organizationId: string
    maxMarks: number
    passingMarks: number | null
    weightage: number | null
    evaluationType: $Enums.EvaluationType
    mode: $Enums.ExamMode
    status: $Enums.ExamStatus
    instructions: string | null
    durationInMinutes: number | null
    venueMapUrl: string | null
    venue: string | null
    isResultsPublished: boolean
    supervisors: string[]
    startDate: Date
    endDate: Date
    createdAt: Date
    updatedAt: Date
    _count: ExamCountAggregateOutputType | null
    _avg: ExamAvgAggregateOutputType | null
    _sum: ExamSumAggregateOutputType | null
    _min: ExamMinAggregateOutputType | null
    _max: ExamMaxAggregateOutputType | null
  }

  type GetExamGroupByPayload<T extends ExamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamGroupByOutputType[P]>
            : GetScalarType<T[P], ExamGroupByOutputType[P]>
        }
      >
    >


  export type ExamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    examSessionId?: boolean
    subjectId?: boolean
    gradeId?: boolean
    sectionId?: boolean
    organizationId?: boolean
    maxMarks?: boolean
    passingMarks?: boolean
    weightage?: boolean
    evaluationType?: boolean
    mode?: boolean
    status?: boolean
    instructions?: boolean
    durationInMinutes?: boolean
    venueMapUrl?: boolean
    venue?: boolean
    isResultsPublished?: boolean
    supervisors?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    examSession?: boolean | ExamSessionDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    hallTickets?: boolean | Exam$hallTicketsArgs<ExtArgs>
    examResult?: boolean | Exam$examResultArgs<ExtArgs>
    examEnrollment?: boolean | Exam$examEnrollmentArgs<ExtArgs>
    _count?: boolean | ExamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exam"]>

  export type ExamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    examSessionId?: boolean
    subjectId?: boolean
    gradeId?: boolean
    sectionId?: boolean
    organizationId?: boolean
    maxMarks?: boolean
    passingMarks?: boolean
    weightage?: boolean
    evaluationType?: boolean
    mode?: boolean
    status?: boolean
    instructions?: boolean
    durationInMinutes?: boolean
    venueMapUrl?: boolean
    venue?: boolean
    isResultsPublished?: boolean
    supervisors?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    examSession?: boolean | ExamSessionDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exam"]>

  export type ExamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    examSessionId?: boolean
    subjectId?: boolean
    gradeId?: boolean
    sectionId?: boolean
    organizationId?: boolean
    maxMarks?: boolean
    passingMarks?: boolean
    weightage?: boolean
    evaluationType?: boolean
    mode?: boolean
    status?: boolean
    instructions?: boolean
    durationInMinutes?: boolean
    venueMapUrl?: boolean
    venue?: boolean
    isResultsPublished?: boolean
    supervisors?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    examSession?: boolean | ExamSessionDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exam"]>

  export type ExamSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    examSessionId?: boolean
    subjectId?: boolean
    gradeId?: boolean
    sectionId?: boolean
    organizationId?: boolean
    maxMarks?: boolean
    passingMarks?: boolean
    weightage?: boolean
    evaluationType?: boolean
    mode?: boolean
    status?: boolean
    instructions?: boolean
    durationInMinutes?: boolean
    venueMapUrl?: boolean
    venue?: boolean
    isResultsPublished?: boolean
    supervisors?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "examSessionId" | "subjectId" | "gradeId" | "sectionId" | "organizationId" | "maxMarks" | "passingMarks" | "weightage" | "evaluationType" | "mode" | "status" | "instructions" | "durationInMinutes" | "venueMapUrl" | "venue" | "isResultsPublished" | "supervisors" | "startDate" | "endDate" | "createdAt" | "updatedAt", ExtArgs["result"]["exam"]>
  export type ExamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examSession?: boolean | ExamSessionDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    hallTickets?: boolean | Exam$hallTicketsArgs<ExtArgs>
    examResult?: boolean | Exam$examResultArgs<ExtArgs>
    examEnrollment?: boolean | Exam$examEnrollmentArgs<ExtArgs>
    _count?: boolean | ExamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examSession?: boolean | ExamSessionDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type ExamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examSession?: boolean | ExamSessionDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $ExamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Exam"
    objects: {
      examSession: Prisma.$ExamSessionPayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs>
      organization: Prisma.$OrganizationPayload<ExtArgs>
      hallTickets: Prisma.$HallTicketPayload<ExtArgs>[]
      examResult: Prisma.$ExamResultPayload<ExtArgs>[]
      examEnrollment: Prisma.$ExamEnrollmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      examSessionId: string
      subjectId: string
      gradeId: string
      sectionId: string
      organizationId: string
      maxMarks: number
      passingMarks: number | null
      weightage: number | null
      evaluationType: $Enums.EvaluationType
      mode: $Enums.ExamMode
      status: $Enums.ExamStatus
      instructions: string | null
      durationInMinutes: number | null
      venueMapUrl: string | null
      venue: string | null
      isResultsPublished: boolean
      supervisors: string[]
      startDate: Date
      endDate: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["exam"]>
    composites: {}
  }

  type ExamGetPayload<S extends boolean | null | undefined | ExamDefaultArgs> = $Result.GetResult<Prisma.$ExamPayload, S>

  type ExamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExamCountAggregateInputType | true
    }

  export interface ExamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Exam'], meta: { name: 'Exam' } }
    /**
     * Find zero or one Exam that matches the filter.
     * @param {ExamFindUniqueArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamFindUniqueArgs>(args: SelectSubset<T, ExamFindUniqueArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Exam that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExamFindUniqueOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindFirstArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamFindFirstArgs>(args?: SelectSubset<T, ExamFindFirstArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exam that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindFirstOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exams
     * const exams = await prisma.exam.findMany()
     * 
     * // Get first 10 Exams
     * const exams = await prisma.exam.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examWithIdOnly = await prisma.exam.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamFindManyArgs>(args?: SelectSubset<T, ExamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Exam.
     * @param {ExamCreateArgs} args - Arguments to create a Exam.
     * @example
     * // Create one Exam
     * const Exam = await prisma.exam.create({
     *   data: {
     *     // ... data to create a Exam
     *   }
     * })
     * 
     */
    create<T extends ExamCreateArgs>(args: SelectSubset<T, ExamCreateArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Exams.
     * @param {ExamCreateManyArgs} args - Arguments to create many Exams.
     * @example
     * // Create many Exams
     * const exam = await prisma.exam.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamCreateManyArgs>(args?: SelectSubset<T, ExamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Exams and returns the data saved in the database.
     * @param {ExamCreateManyAndReturnArgs} args - Arguments to create many Exams.
     * @example
     * // Create many Exams
     * const exam = await prisma.exam.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Exams and only return the `id`
     * const examWithIdOnly = await prisma.exam.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExamCreateManyAndReturnArgs>(args?: SelectSubset<T, ExamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Exam.
     * @param {ExamDeleteArgs} args - Arguments to delete one Exam.
     * @example
     * // Delete one Exam
     * const Exam = await prisma.exam.delete({
     *   where: {
     *     // ... filter to delete one Exam
     *   }
     * })
     * 
     */
    delete<T extends ExamDeleteArgs>(args: SelectSubset<T, ExamDeleteArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Exam.
     * @param {ExamUpdateArgs} args - Arguments to update one Exam.
     * @example
     * // Update one Exam
     * const exam = await prisma.exam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamUpdateArgs>(args: SelectSubset<T, ExamUpdateArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Exams.
     * @param {ExamDeleteManyArgs} args - Arguments to filter Exams to delete.
     * @example
     * // Delete a few Exams
     * const { count } = await prisma.exam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamDeleteManyArgs>(args?: SelectSubset<T, ExamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exams
     * const exam = await prisma.exam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamUpdateManyArgs>(args: SelectSubset<T, ExamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exams and returns the data updated in the database.
     * @param {ExamUpdateManyAndReturnArgs} args - Arguments to update many Exams.
     * @example
     * // Update many Exams
     * const exam = await prisma.exam.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Exams and only return the `id`
     * const examWithIdOnly = await prisma.exam.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExamUpdateManyAndReturnArgs>(args: SelectSubset<T, ExamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Exam.
     * @param {ExamUpsertArgs} args - Arguments to update or create a Exam.
     * @example
     * // Update or create a Exam
     * const exam = await prisma.exam.upsert({
     *   create: {
     *     // ... data to create a Exam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exam we want to update
     *   }
     * })
     */
    upsert<T extends ExamUpsertArgs>(args: SelectSubset<T, ExamUpsertArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamCountArgs} args - Arguments to filter Exams to count.
     * @example
     * // Count the number of Exams
     * const count = await prisma.exam.count({
     *   where: {
     *     // ... the filter for the Exams we want to count
     *   }
     * })
    **/
    count<T extends ExamCountArgs>(
      args?: Subset<T, ExamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamAggregateArgs>(args: Subset<T, ExamAggregateArgs>): Prisma.PrismaPromise<GetExamAggregateType<T>>

    /**
     * Group by Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamGroupByArgs['orderBy'] }
        : { orderBy?: ExamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Exam model
   */
  readonly fields: ExamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Exam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    examSession<T extends ExamSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamSessionDefaultArgs<ExtArgs>>): Prisma__ExamSessionClient<$Result.GetResult<Prisma.$ExamSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    hallTickets<T extends Exam$hallTicketsArgs<ExtArgs> = {}>(args?: Subset<T, Exam$hallTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HallTicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    examResult<T extends Exam$examResultArgs<ExtArgs> = {}>(args?: Subset<T, Exam$examResultArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    examEnrollment<T extends Exam$examEnrollmentArgs<ExtArgs> = {}>(args?: Subset<T, Exam$examEnrollmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Exam model
   */
  interface ExamFieldRefs {
    readonly id: FieldRef<"Exam", 'String'>
    readonly title: FieldRef<"Exam", 'String'>
    readonly description: FieldRef<"Exam", 'String'>
    readonly examSessionId: FieldRef<"Exam", 'String'>
    readonly subjectId: FieldRef<"Exam", 'String'>
    readonly gradeId: FieldRef<"Exam", 'String'>
    readonly sectionId: FieldRef<"Exam", 'String'>
    readonly organizationId: FieldRef<"Exam", 'String'>
    readonly maxMarks: FieldRef<"Exam", 'Float'>
    readonly passingMarks: FieldRef<"Exam", 'Float'>
    readonly weightage: FieldRef<"Exam", 'Float'>
    readonly evaluationType: FieldRef<"Exam", 'EvaluationType'>
    readonly mode: FieldRef<"Exam", 'ExamMode'>
    readonly status: FieldRef<"Exam", 'ExamStatus'>
    readonly instructions: FieldRef<"Exam", 'String'>
    readonly durationInMinutes: FieldRef<"Exam", 'Int'>
    readonly venueMapUrl: FieldRef<"Exam", 'String'>
    readonly venue: FieldRef<"Exam", 'String'>
    readonly isResultsPublished: FieldRef<"Exam", 'Boolean'>
    readonly supervisors: FieldRef<"Exam", 'String[]'>
    readonly startDate: FieldRef<"Exam", 'DateTime'>
    readonly endDate: FieldRef<"Exam", 'DateTime'>
    readonly createdAt: FieldRef<"Exam", 'DateTime'>
    readonly updatedAt: FieldRef<"Exam", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Exam findUnique
   */
  export type ExamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam findUniqueOrThrow
   */
  export type ExamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam findFirst
   */
  export type ExamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exams.
     */
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam findFirstOrThrow
   */
  export type ExamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exams.
     */
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam findMany
   */
  export type ExamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exams to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam create
   */
  export type ExamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The data needed to create a Exam.
     */
    data: XOR<ExamCreateInput, ExamUncheckedCreateInput>
  }

  /**
   * Exam createMany
   */
  export type ExamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exams.
     */
    data: ExamCreateManyInput | ExamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Exam createManyAndReturn
   */
  export type ExamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * The data used to create many Exams.
     */
    data: ExamCreateManyInput | ExamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Exam update
   */
  export type ExamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The data needed to update a Exam.
     */
    data: XOR<ExamUpdateInput, ExamUncheckedUpdateInput>
    /**
     * Choose, which Exam to update.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam updateMany
   */
  export type ExamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exams.
     */
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyInput>
    /**
     * Filter which Exams to update
     */
    where?: ExamWhereInput
    /**
     * Limit how many Exams to update.
     */
    limit?: number
  }

  /**
   * Exam updateManyAndReturn
   */
  export type ExamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * The data used to update Exams.
     */
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyInput>
    /**
     * Filter which Exams to update
     */
    where?: ExamWhereInput
    /**
     * Limit how many Exams to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Exam upsert
   */
  export type ExamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The filter to search for the Exam to update in case it exists.
     */
    where: ExamWhereUniqueInput
    /**
     * In case the Exam found by the `where` argument doesn't exist, create a new Exam with this data.
     */
    create: XOR<ExamCreateInput, ExamUncheckedCreateInput>
    /**
     * In case the Exam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamUpdateInput, ExamUncheckedUpdateInput>
  }

  /**
   * Exam delete
   */
  export type ExamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter which Exam to delete.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam deleteMany
   */
  export type ExamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exams to delete
     */
    where?: ExamWhereInput
    /**
     * Limit how many Exams to delete.
     */
    limit?: number
  }

  /**
   * Exam.hallTickets
   */
  export type Exam$hallTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HallTicket
     */
    select?: HallTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HallTicket
     */
    omit?: HallTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallTicketInclude<ExtArgs> | null
    where?: HallTicketWhereInput
    orderBy?: HallTicketOrderByWithRelationInput | HallTicketOrderByWithRelationInput[]
    cursor?: HallTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HallTicketScalarFieldEnum | HallTicketScalarFieldEnum[]
  }

  /**
   * Exam.examResult
   */
  export type Exam$examResultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamResult
     */
    select?: ExamResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamResult
     */
    omit?: ExamResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamResultInclude<ExtArgs> | null
    where?: ExamResultWhereInput
    orderBy?: ExamResultOrderByWithRelationInput | ExamResultOrderByWithRelationInput[]
    cursor?: ExamResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamResultScalarFieldEnum | ExamResultScalarFieldEnum[]
  }

  /**
   * Exam.examEnrollment
   */
  export type Exam$examEnrollmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamEnrollment
     */
    select?: ExamEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamEnrollment
     */
    omit?: ExamEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamEnrollmentInclude<ExtArgs> | null
    where?: ExamEnrollmentWhereInput
    orderBy?: ExamEnrollmentOrderByWithRelationInput | ExamEnrollmentOrderByWithRelationInput[]
    cursor?: ExamEnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamEnrollmentScalarFieldEnum | ExamEnrollmentScalarFieldEnum[]
  }

  /**
   * Exam without action
   */
  export type ExamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
  }


  /**
   * Model ExamEnrollment
   */

  export type AggregateExamEnrollment = {
    _count: ExamEnrollmentCountAggregateOutputType | null
    _min: ExamEnrollmentMinAggregateOutputType | null
    _max: ExamEnrollmentMaxAggregateOutputType | null
  }

  export type ExamEnrollmentMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    examId: string | null
    status: $Enums.StudentExamStatus | null
    enrolledAt: Date | null
    exemptionReason: string | null
  }

  export type ExamEnrollmentMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    examId: string | null
    status: $Enums.StudentExamStatus | null
    enrolledAt: Date | null
    exemptionReason: string | null
  }

  export type ExamEnrollmentCountAggregateOutputType = {
    id: number
    studentId: number
    examId: number
    status: number
    enrolledAt: number
    exemptionReason: number
    _all: number
  }


  export type ExamEnrollmentMinAggregateInputType = {
    id?: true
    studentId?: true
    examId?: true
    status?: true
    enrolledAt?: true
    exemptionReason?: true
  }

  export type ExamEnrollmentMaxAggregateInputType = {
    id?: true
    studentId?: true
    examId?: true
    status?: true
    enrolledAt?: true
    exemptionReason?: true
  }

  export type ExamEnrollmentCountAggregateInputType = {
    id?: true
    studentId?: true
    examId?: true
    status?: true
    enrolledAt?: true
    exemptionReason?: true
    _all?: true
  }

  export type ExamEnrollmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamEnrollment to aggregate.
     */
    where?: ExamEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamEnrollments to fetch.
     */
    orderBy?: ExamEnrollmentOrderByWithRelationInput | ExamEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExamEnrollments
    **/
    _count?: true | ExamEnrollmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamEnrollmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamEnrollmentMaxAggregateInputType
  }

  export type GetExamEnrollmentAggregateType<T extends ExamEnrollmentAggregateArgs> = {
        [P in keyof T & keyof AggregateExamEnrollment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamEnrollment[P]>
      : GetScalarType<T[P], AggregateExamEnrollment[P]>
  }




  export type ExamEnrollmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamEnrollmentWhereInput
    orderBy?: ExamEnrollmentOrderByWithAggregationInput | ExamEnrollmentOrderByWithAggregationInput[]
    by: ExamEnrollmentScalarFieldEnum[] | ExamEnrollmentScalarFieldEnum
    having?: ExamEnrollmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamEnrollmentCountAggregateInputType | true
    _min?: ExamEnrollmentMinAggregateInputType
    _max?: ExamEnrollmentMaxAggregateInputType
  }

  export type ExamEnrollmentGroupByOutputType = {
    id: string
    studentId: string
    examId: string
    status: $Enums.StudentExamStatus
    enrolledAt: Date
    exemptionReason: string | null
    _count: ExamEnrollmentCountAggregateOutputType | null
    _min: ExamEnrollmentMinAggregateOutputType | null
    _max: ExamEnrollmentMaxAggregateOutputType | null
  }

  type GetExamEnrollmentGroupByPayload<T extends ExamEnrollmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamEnrollmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamEnrollmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamEnrollmentGroupByOutputType[P]>
            : GetScalarType<T[P], ExamEnrollmentGroupByOutputType[P]>
        }
      >
    >


  export type ExamEnrollmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    examId?: boolean
    status?: boolean
    enrolledAt?: boolean
    exemptionReason?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examEnrollment"]>

  export type ExamEnrollmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    examId?: boolean
    status?: boolean
    enrolledAt?: boolean
    exemptionReason?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examEnrollment"]>

  export type ExamEnrollmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    examId?: boolean
    status?: boolean
    enrolledAt?: boolean
    exemptionReason?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examEnrollment"]>

  export type ExamEnrollmentSelectScalar = {
    id?: boolean
    studentId?: boolean
    examId?: boolean
    status?: boolean
    enrolledAt?: boolean
    exemptionReason?: boolean
  }

  export type ExamEnrollmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "examId" | "status" | "enrolledAt" | "exemptionReason", ExtArgs["result"]["examEnrollment"]>
  export type ExamEnrollmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
  }
  export type ExamEnrollmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
  }
  export type ExamEnrollmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
  }

  export type $ExamEnrollmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExamEnrollment"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      exam: Prisma.$ExamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      examId: string
      status: $Enums.StudentExamStatus
      enrolledAt: Date
      exemptionReason: string | null
    }, ExtArgs["result"]["examEnrollment"]>
    composites: {}
  }

  type ExamEnrollmentGetPayload<S extends boolean | null | undefined | ExamEnrollmentDefaultArgs> = $Result.GetResult<Prisma.$ExamEnrollmentPayload, S>

  type ExamEnrollmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExamEnrollmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExamEnrollmentCountAggregateInputType | true
    }

  export interface ExamEnrollmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExamEnrollment'], meta: { name: 'ExamEnrollment' } }
    /**
     * Find zero or one ExamEnrollment that matches the filter.
     * @param {ExamEnrollmentFindUniqueArgs} args - Arguments to find a ExamEnrollment
     * @example
     * // Get one ExamEnrollment
     * const examEnrollment = await prisma.examEnrollment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamEnrollmentFindUniqueArgs>(args: SelectSubset<T, ExamEnrollmentFindUniqueArgs<ExtArgs>>): Prisma__ExamEnrollmentClient<$Result.GetResult<Prisma.$ExamEnrollmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExamEnrollment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExamEnrollmentFindUniqueOrThrowArgs} args - Arguments to find a ExamEnrollment
     * @example
     * // Get one ExamEnrollment
     * const examEnrollment = await prisma.examEnrollment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamEnrollmentFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamEnrollmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamEnrollmentClient<$Result.GetResult<Prisma.$ExamEnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamEnrollment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamEnrollmentFindFirstArgs} args - Arguments to find a ExamEnrollment
     * @example
     * // Get one ExamEnrollment
     * const examEnrollment = await prisma.examEnrollment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamEnrollmentFindFirstArgs>(args?: SelectSubset<T, ExamEnrollmentFindFirstArgs<ExtArgs>>): Prisma__ExamEnrollmentClient<$Result.GetResult<Prisma.$ExamEnrollmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamEnrollment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamEnrollmentFindFirstOrThrowArgs} args - Arguments to find a ExamEnrollment
     * @example
     * // Get one ExamEnrollment
     * const examEnrollment = await prisma.examEnrollment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamEnrollmentFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamEnrollmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamEnrollmentClient<$Result.GetResult<Prisma.$ExamEnrollmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExamEnrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamEnrollmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamEnrollments
     * const examEnrollments = await prisma.examEnrollment.findMany()
     * 
     * // Get first 10 ExamEnrollments
     * const examEnrollments = await prisma.examEnrollment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examEnrollmentWithIdOnly = await prisma.examEnrollment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamEnrollmentFindManyArgs>(args?: SelectSubset<T, ExamEnrollmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExamEnrollment.
     * @param {ExamEnrollmentCreateArgs} args - Arguments to create a ExamEnrollment.
     * @example
     * // Create one ExamEnrollment
     * const ExamEnrollment = await prisma.examEnrollment.create({
     *   data: {
     *     // ... data to create a ExamEnrollment
     *   }
     * })
     * 
     */
    create<T extends ExamEnrollmentCreateArgs>(args: SelectSubset<T, ExamEnrollmentCreateArgs<ExtArgs>>): Prisma__ExamEnrollmentClient<$Result.GetResult<Prisma.$ExamEnrollmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExamEnrollments.
     * @param {ExamEnrollmentCreateManyArgs} args - Arguments to create many ExamEnrollments.
     * @example
     * // Create many ExamEnrollments
     * const examEnrollment = await prisma.examEnrollment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamEnrollmentCreateManyArgs>(args?: SelectSubset<T, ExamEnrollmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExamEnrollments and returns the data saved in the database.
     * @param {ExamEnrollmentCreateManyAndReturnArgs} args - Arguments to create many ExamEnrollments.
     * @example
     * // Create many ExamEnrollments
     * const examEnrollment = await prisma.examEnrollment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExamEnrollments and only return the `id`
     * const examEnrollmentWithIdOnly = await prisma.examEnrollment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExamEnrollmentCreateManyAndReturnArgs>(args?: SelectSubset<T, ExamEnrollmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamEnrollmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExamEnrollment.
     * @param {ExamEnrollmentDeleteArgs} args - Arguments to delete one ExamEnrollment.
     * @example
     * // Delete one ExamEnrollment
     * const ExamEnrollment = await prisma.examEnrollment.delete({
     *   where: {
     *     // ... filter to delete one ExamEnrollment
     *   }
     * })
     * 
     */
    delete<T extends ExamEnrollmentDeleteArgs>(args: SelectSubset<T, ExamEnrollmentDeleteArgs<ExtArgs>>): Prisma__ExamEnrollmentClient<$Result.GetResult<Prisma.$ExamEnrollmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExamEnrollment.
     * @param {ExamEnrollmentUpdateArgs} args - Arguments to update one ExamEnrollment.
     * @example
     * // Update one ExamEnrollment
     * const examEnrollment = await prisma.examEnrollment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamEnrollmentUpdateArgs>(args: SelectSubset<T, ExamEnrollmentUpdateArgs<ExtArgs>>): Prisma__ExamEnrollmentClient<$Result.GetResult<Prisma.$ExamEnrollmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExamEnrollments.
     * @param {ExamEnrollmentDeleteManyArgs} args - Arguments to filter ExamEnrollments to delete.
     * @example
     * // Delete a few ExamEnrollments
     * const { count } = await prisma.examEnrollment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamEnrollmentDeleteManyArgs>(args?: SelectSubset<T, ExamEnrollmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamEnrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamEnrollmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamEnrollments
     * const examEnrollment = await prisma.examEnrollment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamEnrollmentUpdateManyArgs>(args: SelectSubset<T, ExamEnrollmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamEnrollments and returns the data updated in the database.
     * @param {ExamEnrollmentUpdateManyAndReturnArgs} args - Arguments to update many ExamEnrollments.
     * @example
     * // Update many ExamEnrollments
     * const examEnrollment = await prisma.examEnrollment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExamEnrollments and only return the `id`
     * const examEnrollmentWithIdOnly = await prisma.examEnrollment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExamEnrollmentUpdateManyAndReturnArgs>(args: SelectSubset<T, ExamEnrollmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamEnrollmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExamEnrollment.
     * @param {ExamEnrollmentUpsertArgs} args - Arguments to update or create a ExamEnrollment.
     * @example
     * // Update or create a ExamEnrollment
     * const examEnrollment = await prisma.examEnrollment.upsert({
     *   create: {
     *     // ... data to create a ExamEnrollment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamEnrollment we want to update
     *   }
     * })
     */
    upsert<T extends ExamEnrollmentUpsertArgs>(args: SelectSubset<T, ExamEnrollmentUpsertArgs<ExtArgs>>): Prisma__ExamEnrollmentClient<$Result.GetResult<Prisma.$ExamEnrollmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExamEnrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamEnrollmentCountArgs} args - Arguments to filter ExamEnrollments to count.
     * @example
     * // Count the number of ExamEnrollments
     * const count = await prisma.examEnrollment.count({
     *   where: {
     *     // ... the filter for the ExamEnrollments we want to count
     *   }
     * })
    **/
    count<T extends ExamEnrollmentCountArgs>(
      args?: Subset<T, ExamEnrollmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamEnrollmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamEnrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamEnrollmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamEnrollmentAggregateArgs>(args: Subset<T, ExamEnrollmentAggregateArgs>): Prisma.PrismaPromise<GetExamEnrollmentAggregateType<T>>

    /**
     * Group by ExamEnrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamEnrollmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamEnrollmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamEnrollmentGroupByArgs['orderBy'] }
        : { orderBy?: ExamEnrollmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamEnrollmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamEnrollmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExamEnrollment model
   */
  readonly fields: ExamEnrollmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExamEnrollment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamEnrollmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    exam<T extends ExamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamDefaultArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExamEnrollment model
   */
  interface ExamEnrollmentFieldRefs {
    readonly id: FieldRef<"ExamEnrollment", 'String'>
    readonly studentId: FieldRef<"ExamEnrollment", 'String'>
    readonly examId: FieldRef<"ExamEnrollment", 'String'>
    readonly status: FieldRef<"ExamEnrollment", 'StudentExamStatus'>
    readonly enrolledAt: FieldRef<"ExamEnrollment", 'DateTime'>
    readonly exemptionReason: FieldRef<"ExamEnrollment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ExamEnrollment findUnique
   */
  export type ExamEnrollmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamEnrollment
     */
    select?: ExamEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamEnrollment
     */
    omit?: ExamEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which ExamEnrollment to fetch.
     */
    where: ExamEnrollmentWhereUniqueInput
  }

  /**
   * ExamEnrollment findUniqueOrThrow
   */
  export type ExamEnrollmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamEnrollment
     */
    select?: ExamEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamEnrollment
     */
    omit?: ExamEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which ExamEnrollment to fetch.
     */
    where: ExamEnrollmentWhereUniqueInput
  }

  /**
   * ExamEnrollment findFirst
   */
  export type ExamEnrollmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamEnrollment
     */
    select?: ExamEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamEnrollment
     */
    omit?: ExamEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which ExamEnrollment to fetch.
     */
    where?: ExamEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamEnrollments to fetch.
     */
    orderBy?: ExamEnrollmentOrderByWithRelationInput | ExamEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamEnrollments.
     */
    cursor?: ExamEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamEnrollments.
     */
    distinct?: ExamEnrollmentScalarFieldEnum | ExamEnrollmentScalarFieldEnum[]
  }

  /**
   * ExamEnrollment findFirstOrThrow
   */
  export type ExamEnrollmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamEnrollment
     */
    select?: ExamEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamEnrollment
     */
    omit?: ExamEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which ExamEnrollment to fetch.
     */
    where?: ExamEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamEnrollments to fetch.
     */
    orderBy?: ExamEnrollmentOrderByWithRelationInput | ExamEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamEnrollments.
     */
    cursor?: ExamEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamEnrollments.
     */
    distinct?: ExamEnrollmentScalarFieldEnum | ExamEnrollmentScalarFieldEnum[]
  }

  /**
   * ExamEnrollment findMany
   */
  export type ExamEnrollmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamEnrollment
     */
    select?: ExamEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamEnrollment
     */
    omit?: ExamEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which ExamEnrollments to fetch.
     */
    where?: ExamEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamEnrollments to fetch.
     */
    orderBy?: ExamEnrollmentOrderByWithRelationInput | ExamEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExamEnrollments.
     */
    cursor?: ExamEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamEnrollments.
     */
    skip?: number
    distinct?: ExamEnrollmentScalarFieldEnum | ExamEnrollmentScalarFieldEnum[]
  }

  /**
   * ExamEnrollment create
   */
  export type ExamEnrollmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamEnrollment
     */
    select?: ExamEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamEnrollment
     */
    omit?: ExamEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamEnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to create a ExamEnrollment.
     */
    data: XOR<ExamEnrollmentCreateInput, ExamEnrollmentUncheckedCreateInput>
  }

  /**
   * ExamEnrollment createMany
   */
  export type ExamEnrollmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExamEnrollments.
     */
    data: ExamEnrollmentCreateManyInput | ExamEnrollmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExamEnrollment createManyAndReturn
   */
  export type ExamEnrollmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamEnrollment
     */
    select?: ExamEnrollmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamEnrollment
     */
    omit?: ExamEnrollmentOmit<ExtArgs> | null
    /**
     * The data used to create many ExamEnrollments.
     */
    data: ExamEnrollmentCreateManyInput | ExamEnrollmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamEnrollmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamEnrollment update
   */
  export type ExamEnrollmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamEnrollment
     */
    select?: ExamEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamEnrollment
     */
    omit?: ExamEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamEnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to update a ExamEnrollment.
     */
    data: XOR<ExamEnrollmentUpdateInput, ExamEnrollmentUncheckedUpdateInput>
    /**
     * Choose, which ExamEnrollment to update.
     */
    where: ExamEnrollmentWhereUniqueInput
  }

  /**
   * ExamEnrollment updateMany
   */
  export type ExamEnrollmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExamEnrollments.
     */
    data: XOR<ExamEnrollmentUpdateManyMutationInput, ExamEnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which ExamEnrollments to update
     */
    where?: ExamEnrollmentWhereInput
    /**
     * Limit how many ExamEnrollments to update.
     */
    limit?: number
  }

  /**
   * ExamEnrollment updateManyAndReturn
   */
  export type ExamEnrollmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamEnrollment
     */
    select?: ExamEnrollmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamEnrollment
     */
    omit?: ExamEnrollmentOmit<ExtArgs> | null
    /**
     * The data used to update ExamEnrollments.
     */
    data: XOR<ExamEnrollmentUpdateManyMutationInput, ExamEnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which ExamEnrollments to update
     */
    where?: ExamEnrollmentWhereInput
    /**
     * Limit how many ExamEnrollments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamEnrollmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamEnrollment upsert
   */
  export type ExamEnrollmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamEnrollment
     */
    select?: ExamEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamEnrollment
     */
    omit?: ExamEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamEnrollmentInclude<ExtArgs> | null
    /**
     * The filter to search for the ExamEnrollment to update in case it exists.
     */
    where: ExamEnrollmentWhereUniqueInput
    /**
     * In case the ExamEnrollment found by the `where` argument doesn't exist, create a new ExamEnrollment with this data.
     */
    create: XOR<ExamEnrollmentCreateInput, ExamEnrollmentUncheckedCreateInput>
    /**
     * In case the ExamEnrollment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamEnrollmentUpdateInput, ExamEnrollmentUncheckedUpdateInput>
  }

  /**
   * ExamEnrollment delete
   */
  export type ExamEnrollmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamEnrollment
     */
    select?: ExamEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamEnrollment
     */
    omit?: ExamEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamEnrollmentInclude<ExtArgs> | null
    /**
     * Filter which ExamEnrollment to delete.
     */
    where: ExamEnrollmentWhereUniqueInput
  }

  /**
   * ExamEnrollment deleteMany
   */
  export type ExamEnrollmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamEnrollments to delete
     */
    where?: ExamEnrollmentWhereInput
    /**
     * Limit how many ExamEnrollments to delete.
     */
    limit?: number
  }

  /**
   * ExamEnrollment without action
   */
  export type ExamEnrollmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamEnrollment
     */
    select?: ExamEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamEnrollment
     */
    omit?: ExamEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamEnrollmentInclude<ExtArgs> | null
  }


  /**
   * Model ExamResult
   */

  export type AggregateExamResult = {
    _count: ExamResultCountAggregateOutputType | null
    _avg: ExamResultAvgAggregateOutputType | null
    _sum: ExamResultSumAggregateOutputType | null
    _min: ExamResultMinAggregateOutputType | null
    _max: ExamResultMaxAggregateOutputType | null
  }

  export type ExamResultAvgAggregateOutputType = {
    maxMarks: number | null
    obtainedMarks: number | null
    percentage: number | null
  }

  export type ExamResultSumAggregateOutputType = {
    maxMarks: number | null
    obtainedMarks: number | null
    percentage: number | null
  }

  export type ExamResultMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    examId: string | null
    subjectId: string | null
    maxMarks: number | null
    obtainedMarks: number | null
    percentage: number | null
    gradeLabel: string | null
    remarks: string | null
    isPassed: boolean | null
    isAbsent: boolean | null
    isResultsPublished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamResultMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    examId: string | null
    subjectId: string | null
    maxMarks: number | null
    obtainedMarks: number | null
    percentage: number | null
    gradeLabel: string | null
    remarks: string | null
    isPassed: boolean | null
    isAbsent: boolean | null
    isResultsPublished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamResultCountAggregateOutputType = {
    id: number
    studentId: number
    examId: number
    subjectId: number
    maxMarks: number
    obtainedMarks: number
    percentage: number
    gradeLabel: number
    remarks: number
    isPassed: number
    isAbsent: number
    isResultsPublished: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExamResultAvgAggregateInputType = {
    maxMarks?: true
    obtainedMarks?: true
    percentage?: true
  }

  export type ExamResultSumAggregateInputType = {
    maxMarks?: true
    obtainedMarks?: true
    percentage?: true
  }

  export type ExamResultMinAggregateInputType = {
    id?: true
    studentId?: true
    examId?: true
    subjectId?: true
    maxMarks?: true
    obtainedMarks?: true
    percentage?: true
    gradeLabel?: true
    remarks?: true
    isPassed?: true
    isAbsent?: true
    isResultsPublished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamResultMaxAggregateInputType = {
    id?: true
    studentId?: true
    examId?: true
    subjectId?: true
    maxMarks?: true
    obtainedMarks?: true
    percentage?: true
    gradeLabel?: true
    remarks?: true
    isPassed?: true
    isAbsent?: true
    isResultsPublished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamResultCountAggregateInputType = {
    id?: true
    studentId?: true
    examId?: true
    subjectId?: true
    maxMarks?: true
    obtainedMarks?: true
    percentage?: true
    gradeLabel?: true
    remarks?: true
    isPassed?: true
    isAbsent?: true
    isResultsPublished?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExamResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamResult to aggregate.
     */
    where?: ExamResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamResults to fetch.
     */
    orderBy?: ExamResultOrderByWithRelationInput | ExamResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExamResults
    **/
    _count?: true | ExamResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamResultMaxAggregateInputType
  }

  export type GetExamResultAggregateType<T extends ExamResultAggregateArgs> = {
        [P in keyof T & keyof AggregateExamResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamResult[P]>
      : GetScalarType<T[P], AggregateExamResult[P]>
  }




  export type ExamResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamResultWhereInput
    orderBy?: ExamResultOrderByWithAggregationInput | ExamResultOrderByWithAggregationInput[]
    by: ExamResultScalarFieldEnum[] | ExamResultScalarFieldEnum
    having?: ExamResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamResultCountAggregateInputType | true
    _avg?: ExamResultAvgAggregateInputType
    _sum?: ExamResultSumAggregateInputType
    _min?: ExamResultMinAggregateInputType
    _max?: ExamResultMaxAggregateInputType
  }

  export type ExamResultGroupByOutputType = {
    id: string
    studentId: string
    examId: string
    subjectId: string | null
    maxMarks: number
    obtainedMarks: number | null
    percentage: number | null
    gradeLabel: string | null
    remarks: string | null
    isPassed: boolean | null
    isAbsent: boolean
    isResultsPublished: boolean
    createdAt: Date
    updatedAt: Date
    _count: ExamResultCountAggregateOutputType | null
    _avg: ExamResultAvgAggregateOutputType | null
    _sum: ExamResultSumAggregateOutputType | null
    _min: ExamResultMinAggregateOutputType | null
    _max: ExamResultMaxAggregateOutputType | null
  }

  type GetExamResultGroupByPayload<T extends ExamResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamResultGroupByOutputType[P]>
            : GetScalarType<T[P], ExamResultGroupByOutputType[P]>
        }
      >
    >


  export type ExamResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    examId?: boolean
    subjectId?: boolean
    maxMarks?: boolean
    obtainedMarks?: boolean
    percentage?: boolean
    gradeLabel?: boolean
    remarks?: boolean
    isPassed?: boolean
    isAbsent?: boolean
    isResultsPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    subject?: boolean | ExamResult$subjectArgs<ExtArgs>
  }, ExtArgs["result"]["examResult"]>

  export type ExamResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    examId?: boolean
    subjectId?: boolean
    maxMarks?: boolean
    obtainedMarks?: boolean
    percentage?: boolean
    gradeLabel?: boolean
    remarks?: boolean
    isPassed?: boolean
    isAbsent?: boolean
    isResultsPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    subject?: boolean | ExamResult$subjectArgs<ExtArgs>
  }, ExtArgs["result"]["examResult"]>

  export type ExamResultSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    examId?: boolean
    subjectId?: boolean
    maxMarks?: boolean
    obtainedMarks?: boolean
    percentage?: boolean
    gradeLabel?: boolean
    remarks?: boolean
    isPassed?: boolean
    isAbsent?: boolean
    isResultsPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    subject?: boolean | ExamResult$subjectArgs<ExtArgs>
  }, ExtArgs["result"]["examResult"]>

  export type ExamResultSelectScalar = {
    id?: boolean
    studentId?: boolean
    examId?: boolean
    subjectId?: boolean
    maxMarks?: boolean
    obtainedMarks?: boolean
    percentage?: boolean
    gradeLabel?: boolean
    remarks?: boolean
    isPassed?: boolean
    isAbsent?: boolean
    isResultsPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExamResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "examId" | "subjectId" | "maxMarks" | "obtainedMarks" | "percentage" | "gradeLabel" | "remarks" | "isPassed" | "isAbsent" | "isResultsPublished" | "createdAt" | "updatedAt", ExtArgs["result"]["examResult"]>
  export type ExamResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    subject?: boolean | ExamResult$subjectArgs<ExtArgs>
  }
  export type ExamResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    subject?: boolean | ExamResult$subjectArgs<ExtArgs>
  }
  export type ExamResultIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    subject?: boolean | ExamResult$subjectArgs<ExtArgs>
  }

  export type $ExamResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExamResult"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      exam: Prisma.$ExamPayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      examId: string
      subjectId: string | null
      maxMarks: number
      obtainedMarks: number | null
      percentage: number | null
      gradeLabel: string | null
      remarks: string | null
      isPassed: boolean | null
      isAbsent: boolean
      isResultsPublished: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["examResult"]>
    composites: {}
  }

  type ExamResultGetPayload<S extends boolean | null | undefined | ExamResultDefaultArgs> = $Result.GetResult<Prisma.$ExamResultPayload, S>

  type ExamResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExamResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExamResultCountAggregateInputType | true
    }

  export interface ExamResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExamResult'], meta: { name: 'ExamResult' } }
    /**
     * Find zero or one ExamResult that matches the filter.
     * @param {ExamResultFindUniqueArgs} args - Arguments to find a ExamResult
     * @example
     * // Get one ExamResult
     * const examResult = await prisma.examResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamResultFindUniqueArgs>(args: SelectSubset<T, ExamResultFindUniqueArgs<ExtArgs>>): Prisma__ExamResultClient<$Result.GetResult<Prisma.$ExamResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExamResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExamResultFindUniqueOrThrowArgs} args - Arguments to find a ExamResult
     * @example
     * // Get one ExamResult
     * const examResult = await prisma.examResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamResultFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamResultClient<$Result.GetResult<Prisma.$ExamResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamResultFindFirstArgs} args - Arguments to find a ExamResult
     * @example
     * // Get one ExamResult
     * const examResult = await prisma.examResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamResultFindFirstArgs>(args?: SelectSubset<T, ExamResultFindFirstArgs<ExtArgs>>): Prisma__ExamResultClient<$Result.GetResult<Prisma.$ExamResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamResultFindFirstOrThrowArgs} args - Arguments to find a ExamResult
     * @example
     * // Get one ExamResult
     * const examResult = await prisma.examResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamResultFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamResultClient<$Result.GetResult<Prisma.$ExamResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExamResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamResults
     * const examResults = await prisma.examResult.findMany()
     * 
     * // Get first 10 ExamResults
     * const examResults = await prisma.examResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examResultWithIdOnly = await prisma.examResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamResultFindManyArgs>(args?: SelectSubset<T, ExamResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExamResult.
     * @param {ExamResultCreateArgs} args - Arguments to create a ExamResult.
     * @example
     * // Create one ExamResult
     * const ExamResult = await prisma.examResult.create({
     *   data: {
     *     // ... data to create a ExamResult
     *   }
     * })
     * 
     */
    create<T extends ExamResultCreateArgs>(args: SelectSubset<T, ExamResultCreateArgs<ExtArgs>>): Prisma__ExamResultClient<$Result.GetResult<Prisma.$ExamResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExamResults.
     * @param {ExamResultCreateManyArgs} args - Arguments to create many ExamResults.
     * @example
     * // Create many ExamResults
     * const examResult = await prisma.examResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamResultCreateManyArgs>(args?: SelectSubset<T, ExamResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExamResults and returns the data saved in the database.
     * @param {ExamResultCreateManyAndReturnArgs} args - Arguments to create many ExamResults.
     * @example
     * // Create many ExamResults
     * const examResult = await prisma.examResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExamResults and only return the `id`
     * const examResultWithIdOnly = await prisma.examResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExamResultCreateManyAndReturnArgs>(args?: SelectSubset<T, ExamResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExamResult.
     * @param {ExamResultDeleteArgs} args - Arguments to delete one ExamResult.
     * @example
     * // Delete one ExamResult
     * const ExamResult = await prisma.examResult.delete({
     *   where: {
     *     // ... filter to delete one ExamResult
     *   }
     * })
     * 
     */
    delete<T extends ExamResultDeleteArgs>(args: SelectSubset<T, ExamResultDeleteArgs<ExtArgs>>): Prisma__ExamResultClient<$Result.GetResult<Prisma.$ExamResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExamResult.
     * @param {ExamResultUpdateArgs} args - Arguments to update one ExamResult.
     * @example
     * // Update one ExamResult
     * const examResult = await prisma.examResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamResultUpdateArgs>(args: SelectSubset<T, ExamResultUpdateArgs<ExtArgs>>): Prisma__ExamResultClient<$Result.GetResult<Prisma.$ExamResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExamResults.
     * @param {ExamResultDeleteManyArgs} args - Arguments to filter ExamResults to delete.
     * @example
     * // Delete a few ExamResults
     * const { count } = await prisma.examResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamResultDeleteManyArgs>(args?: SelectSubset<T, ExamResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamResults
     * const examResult = await prisma.examResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamResultUpdateManyArgs>(args: SelectSubset<T, ExamResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamResults and returns the data updated in the database.
     * @param {ExamResultUpdateManyAndReturnArgs} args - Arguments to update many ExamResults.
     * @example
     * // Update many ExamResults
     * const examResult = await prisma.examResult.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExamResults and only return the `id`
     * const examResultWithIdOnly = await prisma.examResult.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExamResultUpdateManyAndReturnArgs>(args: SelectSubset<T, ExamResultUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamResultPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExamResult.
     * @param {ExamResultUpsertArgs} args - Arguments to update or create a ExamResult.
     * @example
     * // Update or create a ExamResult
     * const examResult = await prisma.examResult.upsert({
     *   create: {
     *     // ... data to create a ExamResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamResult we want to update
     *   }
     * })
     */
    upsert<T extends ExamResultUpsertArgs>(args: SelectSubset<T, ExamResultUpsertArgs<ExtArgs>>): Prisma__ExamResultClient<$Result.GetResult<Prisma.$ExamResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExamResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamResultCountArgs} args - Arguments to filter ExamResults to count.
     * @example
     * // Count the number of ExamResults
     * const count = await prisma.examResult.count({
     *   where: {
     *     // ... the filter for the ExamResults we want to count
     *   }
     * })
    **/
    count<T extends ExamResultCountArgs>(
      args?: Subset<T, ExamResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamResultAggregateArgs>(args: Subset<T, ExamResultAggregateArgs>): Prisma.PrismaPromise<GetExamResultAggregateType<T>>

    /**
     * Group by ExamResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamResultGroupByArgs['orderBy'] }
        : { orderBy?: ExamResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExamResult model
   */
  readonly fields: ExamResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExamResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    exam<T extends ExamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamDefaultArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subject<T extends ExamResult$subjectArgs<ExtArgs> = {}>(args?: Subset<T, ExamResult$subjectArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExamResult model
   */
  interface ExamResultFieldRefs {
    readonly id: FieldRef<"ExamResult", 'String'>
    readonly studentId: FieldRef<"ExamResult", 'String'>
    readonly examId: FieldRef<"ExamResult", 'String'>
    readonly subjectId: FieldRef<"ExamResult", 'String'>
    readonly maxMarks: FieldRef<"ExamResult", 'Float'>
    readonly obtainedMarks: FieldRef<"ExamResult", 'Float'>
    readonly percentage: FieldRef<"ExamResult", 'Float'>
    readonly gradeLabel: FieldRef<"ExamResult", 'String'>
    readonly remarks: FieldRef<"ExamResult", 'String'>
    readonly isPassed: FieldRef<"ExamResult", 'Boolean'>
    readonly isAbsent: FieldRef<"ExamResult", 'Boolean'>
    readonly isResultsPublished: FieldRef<"ExamResult", 'Boolean'>
    readonly createdAt: FieldRef<"ExamResult", 'DateTime'>
    readonly updatedAt: FieldRef<"ExamResult", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExamResult findUnique
   */
  export type ExamResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamResult
     */
    select?: ExamResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamResult
     */
    omit?: ExamResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamResultInclude<ExtArgs> | null
    /**
     * Filter, which ExamResult to fetch.
     */
    where: ExamResultWhereUniqueInput
  }

  /**
   * ExamResult findUniqueOrThrow
   */
  export type ExamResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamResult
     */
    select?: ExamResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamResult
     */
    omit?: ExamResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamResultInclude<ExtArgs> | null
    /**
     * Filter, which ExamResult to fetch.
     */
    where: ExamResultWhereUniqueInput
  }

  /**
   * ExamResult findFirst
   */
  export type ExamResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamResult
     */
    select?: ExamResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamResult
     */
    omit?: ExamResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamResultInclude<ExtArgs> | null
    /**
     * Filter, which ExamResult to fetch.
     */
    where?: ExamResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamResults to fetch.
     */
    orderBy?: ExamResultOrderByWithRelationInput | ExamResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamResults.
     */
    cursor?: ExamResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamResults.
     */
    distinct?: ExamResultScalarFieldEnum | ExamResultScalarFieldEnum[]
  }

  /**
   * ExamResult findFirstOrThrow
   */
  export type ExamResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamResult
     */
    select?: ExamResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamResult
     */
    omit?: ExamResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamResultInclude<ExtArgs> | null
    /**
     * Filter, which ExamResult to fetch.
     */
    where?: ExamResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamResults to fetch.
     */
    orderBy?: ExamResultOrderByWithRelationInput | ExamResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamResults.
     */
    cursor?: ExamResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamResults.
     */
    distinct?: ExamResultScalarFieldEnum | ExamResultScalarFieldEnum[]
  }

  /**
   * ExamResult findMany
   */
  export type ExamResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamResult
     */
    select?: ExamResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamResult
     */
    omit?: ExamResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamResultInclude<ExtArgs> | null
    /**
     * Filter, which ExamResults to fetch.
     */
    where?: ExamResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamResults to fetch.
     */
    orderBy?: ExamResultOrderByWithRelationInput | ExamResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExamResults.
     */
    cursor?: ExamResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamResults.
     */
    skip?: number
    distinct?: ExamResultScalarFieldEnum | ExamResultScalarFieldEnum[]
  }

  /**
   * ExamResult create
   */
  export type ExamResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamResult
     */
    select?: ExamResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamResult
     */
    omit?: ExamResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamResultInclude<ExtArgs> | null
    /**
     * The data needed to create a ExamResult.
     */
    data: XOR<ExamResultCreateInput, ExamResultUncheckedCreateInput>
  }

  /**
   * ExamResult createMany
   */
  export type ExamResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExamResults.
     */
    data: ExamResultCreateManyInput | ExamResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExamResult createManyAndReturn
   */
  export type ExamResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamResult
     */
    select?: ExamResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamResult
     */
    omit?: ExamResultOmit<ExtArgs> | null
    /**
     * The data used to create many ExamResults.
     */
    data: ExamResultCreateManyInput | ExamResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamResult update
   */
  export type ExamResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamResult
     */
    select?: ExamResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamResult
     */
    omit?: ExamResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamResultInclude<ExtArgs> | null
    /**
     * The data needed to update a ExamResult.
     */
    data: XOR<ExamResultUpdateInput, ExamResultUncheckedUpdateInput>
    /**
     * Choose, which ExamResult to update.
     */
    where: ExamResultWhereUniqueInput
  }

  /**
   * ExamResult updateMany
   */
  export type ExamResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExamResults.
     */
    data: XOR<ExamResultUpdateManyMutationInput, ExamResultUncheckedUpdateManyInput>
    /**
     * Filter which ExamResults to update
     */
    where?: ExamResultWhereInput
    /**
     * Limit how many ExamResults to update.
     */
    limit?: number
  }

  /**
   * ExamResult updateManyAndReturn
   */
  export type ExamResultUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamResult
     */
    select?: ExamResultSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamResult
     */
    omit?: ExamResultOmit<ExtArgs> | null
    /**
     * The data used to update ExamResults.
     */
    data: XOR<ExamResultUpdateManyMutationInput, ExamResultUncheckedUpdateManyInput>
    /**
     * Filter which ExamResults to update
     */
    where?: ExamResultWhereInput
    /**
     * Limit how many ExamResults to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamResultIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamResult upsert
   */
  export type ExamResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamResult
     */
    select?: ExamResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamResult
     */
    omit?: ExamResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamResultInclude<ExtArgs> | null
    /**
     * The filter to search for the ExamResult to update in case it exists.
     */
    where: ExamResultWhereUniqueInput
    /**
     * In case the ExamResult found by the `where` argument doesn't exist, create a new ExamResult with this data.
     */
    create: XOR<ExamResultCreateInput, ExamResultUncheckedCreateInput>
    /**
     * In case the ExamResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamResultUpdateInput, ExamResultUncheckedUpdateInput>
  }

  /**
   * ExamResult delete
   */
  export type ExamResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamResult
     */
    select?: ExamResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamResult
     */
    omit?: ExamResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamResultInclude<ExtArgs> | null
    /**
     * Filter which ExamResult to delete.
     */
    where: ExamResultWhereUniqueInput
  }

  /**
   * ExamResult deleteMany
   */
  export type ExamResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamResults to delete
     */
    where?: ExamResultWhereInput
    /**
     * Limit how many ExamResults to delete.
     */
    limit?: number
  }

  /**
   * ExamResult.subject
   */
  export type ExamResult$subjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
  }

  /**
   * ExamResult without action
   */
  export type ExamResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamResult
     */
    select?: ExamResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamResult
     */
    omit?: ExamResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamResultInclude<ExtArgs> | null
  }


  /**
   * Model HallTicket
   */

  export type AggregateHallTicket = {
    _count: HallTicketCountAggregateOutputType | null
    _min: HallTicketMinAggregateOutputType | null
    _max: HallTicketMaxAggregateOutputType | null
  }

  export type HallTicketMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    examId: string | null
    examSessionId: string | null
    pdfUrl: string | null
    qrCode: string | null
    generatedAt: Date | null
    downloadedAt: Date | null
    expiryDate: Date | null
    organizationId: string | null
  }

  export type HallTicketMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    examId: string | null
    examSessionId: string | null
    pdfUrl: string | null
    qrCode: string | null
    generatedAt: Date | null
    downloadedAt: Date | null
    expiryDate: Date | null
    organizationId: string | null
  }

  export type HallTicketCountAggregateOutputType = {
    id: number
    studentId: number
    examId: number
    examSessionId: number
    pdfUrl: number
    qrCode: number
    generatedAt: number
    downloadedAt: number
    expiryDate: number
    organizationId: number
    _all: number
  }


  export type HallTicketMinAggregateInputType = {
    id?: true
    studentId?: true
    examId?: true
    examSessionId?: true
    pdfUrl?: true
    qrCode?: true
    generatedAt?: true
    downloadedAt?: true
    expiryDate?: true
    organizationId?: true
  }

  export type HallTicketMaxAggregateInputType = {
    id?: true
    studentId?: true
    examId?: true
    examSessionId?: true
    pdfUrl?: true
    qrCode?: true
    generatedAt?: true
    downloadedAt?: true
    expiryDate?: true
    organizationId?: true
  }

  export type HallTicketCountAggregateInputType = {
    id?: true
    studentId?: true
    examId?: true
    examSessionId?: true
    pdfUrl?: true
    qrCode?: true
    generatedAt?: true
    downloadedAt?: true
    expiryDate?: true
    organizationId?: true
    _all?: true
  }

  export type HallTicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HallTicket to aggregate.
     */
    where?: HallTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HallTickets to fetch.
     */
    orderBy?: HallTicketOrderByWithRelationInput | HallTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HallTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HallTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HallTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HallTickets
    **/
    _count?: true | HallTicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HallTicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HallTicketMaxAggregateInputType
  }

  export type GetHallTicketAggregateType<T extends HallTicketAggregateArgs> = {
        [P in keyof T & keyof AggregateHallTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHallTicket[P]>
      : GetScalarType<T[P], AggregateHallTicket[P]>
  }




  export type HallTicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HallTicketWhereInput
    orderBy?: HallTicketOrderByWithAggregationInput | HallTicketOrderByWithAggregationInput[]
    by: HallTicketScalarFieldEnum[] | HallTicketScalarFieldEnum
    having?: HallTicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HallTicketCountAggregateInputType | true
    _min?: HallTicketMinAggregateInputType
    _max?: HallTicketMaxAggregateInputType
  }

  export type HallTicketGroupByOutputType = {
    id: string
    studentId: string
    examId: string | null
    examSessionId: string | null
    pdfUrl: string
    qrCode: string | null
    generatedAt: Date
    downloadedAt: Date | null
    expiryDate: Date | null
    organizationId: string
    _count: HallTicketCountAggregateOutputType | null
    _min: HallTicketMinAggregateOutputType | null
    _max: HallTicketMaxAggregateOutputType | null
  }

  type GetHallTicketGroupByPayload<T extends HallTicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HallTicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HallTicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HallTicketGroupByOutputType[P]>
            : GetScalarType<T[P], HallTicketGroupByOutputType[P]>
        }
      >
    >


  export type HallTicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    examId?: boolean
    examSessionId?: boolean
    pdfUrl?: boolean
    qrCode?: boolean
    generatedAt?: boolean
    downloadedAt?: boolean
    expiryDate?: boolean
    organizationId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    exam?: boolean | HallTicket$examArgs<ExtArgs>
    examSession?: boolean | HallTicket$examSessionArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hallTicket"]>

  export type HallTicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    examId?: boolean
    examSessionId?: boolean
    pdfUrl?: boolean
    qrCode?: boolean
    generatedAt?: boolean
    downloadedAt?: boolean
    expiryDate?: boolean
    organizationId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    exam?: boolean | HallTicket$examArgs<ExtArgs>
    examSession?: boolean | HallTicket$examSessionArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hallTicket"]>

  export type HallTicketSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    examId?: boolean
    examSessionId?: boolean
    pdfUrl?: boolean
    qrCode?: boolean
    generatedAt?: boolean
    downloadedAt?: boolean
    expiryDate?: boolean
    organizationId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    exam?: boolean | HallTicket$examArgs<ExtArgs>
    examSession?: boolean | HallTicket$examSessionArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hallTicket"]>

  export type HallTicketSelectScalar = {
    id?: boolean
    studentId?: boolean
    examId?: boolean
    examSessionId?: boolean
    pdfUrl?: boolean
    qrCode?: boolean
    generatedAt?: boolean
    downloadedAt?: boolean
    expiryDate?: boolean
    organizationId?: boolean
  }

  export type HallTicketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "examId" | "examSessionId" | "pdfUrl" | "qrCode" | "generatedAt" | "downloadedAt" | "expiryDate" | "organizationId", ExtArgs["result"]["hallTicket"]>
  export type HallTicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    exam?: boolean | HallTicket$examArgs<ExtArgs>
    examSession?: boolean | HallTicket$examSessionArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type HallTicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    exam?: boolean | HallTicket$examArgs<ExtArgs>
    examSession?: boolean | HallTicket$examSessionArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type HallTicketIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    exam?: boolean | HallTicket$examArgs<ExtArgs>
    examSession?: boolean | HallTicket$examSessionArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $HallTicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HallTicket"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      exam: Prisma.$ExamPayload<ExtArgs> | null
      examSession: Prisma.$ExamSessionPayload<ExtArgs> | null
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      examId: string | null
      examSessionId: string | null
      pdfUrl: string
      qrCode: string | null
      generatedAt: Date
      downloadedAt: Date | null
      expiryDate: Date | null
      organizationId: string
    }, ExtArgs["result"]["hallTicket"]>
    composites: {}
  }

  type HallTicketGetPayload<S extends boolean | null | undefined | HallTicketDefaultArgs> = $Result.GetResult<Prisma.$HallTicketPayload, S>

  type HallTicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HallTicketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HallTicketCountAggregateInputType | true
    }

  export interface HallTicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HallTicket'], meta: { name: 'HallTicket' } }
    /**
     * Find zero or one HallTicket that matches the filter.
     * @param {HallTicketFindUniqueArgs} args - Arguments to find a HallTicket
     * @example
     * // Get one HallTicket
     * const hallTicket = await prisma.hallTicket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HallTicketFindUniqueArgs>(args: SelectSubset<T, HallTicketFindUniqueArgs<ExtArgs>>): Prisma__HallTicketClient<$Result.GetResult<Prisma.$HallTicketPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HallTicket that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HallTicketFindUniqueOrThrowArgs} args - Arguments to find a HallTicket
     * @example
     * // Get one HallTicket
     * const hallTicket = await prisma.hallTicket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HallTicketFindUniqueOrThrowArgs>(args: SelectSubset<T, HallTicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HallTicketClient<$Result.GetResult<Prisma.$HallTicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HallTicket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HallTicketFindFirstArgs} args - Arguments to find a HallTicket
     * @example
     * // Get one HallTicket
     * const hallTicket = await prisma.hallTicket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HallTicketFindFirstArgs>(args?: SelectSubset<T, HallTicketFindFirstArgs<ExtArgs>>): Prisma__HallTicketClient<$Result.GetResult<Prisma.$HallTicketPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HallTicket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HallTicketFindFirstOrThrowArgs} args - Arguments to find a HallTicket
     * @example
     * // Get one HallTicket
     * const hallTicket = await prisma.hallTicket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HallTicketFindFirstOrThrowArgs>(args?: SelectSubset<T, HallTicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__HallTicketClient<$Result.GetResult<Prisma.$HallTicketPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HallTickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HallTicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HallTickets
     * const hallTickets = await prisma.hallTicket.findMany()
     * 
     * // Get first 10 HallTickets
     * const hallTickets = await prisma.hallTicket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hallTicketWithIdOnly = await prisma.hallTicket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HallTicketFindManyArgs>(args?: SelectSubset<T, HallTicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HallTicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HallTicket.
     * @param {HallTicketCreateArgs} args - Arguments to create a HallTicket.
     * @example
     * // Create one HallTicket
     * const HallTicket = await prisma.hallTicket.create({
     *   data: {
     *     // ... data to create a HallTicket
     *   }
     * })
     * 
     */
    create<T extends HallTicketCreateArgs>(args: SelectSubset<T, HallTicketCreateArgs<ExtArgs>>): Prisma__HallTicketClient<$Result.GetResult<Prisma.$HallTicketPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HallTickets.
     * @param {HallTicketCreateManyArgs} args - Arguments to create many HallTickets.
     * @example
     * // Create many HallTickets
     * const hallTicket = await prisma.hallTicket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HallTicketCreateManyArgs>(args?: SelectSubset<T, HallTicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HallTickets and returns the data saved in the database.
     * @param {HallTicketCreateManyAndReturnArgs} args - Arguments to create many HallTickets.
     * @example
     * // Create many HallTickets
     * const hallTicket = await prisma.hallTicket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HallTickets and only return the `id`
     * const hallTicketWithIdOnly = await prisma.hallTicket.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HallTicketCreateManyAndReturnArgs>(args?: SelectSubset<T, HallTicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HallTicketPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HallTicket.
     * @param {HallTicketDeleteArgs} args - Arguments to delete one HallTicket.
     * @example
     * // Delete one HallTicket
     * const HallTicket = await prisma.hallTicket.delete({
     *   where: {
     *     // ... filter to delete one HallTicket
     *   }
     * })
     * 
     */
    delete<T extends HallTicketDeleteArgs>(args: SelectSubset<T, HallTicketDeleteArgs<ExtArgs>>): Prisma__HallTicketClient<$Result.GetResult<Prisma.$HallTicketPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HallTicket.
     * @param {HallTicketUpdateArgs} args - Arguments to update one HallTicket.
     * @example
     * // Update one HallTicket
     * const hallTicket = await prisma.hallTicket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HallTicketUpdateArgs>(args: SelectSubset<T, HallTicketUpdateArgs<ExtArgs>>): Prisma__HallTicketClient<$Result.GetResult<Prisma.$HallTicketPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HallTickets.
     * @param {HallTicketDeleteManyArgs} args - Arguments to filter HallTickets to delete.
     * @example
     * // Delete a few HallTickets
     * const { count } = await prisma.hallTicket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HallTicketDeleteManyArgs>(args?: SelectSubset<T, HallTicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HallTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HallTicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HallTickets
     * const hallTicket = await prisma.hallTicket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HallTicketUpdateManyArgs>(args: SelectSubset<T, HallTicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HallTickets and returns the data updated in the database.
     * @param {HallTicketUpdateManyAndReturnArgs} args - Arguments to update many HallTickets.
     * @example
     * // Update many HallTickets
     * const hallTicket = await prisma.hallTicket.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HallTickets and only return the `id`
     * const hallTicketWithIdOnly = await prisma.hallTicket.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HallTicketUpdateManyAndReturnArgs>(args: SelectSubset<T, HallTicketUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HallTicketPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HallTicket.
     * @param {HallTicketUpsertArgs} args - Arguments to update or create a HallTicket.
     * @example
     * // Update or create a HallTicket
     * const hallTicket = await prisma.hallTicket.upsert({
     *   create: {
     *     // ... data to create a HallTicket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HallTicket we want to update
     *   }
     * })
     */
    upsert<T extends HallTicketUpsertArgs>(args: SelectSubset<T, HallTicketUpsertArgs<ExtArgs>>): Prisma__HallTicketClient<$Result.GetResult<Prisma.$HallTicketPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HallTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HallTicketCountArgs} args - Arguments to filter HallTickets to count.
     * @example
     * // Count the number of HallTickets
     * const count = await prisma.hallTicket.count({
     *   where: {
     *     // ... the filter for the HallTickets we want to count
     *   }
     * })
    **/
    count<T extends HallTicketCountArgs>(
      args?: Subset<T, HallTicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HallTicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HallTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HallTicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HallTicketAggregateArgs>(args: Subset<T, HallTicketAggregateArgs>): Prisma.PrismaPromise<GetHallTicketAggregateType<T>>

    /**
     * Group by HallTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HallTicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HallTicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HallTicketGroupByArgs['orderBy'] }
        : { orderBy?: HallTicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HallTicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHallTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HallTicket model
   */
  readonly fields: HallTicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HallTicket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HallTicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    exam<T extends HallTicket$examArgs<ExtArgs> = {}>(args?: Subset<T, HallTicket$examArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    examSession<T extends HallTicket$examSessionArgs<ExtArgs> = {}>(args?: Subset<T, HallTicket$examSessionArgs<ExtArgs>>): Prisma__ExamSessionClient<$Result.GetResult<Prisma.$ExamSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HallTicket model
   */
  interface HallTicketFieldRefs {
    readonly id: FieldRef<"HallTicket", 'String'>
    readonly studentId: FieldRef<"HallTicket", 'String'>
    readonly examId: FieldRef<"HallTicket", 'String'>
    readonly examSessionId: FieldRef<"HallTicket", 'String'>
    readonly pdfUrl: FieldRef<"HallTicket", 'String'>
    readonly qrCode: FieldRef<"HallTicket", 'String'>
    readonly generatedAt: FieldRef<"HallTicket", 'DateTime'>
    readonly downloadedAt: FieldRef<"HallTicket", 'DateTime'>
    readonly expiryDate: FieldRef<"HallTicket", 'DateTime'>
    readonly organizationId: FieldRef<"HallTicket", 'String'>
  }
    

  // Custom InputTypes
  /**
   * HallTicket findUnique
   */
  export type HallTicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HallTicket
     */
    select?: HallTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HallTicket
     */
    omit?: HallTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallTicketInclude<ExtArgs> | null
    /**
     * Filter, which HallTicket to fetch.
     */
    where: HallTicketWhereUniqueInput
  }

  /**
   * HallTicket findUniqueOrThrow
   */
  export type HallTicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HallTicket
     */
    select?: HallTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HallTicket
     */
    omit?: HallTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallTicketInclude<ExtArgs> | null
    /**
     * Filter, which HallTicket to fetch.
     */
    where: HallTicketWhereUniqueInput
  }

  /**
   * HallTicket findFirst
   */
  export type HallTicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HallTicket
     */
    select?: HallTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HallTicket
     */
    omit?: HallTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallTicketInclude<ExtArgs> | null
    /**
     * Filter, which HallTicket to fetch.
     */
    where?: HallTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HallTickets to fetch.
     */
    orderBy?: HallTicketOrderByWithRelationInput | HallTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HallTickets.
     */
    cursor?: HallTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HallTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HallTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HallTickets.
     */
    distinct?: HallTicketScalarFieldEnum | HallTicketScalarFieldEnum[]
  }

  /**
   * HallTicket findFirstOrThrow
   */
  export type HallTicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HallTicket
     */
    select?: HallTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HallTicket
     */
    omit?: HallTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallTicketInclude<ExtArgs> | null
    /**
     * Filter, which HallTicket to fetch.
     */
    where?: HallTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HallTickets to fetch.
     */
    orderBy?: HallTicketOrderByWithRelationInput | HallTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HallTickets.
     */
    cursor?: HallTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HallTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HallTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HallTickets.
     */
    distinct?: HallTicketScalarFieldEnum | HallTicketScalarFieldEnum[]
  }

  /**
   * HallTicket findMany
   */
  export type HallTicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HallTicket
     */
    select?: HallTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HallTicket
     */
    omit?: HallTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallTicketInclude<ExtArgs> | null
    /**
     * Filter, which HallTickets to fetch.
     */
    where?: HallTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HallTickets to fetch.
     */
    orderBy?: HallTicketOrderByWithRelationInput | HallTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HallTickets.
     */
    cursor?: HallTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HallTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HallTickets.
     */
    skip?: number
    distinct?: HallTicketScalarFieldEnum | HallTicketScalarFieldEnum[]
  }

  /**
   * HallTicket create
   */
  export type HallTicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HallTicket
     */
    select?: HallTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HallTicket
     */
    omit?: HallTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallTicketInclude<ExtArgs> | null
    /**
     * The data needed to create a HallTicket.
     */
    data: XOR<HallTicketCreateInput, HallTicketUncheckedCreateInput>
  }

  /**
   * HallTicket createMany
   */
  export type HallTicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HallTickets.
     */
    data: HallTicketCreateManyInput | HallTicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HallTicket createManyAndReturn
   */
  export type HallTicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HallTicket
     */
    select?: HallTicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HallTicket
     */
    omit?: HallTicketOmit<ExtArgs> | null
    /**
     * The data used to create many HallTickets.
     */
    data: HallTicketCreateManyInput | HallTicketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallTicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HallTicket update
   */
  export type HallTicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HallTicket
     */
    select?: HallTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HallTicket
     */
    omit?: HallTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallTicketInclude<ExtArgs> | null
    /**
     * The data needed to update a HallTicket.
     */
    data: XOR<HallTicketUpdateInput, HallTicketUncheckedUpdateInput>
    /**
     * Choose, which HallTicket to update.
     */
    where: HallTicketWhereUniqueInput
  }

  /**
   * HallTicket updateMany
   */
  export type HallTicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HallTickets.
     */
    data: XOR<HallTicketUpdateManyMutationInput, HallTicketUncheckedUpdateManyInput>
    /**
     * Filter which HallTickets to update
     */
    where?: HallTicketWhereInput
    /**
     * Limit how many HallTickets to update.
     */
    limit?: number
  }

  /**
   * HallTicket updateManyAndReturn
   */
  export type HallTicketUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HallTicket
     */
    select?: HallTicketSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HallTicket
     */
    omit?: HallTicketOmit<ExtArgs> | null
    /**
     * The data used to update HallTickets.
     */
    data: XOR<HallTicketUpdateManyMutationInput, HallTicketUncheckedUpdateManyInput>
    /**
     * Filter which HallTickets to update
     */
    where?: HallTicketWhereInput
    /**
     * Limit how many HallTickets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallTicketIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * HallTicket upsert
   */
  export type HallTicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HallTicket
     */
    select?: HallTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HallTicket
     */
    omit?: HallTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallTicketInclude<ExtArgs> | null
    /**
     * The filter to search for the HallTicket to update in case it exists.
     */
    where: HallTicketWhereUniqueInput
    /**
     * In case the HallTicket found by the `where` argument doesn't exist, create a new HallTicket with this data.
     */
    create: XOR<HallTicketCreateInput, HallTicketUncheckedCreateInput>
    /**
     * In case the HallTicket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HallTicketUpdateInput, HallTicketUncheckedUpdateInput>
  }

  /**
   * HallTicket delete
   */
  export type HallTicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HallTicket
     */
    select?: HallTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HallTicket
     */
    omit?: HallTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallTicketInclude<ExtArgs> | null
    /**
     * Filter which HallTicket to delete.
     */
    where: HallTicketWhereUniqueInput
  }

  /**
   * HallTicket deleteMany
   */
  export type HallTicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HallTickets to delete
     */
    where?: HallTicketWhereInput
    /**
     * Limit how many HallTickets to delete.
     */
    limit?: number
  }

  /**
   * HallTicket.exam
   */
  export type HallTicket$examArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
  }

  /**
   * HallTicket.examSession
   */
  export type HallTicket$examSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSession
     */
    select?: ExamSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamSession
     */
    omit?: ExamSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSessionInclude<ExtArgs> | null
    where?: ExamSessionWhereInput
  }

  /**
   * HallTicket without action
   */
  export type HallTicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HallTicket
     */
    select?: HallTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HallTicket
     */
    omit?: HallTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallTicketInclude<ExtArgs> | null
  }


  /**
   * Model ReportCard
   */

  export type AggregateReportCard = {
    _count: ReportCardCountAggregateOutputType | null
    _avg: ReportCardAvgAggregateOutputType | null
    _sum: ReportCardSumAggregateOutputType | null
    _min: ReportCardMinAggregateOutputType | null
    _max: ReportCardMaxAggregateOutputType | null
  }

  export type ReportCardAvgAggregateOutputType = {
    totalMaxMarks: number | null
    totalObtained: number | null
    percentage: number | null
    cgpa: number | null
    classRank: number | null
    gradeRank: number | null
    attendancePercent: number | null
    rank: number | null
  }

  export type ReportCardSumAggregateOutputType = {
    totalMaxMarks: number | null
    totalObtained: number | null
    percentage: number | null
    cgpa: number | null
    classRank: number | null
    gradeRank: number | null
    attendancePercent: number | null
    rank: number | null
  }

  export type ReportCardMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    examSessionId: string | null
    totalMaxMarks: number | null
    totalObtained: number | null
    percentage: number | null
    cgpa: number | null
    overallGrade: string | null
    resultStatus: $Enums.ResultStatus | null
    classRank: number | null
    gradeRank: number | null
    attendancePercent: number | null
    conductGrade: string | null
    remarks: string | null
    principalRemarks: string | null
    rank: number | null
    pdfUrl: string | null
    generatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportCardMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    examSessionId: string | null
    totalMaxMarks: number | null
    totalObtained: number | null
    percentage: number | null
    cgpa: number | null
    overallGrade: string | null
    resultStatus: $Enums.ResultStatus | null
    classRank: number | null
    gradeRank: number | null
    attendancePercent: number | null
    conductGrade: string | null
    remarks: string | null
    principalRemarks: string | null
    rank: number | null
    pdfUrl: string | null
    generatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportCardCountAggregateOutputType = {
    id: number
    studentId: number
    examSessionId: number
    totalMaxMarks: number
    totalObtained: number
    percentage: number
    cgpa: number
    overallGrade: number
    resultStatus: number
    classRank: number
    gradeRank: number
    attendancePercent: number
    conductGrade: number
    remarks: number
    principalRemarks: number
    rank: number
    pdfUrl: number
    generatedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReportCardAvgAggregateInputType = {
    totalMaxMarks?: true
    totalObtained?: true
    percentage?: true
    cgpa?: true
    classRank?: true
    gradeRank?: true
    attendancePercent?: true
    rank?: true
  }

  export type ReportCardSumAggregateInputType = {
    totalMaxMarks?: true
    totalObtained?: true
    percentage?: true
    cgpa?: true
    classRank?: true
    gradeRank?: true
    attendancePercent?: true
    rank?: true
  }

  export type ReportCardMinAggregateInputType = {
    id?: true
    studentId?: true
    examSessionId?: true
    totalMaxMarks?: true
    totalObtained?: true
    percentage?: true
    cgpa?: true
    overallGrade?: true
    resultStatus?: true
    classRank?: true
    gradeRank?: true
    attendancePercent?: true
    conductGrade?: true
    remarks?: true
    principalRemarks?: true
    rank?: true
    pdfUrl?: true
    generatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportCardMaxAggregateInputType = {
    id?: true
    studentId?: true
    examSessionId?: true
    totalMaxMarks?: true
    totalObtained?: true
    percentage?: true
    cgpa?: true
    overallGrade?: true
    resultStatus?: true
    classRank?: true
    gradeRank?: true
    attendancePercent?: true
    conductGrade?: true
    remarks?: true
    principalRemarks?: true
    rank?: true
    pdfUrl?: true
    generatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportCardCountAggregateInputType = {
    id?: true
    studentId?: true
    examSessionId?: true
    totalMaxMarks?: true
    totalObtained?: true
    percentage?: true
    cgpa?: true
    overallGrade?: true
    resultStatus?: true
    classRank?: true
    gradeRank?: true
    attendancePercent?: true
    conductGrade?: true
    remarks?: true
    principalRemarks?: true
    rank?: true
    pdfUrl?: true
    generatedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReportCardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportCard to aggregate.
     */
    where?: ReportCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportCards to fetch.
     */
    orderBy?: ReportCardOrderByWithRelationInput | ReportCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportCards
    **/
    _count?: true | ReportCardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportCardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportCardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportCardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportCardMaxAggregateInputType
  }

  export type GetReportCardAggregateType<T extends ReportCardAggregateArgs> = {
        [P in keyof T & keyof AggregateReportCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportCard[P]>
      : GetScalarType<T[P], AggregateReportCard[P]>
  }




  export type ReportCardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportCardWhereInput
    orderBy?: ReportCardOrderByWithAggregationInput | ReportCardOrderByWithAggregationInput[]
    by: ReportCardScalarFieldEnum[] | ReportCardScalarFieldEnum
    having?: ReportCardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCardCountAggregateInputType | true
    _avg?: ReportCardAvgAggregateInputType
    _sum?: ReportCardSumAggregateInputType
    _min?: ReportCardMinAggregateInputType
    _max?: ReportCardMaxAggregateInputType
  }

  export type ReportCardGroupByOutputType = {
    id: string
    studentId: string
    examSessionId: string
    totalMaxMarks: number
    totalObtained: number
    percentage: number
    cgpa: number | null
    overallGrade: string
    resultStatus: $Enums.ResultStatus
    classRank: number | null
    gradeRank: number | null
    attendancePercent: number | null
    conductGrade: string | null
    remarks: string | null
    principalRemarks: string | null
    rank: number | null
    pdfUrl: string | null
    generatedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ReportCardCountAggregateOutputType | null
    _avg: ReportCardAvgAggregateOutputType | null
    _sum: ReportCardSumAggregateOutputType | null
    _min: ReportCardMinAggregateOutputType | null
    _max: ReportCardMaxAggregateOutputType | null
  }

  type GetReportCardGroupByPayload<T extends ReportCardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportCardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportCardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportCardGroupByOutputType[P]>
            : GetScalarType<T[P], ReportCardGroupByOutputType[P]>
        }
      >
    >


  export type ReportCardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    examSessionId?: boolean
    totalMaxMarks?: boolean
    totalObtained?: boolean
    percentage?: boolean
    cgpa?: boolean
    overallGrade?: boolean
    resultStatus?: boolean
    classRank?: boolean
    gradeRank?: boolean
    attendancePercent?: boolean
    conductGrade?: boolean
    remarks?: boolean
    principalRemarks?: boolean
    rank?: boolean
    pdfUrl?: boolean
    generatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    examSession?: boolean | ExamSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportCard"]>

  export type ReportCardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    examSessionId?: boolean
    totalMaxMarks?: boolean
    totalObtained?: boolean
    percentage?: boolean
    cgpa?: boolean
    overallGrade?: boolean
    resultStatus?: boolean
    classRank?: boolean
    gradeRank?: boolean
    attendancePercent?: boolean
    conductGrade?: boolean
    remarks?: boolean
    principalRemarks?: boolean
    rank?: boolean
    pdfUrl?: boolean
    generatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    examSession?: boolean | ExamSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportCard"]>

  export type ReportCardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    examSessionId?: boolean
    totalMaxMarks?: boolean
    totalObtained?: boolean
    percentage?: boolean
    cgpa?: boolean
    overallGrade?: boolean
    resultStatus?: boolean
    classRank?: boolean
    gradeRank?: boolean
    attendancePercent?: boolean
    conductGrade?: boolean
    remarks?: boolean
    principalRemarks?: boolean
    rank?: boolean
    pdfUrl?: boolean
    generatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    examSession?: boolean | ExamSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportCard"]>

  export type ReportCardSelectScalar = {
    id?: boolean
    studentId?: boolean
    examSessionId?: boolean
    totalMaxMarks?: boolean
    totalObtained?: boolean
    percentage?: boolean
    cgpa?: boolean
    overallGrade?: boolean
    resultStatus?: boolean
    classRank?: boolean
    gradeRank?: boolean
    attendancePercent?: boolean
    conductGrade?: boolean
    remarks?: boolean
    principalRemarks?: boolean
    rank?: boolean
    pdfUrl?: boolean
    generatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReportCardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "examSessionId" | "totalMaxMarks" | "totalObtained" | "percentage" | "cgpa" | "overallGrade" | "resultStatus" | "classRank" | "gradeRank" | "attendancePercent" | "conductGrade" | "remarks" | "principalRemarks" | "rank" | "pdfUrl" | "generatedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["reportCard"]>
  export type ReportCardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    examSession?: boolean | ExamSessionDefaultArgs<ExtArgs>
  }
  export type ReportCardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    examSession?: boolean | ExamSessionDefaultArgs<ExtArgs>
  }
  export type ReportCardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    examSession?: boolean | ExamSessionDefaultArgs<ExtArgs>
  }

  export type $ReportCardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportCard"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      examSession: Prisma.$ExamSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      examSessionId: string
      totalMaxMarks: number
      totalObtained: number
      percentage: number
      cgpa: number | null
      overallGrade: string
      resultStatus: $Enums.ResultStatus
      classRank: number | null
      gradeRank: number | null
      attendancePercent: number | null
      conductGrade: string | null
      remarks: string | null
      principalRemarks: string | null
      rank: number | null
      pdfUrl: string | null
      generatedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["reportCard"]>
    composites: {}
  }

  type ReportCardGetPayload<S extends boolean | null | undefined | ReportCardDefaultArgs> = $Result.GetResult<Prisma.$ReportCardPayload, S>

  type ReportCardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportCardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportCardCountAggregateInputType | true
    }

  export interface ReportCardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportCard'], meta: { name: 'ReportCard' } }
    /**
     * Find zero or one ReportCard that matches the filter.
     * @param {ReportCardFindUniqueArgs} args - Arguments to find a ReportCard
     * @example
     * // Get one ReportCard
     * const reportCard = await prisma.reportCard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportCardFindUniqueArgs>(args: SelectSubset<T, ReportCardFindUniqueArgs<ExtArgs>>): Prisma__ReportCardClient<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReportCard that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportCardFindUniqueOrThrowArgs} args - Arguments to find a ReportCard
     * @example
     * // Get one ReportCard
     * const reportCard = await prisma.reportCard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportCardFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportCardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportCardClient<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportCard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCardFindFirstArgs} args - Arguments to find a ReportCard
     * @example
     * // Get one ReportCard
     * const reportCard = await prisma.reportCard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportCardFindFirstArgs>(args?: SelectSubset<T, ReportCardFindFirstArgs<ExtArgs>>): Prisma__ReportCardClient<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportCard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCardFindFirstOrThrowArgs} args - Arguments to find a ReportCard
     * @example
     * // Get one ReportCard
     * const reportCard = await prisma.reportCard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportCardFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportCardFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportCardClient<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReportCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportCards
     * const reportCards = await prisma.reportCard.findMany()
     * 
     * // Get first 10 ReportCards
     * const reportCards = await prisma.reportCard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportCardWithIdOnly = await prisma.reportCard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportCardFindManyArgs>(args?: SelectSubset<T, ReportCardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReportCard.
     * @param {ReportCardCreateArgs} args - Arguments to create a ReportCard.
     * @example
     * // Create one ReportCard
     * const ReportCard = await prisma.reportCard.create({
     *   data: {
     *     // ... data to create a ReportCard
     *   }
     * })
     * 
     */
    create<T extends ReportCardCreateArgs>(args: SelectSubset<T, ReportCardCreateArgs<ExtArgs>>): Prisma__ReportCardClient<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReportCards.
     * @param {ReportCardCreateManyArgs} args - Arguments to create many ReportCards.
     * @example
     * // Create many ReportCards
     * const reportCard = await prisma.reportCard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCardCreateManyArgs>(args?: SelectSubset<T, ReportCardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReportCards and returns the data saved in the database.
     * @param {ReportCardCreateManyAndReturnArgs} args - Arguments to create many ReportCards.
     * @example
     * // Create many ReportCards
     * const reportCard = await prisma.reportCard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReportCards and only return the `id`
     * const reportCardWithIdOnly = await prisma.reportCard.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportCardCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportCardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReportCard.
     * @param {ReportCardDeleteArgs} args - Arguments to delete one ReportCard.
     * @example
     * // Delete one ReportCard
     * const ReportCard = await prisma.reportCard.delete({
     *   where: {
     *     // ... filter to delete one ReportCard
     *   }
     * })
     * 
     */
    delete<T extends ReportCardDeleteArgs>(args: SelectSubset<T, ReportCardDeleteArgs<ExtArgs>>): Prisma__ReportCardClient<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReportCard.
     * @param {ReportCardUpdateArgs} args - Arguments to update one ReportCard.
     * @example
     * // Update one ReportCard
     * const reportCard = await prisma.reportCard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportCardUpdateArgs>(args: SelectSubset<T, ReportCardUpdateArgs<ExtArgs>>): Prisma__ReportCardClient<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReportCards.
     * @param {ReportCardDeleteManyArgs} args - Arguments to filter ReportCards to delete.
     * @example
     * // Delete a few ReportCards
     * const { count } = await prisma.reportCard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportCardDeleteManyArgs>(args?: SelectSubset<T, ReportCardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportCards
     * const reportCard = await prisma.reportCard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportCardUpdateManyArgs>(args: SelectSubset<T, ReportCardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportCards and returns the data updated in the database.
     * @param {ReportCardUpdateManyAndReturnArgs} args - Arguments to update many ReportCards.
     * @example
     * // Update many ReportCards
     * const reportCard = await prisma.reportCard.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReportCards and only return the `id`
     * const reportCardWithIdOnly = await prisma.reportCard.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportCardUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportCardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReportCard.
     * @param {ReportCardUpsertArgs} args - Arguments to update or create a ReportCard.
     * @example
     * // Update or create a ReportCard
     * const reportCard = await prisma.reportCard.upsert({
     *   create: {
     *     // ... data to create a ReportCard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportCard we want to update
     *   }
     * })
     */
    upsert<T extends ReportCardUpsertArgs>(args: SelectSubset<T, ReportCardUpsertArgs<ExtArgs>>): Prisma__ReportCardClient<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReportCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCardCountArgs} args - Arguments to filter ReportCards to count.
     * @example
     * // Count the number of ReportCards
     * const count = await prisma.reportCard.count({
     *   where: {
     *     // ... the filter for the ReportCards we want to count
     *   }
     * })
    **/
    count<T extends ReportCardCountArgs>(
      args?: Subset<T, ReportCardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportCardAggregateArgs>(args: Subset<T, ReportCardAggregateArgs>): Prisma.PrismaPromise<GetReportCardAggregateType<T>>

    /**
     * Group by ReportCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportCardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportCardGroupByArgs['orderBy'] }
        : { orderBy?: ReportCardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportCardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportCardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportCard model
   */
  readonly fields: ReportCardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportCard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportCardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    examSession<T extends ExamSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamSessionDefaultArgs<ExtArgs>>): Prisma__ExamSessionClient<$Result.GetResult<Prisma.$ExamSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReportCard model
   */
  interface ReportCardFieldRefs {
    readonly id: FieldRef<"ReportCard", 'String'>
    readonly studentId: FieldRef<"ReportCard", 'String'>
    readonly examSessionId: FieldRef<"ReportCard", 'String'>
    readonly totalMaxMarks: FieldRef<"ReportCard", 'Float'>
    readonly totalObtained: FieldRef<"ReportCard", 'Float'>
    readonly percentage: FieldRef<"ReportCard", 'Float'>
    readonly cgpa: FieldRef<"ReportCard", 'Float'>
    readonly overallGrade: FieldRef<"ReportCard", 'String'>
    readonly resultStatus: FieldRef<"ReportCard", 'ResultStatus'>
    readonly classRank: FieldRef<"ReportCard", 'Int'>
    readonly gradeRank: FieldRef<"ReportCard", 'Int'>
    readonly attendancePercent: FieldRef<"ReportCard", 'Float'>
    readonly conductGrade: FieldRef<"ReportCard", 'String'>
    readonly remarks: FieldRef<"ReportCard", 'String'>
    readonly principalRemarks: FieldRef<"ReportCard", 'String'>
    readonly rank: FieldRef<"ReportCard", 'Int'>
    readonly pdfUrl: FieldRef<"ReportCard", 'String'>
    readonly generatedAt: FieldRef<"ReportCard", 'DateTime'>
    readonly createdAt: FieldRef<"ReportCard", 'DateTime'>
    readonly updatedAt: FieldRef<"ReportCard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReportCard findUnique
   */
  export type ReportCardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportCard
     */
    omit?: ReportCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * Filter, which ReportCard to fetch.
     */
    where: ReportCardWhereUniqueInput
  }

  /**
   * ReportCard findUniqueOrThrow
   */
  export type ReportCardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportCard
     */
    omit?: ReportCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * Filter, which ReportCard to fetch.
     */
    where: ReportCardWhereUniqueInput
  }

  /**
   * ReportCard findFirst
   */
  export type ReportCardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportCard
     */
    omit?: ReportCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * Filter, which ReportCard to fetch.
     */
    where?: ReportCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportCards to fetch.
     */
    orderBy?: ReportCardOrderByWithRelationInput | ReportCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportCards.
     */
    cursor?: ReportCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportCards.
     */
    distinct?: ReportCardScalarFieldEnum | ReportCardScalarFieldEnum[]
  }

  /**
   * ReportCard findFirstOrThrow
   */
  export type ReportCardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportCard
     */
    omit?: ReportCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * Filter, which ReportCard to fetch.
     */
    where?: ReportCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportCards to fetch.
     */
    orderBy?: ReportCardOrderByWithRelationInput | ReportCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportCards.
     */
    cursor?: ReportCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportCards.
     */
    distinct?: ReportCardScalarFieldEnum | ReportCardScalarFieldEnum[]
  }

  /**
   * ReportCard findMany
   */
  export type ReportCardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportCard
     */
    omit?: ReportCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * Filter, which ReportCards to fetch.
     */
    where?: ReportCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportCards to fetch.
     */
    orderBy?: ReportCardOrderByWithRelationInput | ReportCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportCards.
     */
    cursor?: ReportCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportCards.
     */
    skip?: number
    distinct?: ReportCardScalarFieldEnum | ReportCardScalarFieldEnum[]
  }

  /**
   * ReportCard create
   */
  export type ReportCardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportCard
     */
    omit?: ReportCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * The data needed to create a ReportCard.
     */
    data: XOR<ReportCardCreateInput, ReportCardUncheckedCreateInput>
  }

  /**
   * ReportCard createMany
   */
  export type ReportCardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReportCards.
     */
    data: ReportCardCreateManyInput | ReportCardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportCard createManyAndReturn
   */
  export type ReportCardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportCard
     */
    omit?: ReportCardOmit<ExtArgs> | null
    /**
     * The data used to create many ReportCards.
     */
    data: ReportCardCreateManyInput | ReportCardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportCard update
   */
  export type ReportCardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportCard
     */
    omit?: ReportCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * The data needed to update a ReportCard.
     */
    data: XOR<ReportCardUpdateInput, ReportCardUncheckedUpdateInput>
    /**
     * Choose, which ReportCard to update.
     */
    where: ReportCardWhereUniqueInput
  }

  /**
   * ReportCard updateMany
   */
  export type ReportCardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportCards.
     */
    data: XOR<ReportCardUpdateManyMutationInput, ReportCardUncheckedUpdateManyInput>
    /**
     * Filter which ReportCards to update
     */
    where?: ReportCardWhereInput
    /**
     * Limit how many ReportCards to update.
     */
    limit?: number
  }

  /**
   * ReportCard updateManyAndReturn
   */
  export type ReportCardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportCard
     */
    omit?: ReportCardOmit<ExtArgs> | null
    /**
     * The data used to update ReportCards.
     */
    data: XOR<ReportCardUpdateManyMutationInput, ReportCardUncheckedUpdateManyInput>
    /**
     * Filter which ReportCards to update
     */
    where?: ReportCardWhereInput
    /**
     * Limit how many ReportCards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportCard upsert
   */
  export type ReportCardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportCard
     */
    omit?: ReportCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * The filter to search for the ReportCard to update in case it exists.
     */
    where: ReportCardWhereUniqueInput
    /**
     * In case the ReportCard found by the `where` argument doesn't exist, create a new ReportCard with this data.
     */
    create: XOR<ReportCardCreateInput, ReportCardUncheckedCreateInput>
    /**
     * In case the ReportCard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportCardUpdateInput, ReportCardUncheckedUpdateInput>
  }

  /**
   * ReportCard delete
   */
  export type ReportCardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportCard
     */
    omit?: ReportCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * Filter which ReportCard to delete.
     */
    where: ReportCardWhereUniqueInput
  }

  /**
   * ReportCard deleteMany
   */
  export type ReportCardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportCards to delete
     */
    where?: ReportCardWhereInput
    /**
     * Limit how many ReportCards to delete.
     */
    limit?: number
  }

  /**
   * ReportCard without action
   */
  export type ReportCardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportCard
     */
    omit?: ReportCardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AcademicYearScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    name: 'name',
    startDate: 'startDate',
    endDate: 'endDate',
    type: 'type',
    isCurrent: 'isCurrent',
    description: 'description',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AcademicYearScalarFieldEnum = (typeof AcademicYearScalarFieldEnum)[keyof typeof AcademicYearScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    organizationSlug: 'organizationSlug',
    organizationLogo: 'organizationLogo',
    contactEmail: 'contactEmail',
    contactPhone: 'contactPhone',
    website: 'website',
    isActive: 'isActive',
    isPaid: 'isPaid',
    plan: 'plan',
    planStartedAt: 'planStartedAt',
    planExpiresAt: 'planExpiresAt',
    maxStudents: 'maxStudents',
    organizationType: 'organizationType',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    password: 'password',
    profileImage: 'profileImage',
    role: 'role',
    clerkId: 'clerkId',
    isActive: 'isActive',
    organizationId: 'organizationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const GradeScalarFieldEnum: {
    id: 'id',
    grade: 'grade',
    organizationId: 'organizationId'
  };

  export type GradeScalarFieldEnum = (typeof GradeScalarFieldEnum)[keyof typeof GradeScalarFieldEnum]


  export const SectionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    gradeId: 'gradeId',
    organizationId: 'organizationId',
    classTeacherId: 'classTeacherId'
  };

  export type SectionScalarFieldEnum = (typeof SectionScalarFieldEnum)[keyof typeof SectionScalarFieldEnum]


  export const TeacherScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    employeeCode: 'employeeCode',
    employmentStatus: 'employmentStatus',
    isActive: 'isActive',
    organizationId: 'organizationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeacherScalarFieldEnum = (typeof TeacherScalarFieldEnum)[keyof typeof TeacherScalarFieldEnum]


  export const TeacherProfileScalarFieldEnum: {
    id: 'id',
    teacherId: 'teacherId',
    contactEmail: 'contactEmail',
    contactPhone: 'contactPhone',
    address: 'address',
    city: 'city',
    state: 'state',
    dateOfBirth: 'dateOfBirth',
    qualification: 'qualification',
    experienceInYears: 'experienceInYears',
    resumeUrl: 'resumeUrl',
    joinedAt: 'joinedAt',
    bio: 'bio',
    teachingPhilosophy: 'teachingPhilosophy',
    specializedSubjects: 'specializedSubjects',
    preferredGrades: 'preferredGrades',
    idProofUrl: 'idProofUrl',
    linkedinPortfolio: 'linkedinPortfolio',
    languagesKnown: 'languagesKnown',
    certificateUrls: 'certificateUrls'
  };

  export type TeacherProfileScalarFieldEnum = (typeof TeacherProfileScalarFieldEnum)[keyof typeof TeacherProfileScalarFieldEnum]


  export const SubjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description',
    organizationId: 'organizationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubjectScalarFieldEnum = (typeof SubjectScalarFieldEnum)[keyof typeof SubjectScalarFieldEnum]


  export const TeachingAssignmentScalarFieldEnum: {
    id: 'id',
    teacherId: 'teacherId',
    subjectId: 'subjectId',
    gradeId: 'gradeId',
    sectionId: 'sectionId',
    organizationId: 'organizationId',
    academicYear: 'academicYear',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    academicYearId: 'academicYearId'
  };

  export type TeachingAssignmentScalarFieldEnum = (typeof TeachingAssignmentScalarFieldEnum)[keyof typeof TeachingAssignmentScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    middleName: 'middleName',
    motherName: 'motherName',
    fullName: 'fullName',
    dateOfBirth: 'dateOfBirth',
    profileImage: 'profileImage',
    rollNumber: 'rollNumber',
    phoneNumber: 'phoneNumber',
    whatsAppNumber: 'whatsAppNumber',
    email: 'email',
    emergencyContact: 'emergencyContact',
    gender: 'gender',
    sectionId: 'sectionId',
    gradeId: 'gradeId',
    organizationId: 'organizationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const ParentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phoneNumber: 'phoneNumber',
    whatsAppNumber: 'whatsAppNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ParentScalarFieldEnum = (typeof ParentScalarFieldEnum)[keyof typeof ParentScalarFieldEnum]


  export const ParentStudentScalarFieldEnum: {
    id: 'id',
    relationship: 'relationship',
    studentId: 'studentId',
    parentId: 'parentId',
    isPrimary: 'isPrimary'
  };

  export type ParentStudentScalarFieldEnum = (typeof ParentStudentScalarFieldEnum)[keyof typeof ParentStudentScalarFieldEnum]


  export const StudentAttendanceScalarFieldEnum: {
    id: 'id',
    date: 'date',
    status: 'status',
    note: 'note',
    recordedBy: 'recordedBy',
    studentId: 'studentId',
    present: 'present',
    sectionId: 'sectionId',
    academicYearId: 'academicYearId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentAttendanceScalarFieldEnum = (typeof StudentAttendanceScalarFieldEnum)[keyof typeof StudentAttendanceScalarFieldEnum]


  export const StudentDocumentScalarFieldEnum: {
    id: 'id',
    type: 'type',
    fileName: 'fileName',
    fileSize: 'fileSize',
    fileType: 'fileType',
    documentUrl: 'documentUrl',
    studentId: 'studentId',
    verified: 'verified',
    verifiedBy: 'verifiedBy',
    verifiedAt: 'verifiedAt',
    rejected: 'rejected',
    rejectedBy: 'rejectedBy',
    rejectedAt: 'rejectedAt',
    rejectReason: 'rejectReason',
    uploadedBy: 'uploadedBy',
    uploadedAt: 'uploadedAt',
    note: 'note',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    organizationId: 'organizationId'
  };

  export type StudentDocumentScalarFieldEnum = (typeof StudentDocumentScalarFieldEnum)[keyof typeof StudentDocumentScalarFieldEnum]


  export const FeeScalarFieldEnum: {
    id: 'id',
    totalFee: 'totalFee',
    paidAmount: 'paidAmount',
    pendingAmount: 'pendingAmount',
    dueDate: 'dueDate',
    status: 'status',
    studentId: 'studentId',
    feeCategoryId: 'feeCategoryId',
    organizationId: 'organizationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeeScalarFieldEnum = (typeof FeeScalarFieldEnum)[keyof typeof FeeScalarFieldEnum]


  export const FeePaymentScalarFieldEnum: {
    id: 'id',
    feeId: 'feeId',
    amount: 'amount',
    status: 'status',
    paymentMethod: 'paymentMethod',
    paymentDate: 'paymentDate',
    receiptNumber: 'receiptNumber',
    note: 'note',
    transactionId: 'transactionId',
    payerId: 'payerId',
    platformFee: 'platformFee',
    recordedBy: 'recordedBy',
    organizationId: 'organizationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeePaymentScalarFieldEnum = (typeof FeePaymentScalarFieldEnum)[keyof typeof FeePaymentScalarFieldEnum]


  export const ScheduledJobScalarFieldEnum: {
    id: 'id',
    data: 'data',
    type: 'type',
    scheduledAt: 'scheduledAt',
    channels: 'channels',
    status: 'status',
    result: 'result',
    error: 'error',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    organizationId: 'organizationId'
  };

  export type ScheduledJobScalarFieldEnum = (typeof ScheduledJobScalarFieldEnum)[keyof typeof ScheduledJobScalarFieldEnum]


  export const FeeCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    organizationId: 'organizationId'
  };

  export type FeeCategoryScalarFieldEnum = (typeof FeeCategoryScalarFieldEnum)[keyof typeof FeeCategoryScalarFieldEnum]


  export const AcademicCalendarScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    name: 'name',
    startDate: 'startDate',
    endDate: 'endDate',
    type: 'type',
    reason: 'reason',
    isRecurring: 'isRecurring',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    academicYearId: 'academicYearId'
  };

  export type AcademicCalendarScalarFieldEnum = (typeof AcademicCalendarScalarFieldEnum)[keyof typeof AcademicCalendarScalarFieldEnum]


  export const AnonymousComplaintScalarFieldEnum: {
    id: 'id',
    trackingId: 'trackingId',
    category: 'category',
    severity: 'severity',
    subject: 'subject',
    description: 'description',
    evidenceUrls: 'evidenceUrls',
    submittedAt: 'submittedAt',
    currentStatus: 'currentStatus',
    organizationId: 'organizationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    academicYearId: 'academicYearId'
  };

  export type AnonymousComplaintScalarFieldEnum = (typeof AnonymousComplaintScalarFieldEnum)[keyof typeof AnonymousComplaintScalarFieldEnum]


  export const ComplaintStatusTimelineScalarFieldEnum: {
    id: 'id',
    complaintId: 'complaintId',
    note: 'note',
    status: 'status',
    changedBy: 'changedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ComplaintStatusTimelineScalarFieldEnum = (typeof ComplaintStatusTimelineScalarFieldEnum)[keyof typeof ComplaintStatusTimelineScalarFieldEnum]


  export const NoticeScalarFieldEnum: {
    id: 'id',
    noticeType: 'noticeType',
    title: 'title',
    startDate: 'startDate',
    endDate: 'endDate',
    content: 'content',
    summary: 'summary',
    isNoticeApproved: 'isNoticeApproved',
    isDraft: 'isDraft',
    isPublished: 'isPublished',
    emailNotification: 'emailNotification',
    pushNotification: 'pushNotification',
    WhatsAppNotification: 'WhatsAppNotification',
    smsNotification: 'smsNotification',
    targetAudience: 'targetAudience',
    attachments: 'attachments',
    publishedBy: 'publishedBy',
    organizationId: 'organizationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    academicYearId: 'academicYearId'
  };

  export type NoticeScalarFieldEnum = (typeof NoticeScalarFieldEnum)[keyof typeof NoticeScalarFieldEnum]


  export const NotificationLogScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    userId: 'userId',
    parentId: 'parentId',
    studentId: 'studentId',
    channel: 'channel',
    status: 'status',
    notificationType: 'notificationType',
    units: 'units',
    cost: 'cost',
    sentAt: 'sentAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationLogScalarFieldEnum = (typeof NotificationLogScalarFieldEnum)[keyof typeof NotificationLogScalarFieldEnum]


  export const ExamSessionScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    academicYearId: 'academicYearId',
    startDate: 'startDate',
    endDate: 'endDate',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExamSessionScalarFieldEnum = (typeof ExamSessionScalarFieldEnum)[keyof typeof ExamSessionScalarFieldEnum]


  export const ExamScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    examSessionId: 'examSessionId',
    subjectId: 'subjectId',
    gradeId: 'gradeId',
    sectionId: 'sectionId',
    organizationId: 'organizationId',
    maxMarks: 'maxMarks',
    passingMarks: 'passingMarks',
    weightage: 'weightage',
    evaluationType: 'evaluationType',
    mode: 'mode',
    status: 'status',
    instructions: 'instructions',
    durationInMinutes: 'durationInMinutes',
    venueMapUrl: 'venueMapUrl',
    venue: 'venue',
    isResultsPublished: 'isResultsPublished',
    supervisors: 'supervisors',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExamScalarFieldEnum = (typeof ExamScalarFieldEnum)[keyof typeof ExamScalarFieldEnum]


  export const ExamEnrollmentScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    examId: 'examId',
    status: 'status',
    enrolledAt: 'enrolledAt',
    exemptionReason: 'exemptionReason'
  };

  export type ExamEnrollmentScalarFieldEnum = (typeof ExamEnrollmentScalarFieldEnum)[keyof typeof ExamEnrollmentScalarFieldEnum]


  export const ExamResultScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    examId: 'examId',
    subjectId: 'subjectId',
    maxMarks: 'maxMarks',
    obtainedMarks: 'obtainedMarks',
    percentage: 'percentage',
    gradeLabel: 'gradeLabel',
    remarks: 'remarks',
    isPassed: 'isPassed',
    isAbsent: 'isAbsent',
    isResultsPublished: 'isResultsPublished',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExamResultScalarFieldEnum = (typeof ExamResultScalarFieldEnum)[keyof typeof ExamResultScalarFieldEnum]


  export const HallTicketScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    examId: 'examId',
    examSessionId: 'examSessionId',
    pdfUrl: 'pdfUrl',
    qrCode: 'qrCode',
    generatedAt: 'generatedAt',
    downloadedAt: 'downloadedAt',
    expiryDate: 'expiryDate',
    organizationId: 'organizationId'
  };

  export type HallTicketScalarFieldEnum = (typeof HallTicketScalarFieldEnum)[keyof typeof HallTicketScalarFieldEnum]


  export const ReportCardScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    examSessionId: 'examSessionId',
    totalMaxMarks: 'totalMaxMarks',
    totalObtained: 'totalObtained',
    percentage: 'percentage',
    cgpa: 'cgpa',
    overallGrade: 'overallGrade',
    resultStatus: 'resultStatus',
    classRank: 'classRank',
    gradeRank: 'gradeRank',
    attendancePercent: 'attendancePercent',
    conductGrade: 'conductGrade',
    remarks: 'remarks',
    principalRemarks: 'principalRemarks',
    rank: 'rank',
    pdfUrl: 'pdfUrl',
    generatedAt: 'generatedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReportCardScalarFieldEnum = (typeof ReportCardScalarFieldEnum)[keyof typeof ReportCardScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const AcademicYearOrderByRelevanceFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    name: 'name',
    description: 'description',
    createdBy: 'createdBy'
  };

  export type AcademicYearOrderByRelevanceFieldEnum = (typeof AcademicYearOrderByRelevanceFieldEnum)[keyof typeof AcademicYearOrderByRelevanceFieldEnum]


  export const OrganizationOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    organizationSlug: 'organizationSlug',
    organizationLogo: 'organizationLogo',
    contactEmail: 'contactEmail',
    contactPhone: 'contactPhone',
    website: 'website',
    createdBy: 'createdBy'
  };

  export type OrganizationOrderByRelevanceFieldEnum = (typeof OrganizationOrderByRelevanceFieldEnum)[keyof typeof OrganizationOrderByRelevanceFieldEnum]


  export const UserOrderByRelevanceFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    password: 'password',
    profileImage: 'profileImage',
    clerkId: 'clerkId',
    organizationId: 'organizationId'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const GradeOrderByRelevanceFieldEnum: {
    id: 'id',
    grade: 'grade',
    organizationId: 'organizationId'
  };

  export type GradeOrderByRelevanceFieldEnum = (typeof GradeOrderByRelevanceFieldEnum)[keyof typeof GradeOrderByRelevanceFieldEnum]


  export const SectionOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    gradeId: 'gradeId',
    organizationId: 'organizationId',
    classTeacherId: 'classTeacherId'
  };

  export type SectionOrderByRelevanceFieldEnum = (typeof SectionOrderByRelevanceFieldEnum)[keyof typeof SectionOrderByRelevanceFieldEnum]


  export const TeacherOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    employeeCode: 'employeeCode',
    organizationId: 'organizationId'
  };

  export type TeacherOrderByRelevanceFieldEnum = (typeof TeacherOrderByRelevanceFieldEnum)[keyof typeof TeacherOrderByRelevanceFieldEnum]


  export const TeacherProfileOrderByRelevanceFieldEnum: {
    id: 'id',
    teacherId: 'teacherId',
    contactEmail: 'contactEmail',
    contactPhone: 'contactPhone',
    address: 'address',
    city: 'city',
    state: 'state',
    qualification: 'qualification',
    resumeUrl: 'resumeUrl',
    bio: 'bio',
    teachingPhilosophy: 'teachingPhilosophy',
    specializedSubjects: 'specializedSubjects',
    preferredGrades: 'preferredGrades',
    idProofUrl: 'idProofUrl',
    linkedinPortfolio: 'linkedinPortfolio',
    languagesKnown: 'languagesKnown',
    certificateUrls: 'certificateUrls'
  };

  export type TeacherProfileOrderByRelevanceFieldEnum = (typeof TeacherProfileOrderByRelevanceFieldEnum)[keyof typeof TeacherProfileOrderByRelevanceFieldEnum]


  export const SubjectOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description',
    organizationId: 'organizationId'
  };

  export type SubjectOrderByRelevanceFieldEnum = (typeof SubjectOrderByRelevanceFieldEnum)[keyof typeof SubjectOrderByRelevanceFieldEnum]


  export const TeachingAssignmentOrderByRelevanceFieldEnum: {
    id: 'id',
    teacherId: 'teacherId',
    subjectId: 'subjectId',
    gradeId: 'gradeId',
    sectionId: 'sectionId',
    organizationId: 'organizationId',
    academicYear: 'academicYear',
    academicYearId: 'academicYearId'
  };

  export type TeachingAssignmentOrderByRelevanceFieldEnum = (typeof TeachingAssignmentOrderByRelevanceFieldEnum)[keyof typeof TeachingAssignmentOrderByRelevanceFieldEnum]


  export const StudentOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    middleName: 'middleName',
    motherName: 'motherName',
    fullName: 'fullName',
    profileImage: 'profileImage',
    rollNumber: 'rollNumber',
    phoneNumber: 'phoneNumber',
    whatsAppNumber: 'whatsAppNumber',
    email: 'email',
    emergencyContact: 'emergencyContact',
    sectionId: 'sectionId',
    gradeId: 'gradeId',
    organizationId: 'organizationId'
  };

  export type StudentOrderByRelevanceFieldEnum = (typeof StudentOrderByRelevanceFieldEnum)[keyof typeof StudentOrderByRelevanceFieldEnum]


  export const ParentOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phoneNumber: 'phoneNumber',
    whatsAppNumber: 'whatsAppNumber'
  };

  export type ParentOrderByRelevanceFieldEnum = (typeof ParentOrderByRelevanceFieldEnum)[keyof typeof ParentOrderByRelevanceFieldEnum]


  export const ParentStudentOrderByRelevanceFieldEnum: {
    id: 'id',
    relationship: 'relationship',
    studentId: 'studentId',
    parentId: 'parentId'
  };

  export type ParentStudentOrderByRelevanceFieldEnum = (typeof ParentStudentOrderByRelevanceFieldEnum)[keyof typeof ParentStudentOrderByRelevanceFieldEnum]


  export const StudentAttendanceOrderByRelevanceFieldEnum: {
    id: 'id',
    note: 'note',
    recordedBy: 'recordedBy',
    studentId: 'studentId',
    sectionId: 'sectionId',
    academicYearId: 'academicYearId'
  };

  export type StudentAttendanceOrderByRelevanceFieldEnum = (typeof StudentAttendanceOrderByRelevanceFieldEnum)[keyof typeof StudentAttendanceOrderByRelevanceFieldEnum]


  export const StudentDocumentOrderByRelevanceFieldEnum: {
    id: 'id',
    fileName: 'fileName',
    fileType: 'fileType',
    documentUrl: 'documentUrl',
    studentId: 'studentId',
    verifiedBy: 'verifiedBy',
    rejectedBy: 'rejectedBy',
    rejectReason: 'rejectReason',
    uploadedBy: 'uploadedBy',
    note: 'note',
    organizationId: 'organizationId'
  };

  export type StudentDocumentOrderByRelevanceFieldEnum = (typeof StudentDocumentOrderByRelevanceFieldEnum)[keyof typeof StudentDocumentOrderByRelevanceFieldEnum]


  export const FeeOrderByRelevanceFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    feeCategoryId: 'feeCategoryId',
    organizationId: 'organizationId'
  };

  export type FeeOrderByRelevanceFieldEnum = (typeof FeeOrderByRelevanceFieldEnum)[keyof typeof FeeOrderByRelevanceFieldEnum]


  export const FeePaymentOrderByRelevanceFieldEnum: {
    id: 'id',
    feeId: 'feeId',
    receiptNumber: 'receiptNumber',
    note: 'note',
    transactionId: 'transactionId',
    payerId: 'payerId',
    recordedBy: 'recordedBy',
    organizationId: 'organizationId'
  };

  export type FeePaymentOrderByRelevanceFieldEnum = (typeof FeePaymentOrderByRelevanceFieldEnum)[keyof typeof FeePaymentOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const ScheduledJobOrderByRelevanceFieldEnum: {
    id: 'id',
    status: 'status',
    error: 'error',
    createdBy: 'createdBy',
    organizationId: 'organizationId'
  };

  export type ScheduledJobOrderByRelevanceFieldEnum = (typeof ScheduledJobOrderByRelevanceFieldEnum)[keyof typeof ScheduledJobOrderByRelevanceFieldEnum]


  export const FeeCategoryOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    organizationId: 'organizationId'
  };

  export type FeeCategoryOrderByRelevanceFieldEnum = (typeof FeeCategoryOrderByRelevanceFieldEnum)[keyof typeof FeeCategoryOrderByRelevanceFieldEnum]


  export const AcademicCalendarOrderByRelevanceFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    name: 'name',
    reason: 'reason',
    createdBy: 'createdBy',
    academicYearId: 'academicYearId'
  };

  export type AcademicCalendarOrderByRelevanceFieldEnum = (typeof AcademicCalendarOrderByRelevanceFieldEnum)[keyof typeof AcademicCalendarOrderByRelevanceFieldEnum]


  export const AnonymousComplaintOrderByRelevanceFieldEnum: {
    id: 'id',
    trackingId: 'trackingId',
    category: 'category',
    subject: 'subject',
    description: 'description',
    evidenceUrls: 'evidenceUrls',
    organizationId: 'organizationId',
    academicYearId: 'academicYearId'
  };

  export type AnonymousComplaintOrderByRelevanceFieldEnum = (typeof AnonymousComplaintOrderByRelevanceFieldEnum)[keyof typeof AnonymousComplaintOrderByRelevanceFieldEnum]


  export const ComplaintStatusTimelineOrderByRelevanceFieldEnum: {
    id: 'id',
    complaintId: 'complaintId',
    note: 'note',
    changedBy: 'changedBy'
  };

  export type ComplaintStatusTimelineOrderByRelevanceFieldEnum = (typeof ComplaintStatusTimelineOrderByRelevanceFieldEnum)[keyof typeof ComplaintStatusTimelineOrderByRelevanceFieldEnum]


  export const NoticeOrderByRelevanceFieldEnum: {
    id: 'id',
    noticeType: 'noticeType',
    title: 'title',
    content: 'content',
    summary: 'summary',
    targetAudience: 'targetAudience',
    publishedBy: 'publishedBy',
    organizationId: 'organizationId',
    academicYearId: 'academicYearId'
  };

  export type NoticeOrderByRelevanceFieldEnum = (typeof NoticeOrderByRelevanceFieldEnum)[keyof typeof NoticeOrderByRelevanceFieldEnum]


  export const NotificationLogOrderByRelevanceFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    userId: 'userId',
    parentId: 'parentId',
    studentId: 'studentId'
  };

  export type NotificationLogOrderByRelevanceFieldEnum = (typeof NotificationLogOrderByRelevanceFieldEnum)[keyof typeof NotificationLogOrderByRelevanceFieldEnum]


  export const ExamSessionOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    academicYearId: 'academicYearId',
    createdBy: 'createdBy'
  };

  export type ExamSessionOrderByRelevanceFieldEnum = (typeof ExamSessionOrderByRelevanceFieldEnum)[keyof typeof ExamSessionOrderByRelevanceFieldEnum]


  export const ExamOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    examSessionId: 'examSessionId',
    subjectId: 'subjectId',
    gradeId: 'gradeId',
    sectionId: 'sectionId',
    organizationId: 'organizationId',
    instructions: 'instructions',
    venueMapUrl: 'venueMapUrl',
    venue: 'venue',
    supervisors: 'supervisors'
  };

  export type ExamOrderByRelevanceFieldEnum = (typeof ExamOrderByRelevanceFieldEnum)[keyof typeof ExamOrderByRelevanceFieldEnum]


  export const ExamEnrollmentOrderByRelevanceFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    examId: 'examId',
    exemptionReason: 'exemptionReason'
  };

  export type ExamEnrollmentOrderByRelevanceFieldEnum = (typeof ExamEnrollmentOrderByRelevanceFieldEnum)[keyof typeof ExamEnrollmentOrderByRelevanceFieldEnum]


  export const ExamResultOrderByRelevanceFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    examId: 'examId',
    subjectId: 'subjectId',
    gradeLabel: 'gradeLabel',
    remarks: 'remarks'
  };

  export type ExamResultOrderByRelevanceFieldEnum = (typeof ExamResultOrderByRelevanceFieldEnum)[keyof typeof ExamResultOrderByRelevanceFieldEnum]


  export const HallTicketOrderByRelevanceFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    examId: 'examId',
    examSessionId: 'examSessionId',
    pdfUrl: 'pdfUrl',
    qrCode: 'qrCode',
    organizationId: 'organizationId'
  };

  export type HallTicketOrderByRelevanceFieldEnum = (typeof HallTicketOrderByRelevanceFieldEnum)[keyof typeof HallTicketOrderByRelevanceFieldEnum]


  export const ReportCardOrderByRelevanceFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    examSessionId: 'examSessionId',
    overallGrade: 'overallGrade',
    conductGrade: 'conductGrade',
    remarks: 'remarks',
    principalRemarks: 'principalRemarks',
    pdfUrl: 'pdfUrl'
  };

  export type ReportCardOrderByRelevanceFieldEnum = (typeof ReportCardOrderByRelevanceFieldEnum)[keyof typeof ReportCardOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'YearType'
   */
  export type EnumYearTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'YearType'>
    


  /**
   * Reference to a field of type 'YearType[]'
   */
  export type ListEnumYearTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'YearType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'PlanType'
   */
  export type EnumPlanTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanType'>
    


  /**
   * Reference to a field of type 'PlanType[]'
   */
  export type ListEnumPlanTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'OrganizationType'
   */
  export type EnumOrganizationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrganizationType'>
    


  /**
   * Reference to a field of type 'OrganizationType[]'
   */
  export type ListEnumOrganizationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrganizationType[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'EmploymentStatus'
   */
  export type EnumEmploymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmploymentStatus'>
    


  /**
   * Reference to a field of type 'EmploymentStatus[]'
   */
  export type ListEnumEmploymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmploymentStatus[]'>
    


  /**
   * Reference to a field of type 'AssignmentStatus'
   */
  export type EnumAssignmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssignmentStatus'>
    


  /**
   * Reference to a field of type 'AssignmentStatus[]'
   */
  export type ListEnumAssignmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssignmentStatus[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'AttendanceStatus'
   */
  export type EnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus'>
    


  /**
   * Reference to a field of type 'AttendanceStatus[]'
   */
  export type ListEnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus[]'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'FeeStatus'
   */
  export type EnumFeeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeeStatus'>
    


  /**
   * Reference to a field of type 'FeeStatus[]'
   */
  export type ListEnumFeeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeeStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'scheduledJobType'
   */
  export type EnumscheduledJobTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'scheduledJobType'>
    


  /**
   * Reference to a field of type 'scheduledJobType[]'
   */
  export type ListEnumscheduledJobTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'scheduledJobType[]'>
    


  /**
   * Reference to a field of type 'NotificationChannel[]'
   */
  export type ListEnumNotificationChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationChannel[]'>
    


  /**
   * Reference to a field of type 'NotificationChannel'
   */
  export type EnumNotificationChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationChannel'>
    


  /**
   * Reference to a field of type 'CalendarEventType'
   */
  export type EnumCalendarEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CalendarEventType'>
    


  /**
   * Reference to a field of type 'CalendarEventType[]'
   */
  export type ListEnumCalendarEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CalendarEventType[]'>
    


  /**
   * Reference to a field of type 'Severity'
   */
  export type EnumSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Severity'>
    


  /**
   * Reference to a field of type 'Severity[]'
   */
  export type ListEnumSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Severity[]'>
    


  /**
   * Reference to a field of type 'ComplaintStatus'
   */
  export type EnumComplaintStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComplaintStatus'>
    


  /**
   * Reference to a field of type 'ComplaintStatus[]'
   */
  export type ListEnumComplaintStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComplaintStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationStatus'
   */
  export type EnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus'>
    


  /**
   * Reference to a field of type 'NotificationStatus[]'
   */
  export type ListEnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'EvaluationType'
   */
  export type EnumEvaluationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EvaluationType'>
    


  /**
   * Reference to a field of type 'EvaluationType[]'
   */
  export type ListEnumEvaluationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EvaluationType[]'>
    


  /**
   * Reference to a field of type 'ExamMode'
   */
  export type EnumExamModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExamMode'>
    


  /**
   * Reference to a field of type 'ExamMode[]'
   */
  export type ListEnumExamModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExamMode[]'>
    


  /**
   * Reference to a field of type 'ExamStatus'
   */
  export type EnumExamStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExamStatus'>
    


  /**
   * Reference to a field of type 'ExamStatus[]'
   */
  export type ListEnumExamStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExamStatus[]'>
    


  /**
   * Reference to a field of type 'StudentExamStatus'
   */
  export type EnumStudentExamStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StudentExamStatus'>
    


  /**
   * Reference to a field of type 'StudentExamStatus[]'
   */
  export type ListEnumStudentExamStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StudentExamStatus[]'>
    


  /**
   * Reference to a field of type 'ResultStatus'
   */
  export type EnumResultStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResultStatus'>
    


  /**
   * Reference to a field of type 'ResultStatus[]'
   */
  export type ListEnumResultStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResultStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type AcademicYearWhereInput = {
    AND?: AcademicYearWhereInput | AcademicYearWhereInput[]
    OR?: AcademicYearWhereInput[]
    NOT?: AcademicYearWhereInput | AcademicYearWhereInput[]
    id?: StringFilter<"AcademicYear"> | string
    organizationId?: StringFilter<"AcademicYear"> | string
    name?: StringFilter<"AcademicYear"> | string
    startDate?: DateTimeFilter<"AcademicYear"> | Date | string
    endDate?: DateTimeFilter<"AcademicYear"> | Date | string
    type?: EnumYearTypeFilter<"AcademicYear"> | $Enums.YearType
    isCurrent?: BoolFilter<"AcademicYear"> | boolean
    description?: StringNullableFilter<"AcademicYear"> | string | null
    createdBy?: StringFilter<"AcademicYear"> | string
    createdAt?: DateTimeFilter<"AcademicYear"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicYear"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    complaints?: AnonymousComplaintListRelationFilter
    notices?: NoticeListRelationFilter
    TeachingAssignment?: TeachingAssignmentListRelationFilter
    StudentAttendance?: StudentAttendanceListRelationFilter
    AcademicCalendar?: AcademicCalendarListRelationFilter
    ExamSession?: ExamSessionListRelationFilter
  }

  export type AcademicYearOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    type?: SortOrder
    isCurrent?: SortOrder
    description?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    complaints?: AnonymousComplaintOrderByRelationAggregateInput
    notices?: NoticeOrderByRelationAggregateInput
    TeachingAssignment?: TeachingAssignmentOrderByRelationAggregateInput
    StudentAttendance?: StudentAttendanceOrderByRelationAggregateInput
    AcademicCalendar?: AcademicCalendarOrderByRelationAggregateInput
    ExamSession?: ExamSessionOrderByRelationAggregateInput
    _relevance?: AcademicYearOrderByRelevanceInput
  }

  export type AcademicYearWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    organizationId_name?: AcademicYearOrganizationIdNameCompoundUniqueInput
    AND?: AcademicYearWhereInput | AcademicYearWhereInput[]
    OR?: AcademicYearWhereInput[]
    NOT?: AcademicYearWhereInput | AcademicYearWhereInput[]
    organizationId?: StringFilter<"AcademicYear"> | string
    name?: StringFilter<"AcademicYear"> | string
    startDate?: DateTimeFilter<"AcademicYear"> | Date | string
    endDate?: DateTimeFilter<"AcademicYear"> | Date | string
    type?: EnumYearTypeFilter<"AcademicYear"> | $Enums.YearType
    isCurrent?: BoolFilter<"AcademicYear"> | boolean
    description?: StringNullableFilter<"AcademicYear"> | string | null
    createdBy?: StringFilter<"AcademicYear"> | string
    createdAt?: DateTimeFilter<"AcademicYear"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicYear"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    complaints?: AnonymousComplaintListRelationFilter
    notices?: NoticeListRelationFilter
    TeachingAssignment?: TeachingAssignmentListRelationFilter
    StudentAttendance?: StudentAttendanceListRelationFilter
    AcademicCalendar?: AcademicCalendarListRelationFilter
    ExamSession?: ExamSessionListRelationFilter
  }, "id" | "organizationId_name">

  export type AcademicYearOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    type?: SortOrder
    isCurrent?: SortOrder
    description?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AcademicYearCountOrderByAggregateInput
    _max?: AcademicYearMaxOrderByAggregateInput
    _min?: AcademicYearMinOrderByAggregateInput
  }

  export type AcademicYearScalarWhereWithAggregatesInput = {
    AND?: AcademicYearScalarWhereWithAggregatesInput | AcademicYearScalarWhereWithAggregatesInput[]
    OR?: AcademicYearScalarWhereWithAggregatesInput[]
    NOT?: AcademicYearScalarWhereWithAggregatesInput | AcademicYearScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AcademicYear"> | string
    organizationId?: StringWithAggregatesFilter<"AcademicYear"> | string
    name?: StringWithAggregatesFilter<"AcademicYear"> | string
    startDate?: DateTimeWithAggregatesFilter<"AcademicYear"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"AcademicYear"> | Date | string
    type?: EnumYearTypeWithAggregatesFilter<"AcademicYear"> | $Enums.YearType
    isCurrent?: BoolWithAggregatesFilter<"AcademicYear"> | boolean
    description?: StringNullableWithAggregatesFilter<"AcademicYear"> | string | null
    createdBy?: StringWithAggregatesFilter<"AcademicYear"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AcademicYear"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AcademicYear"> | Date | string
  }

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: StringFilter<"Organization"> | string
    name?: StringNullableFilter<"Organization"> | string | null
    organizationSlug?: StringFilter<"Organization"> | string
    organizationLogo?: StringNullableFilter<"Organization"> | string | null
    contactEmail?: StringNullableFilter<"Organization"> | string | null
    contactPhone?: StringNullableFilter<"Organization"> | string | null
    website?: StringNullableFilter<"Organization"> | string | null
    isActive?: BoolFilter<"Organization"> | boolean
    isPaid?: BoolFilter<"Organization"> | boolean
    plan?: EnumPlanTypeFilter<"Organization"> | $Enums.PlanType
    planStartedAt?: DateTimeNullableFilter<"Organization"> | Date | string | null
    planExpiresAt?: DateTimeNullableFilter<"Organization"> | Date | string | null
    maxStudents?: IntNullableFilter<"Organization"> | number | null
    organizationType?: EnumOrganizationTypeNullableFilter<"Organization"> | $Enums.OrganizationType | null
    createdBy?: StringNullableFilter<"Organization"> | string | null
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    users?: UserListRelationFilter
    notices?: NoticeListRelationFilter
    Student?: StudentListRelationFilter
    StudentDocument?: StudentDocumentListRelationFilter
    Grade?: GradeListRelationFilter
    Section?: SectionListRelationFilter
    Fee?: FeeListRelationFilter
    FeeCategory?: FeeCategoryListRelationFilter
    FeePayment?: FeePaymentListRelationFilter
    AcademicCalendar?: AcademicCalendarListRelationFilter
    AnonymousComplaint?: AnonymousComplaintListRelationFilter
    Teacher?: TeacherListRelationFilter
    Subject?: SubjectListRelationFilter
    TeachingAssignment?: TeachingAssignmentListRelationFilter
    NotificationLog?: NotificationLogListRelationFilter
    AcademicYear?: AcademicYearListRelationFilter
    scheduledJob?: ScheduledJobListRelationFilter
    Exam?: ExamListRelationFilter
    hallTicket?: HallTicketListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    organizationSlug?: SortOrder
    organizationLogo?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isPaid?: SortOrder
    plan?: SortOrder
    planStartedAt?: SortOrderInput | SortOrder
    planExpiresAt?: SortOrderInput | SortOrder
    maxStudents?: SortOrderInput | SortOrder
    organizationType?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    notices?: NoticeOrderByRelationAggregateInput
    Student?: StudentOrderByRelationAggregateInput
    StudentDocument?: StudentDocumentOrderByRelationAggregateInput
    Grade?: GradeOrderByRelationAggregateInput
    Section?: SectionOrderByRelationAggregateInput
    Fee?: FeeOrderByRelationAggregateInput
    FeeCategory?: FeeCategoryOrderByRelationAggregateInput
    FeePayment?: FeePaymentOrderByRelationAggregateInput
    AcademicCalendar?: AcademicCalendarOrderByRelationAggregateInput
    AnonymousComplaint?: AnonymousComplaintOrderByRelationAggregateInput
    Teacher?: TeacherOrderByRelationAggregateInput
    Subject?: SubjectOrderByRelationAggregateInput
    TeachingAssignment?: TeachingAssignmentOrderByRelationAggregateInput
    NotificationLog?: NotificationLogOrderByRelationAggregateInput
    AcademicYear?: AcademicYearOrderByRelationAggregateInput
    scheduledJob?: ScheduledJobOrderByRelationAggregateInput
    Exam?: ExamOrderByRelationAggregateInput
    hallTicket?: HallTicketOrderByRelationAggregateInput
    _relevance?: OrganizationOrderByRelevanceInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    organizationSlug?: string
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    name?: StringNullableFilter<"Organization"> | string | null
    organizationLogo?: StringNullableFilter<"Organization"> | string | null
    contactEmail?: StringNullableFilter<"Organization"> | string | null
    contactPhone?: StringNullableFilter<"Organization"> | string | null
    website?: StringNullableFilter<"Organization"> | string | null
    isActive?: BoolFilter<"Organization"> | boolean
    isPaid?: BoolFilter<"Organization"> | boolean
    plan?: EnumPlanTypeFilter<"Organization"> | $Enums.PlanType
    planStartedAt?: DateTimeNullableFilter<"Organization"> | Date | string | null
    planExpiresAt?: DateTimeNullableFilter<"Organization"> | Date | string | null
    maxStudents?: IntNullableFilter<"Organization"> | number | null
    organizationType?: EnumOrganizationTypeNullableFilter<"Organization"> | $Enums.OrganizationType | null
    createdBy?: StringNullableFilter<"Organization"> | string | null
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    users?: UserListRelationFilter
    notices?: NoticeListRelationFilter
    Student?: StudentListRelationFilter
    StudentDocument?: StudentDocumentListRelationFilter
    Grade?: GradeListRelationFilter
    Section?: SectionListRelationFilter
    Fee?: FeeListRelationFilter
    FeeCategory?: FeeCategoryListRelationFilter
    FeePayment?: FeePaymentListRelationFilter
    AcademicCalendar?: AcademicCalendarListRelationFilter
    AnonymousComplaint?: AnonymousComplaintListRelationFilter
    Teacher?: TeacherListRelationFilter
    Subject?: SubjectListRelationFilter
    TeachingAssignment?: TeachingAssignmentListRelationFilter
    NotificationLog?: NotificationLogListRelationFilter
    AcademicYear?: AcademicYearListRelationFilter
    scheduledJob?: ScheduledJobListRelationFilter
    Exam?: ExamListRelationFilter
    hallTicket?: HallTicketListRelationFilter
  }, "id" | "organizationSlug">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    organizationSlug?: SortOrder
    organizationLogo?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isPaid?: SortOrder
    plan?: SortOrder
    planStartedAt?: SortOrderInput | SortOrder
    planExpiresAt?: SortOrderInput | SortOrder
    maxStudents?: SortOrderInput | SortOrder
    organizationType?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _avg?: OrganizationAvgOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
    _sum?: OrganizationSumOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Organization"> | string
    name?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    organizationSlug?: StringWithAggregatesFilter<"Organization"> | string
    organizationLogo?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    contactEmail?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    contactPhone?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    website?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    isActive?: BoolWithAggregatesFilter<"Organization"> | boolean
    isPaid?: BoolWithAggregatesFilter<"Organization"> | boolean
    plan?: EnumPlanTypeWithAggregatesFilter<"Organization"> | $Enums.PlanType
    planStartedAt?: DateTimeNullableWithAggregatesFilter<"Organization"> | Date | string | null
    planExpiresAt?: DateTimeNullableWithAggregatesFilter<"Organization"> | Date | string | null
    maxStudents?: IntNullableWithAggregatesFilter<"Organization"> | number | null
    organizationType?: EnumOrganizationTypeNullableWithAggregatesFilter<"Organization"> | $Enums.OrganizationType | null
    createdBy?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    profileImage?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    clerkId?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    organizationId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    organization?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
    teacher?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    parent?: XOR<ParentNullableScalarRelationFilter, ParentWhereInput> | null
    FeePayment?: FeePaymentListRelationFilter
    NotificationLog?: NotificationLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    profileImage?: SortOrder
    role?: SortOrder
    clerkId?: SortOrder
    isActive?: SortOrder
    organizationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    teacher?: TeacherOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
    parent?: ParentOrderByWithRelationInput
    FeePayment?: FeePaymentOrderByRelationAggregateInput
    NotificationLog?: NotificationLogOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    clerkId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    profileImage?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    isActive?: BoolFilter<"User"> | boolean
    organizationId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    organization?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
    teacher?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    parent?: XOR<ParentNullableScalarRelationFilter, ParentWhereInput> | null
    FeePayment?: FeePaymentListRelationFilter
    NotificationLog?: NotificationLogListRelationFilter
  }, "id" | "email" | "clerkId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    profileImage?: SortOrder
    role?: SortOrder
    clerkId?: SortOrder
    isActive?: SortOrder
    organizationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    profileImage?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    clerkId?: StringWithAggregatesFilter<"User"> | string
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    organizationId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type GradeWhereInput = {
    AND?: GradeWhereInput | GradeWhereInput[]
    OR?: GradeWhereInput[]
    NOT?: GradeWhereInput | GradeWhereInput[]
    id?: StringFilter<"Grade"> | string
    grade?: StringFilter<"Grade"> | string
    organizationId?: StringFilter<"Grade"> | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    students?: StudentListRelationFilter
    section?: SectionListRelationFilter
    TeachingAssignment?: TeachingAssignmentListRelationFilter
  }

  export type GradeOrderByWithRelationInput = {
    id?: SortOrder
    grade?: SortOrder
    organizationId?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    students?: StudentOrderByRelationAggregateInput
    section?: SectionOrderByRelationAggregateInput
    TeachingAssignment?: TeachingAssignmentOrderByRelationAggregateInput
    _relevance?: GradeOrderByRelevanceInput
  }

  export type GradeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GradeWhereInput | GradeWhereInput[]
    OR?: GradeWhereInput[]
    NOT?: GradeWhereInput | GradeWhereInput[]
    grade?: StringFilter<"Grade"> | string
    organizationId?: StringFilter<"Grade"> | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    students?: StudentListRelationFilter
    section?: SectionListRelationFilter
    TeachingAssignment?: TeachingAssignmentListRelationFilter
  }, "id">

  export type GradeOrderByWithAggregationInput = {
    id?: SortOrder
    grade?: SortOrder
    organizationId?: SortOrder
    _count?: GradeCountOrderByAggregateInput
    _max?: GradeMaxOrderByAggregateInput
    _min?: GradeMinOrderByAggregateInput
  }

  export type GradeScalarWhereWithAggregatesInput = {
    AND?: GradeScalarWhereWithAggregatesInput | GradeScalarWhereWithAggregatesInput[]
    OR?: GradeScalarWhereWithAggregatesInput[]
    NOT?: GradeScalarWhereWithAggregatesInput | GradeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Grade"> | string
    grade?: StringWithAggregatesFilter<"Grade"> | string
    organizationId?: StringWithAggregatesFilter<"Grade"> | string
  }

  export type SectionWhereInput = {
    AND?: SectionWhereInput | SectionWhereInput[]
    OR?: SectionWhereInput[]
    NOT?: SectionWhereInput | SectionWhereInput[]
    id?: StringFilter<"Section"> | string
    name?: StringFilter<"Section"> | string
    gradeId?: StringFilter<"Section"> | string
    organizationId?: StringFilter<"Section"> | string
    classTeacherId?: StringNullableFilter<"Section"> | string | null
    grade?: XOR<GradeScalarRelationFilter, GradeWhereInput>
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    classTeacher?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
    students?: StudentListRelationFilter
    StudentAttendance?: StudentAttendanceListRelationFilter
    TeachingAssignment?: TeachingAssignmentListRelationFilter
  }

  export type SectionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    gradeId?: SortOrder
    organizationId?: SortOrder
    classTeacherId?: SortOrderInput | SortOrder
    grade?: GradeOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
    classTeacher?: TeacherOrderByWithRelationInput
    students?: StudentOrderByRelationAggregateInput
    StudentAttendance?: StudentAttendanceOrderByRelationAggregateInput
    TeachingAssignment?: TeachingAssignmentOrderByRelationAggregateInput
    _relevance?: SectionOrderByRelevanceInput
  }

  export type SectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name_gradeId?: SectionNameGradeIdCompoundUniqueInput
    AND?: SectionWhereInput | SectionWhereInput[]
    OR?: SectionWhereInput[]
    NOT?: SectionWhereInput | SectionWhereInput[]
    name?: StringFilter<"Section"> | string
    gradeId?: StringFilter<"Section"> | string
    organizationId?: StringFilter<"Section"> | string
    classTeacherId?: StringNullableFilter<"Section"> | string | null
    grade?: XOR<GradeScalarRelationFilter, GradeWhereInput>
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    classTeacher?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
    students?: StudentListRelationFilter
    StudentAttendance?: StudentAttendanceListRelationFilter
    TeachingAssignment?: TeachingAssignmentListRelationFilter
  }, "id" | "name_gradeId">

  export type SectionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    gradeId?: SortOrder
    organizationId?: SortOrder
    classTeacherId?: SortOrderInput | SortOrder
    _count?: SectionCountOrderByAggregateInput
    _max?: SectionMaxOrderByAggregateInput
    _min?: SectionMinOrderByAggregateInput
  }

  export type SectionScalarWhereWithAggregatesInput = {
    AND?: SectionScalarWhereWithAggregatesInput | SectionScalarWhereWithAggregatesInput[]
    OR?: SectionScalarWhereWithAggregatesInput[]
    NOT?: SectionScalarWhereWithAggregatesInput | SectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Section"> | string
    name?: StringWithAggregatesFilter<"Section"> | string
    gradeId?: StringWithAggregatesFilter<"Section"> | string
    organizationId?: StringWithAggregatesFilter<"Section"> | string
    classTeacherId?: StringNullableWithAggregatesFilter<"Section"> | string | null
  }

  export type TeacherWhereInput = {
    AND?: TeacherWhereInput | TeacherWhereInput[]
    OR?: TeacherWhereInput[]
    NOT?: TeacherWhereInput | TeacherWhereInput[]
    id?: StringFilter<"Teacher"> | string
    userId?: StringFilter<"Teacher"> | string
    employeeCode?: StringNullableFilter<"Teacher"> | string | null
    employmentStatus?: EnumEmploymentStatusFilter<"Teacher"> | $Enums.EmploymentStatus
    isActive?: BoolFilter<"Teacher"> | boolean
    organizationId?: StringFilter<"Teacher"> | string
    createdAt?: DateTimeFilter<"Teacher"> | Date | string
    updatedAt?: DateTimeFilter<"Teacher"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    profile?: XOR<TeacherProfileNullableScalarRelationFilter, TeacherProfileWhereInput> | null
    TeachingAssignment?: TeachingAssignmentListRelationFilter
    Section?: SectionListRelationFilter
  }

  export type TeacherOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    employeeCode?: SortOrderInput | SortOrder
    employmentStatus?: SortOrder
    isActive?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
    profile?: TeacherProfileOrderByWithRelationInput
    TeachingAssignment?: TeachingAssignmentOrderByRelationAggregateInput
    Section?: SectionOrderByRelationAggregateInput
    _relevance?: TeacherOrderByRelevanceInput
  }

  export type TeacherWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    employeeCode?: string
    AND?: TeacherWhereInput | TeacherWhereInput[]
    OR?: TeacherWhereInput[]
    NOT?: TeacherWhereInput | TeacherWhereInput[]
    employmentStatus?: EnumEmploymentStatusFilter<"Teacher"> | $Enums.EmploymentStatus
    isActive?: BoolFilter<"Teacher"> | boolean
    organizationId?: StringFilter<"Teacher"> | string
    createdAt?: DateTimeFilter<"Teacher"> | Date | string
    updatedAt?: DateTimeFilter<"Teacher"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    profile?: XOR<TeacherProfileNullableScalarRelationFilter, TeacherProfileWhereInput> | null
    TeachingAssignment?: TeachingAssignmentListRelationFilter
    Section?: SectionListRelationFilter
  }, "id" | "userId" | "employeeCode">

  export type TeacherOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    employeeCode?: SortOrderInput | SortOrder
    employmentStatus?: SortOrder
    isActive?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeacherCountOrderByAggregateInput
    _max?: TeacherMaxOrderByAggregateInput
    _min?: TeacherMinOrderByAggregateInput
  }

  export type TeacherScalarWhereWithAggregatesInput = {
    AND?: TeacherScalarWhereWithAggregatesInput | TeacherScalarWhereWithAggregatesInput[]
    OR?: TeacherScalarWhereWithAggregatesInput[]
    NOT?: TeacherScalarWhereWithAggregatesInput | TeacherScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Teacher"> | string
    userId?: StringWithAggregatesFilter<"Teacher"> | string
    employeeCode?: StringNullableWithAggregatesFilter<"Teacher"> | string | null
    employmentStatus?: EnumEmploymentStatusWithAggregatesFilter<"Teacher"> | $Enums.EmploymentStatus
    isActive?: BoolWithAggregatesFilter<"Teacher"> | boolean
    organizationId?: StringWithAggregatesFilter<"Teacher"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Teacher"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Teacher"> | Date | string
  }

  export type TeacherProfileWhereInput = {
    AND?: TeacherProfileWhereInput | TeacherProfileWhereInput[]
    OR?: TeacherProfileWhereInput[]
    NOT?: TeacherProfileWhereInput | TeacherProfileWhereInput[]
    id?: StringFilter<"TeacherProfile"> | string
    teacherId?: StringFilter<"TeacherProfile"> | string
    contactEmail?: StringFilter<"TeacherProfile"> | string
    contactPhone?: StringFilter<"TeacherProfile"> | string
    address?: StringFilter<"TeacherProfile"> | string
    city?: StringNullableFilter<"TeacherProfile"> | string | null
    state?: StringNullableFilter<"TeacherProfile"> | string | null
    dateOfBirth?: DateTimeFilter<"TeacherProfile"> | Date | string
    qualification?: StringFilter<"TeacherProfile"> | string
    experienceInYears?: IntFilter<"TeacherProfile"> | number
    resumeUrl?: StringNullableFilter<"TeacherProfile"> | string | null
    joinedAt?: DateTimeFilter<"TeacherProfile"> | Date | string
    bio?: StringNullableFilter<"TeacherProfile"> | string | null
    teachingPhilosophy?: StringNullableFilter<"TeacherProfile"> | string | null
    specializedSubjects?: StringNullableListFilter<"TeacherProfile">
    preferredGrades?: StringNullableListFilter<"TeacherProfile">
    idProofUrl?: StringFilter<"TeacherProfile"> | string
    linkedinPortfolio?: StringNullableFilter<"TeacherProfile"> | string | null
    languagesKnown?: StringNullableListFilter<"TeacherProfile">
    certificateUrls?: StringNullableListFilter<"TeacherProfile">
    teacher?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
  }

  export type TeacherProfileOrderByWithRelationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    address?: SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrder
    qualification?: SortOrder
    experienceInYears?: SortOrder
    resumeUrl?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    bio?: SortOrderInput | SortOrder
    teachingPhilosophy?: SortOrderInput | SortOrder
    specializedSubjects?: SortOrder
    preferredGrades?: SortOrder
    idProofUrl?: SortOrder
    linkedinPortfolio?: SortOrderInput | SortOrder
    languagesKnown?: SortOrder
    certificateUrls?: SortOrder
    teacher?: TeacherOrderByWithRelationInput
    _relevance?: TeacherProfileOrderByRelevanceInput
  }

  export type TeacherProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    teacherId?: string
    AND?: TeacherProfileWhereInput | TeacherProfileWhereInput[]
    OR?: TeacherProfileWhereInput[]
    NOT?: TeacherProfileWhereInput | TeacherProfileWhereInput[]
    contactEmail?: StringFilter<"TeacherProfile"> | string
    contactPhone?: StringFilter<"TeacherProfile"> | string
    address?: StringFilter<"TeacherProfile"> | string
    city?: StringNullableFilter<"TeacherProfile"> | string | null
    state?: StringNullableFilter<"TeacherProfile"> | string | null
    dateOfBirth?: DateTimeFilter<"TeacherProfile"> | Date | string
    qualification?: StringFilter<"TeacherProfile"> | string
    experienceInYears?: IntFilter<"TeacherProfile"> | number
    resumeUrl?: StringNullableFilter<"TeacherProfile"> | string | null
    joinedAt?: DateTimeFilter<"TeacherProfile"> | Date | string
    bio?: StringNullableFilter<"TeacherProfile"> | string | null
    teachingPhilosophy?: StringNullableFilter<"TeacherProfile"> | string | null
    specializedSubjects?: StringNullableListFilter<"TeacherProfile">
    preferredGrades?: StringNullableListFilter<"TeacherProfile">
    idProofUrl?: StringFilter<"TeacherProfile"> | string
    linkedinPortfolio?: StringNullableFilter<"TeacherProfile"> | string | null
    languagesKnown?: StringNullableListFilter<"TeacherProfile">
    certificateUrls?: StringNullableListFilter<"TeacherProfile">
    teacher?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
  }, "id" | "teacherId">

  export type TeacherProfileOrderByWithAggregationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    address?: SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrder
    qualification?: SortOrder
    experienceInYears?: SortOrder
    resumeUrl?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    bio?: SortOrderInput | SortOrder
    teachingPhilosophy?: SortOrderInput | SortOrder
    specializedSubjects?: SortOrder
    preferredGrades?: SortOrder
    idProofUrl?: SortOrder
    linkedinPortfolio?: SortOrderInput | SortOrder
    languagesKnown?: SortOrder
    certificateUrls?: SortOrder
    _count?: TeacherProfileCountOrderByAggregateInput
    _avg?: TeacherProfileAvgOrderByAggregateInput
    _max?: TeacherProfileMaxOrderByAggregateInput
    _min?: TeacherProfileMinOrderByAggregateInput
    _sum?: TeacherProfileSumOrderByAggregateInput
  }

  export type TeacherProfileScalarWhereWithAggregatesInput = {
    AND?: TeacherProfileScalarWhereWithAggregatesInput | TeacherProfileScalarWhereWithAggregatesInput[]
    OR?: TeacherProfileScalarWhereWithAggregatesInput[]
    NOT?: TeacherProfileScalarWhereWithAggregatesInput | TeacherProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeacherProfile"> | string
    teacherId?: StringWithAggregatesFilter<"TeacherProfile"> | string
    contactEmail?: StringWithAggregatesFilter<"TeacherProfile"> | string
    contactPhone?: StringWithAggregatesFilter<"TeacherProfile"> | string
    address?: StringWithAggregatesFilter<"TeacherProfile"> | string
    city?: StringNullableWithAggregatesFilter<"TeacherProfile"> | string | null
    state?: StringNullableWithAggregatesFilter<"TeacherProfile"> | string | null
    dateOfBirth?: DateTimeWithAggregatesFilter<"TeacherProfile"> | Date | string
    qualification?: StringWithAggregatesFilter<"TeacherProfile"> | string
    experienceInYears?: IntWithAggregatesFilter<"TeacherProfile"> | number
    resumeUrl?: StringNullableWithAggregatesFilter<"TeacherProfile"> | string | null
    joinedAt?: DateTimeWithAggregatesFilter<"TeacherProfile"> | Date | string
    bio?: StringNullableWithAggregatesFilter<"TeacherProfile"> | string | null
    teachingPhilosophy?: StringNullableWithAggregatesFilter<"TeacherProfile"> | string | null
    specializedSubjects?: StringNullableListFilter<"TeacherProfile">
    preferredGrades?: StringNullableListFilter<"TeacherProfile">
    idProofUrl?: StringWithAggregatesFilter<"TeacherProfile"> | string
    linkedinPortfolio?: StringNullableWithAggregatesFilter<"TeacherProfile"> | string | null
    languagesKnown?: StringNullableListFilter<"TeacherProfile">
    certificateUrls?: StringNullableListFilter<"TeacherProfile">
  }

  export type SubjectWhereInput = {
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    id?: StringFilter<"Subject"> | string
    name?: StringFilter<"Subject"> | string
    code?: StringFilter<"Subject"> | string
    description?: StringFilter<"Subject"> | string
    organizationId?: StringFilter<"Subject"> | string
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    updatedAt?: DateTimeFilter<"Subject"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    teachingAssignments?: TeachingAssignmentListRelationFilter
    exam?: ExamListRelationFilter
    examResult?: ExamResultListRelationFilter
  }

  export type SubjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    teachingAssignments?: TeachingAssignmentOrderByRelationAggregateInput
    exam?: ExamOrderByRelationAggregateInput
    examResult?: ExamResultOrderByRelationAggregateInput
    _relevance?: SubjectOrderByRelevanceInput
  }

  export type SubjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    name?: StringFilter<"Subject"> | string
    description?: StringFilter<"Subject"> | string
    organizationId?: StringFilter<"Subject"> | string
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    updatedAt?: DateTimeFilter<"Subject"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    teachingAssignments?: TeachingAssignmentListRelationFilter
    exam?: ExamListRelationFilter
    examResult?: ExamResultListRelationFilter
  }, "id" | "code">

  export type SubjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubjectCountOrderByAggregateInput
    _max?: SubjectMaxOrderByAggregateInput
    _min?: SubjectMinOrderByAggregateInput
  }

  export type SubjectScalarWhereWithAggregatesInput = {
    AND?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    OR?: SubjectScalarWhereWithAggregatesInput[]
    NOT?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subject"> | string
    name?: StringWithAggregatesFilter<"Subject"> | string
    code?: StringWithAggregatesFilter<"Subject"> | string
    description?: StringWithAggregatesFilter<"Subject"> | string
    organizationId?: StringWithAggregatesFilter<"Subject"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Subject"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subject"> | Date | string
  }

  export type TeachingAssignmentWhereInput = {
    AND?: TeachingAssignmentWhereInput | TeachingAssignmentWhereInput[]
    OR?: TeachingAssignmentWhereInput[]
    NOT?: TeachingAssignmentWhereInput | TeachingAssignmentWhereInput[]
    id?: StringFilter<"TeachingAssignment"> | string
    teacherId?: StringFilter<"TeachingAssignment"> | string
    subjectId?: StringFilter<"TeachingAssignment"> | string
    gradeId?: StringFilter<"TeachingAssignment"> | string
    sectionId?: StringFilter<"TeachingAssignment"> | string
    organizationId?: StringFilter<"TeachingAssignment"> | string
    academicYear?: StringNullableFilter<"TeachingAssignment"> | string | null
    status?: EnumAssignmentStatusFilter<"TeachingAssignment"> | $Enums.AssignmentStatus
    createdAt?: DateTimeFilter<"TeachingAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"TeachingAssignment"> | Date | string
    academicYearId?: StringNullableFilter<"TeachingAssignment"> | string | null
    teacher?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    grade?: XOR<GradeScalarRelationFilter, GradeWhereInput>
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    AcademicYear?: XOR<AcademicYearNullableScalarRelationFilter, AcademicYearWhereInput> | null
  }

  export type TeachingAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    gradeId?: SortOrder
    sectionId?: SortOrder
    organizationId?: SortOrder
    academicYear?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicYearId?: SortOrderInput | SortOrder
    teacher?: TeacherOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
    grade?: GradeOrderByWithRelationInput
    section?: SectionOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
    AcademicYear?: AcademicYearOrderByWithRelationInput
    _relevance?: TeachingAssignmentOrderByRelevanceInput
  }

  export type TeachingAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    teacherId_subjectId_gradeId_sectionId_academicYearId?: TeachingAssignmentTeacherIdSubjectIdGradeIdSectionIdAcademicYearIdCompoundUniqueInput
    AND?: TeachingAssignmentWhereInput | TeachingAssignmentWhereInput[]
    OR?: TeachingAssignmentWhereInput[]
    NOT?: TeachingAssignmentWhereInput | TeachingAssignmentWhereInput[]
    teacherId?: StringFilter<"TeachingAssignment"> | string
    subjectId?: StringFilter<"TeachingAssignment"> | string
    gradeId?: StringFilter<"TeachingAssignment"> | string
    sectionId?: StringFilter<"TeachingAssignment"> | string
    organizationId?: StringFilter<"TeachingAssignment"> | string
    academicYear?: StringNullableFilter<"TeachingAssignment"> | string | null
    status?: EnumAssignmentStatusFilter<"TeachingAssignment"> | $Enums.AssignmentStatus
    createdAt?: DateTimeFilter<"TeachingAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"TeachingAssignment"> | Date | string
    academicYearId?: StringNullableFilter<"TeachingAssignment"> | string | null
    teacher?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    grade?: XOR<GradeScalarRelationFilter, GradeWhereInput>
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    AcademicYear?: XOR<AcademicYearNullableScalarRelationFilter, AcademicYearWhereInput> | null
  }, "id" | "teacherId_subjectId_gradeId_sectionId_academicYearId">

  export type TeachingAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    gradeId?: SortOrder
    sectionId?: SortOrder
    organizationId?: SortOrder
    academicYear?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicYearId?: SortOrderInput | SortOrder
    _count?: TeachingAssignmentCountOrderByAggregateInput
    _max?: TeachingAssignmentMaxOrderByAggregateInput
    _min?: TeachingAssignmentMinOrderByAggregateInput
  }

  export type TeachingAssignmentScalarWhereWithAggregatesInput = {
    AND?: TeachingAssignmentScalarWhereWithAggregatesInput | TeachingAssignmentScalarWhereWithAggregatesInput[]
    OR?: TeachingAssignmentScalarWhereWithAggregatesInput[]
    NOT?: TeachingAssignmentScalarWhereWithAggregatesInput | TeachingAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeachingAssignment"> | string
    teacherId?: StringWithAggregatesFilter<"TeachingAssignment"> | string
    subjectId?: StringWithAggregatesFilter<"TeachingAssignment"> | string
    gradeId?: StringWithAggregatesFilter<"TeachingAssignment"> | string
    sectionId?: StringWithAggregatesFilter<"TeachingAssignment"> | string
    organizationId?: StringWithAggregatesFilter<"TeachingAssignment"> | string
    academicYear?: StringNullableWithAggregatesFilter<"TeachingAssignment"> | string | null
    status?: EnumAssignmentStatusWithAggregatesFilter<"TeachingAssignment"> | $Enums.AssignmentStatus
    createdAt?: DateTimeWithAggregatesFilter<"TeachingAssignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TeachingAssignment"> | Date | string
    academicYearId?: StringNullableWithAggregatesFilter<"TeachingAssignment"> | string | null
  }

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    id?: StringFilter<"Student"> | string
    userId?: StringFilter<"Student"> | string
    firstName?: StringFilter<"Student"> | string
    lastName?: StringFilter<"Student"> | string
    middleName?: StringNullableFilter<"Student"> | string | null
    motherName?: StringNullableFilter<"Student"> | string | null
    fullName?: StringNullableFilter<"Student"> | string | null
    dateOfBirth?: DateTimeFilter<"Student"> | Date | string
    profileImage?: StringNullableFilter<"Student"> | string | null
    rollNumber?: StringFilter<"Student"> | string
    phoneNumber?: StringFilter<"Student"> | string
    whatsAppNumber?: StringFilter<"Student"> | string
    email?: StringFilter<"Student"> | string
    emergencyContact?: StringFilter<"Student"> | string
    gender?: EnumGenderFilter<"Student"> | $Enums.Gender
    sectionId?: StringFilter<"Student"> | string
    gradeId?: StringFilter<"Student"> | string
    organizationId?: StringFilter<"Student"> | string
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
    grade?: XOR<GradeScalarRelationFilter, GradeWhereInput>
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    Fee?: FeeListRelationFilter
    parents?: ParentStudentListRelationFilter
    StudentAttendance?: StudentAttendanceListRelationFilter
    StudentDocument?: StudentDocumentListRelationFilter
    NotificationLog?: NotificationLogListRelationFilter
    reportCard?: ReportCardListRelationFilter
    hallTicket?: HallTicketListRelationFilter
    examResult?: ExamResultListRelationFilter
    examEnrollment?: ExamEnrollmentListRelationFilter
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    middleName?: SortOrderInput | SortOrder
    motherName?: SortOrderInput | SortOrder
    fullName?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    rollNumber?: SortOrder
    phoneNumber?: SortOrder
    whatsAppNumber?: SortOrder
    email?: SortOrder
    emergencyContact?: SortOrder
    gender?: SortOrder
    sectionId?: SortOrder
    gradeId?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    section?: SectionOrderByWithRelationInput
    grade?: GradeOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
    Fee?: FeeOrderByRelationAggregateInput
    parents?: ParentStudentOrderByRelationAggregateInput
    StudentAttendance?: StudentAttendanceOrderByRelationAggregateInput
    StudentDocument?: StudentDocumentOrderByRelationAggregateInput
    NotificationLog?: NotificationLogOrderByRelationAggregateInput
    reportCard?: ReportCardOrderByRelationAggregateInput
    hallTicket?: HallTicketOrderByRelationAggregateInput
    examResult?: ExamResultOrderByRelationAggregateInput
    examEnrollment?: ExamEnrollmentOrderByRelationAggregateInput
    _relevance?: StudentOrderByRelevanceInput
  }

  export type StudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    rollNumber?: string
    organizationId_rollNumber?: StudentOrganizationIdRollNumberCompoundUniqueInput
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    firstName?: StringFilter<"Student"> | string
    lastName?: StringFilter<"Student"> | string
    middleName?: StringNullableFilter<"Student"> | string | null
    motherName?: StringNullableFilter<"Student"> | string | null
    fullName?: StringNullableFilter<"Student"> | string | null
    dateOfBirth?: DateTimeFilter<"Student"> | Date | string
    profileImage?: StringNullableFilter<"Student"> | string | null
    phoneNumber?: StringFilter<"Student"> | string
    whatsAppNumber?: StringFilter<"Student"> | string
    email?: StringFilter<"Student"> | string
    emergencyContact?: StringFilter<"Student"> | string
    gender?: EnumGenderFilter<"Student"> | $Enums.Gender
    sectionId?: StringFilter<"Student"> | string
    gradeId?: StringFilter<"Student"> | string
    organizationId?: StringFilter<"Student"> | string
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
    grade?: XOR<GradeScalarRelationFilter, GradeWhereInput>
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    Fee?: FeeListRelationFilter
    parents?: ParentStudentListRelationFilter
    StudentAttendance?: StudentAttendanceListRelationFilter
    StudentDocument?: StudentDocumentListRelationFilter
    NotificationLog?: NotificationLogListRelationFilter
    reportCard?: ReportCardListRelationFilter
    hallTicket?: HallTicketListRelationFilter
    examResult?: ExamResultListRelationFilter
    examEnrollment?: ExamEnrollmentListRelationFilter
  }, "id" | "userId" | "rollNumber" | "organizationId_rollNumber">

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    middleName?: SortOrderInput | SortOrder
    motherName?: SortOrderInput | SortOrder
    fullName?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    rollNumber?: SortOrder
    phoneNumber?: SortOrder
    whatsAppNumber?: SortOrder
    email?: SortOrder
    emergencyContact?: SortOrder
    gender?: SortOrder
    sectionId?: SortOrder
    gradeId?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentCountOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    OR?: StudentScalarWhereWithAggregatesInput[]
    NOT?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Student"> | string
    userId?: StringWithAggregatesFilter<"Student"> | string
    firstName?: StringWithAggregatesFilter<"Student"> | string
    lastName?: StringWithAggregatesFilter<"Student"> | string
    middleName?: StringNullableWithAggregatesFilter<"Student"> | string | null
    motherName?: StringNullableWithAggregatesFilter<"Student"> | string | null
    fullName?: StringNullableWithAggregatesFilter<"Student"> | string | null
    dateOfBirth?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    profileImage?: StringNullableWithAggregatesFilter<"Student"> | string | null
    rollNumber?: StringWithAggregatesFilter<"Student"> | string
    phoneNumber?: StringWithAggregatesFilter<"Student"> | string
    whatsAppNumber?: StringWithAggregatesFilter<"Student"> | string
    email?: StringWithAggregatesFilter<"Student"> | string
    emergencyContact?: StringWithAggregatesFilter<"Student"> | string
    gender?: EnumGenderWithAggregatesFilter<"Student"> | $Enums.Gender
    sectionId?: StringWithAggregatesFilter<"Student"> | string
    gradeId?: StringWithAggregatesFilter<"Student"> | string
    organizationId?: StringWithAggregatesFilter<"Student"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
  }

  export type ParentWhereInput = {
    AND?: ParentWhereInput | ParentWhereInput[]
    OR?: ParentWhereInput[]
    NOT?: ParentWhereInput | ParentWhereInput[]
    id?: StringFilter<"Parent"> | string
    userId?: StringNullableFilter<"Parent"> | string | null
    firstName?: StringFilter<"Parent"> | string
    lastName?: StringFilter<"Parent"> | string
    email?: StringFilter<"Parent"> | string
    phoneNumber?: StringFilter<"Parent"> | string
    whatsAppNumber?: StringFilter<"Parent"> | string
    createdAt?: DateTimeFilter<"Parent"> | Date | string
    updatedAt?: DateTimeFilter<"Parent"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    students?: ParentStudentListRelationFilter
    NotificationLog?: NotificationLogListRelationFilter
  }

  export type ParentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    whatsAppNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    students?: ParentStudentOrderByRelationAggregateInput
    NotificationLog?: NotificationLogOrderByRelationAggregateInput
    _relevance?: ParentOrderByRelevanceInput
  }

  export type ParentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    email?: string
    AND?: ParentWhereInput | ParentWhereInput[]
    OR?: ParentWhereInput[]
    NOT?: ParentWhereInput | ParentWhereInput[]
    firstName?: StringFilter<"Parent"> | string
    lastName?: StringFilter<"Parent"> | string
    phoneNumber?: StringFilter<"Parent"> | string
    whatsAppNumber?: StringFilter<"Parent"> | string
    createdAt?: DateTimeFilter<"Parent"> | Date | string
    updatedAt?: DateTimeFilter<"Parent"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    students?: ParentStudentListRelationFilter
    NotificationLog?: NotificationLogListRelationFilter
  }, "id" | "userId" | "email">

  export type ParentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    whatsAppNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ParentCountOrderByAggregateInput
    _max?: ParentMaxOrderByAggregateInput
    _min?: ParentMinOrderByAggregateInput
  }

  export type ParentScalarWhereWithAggregatesInput = {
    AND?: ParentScalarWhereWithAggregatesInput | ParentScalarWhereWithAggregatesInput[]
    OR?: ParentScalarWhereWithAggregatesInput[]
    NOT?: ParentScalarWhereWithAggregatesInput | ParentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Parent"> | string
    userId?: StringNullableWithAggregatesFilter<"Parent"> | string | null
    firstName?: StringWithAggregatesFilter<"Parent"> | string
    lastName?: StringWithAggregatesFilter<"Parent"> | string
    email?: StringWithAggregatesFilter<"Parent"> | string
    phoneNumber?: StringWithAggregatesFilter<"Parent"> | string
    whatsAppNumber?: StringWithAggregatesFilter<"Parent"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Parent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Parent"> | Date | string
  }

  export type ParentStudentWhereInput = {
    AND?: ParentStudentWhereInput | ParentStudentWhereInput[]
    OR?: ParentStudentWhereInput[]
    NOT?: ParentStudentWhereInput | ParentStudentWhereInput[]
    id?: StringFilter<"ParentStudent"> | string
    relationship?: StringFilter<"ParentStudent"> | string
    studentId?: StringFilter<"ParentStudent"> | string
    parentId?: StringFilter<"ParentStudent"> | string
    isPrimary?: BoolNullableFilter<"ParentStudent"> | boolean | null
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    parent?: XOR<ParentScalarRelationFilter, ParentWhereInput>
  }

  export type ParentStudentOrderByWithRelationInput = {
    id?: SortOrder
    relationship?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    isPrimary?: SortOrderInput | SortOrder
    student?: StudentOrderByWithRelationInput
    parent?: ParentOrderByWithRelationInput
    _relevance?: ParentStudentOrderByRelevanceInput
  }

  export type ParentStudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ParentStudentWhereInput | ParentStudentWhereInput[]
    OR?: ParentStudentWhereInput[]
    NOT?: ParentStudentWhereInput | ParentStudentWhereInput[]
    relationship?: StringFilter<"ParentStudent"> | string
    studentId?: StringFilter<"ParentStudent"> | string
    parentId?: StringFilter<"ParentStudent"> | string
    isPrimary?: BoolNullableFilter<"ParentStudent"> | boolean | null
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    parent?: XOR<ParentScalarRelationFilter, ParentWhereInput>
  }, "id">

  export type ParentStudentOrderByWithAggregationInput = {
    id?: SortOrder
    relationship?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    isPrimary?: SortOrderInput | SortOrder
    _count?: ParentStudentCountOrderByAggregateInput
    _max?: ParentStudentMaxOrderByAggregateInput
    _min?: ParentStudentMinOrderByAggregateInput
  }

  export type ParentStudentScalarWhereWithAggregatesInput = {
    AND?: ParentStudentScalarWhereWithAggregatesInput | ParentStudentScalarWhereWithAggregatesInput[]
    OR?: ParentStudentScalarWhereWithAggregatesInput[]
    NOT?: ParentStudentScalarWhereWithAggregatesInput | ParentStudentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ParentStudent"> | string
    relationship?: StringWithAggregatesFilter<"ParentStudent"> | string
    studentId?: StringWithAggregatesFilter<"ParentStudent"> | string
    parentId?: StringWithAggregatesFilter<"ParentStudent"> | string
    isPrimary?: BoolNullableWithAggregatesFilter<"ParentStudent"> | boolean | null
  }

  export type StudentAttendanceWhereInput = {
    AND?: StudentAttendanceWhereInput | StudentAttendanceWhereInput[]
    OR?: StudentAttendanceWhereInput[]
    NOT?: StudentAttendanceWhereInput | StudentAttendanceWhereInput[]
    id?: StringFilter<"StudentAttendance"> | string
    date?: DateTimeFilter<"StudentAttendance"> | Date | string
    status?: EnumAttendanceStatusFilter<"StudentAttendance"> | $Enums.AttendanceStatus
    note?: StringNullableFilter<"StudentAttendance"> | string | null
    recordedBy?: StringFilter<"StudentAttendance"> | string
    studentId?: StringFilter<"StudentAttendance"> | string
    present?: BoolFilter<"StudentAttendance"> | boolean
    sectionId?: StringFilter<"StudentAttendance"> | string
    academicYearId?: StringNullableFilter<"StudentAttendance"> | string | null
    createdAt?: DateTimeFilter<"StudentAttendance"> | Date | string
    updatedAt?: DateTimeFilter<"StudentAttendance"> | Date | string
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    academicYear?: XOR<AcademicYearNullableScalarRelationFilter, AcademicYearWhereInput> | null
  }

  export type StudentAttendanceOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    note?: SortOrderInput | SortOrder
    recordedBy?: SortOrder
    studentId?: SortOrder
    present?: SortOrder
    sectionId?: SortOrder
    academicYearId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    section?: SectionOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
    academicYear?: AcademicYearOrderByWithRelationInput
    _relevance?: StudentAttendanceOrderByRelevanceInput
  }

  export type StudentAttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_date?: StudentAttendanceStudentIdDateCompoundUniqueInput
    AND?: StudentAttendanceWhereInput | StudentAttendanceWhereInput[]
    OR?: StudentAttendanceWhereInput[]
    NOT?: StudentAttendanceWhereInput | StudentAttendanceWhereInput[]
    date?: DateTimeFilter<"StudentAttendance"> | Date | string
    status?: EnumAttendanceStatusFilter<"StudentAttendance"> | $Enums.AttendanceStatus
    note?: StringNullableFilter<"StudentAttendance"> | string | null
    recordedBy?: StringFilter<"StudentAttendance"> | string
    studentId?: StringFilter<"StudentAttendance"> | string
    present?: BoolFilter<"StudentAttendance"> | boolean
    sectionId?: StringFilter<"StudentAttendance"> | string
    academicYearId?: StringNullableFilter<"StudentAttendance"> | string | null
    createdAt?: DateTimeFilter<"StudentAttendance"> | Date | string
    updatedAt?: DateTimeFilter<"StudentAttendance"> | Date | string
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    academicYear?: XOR<AcademicYearNullableScalarRelationFilter, AcademicYearWhereInput> | null
  }, "id" | "studentId_date">

  export type StudentAttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    note?: SortOrderInput | SortOrder
    recordedBy?: SortOrder
    studentId?: SortOrder
    present?: SortOrder
    sectionId?: SortOrder
    academicYearId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentAttendanceCountOrderByAggregateInput
    _max?: StudentAttendanceMaxOrderByAggregateInput
    _min?: StudentAttendanceMinOrderByAggregateInput
  }

  export type StudentAttendanceScalarWhereWithAggregatesInput = {
    AND?: StudentAttendanceScalarWhereWithAggregatesInput | StudentAttendanceScalarWhereWithAggregatesInput[]
    OR?: StudentAttendanceScalarWhereWithAggregatesInput[]
    NOT?: StudentAttendanceScalarWhereWithAggregatesInput | StudentAttendanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentAttendance"> | string
    date?: DateTimeWithAggregatesFilter<"StudentAttendance"> | Date | string
    status?: EnumAttendanceStatusWithAggregatesFilter<"StudentAttendance"> | $Enums.AttendanceStatus
    note?: StringNullableWithAggregatesFilter<"StudentAttendance"> | string | null
    recordedBy?: StringWithAggregatesFilter<"StudentAttendance"> | string
    studentId?: StringWithAggregatesFilter<"StudentAttendance"> | string
    present?: BoolWithAggregatesFilter<"StudentAttendance"> | boolean
    sectionId?: StringWithAggregatesFilter<"StudentAttendance"> | string
    academicYearId?: StringNullableWithAggregatesFilter<"StudentAttendance"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StudentAttendance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentAttendance"> | Date | string
  }

  export type StudentDocumentWhereInput = {
    AND?: StudentDocumentWhereInput | StudentDocumentWhereInput[]
    OR?: StudentDocumentWhereInput[]
    NOT?: StudentDocumentWhereInput | StudentDocumentWhereInput[]
    id?: StringFilter<"StudentDocument"> | string
    type?: EnumDocumentTypeFilter<"StudentDocument"> | $Enums.DocumentType
    fileName?: StringNullableFilter<"StudentDocument"> | string | null
    fileSize?: IntNullableFilter<"StudentDocument"> | number | null
    fileType?: StringNullableFilter<"StudentDocument"> | string | null
    documentUrl?: StringFilter<"StudentDocument"> | string
    studentId?: StringFilter<"StudentDocument"> | string
    verified?: BoolFilter<"StudentDocument"> | boolean
    verifiedBy?: StringNullableFilter<"StudentDocument"> | string | null
    verifiedAt?: DateTimeNullableFilter<"StudentDocument"> | Date | string | null
    rejected?: BoolFilter<"StudentDocument"> | boolean
    rejectedBy?: StringNullableFilter<"StudentDocument"> | string | null
    rejectedAt?: DateTimeNullableFilter<"StudentDocument"> | Date | string | null
    rejectReason?: StringNullableFilter<"StudentDocument"> | string | null
    uploadedBy?: StringNullableFilter<"StudentDocument"> | string | null
    uploadedAt?: DateTimeFilter<"StudentDocument"> | Date | string
    note?: StringNullableFilter<"StudentDocument"> | string | null
    isDeleted?: BoolFilter<"StudentDocument"> | boolean
    deletedAt?: DateTimeNullableFilter<"StudentDocument"> | Date | string | null
    createdAt?: DateTimeFilter<"StudentDocument"> | Date | string
    updatedAt?: DateTimeFilter<"StudentDocument"> | Date | string
    organizationId?: StringFilter<"StudentDocument"> | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    Organization?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
  }

  export type StudentDocumentOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    fileName?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    fileType?: SortOrderInput | SortOrder
    documentUrl?: SortOrder
    studentId?: SortOrder
    verified?: SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    rejected?: SortOrder
    rejectedBy?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    rejectReason?: SortOrderInput | SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    note?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
    student?: StudentOrderByWithRelationInput
    Organization?: OrganizationOrderByWithRelationInput
    _relevance?: StudentDocumentOrderByRelevanceInput
  }

  export type StudentDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudentDocumentWhereInput | StudentDocumentWhereInput[]
    OR?: StudentDocumentWhereInput[]
    NOT?: StudentDocumentWhereInput | StudentDocumentWhereInput[]
    type?: EnumDocumentTypeFilter<"StudentDocument"> | $Enums.DocumentType
    fileName?: StringNullableFilter<"StudentDocument"> | string | null
    fileSize?: IntNullableFilter<"StudentDocument"> | number | null
    fileType?: StringNullableFilter<"StudentDocument"> | string | null
    documentUrl?: StringFilter<"StudentDocument"> | string
    studentId?: StringFilter<"StudentDocument"> | string
    verified?: BoolFilter<"StudentDocument"> | boolean
    verifiedBy?: StringNullableFilter<"StudentDocument"> | string | null
    verifiedAt?: DateTimeNullableFilter<"StudentDocument"> | Date | string | null
    rejected?: BoolFilter<"StudentDocument"> | boolean
    rejectedBy?: StringNullableFilter<"StudentDocument"> | string | null
    rejectedAt?: DateTimeNullableFilter<"StudentDocument"> | Date | string | null
    rejectReason?: StringNullableFilter<"StudentDocument"> | string | null
    uploadedBy?: StringNullableFilter<"StudentDocument"> | string | null
    uploadedAt?: DateTimeFilter<"StudentDocument"> | Date | string
    note?: StringNullableFilter<"StudentDocument"> | string | null
    isDeleted?: BoolFilter<"StudentDocument"> | boolean
    deletedAt?: DateTimeNullableFilter<"StudentDocument"> | Date | string | null
    createdAt?: DateTimeFilter<"StudentDocument"> | Date | string
    updatedAt?: DateTimeFilter<"StudentDocument"> | Date | string
    organizationId?: StringFilter<"StudentDocument"> | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    Organization?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
  }, "id">

  export type StudentDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    fileName?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    fileType?: SortOrderInput | SortOrder
    documentUrl?: SortOrder
    studentId?: SortOrder
    verified?: SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    rejected?: SortOrder
    rejectedBy?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    rejectReason?: SortOrderInput | SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    note?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
    _count?: StudentDocumentCountOrderByAggregateInput
    _avg?: StudentDocumentAvgOrderByAggregateInput
    _max?: StudentDocumentMaxOrderByAggregateInput
    _min?: StudentDocumentMinOrderByAggregateInput
    _sum?: StudentDocumentSumOrderByAggregateInput
  }

  export type StudentDocumentScalarWhereWithAggregatesInput = {
    AND?: StudentDocumentScalarWhereWithAggregatesInput | StudentDocumentScalarWhereWithAggregatesInput[]
    OR?: StudentDocumentScalarWhereWithAggregatesInput[]
    NOT?: StudentDocumentScalarWhereWithAggregatesInput | StudentDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentDocument"> | string
    type?: EnumDocumentTypeWithAggregatesFilter<"StudentDocument"> | $Enums.DocumentType
    fileName?: StringNullableWithAggregatesFilter<"StudentDocument"> | string | null
    fileSize?: IntNullableWithAggregatesFilter<"StudentDocument"> | number | null
    fileType?: StringNullableWithAggregatesFilter<"StudentDocument"> | string | null
    documentUrl?: StringWithAggregatesFilter<"StudentDocument"> | string
    studentId?: StringWithAggregatesFilter<"StudentDocument"> | string
    verified?: BoolWithAggregatesFilter<"StudentDocument"> | boolean
    verifiedBy?: StringNullableWithAggregatesFilter<"StudentDocument"> | string | null
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"StudentDocument"> | Date | string | null
    rejected?: BoolWithAggregatesFilter<"StudentDocument"> | boolean
    rejectedBy?: StringNullableWithAggregatesFilter<"StudentDocument"> | string | null
    rejectedAt?: DateTimeNullableWithAggregatesFilter<"StudentDocument"> | Date | string | null
    rejectReason?: StringNullableWithAggregatesFilter<"StudentDocument"> | string | null
    uploadedBy?: StringNullableWithAggregatesFilter<"StudentDocument"> | string | null
    uploadedAt?: DateTimeWithAggregatesFilter<"StudentDocument"> | Date | string
    note?: StringNullableWithAggregatesFilter<"StudentDocument"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"StudentDocument"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"StudentDocument"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StudentDocument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentDocument"> | Date | string
    organizationId?: StringWithAggregatesFilter<"StudentDocument"> | string
  }

  export type FeeWhereInput = {
    AND?: FeeWhereInput | FeeWhereInput[]
    OR?: FeeWhereInput[]
    NOT?: FeeWhereInput | FeeWhereInput[]
    id?: StringFilter<"Fee"> | string
    totalFee?: FloatFilter<"Fee"> | number
    paidAmount?: FloatFilter<"Fee"> | number
    pendingAmount?: FloatNullableFilter<"Fee"> | number | null
    dueDate?: DateTimeFilter<"Fee"> | Date | string
    status?: EnumFeeStatusFilter<"Fee"> | $Enums.FeeStatus
    studentId?: StringFilter<"Fee"> | string
    feeCategoryId?: StringFilter<"Fee"> | string
    organizationId?: StringFilter<"Fee"> | string
    createdAt?: DateTimeFilter<"Fee"> | Date | string
    updatedAt?: DateTimeFilter<"Fee"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    feeCategory?: XOR<FeeCategoryScalarRelationFilter, FeeCategoryWhereInput>
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    payments?: FeePaymentListRelationFilter
  }

  export type FeeOrderByWithRelationInput = {
    id?: SortOrder
    totalFee?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrderInput | SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    studentId?: SortOrder
    feeCategoryId?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    feeCategory?: FeeCategoryOrderByWithRelationInput
    Organization?: OrganizationOrderByWithRelationInput
    payments?: FeePaymentOrderByRelationAggregateInput
    _relevance?: FeeOrderByRelevanceInput
  }

  export type FeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeeWhereInput | FeeWhereInput[]
    OR?: FeeWhereInput[]
    NOT?: FeeWhereInput | FeeWhereInput[]
    totalFee?: FloatFilter<"Fee"> | number
    paidAmount?: FloatFilter<"Fee"> | number
    pendingAmount?: FloatNullableFilter<"Fee"> | number | null
    dueDate?: DateTimeFilter<"Fee"> | Date | string
    status?: EnumFeeStatusFilter<"Fee"> | $Enums.FeeStatus
    studentId?: StringFilter<"Fee"> | string
    feeCategoryId?: StringFilter<"Fee"> | string
    organizationId?: StringFilter<"Fee"> | string
    createdAt?: DateTimeFilter<"Fee"> | Date | string
    updatedAt?: DateTimeFilter<"Fee"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    feeCategory?: XOR<FeeCategoryScalarRelationFilter, FeeCategoryWhereInput>
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    payments?: FeePaymentListRelationFilter
  }, "id">

  export type FeeOrderByWithAggregationInput = {
    id?: SortOrder
    totalFee?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrderInput | SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    studentId?: SortOrder
    feeCategoryId?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeeCountOrderByAggregateInput
    _avg?: FeeAvgOrderByAggregateInput
    _max?: FeeMaxOrderByAggregateInput
    _min?: FeeMinOrderByAggregateInput
    _sum?: FeeSumOrderByAggregateInput
  }

  export type FeeScalarWhereWithAggregatesInput = {
    AND?: FeeScalarWhereWithAggregatesInput | FeeScalarWhereWithAggregatesInput[]
    OR?: FeeScalarWhereWithAggregatesInput[]
    NOT?: FeeScalarWhereWithAggregatesInput | FeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Fee"> | string
    totalFee?: FloatWithAggregatesFilter<"Fee"> | number
    paidAmount?: FloatWithAggregatesFilter<"Fee"> | number
    pendingAmount?: FloatNullableWithAggregatesFilter<"Fee"> | number | null
    dueDate?: DateTimeWithAggregatesFilter<"Fee"> | Date | string
    status?: EnumFeeStatusWithAggregatesFilter<"Fee"> | $Enums.FeeStatus
    studentId?: StringWithAggregatesFilter<"Fee"> | string
    feeCategoryId?: StringWithAggregatesFilter<"Fee"> | string
    organizationId?: StringWithAggregatesFilter<"Fee"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Fee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Fee"> | Date | string
  }

  export type FeePaymentWhereInput = {
    AND?: FeePaymentWhereInput | FeePaymentWhereInput[]
    OR?: FeePaymentWhereInput[]
    NOT?: FeePaymentWhereInput | FeePaymentWhereInput[]
    id?: StringFilter<"FeePayment"> | string
    feeId?: StringFilter<"FeePayment"> | string
    amount?: FloatFilter<"FeePayment"> | number
    status?: EnumPaymentStatusFilter<"FeePayment"> | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFilter<"FeePayment"> | $Enums.PaymentMethod
    paymentDate?: DateTimeFilter<"FeePayment"> | Date | string
    receiptNumber?: StringFilter<"FeePayment"> | string
    note?: StringNullableFilter<"FeePayment"> | string | null
    transactionId?: StringNullableFilter<"FeePayment"> | string | null
    payerId?: StringFilter<"FeePayment"> | string
    platformFee?: FloatNullableFilter<"FeePayment"> | number | null
    recordedBy?: StringNullableFilter<"FeePayment"> | string | null
    organizationId?: StringFilter<"FeePayment"> | string
    createdAt?: DateTimeFilter<"FeePayment"> | Date | string
    updatedAt?: DateTimeFilter<"FeePayment"> | Date | string
    fee?: XOR<FeeScalarRelationFilter, FeeWhereInput>
    payer?: XOR<UserScalarRelationFilter, UserWhereInput>
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type FeePaymentOrderByWithRelationInput = {
    id?: SortOrder
    feeId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    receiptNumber?: SortOrder
    note?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    payerId?: SortOrder
    platformFee?: SortOrderInput | SortOrder
    recordedBy?: SortOrderInput | SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fee?: FeeOrderByWithRelationInput
    payer?: UserOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
    _relevance?: FeePaymentOrderByRelevanceInput
  }

  export type FeePaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    receiptNumber?: string
    AND?: FeePaymentWhereInput | FeePaymentWhereInput[]
    OR?: FeePaymentWhereInput[]
    NOT?: FeePaymentWhereInput | FeePaymentWhereInput[]
    feeId?: StringFilter<"FeePayment"> | string
    amount?: FloatFilter<"FeePayment"> | number
    status?: EnumPaymentStatusFilter<"FeePayment"> | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFilter<"FeePayment"> | $Enums.PaymentMethod
    paymentDate?: DateTimeFilter<"FeePayment"> | Date | string
    note?: StringNullableFilter<"FeePayment"> | string | null
    transactionId?: StringNullableFilter<"FeePayment"> | string | null
    payerId?: StringFilter<"FeePayment"> | string
    platformFee?: FloatNullableFilter<"FeePayment"> | number | null
    recordedBy?: StringNullableFilter<"FeePayment"> | string | null
    organizationId?: StringFilter<"FeePayment"> | string
    createdAt?: DateTimeFilter<"FeePayment"> | Date | string
    updatedAt?: DateTimeFilter<"FeePayment"> | Date | string
    fee?: XOR<FeeScalarRelationFilter, FeeWhereInput>
    payer?: XOR<UserScalarRelationFilter, UserWhereInput>
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id" | "receiptNumber">

  export type FeePaymentOrderByWithAggregationInput = {
    id?: SortOrder
    feeId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    receiptNumber?: SortOrder
    note?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    payerId?: SortOrder
    platformFee?: SortOrderInput | SortOrder
    recordedBy?: SortOrderInput | SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeePaymentCountOrderByAggregateInput
    _avg?: FeePaymentAvgOrderByAggregateInput
    _max?: FeePaymentMaxOrderByAggregateInput
    _min?: FeePaymentMinOrderByAggregateInput
    _sum?: FeePaymentSumOrderByAggregateInput
  }

  export type FeePaymentScalarWhereWithAggregatesInput = {
    AND?: FeePaymentScalarWhereWithAggregatesInput | FeePaymentScalarWhereWithAggregatesInput[]
    OR?: FeePaymentScalarWhereWithAggregatesInput[]
    NOT?: FeePaymentScalarWhereWithAggregatesInput | FeePaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeePayment"> | string
    feeId?: StringWithAggregatesFilter<"FeePayment"> | string
    amount?: FloatWithAggregatesFilter<"FeePayment"> | number
    status?: EnumPaymentStatusWithAggregatesFilter<"FeePayment"> | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"FeePayment"> | $Enums.PaymentMethod
    paymentDate?: DateTimeWithAggregatesFilter<"FeePayment"> | Date | string
    receiptNumber?: StringWithAggregatesFilter<"FeePayment"> | string
    note?: StringNullableWithAggregatesFilter<"FeePayment"> | string | null
    transactionId?: StringNullableWithAggregatesFilter<"FeePayment"> | string | null
    payerId?: StringWithAggregatesFilter<"FeePayment"> | string
    platformFee?: FloatNullableWithAggregatesFilter<"FeePayment"> | number | null
    recordedBy?: StringNullableWithAggregatesFilter<"FeePayment"> | string | null
    organizationId?: StringWithAggregatesFilter<"FeePayment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FeePayment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FeePayment"> | Date | string
  }

  export type ScheduledJobWhereInput = {
    AND?: ScheduledJobWhereInput | ScheduledJobWhereInput[]
    OR?: ScheduledJobWhereInput[]
    NOT?: ScheduledJobWhereInput | ScheduledJobWhereInput[]
    id?: StringFilter<"ScheduledJob"> | string
    data?: JsonFilter<"ScheduledJob">
    type?: EnumscheduledJobTypeFilter<"ScheduledJob"> | $Enums.scheduledJobType
    scheduledAt?: DateTimeFilter<"ScheduledJob"> | Date | string
    channels?: EnumNotificationChannelNullableListFilter<"ScheduledJob">
    status?: StringFilter<"ScheduledJob"> | string
    result?: JsonNullableFilter<"ScheduledJob">
    error?: StringNullableFilter<"ScheduledJob"> | string | null
    createdBy?: StringNullableFilter<"ScheduledJob"> | string | null
    createdAt?: DateTimeFilter<"ScheduledJob"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledJob"> | Date | string
    organizationId?: StringFilter<"ScheduledJob"> | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type ScheduledJobOrderByWithRelationInput = {
    id?: SortOrder
    data?: SortOrder
    type?: SortOrder
    scheduledAt?: SortOrder
    channels?: SortOrder
    status?: SortOrder
    result?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    _relevance?: ScheduledJobOrderByRelevanceInput
  }

  export type ScheduledJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScheduledJobWhereInput | ScheduledJobWhereInput[]
    OR?: ScheduledJobWhereInput[]
    NOT?: ScheduledJobWhereInput | ScheduledJobWhereInput[]
    data?: JsonFilter<"ScheduledJob">
    type?: EnumscheduledJobTypeFilter<"ScheduledJob"> | $Enums.scheduledJobType
    scheduledAt?: DateTimeFilter<"ScheduledJob"> | Date | string
    channels?: EnumNotificationChannelNullableListFilter<"ScheduledJob">
    status?: StringFilter<"ScheduledJob"> | string
    result?: JsonNullableFilter<"ScheduledJob">
    error?: StringNullableFilter<"ScheduledJob"> | string | null
    createdBy?: StringNullableFilter<"ScheduledJob"> | string | null
    createdAt?: DateTimeFilter<"ScheduledJob"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledJob"> | Date | string
    organizationId?: StringFilter<"ScheduledJob"> | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id">

  export type ScheduledJobOrderByWithAggregationInput = {
    id?: SortOrder
    data?: SortOrder
    type?: SortOrder
    scheduledAt?: SortOrder
    channels?: SortOrder
    status?: SortOrder
    result?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
    _count?: ScheduledJobCountOrderByAggregateInput
    _max?: ScheduledJobMaxOrderByAggregateInput
    _min?: ScheduledJobMinOrderByAggregateInput
  }

  export type ScheduledJobScalarWhereWithAggregatesInput = {
    AND?: ScheduledJobScalarWhereWithAggregatesInput | ScheduledJobScalarWhereWithAggregatesInput[]
    OR?: ScheduledJobScalarWhereWithAggregatesInput[]
    NOT?: ScheduledJobScalarWhereWithAggregatesInput | ScheduledJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScheduledJob"> | string
    data?: JsonWithAggregatesFilter<"ScheduledJob">
    type?: EnumscheduledJobTypeWithAggregatesFilter<"ScheduledJob"> | $Enums.scheduledJobType
    scheduledAt?: DateTimeWithAggregatesFilter<"ScheduledJob"> | Date | string
    channels?: EnumNotificationChannelNullableListFilter<"ScheduledJob">
    status?: StringWithAggregatesFilter<"ScheduledJob"> | string
    result?: JsonNullableWithAggregatesFilter<"ScheduledJob">
    error?: StringNullableWithAggregatesFilter<"ScheduledJob"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"ScheduledJob"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ScheduledJob"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ScheduledJob"> | Date | string
    organizationId?: StringWithAggregatesFilter<"ScheduledJob"> | string
  }

  export type FeeCategoryWhereInput = {
    AND?: FeeCategoryWhereInput | FeeCategoryWhereInput[]
    OR?: FeeCategoryWhereInput[]
    NOT?: FeeCategoryWhereInput | FeeCategoryWhereInput[]
    id?: StringFilter<"FeeCategory"> | string
    name?: StringFilter<"FeeCategory"> | string
    description?: StringNullableFilter<"FeeCategory"> | string | null
    createdAt?: DateTimeFilter<"FeeCategory"> | Date | string
    updatedAt?: DateTimeFilter<"FeeCategory"> | Date | string
    organizationId?: StringFilter<"FeeCategory"> | string
    fees?: FeeListRelationFilter
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type FeeCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
    fees?: FeeOrderByRelationAggregateInput
    Organization?: OrganizationOrderByWithRelationInput
    _relevance?: FeeCategoryOrderByRelevanceInput
  }

  export type FeeCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name_organizationId?: FeeCategoryNameOrganizationIdCompoundUniqueInput
    AND?: FeeCategoryWhereInput | FeeCategoryWhereInput[]
    OR?: FeeCategoryWhereInput[]
    NOT?: FeeCategoryWhereInput | FeeCategoryWhereInput[]
    name?: StringFilter<"FeeCategory"> | string
    description?: StringNullableFilter<"FeeCategory"> | string | null
    createdAt?: DateTimeFilter<"FeeCategory"> | Date | string
    updatedAt?: DateTimeFilter<"FeeCategory"> | Date | string
    organizationId?: StringFilter<"FeeCategory"> | string
    fees?: FeeListRelationFilter
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id" | "name_organizationId">

  export type FeeCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
    _count?: FeeCategoryCountOrderByAggregateInput
    _max?: FeeCategoryMaxOrderByAggregateInput
    _min?: FeeCategoryMinOrderByAggregateInput
  }

  export type FeeCategoryScalarWhereWithAggregatesInput = {
    AND?: FeeCategoryScalarWhereWithAggregatesInput | FeeCategoryScalarWhereWithAggregatesInput[]
    OR?: FeeCategoryScalarWhereWithAggregatesInput[]
    NOT?: FeeCategoryScalarWhereWithAggregatesInput | FeeCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeeCategory"> | string
    name?: StringWithAggregatesFilter<"FeeCategory"> | string
    description?: StringNullableWithAggregatesFilter<"FeeCategory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FeeCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FeeCategory"> | Date | string
    organizationId?: StringWithAggregatesFilter<"FeeCategory"> | string
  }

  export type AcademicCalendarWhereInput = {
    AND?: AcademicCalendarWhereInput | AcademicCalendarWhereInput[]
    OR?: AcademicCalendarWhereInput[]
    NOT?: AcademicCalendarWhereInput | AcademicCalendarWhereInput[]
    id?: StringFilter<"AcademicCalendar"> | string
    organizationId?: StringFilter<"AcademicCalendar"> | string
    name?: StringFilter<"AcademicCalendar"> | string
    startDate?: DateTimeFilter<"AcademicCalendar"> | Date | string
    endDate?: DateTimeFilter<"AcademicCalendar"> | Date | string
    type?: EnumCalendarEventTypeFilter<"AcademicCalendar"> | $Enums.CalendarEventType
    reason?: StringNullableFilter<"AcademicCalendar"> | string | null
    isRecurring?: BoolFilter<"AcademicCalendar"> | boolean
    createdBy?: StringFilter<"AcademicCalendar"> | string
    createdAt?: DateTimeFilter<"AcademicCalendar"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicCalendar"> | Date | string
    academicYearId?: StringNullableFilter<"AcademicCalendar"> | string | null
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    academicYear?: XOR<AcademicYearNullableScalarRelationFilter, AcademicYearWhereInput> | null
  }

  export type AcademicCalendarOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    type?: SortOrder
    reason?: SortOrderInput | SortOrder
    isRecurring?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicYearId?: SortOrderInput | SortOrder
    organization?: OrganizationOrderByWithRelationInput
    academicYear?: AcademicYearOrderByWithRelationInput
    _relevance?: AcademicCalendarOrderByRelevanceInput
  }

  export type AcademicCalendarWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    organizationId_startDate_endDate?: AcademicCalendarOrganizationIdStartDateEndDateCompoundUniqueInput
    AND?: AcademicCalendarWhereInput | AcademicCalendarWhereInput[]
    OR?: AcademicCalendarWhereInput[]
    NOT?: AcademicCalendarWhereInput | AcademicCalendarWhereInput[]
    organizationId?: StringFilter<"AcademicCalendar"> | string
    name?: StringFilter<"AcademicCalendar"> | string
    startDate?: DateTimeFilter<"AcademicCalendar"> | Date | string
    endDate?: DateTimeFilter<"AcademicCalendar"> | Date | string
    type?: EnumCalendarEventTypeFilter<"AcademicCalendar"> | $Enums.CalendarEventType
    reason?: StringNullableFilter<"AcademicCalendar"> | string | null
    isRecurring?: BoolFilter<"AcademicCalendar"> | boolean
    createdBy?: StringFilter<"AcademicCalendar"> | string
    createdAt?: DateTimeFilter<"AcademicCalendar"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicCalendar"> | Date | string
    academicYearId?: StringNullableFilter<"AcademicCalendar"> | string | null
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    academicYear?: XOR<AcademicYearNullableScalarRelationFilter, AcademicYearWhereInput> | null
  }, "id" | "organizationId_startDate_endDate">

  export type AcademicCalendarOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    type?: SortOrder
    reason?: SortOrderInput | SortOrder
    isRecurring?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicYearId?: SortOrderInput | SortOrder
    _count?: AcademicCalendarCountOrderByAggregateInput
    _max?: AcademicCalendarMaxOrderByAggregateInput
    _min?: AcademicCalendarMinOrderByAggregateInput
  }

  export type AcademicCalendarScalarWhereWithAggregatesInput = {
    AND?: AcademicCalendarScalarWhereWithAggregatesInput | AcademicCalendarScalarWhereWithAggregatesInput[]
    OR?: AcademicCalendarScalarWhereWithAggregatesInput[]
    NOT?: AcademicCalendarScalarWhereWithAggregatesInput | AcademicCalendarScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AcademicCalendar"> | string
    organizationId?: StringWithAggregatesFilter<"AcademicCalendar"> | string
    name?: StringWithAggregatesFilter<"AcademicCalendar"> | string
    startDate?: DateTimeWithAggregatesFilter<"AcademicCalendar"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"AcademicCalendar"> | Date | string
    type?: EnumCalendarEventTypeWithAggregatesFilter<"AcademicCalendar"> | $Enums.CalendarEventType
    reason?: StringNullableWithAggregatesFilter<"AcademicCalendar"> | string | null
    isRecurring?: BoolWithAggregatesFilter<"AcademicCalendar"> | boolean
    createdBy?: StringWithAggregatesFilter<"AcademicCalendar"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AcademicCalendar"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AcademicCalendar"> | Date | string
    academicYearId?: StringNullableWithAggregatesFilter<"AcademicCalendar"> | string | null
  }

  export type AnonymousComplaintWhereInput = {
    AND?: AnonymousComplaintWhereInput | AnonymousComplaintWhereInput[]
    OR?: AnonymousComplaintWhereInput[]
    NOT?: AnonymousComplaintWhereInput | AnonymousComplaintWhereInput[]
    id?: StringFilter<"AnonymousComplaint"> | string
    trackingId?: StringFilter<"AnonymousComplaint"> | string
    category?: StringFilter<"AnonymousComplaint"> | string
    severity?: EnumSeverityFilter<"AnonymousComplaint"> | $Enums.Severity
    subject?: StringFilter<"AnonymousComplaint"> | string
    description?: StringFilter<"AnonymousComplaint"> | string
    evidenceUrls?: StringNullableListFilter<"AnonymousComplaint">
    submittedAt?: DateTimeFilter<"AnonymousComplaint"> | Date | string
    currentStatus?: EnumComplaintStatusFilter<"AnonymousComplaint"> | $Enums.ComplaintStatus
    organizationId?: StringFilter<"AnonymousComplaint"> | string
    createdAt?: DateTimeFilter<"AnonymousComplaint"> | Date | string
    updatedAt?: DateTimeFilter<"AnonymousComplaint"> | Date | string
    academicYearId?: StringNullableFilter<"AnonymousComplaint"> | string | null
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    ComplaintStatusTimeline?: ComplaintStatusTimelineListRelationFilter
    academicYear?: XOR<AcademicYearNullableScalarRelationFilter, AcademicYearWhereInput> | null
  }

  export type AnonymousComplaintOrderByWithRelationInput = {
    id?: SortOrder
    trackingId?: SortOrder
    category?: SortOrder
    severity?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    evidenceUrls?: SortOrder
    submittedAt?: SortOrder
    currentStatus?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicYearId?: SortOrderInput | SortOrder
    organization?: OrganizationOrderByWithRelationInput
    ComplaintStatusTimeline?: ComplaintStatusTimelineOrderByRelationAggregateInput
    academicYear?: AcademicYearOrderByWithRelationInput
    _relevance?: AnonymousComplaintOrderByRelevanceInput
  }

  export type AnonymousComplaintWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    trackingId?: string
    AND?: AnonymousComplaintWhereInput | AnonymousComplaintWhereInput[]
    OR?: AnonymousComplaintWhereInput[]
    NOT?: AnonymousComplaintWhereInput | AnonymousComplaintWhereInput[]
    category?: StringFilter<"AnonymousComplaint"> | string
    severity?: EnumSeverityFilter<"AnonymousComplaint"> | $Enums.Severity
    subject?: StringFilter<"AnonymousComplaint"> | string
    description?: StringFilter<"AnonymousComplaint"> | string
    evidenceUrls?: StringNullableListFilter<"AnonymousComplaint">
    submittedAt?: DateTimeFilter<"AnonymousComplaint"> | Date | string
    currentStatus?: EnumComplaintStatusFilter<"AnonymousComplaint"> | $Enums.ComplaintStatus
    organizationId?: StringFilter<"AnonymousComplaint"> | string
    createdAt?: DateTimeFilter<"AnonymousComplaint"> | Date | string
    updatedAt?: DateTimeFilter<"AnonymousComplaint"> | Date | string
    academicYearId?: StringNullableFilter<"AnonymousComplaint"> | string | null
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    ComplaintStatusTimeline?: ComplaintStatusTimelineListRelationFilter
    academicYear?: XOR<AcademicYearNullableScalarRelationFilter, AcademicYearWhereInput> | null
  }, "id" | "trackingId">

  export type AnonymousComplaintOrderByWithAggregationInput = {
    id?: SortOrder
    trackingId?: SortOrder
    category?: SortOrder
    severity?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    evidenceUrls?: SortOrder
    submittedAt?: SortOrder
    currentStatus?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicYearId?: SortOrderInput | SortOrder
    _count?: AnonymousComplaintCountOrderByAggregateInput
    _max?: AnonymousComplaintMaxOrderByAggregateInput
    _min?: AnonymousComplaintMinOrderByAggregateInput
  }

  export type AnonymousComplaintScalarWhereWithAggregatesInput = {
    AND?: AnonymousComplaintScalarWhereWithAggregatesInput | AnonymousComplaintScalarWhereWithAggregatesInput[]
    OR?: AnonymousComplaintScalarWhereWithAggregatesInput[]
    NOT?: AnonymousComplaintScalarWhereWithAggregatesInput | AnonymousComplaintScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnonymousComplaint"> | string
    trackingId?: StringWithAggregatesFilter<"AnonymousComplaint"> | string
    category?: StringWithAggregatesFilter<"AnonymousComplaint"> | string
    severity?: EnumSeverityWithAggregatesFilter<"AnonymousComplaint"> | $Enums.Severity
    subject?: StringWithAggregatesFilter<"AnonymousComplaint"> | string
    description?: StringWithAggregatesFilter<"AnonymousComplaint"> | string
    evidenceUrls?: StringNullableListFilter<"AnonymousComplaint">
    submittedAt?: DateTimeWithAggregatesFilter<"AnonymousComplaint"> | Date | string
    currentStatus?: EnumComplaintStatusWithAggregatesFilter<"AnonymousComplaint"> | $Enums.ComplaintStatus
    organizationId?: StringWithAggregatesFilter<"AnonymousComplaint"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AnonymousComplaint"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AnonymousComplaint"> | Date | string
    academicYearId?: StringNullableWithAggregatesFilter<"AnonymousComplaint"> | string | null
  }

  export type ComplaintStatusTimelineWhereInput = {
    AND?: ComplaintStatusTimelineWhereInput | ComplaintStatusTimelineWhereInput[]
    OR?: ComplaintStatusTimelineWhereInput[]
    NOT?: ComplaintStatusTimelineWhereInput | ComplaintStatusTimelineWhereInput[]
    id?: StringFilter<"ComplaintStatusTimeline"> | string
    complaintId?: StringFilter<"ComplaintStatusTimeline"> | string
    note?: StringNullableFilter<"ComplaintStatusTimeline"> | string | null
    status?: EnumComplaintStatusFilter<"ComplaintStatusTimeline"> | $Enums.ComplaintStatus
    changedBy?: StringNullableFilter<"ComplaintStatusTimeline"> | string | null
    createdAt?: DateTimeFilter<"ComplaintStatusTimeline"> | Date | string
    updatedAt?: DateTimeFilter<"ComplaintStatusTimeline"> | Date | string
    complaint?: XOR<AnonymousComplaintScalarRelationFilter, AnonymousComplaintWhereInput>
  }

  export type ComplaintStatusTimelineOrderByWithRelationInput = {
    id?: SortOrder
    complaintId?: SortOrder
    note?: SortOrderInput | SortOrder
    status?: SortOrder
    changedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    complaint?: AnonymousComplaintOrderByWithRelationInput
    _relevance?: ComplaintStatusTimelineOrderByRelevanceInput
  }

  export type ComplaintStatusTimelineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ComplaintStatusTimelineWhereInput | ComplaintStatusTimelineWhereInput[]
    OR?: ComplaintStatusTimelineWhereInput[]
    NOT?: ComplaintStatusTimelineWhereInput | ComplaintStatusTimelineWhereInput[]
    complaintId?: StringFilter<"ComplaintStatusTimeline"> | string
    note?: StringNullableFilter<"ComplaintStatusTimeline"> | string | null
    status?: EnumComplaintStatusFilter<"ComplaintStatusTimeline"> | $Enums.ComplaintStatus
    changedBy?: StringNullableFilter<"ComplaintStatusTimeline"> | string | null
    createdAt?: DateTimeFilter<"ComplaintStatusTimeline"> | Date | string
    updatedAt?: DateTimeFilter<"ComplaintStatusTimeline"> | Date | string
    complaint?: XOR<AnonymousComplaintScalarRelationFilter, AnonymousComplaintWhereInput>
  }, "id">

  export type ComplaintStatusTimelineOrderByWithAggregationInput = {
    id?: SortOrder
    complaintId?: SortOrder
    note?: SortOrderInput | SortOrder
    status?: SortOrder
    changedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ComplaintStatusTimelineCountOrderByAggregateInput
    _max?: ComplaintStatusTimelineMaxOrderByAggregateInput
    _min?: ComplaintStatusTimelineMinOrderByAggregateInput
  }

  export type ComplaintStatusTimelineScalarWhereWithAggregatesInput = {
    AND?: ComplaintStatusTimelineScalarWhereWithAggregatesInput | ComplaintStatusTimelineScalarWhereWithAggregatesInput[]
    OR?: ComplaintStatusTimelineScalarWhereWithAggregatesInput[]
    NOT?: ComplaintStatusTimelineScalarWhereWithAggregatesInput | ComplaintStatusTimelineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ComplaintStatusTimeline"> | string
    complaintId?: StringWithAggregatesFilter<"ComplaintStatusTimeline"> | string
    note?: StringNullableWithAggregatesFilter<"ComplaintStatusTimeline"> | string | null
    status?: EnumComplaintStatusWithAggregatesFilter<"ComplaintStatusTimeline"> | $Enums.ComplaintStatus
    changedBy?: StringNullableWithAggregatesFilter<"ComplaintStatusTimeline"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ComplaintStatusTimeline"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ComplaintStatusTimeline"> | Date | string
  }

  export type NoticeWhereInput = {
    AND?: NoticeWhereInput | NoticeWhereInput[]
    OR?: NoticeWhereInput[]
    NOT?: NoticeWhereInput | NoticeWhereInput[]
    id?: StringFilter<"Notice"> | string
    noticeType?: StringFilter<"Notice"> | string
    title?: StringFilter<"Notice"> | string
    startDate?: DateTimeFilter<"Notice"> | Date | string
    endDate?: DateTimeFilter<"Notice"> | Date | string
    content?: StringFilter<"Notice"> | string
    summary?: StringNullableFilter<"Notice"> | string | null
    isNoticeApproved?: BoolFilter<"Notice"> | boolean
    isDraft?: BoolFilter<"Notice"> | boolean
    isPublished?: BoolFilter<"Notice"> | boolean
    emailNotification?: BoolFilter<"Notice"> | boolean
    pushNotification?: BoolFilter<"Notice"> | boolean
    WhatsAppNotification?: BoolFilter<"Notice"> | boolean
    smsNotification?: BoolFilter<"Notice"> | boolean
    targetAudience?: StringNullableListFilter<"Notice">
    attachments?: JsonNullableFilter<"Notice">
    publishedBy?: StringFilter<"Notice"> | string
    organizationId?: StringFilter<"Notice"> | string
    createdAt?: DateTimeFilter<"Notice"> | Date | string
    updatedAt?: DateTimeFilter<"Notice"> | Date | string
    academicYearId?: StringNullableFilter<"Notice"> | string | null
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    academicYear?: XOR<AcademicYearNullableScalarRelationFilter, AcademicYearWhereInput> | null
  }

  export type NoticeOrderByWithRelationInput = {
    id?: SortOrder
    noticeType?: SortOrder
    title?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    content?: SortOrder
    summary?: SortOrderInput | SortOrder
    isNoticeApproved?: SortOrder
    isDraft?: SortOrder
    isPublished?: SortOrder
    emailNotification?: SortOrder
    pushNotification?: SortOrder
    WhatsAppNotification?: SortOrder
    smsNotification?: SortOrder
    targetAudience?: SortOrder
    attachments?: SortOrderInput | SortOrder
    publishedBy?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicYearId?: SortOrderInput | SortOrder
    Organization?: OrganizationOrderByWithRelationInput
    academicYear?: AcademicYearOrderByWithRelationInput
    _relevance?: NoticeOrderByRelevanceInput
  }

  export type NoticeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NoticeWhereInput | NoticeWhereInput[]
    OR?: NoticeWhereInput[]
    NOT?: NoticeWhereInput | NoticeWhereInput[]
    noticeType?: StringFilter<"Notice"> | string
    title?: StringFilter<"Notice"> | string
    startDate?: DateTimeFilter<"Notice"> | Date | string
    endDate?: DateTimeFilter<"Notice"> | Date | string
    content?: StringFilter<"Notice"> | string
    summary?: StringNullableFilter<"Notice"> | string | null
    isNoticeApproved?: BoolFilter<"Notice"> | boolean
    isDraft?: BoolFilter<"Notice"> | boolean
    isPublished?: BoolFilter<"Notice"> | boolean
    emailNotification?: BoolFilter<"Notice"> | boolean
    pushNotification?: BoolFilter<"Notice"> | boolean
    WhatsAppNotification?: BoolFilter<"Notice"> | boolean
    smsNotification?: BoolFilter<"Notice"> | boolean
    targetAudience?: StringNullableListFilter<"Notice">
    attachments?: JsonNullableFilter<"Notice">
    publishedBy?: StringFilter<"Notice"> | string
    organizationId?: StringFilter<"Notice"> | string
    createdAt?: DateTimeFilter<"Notice"> | Date | string
    updatedAt?: DateTimeFilter<"Notice"> | Date | string
    academicYearId?: StringNullableFilter<"Notice"> | string | null
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    academicYear?: XOR<AcademicYearNullableScalarRelationFilter, AcademicYearWhereInput> | null
  }, "id">

  export type NoticeOrderByWithAggregationInput = {
    id?: SortOrder
    noticeType?: SortOrder
    title?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    content?: SortOrder
    summary?: SortOrderInput | SortOrder
    isNoticeApproved?: SortOrder
    isDraft?: SortOrder
    isPublished?: SortOrder
    emailNotification?: SortOrder
    pushNotification?: SortOrder
    WhatsAppNotification?: SortOrder
    smsNotification?: SortOrder
    targetAudience?: SortOrder
    attachments?: SortOrderInput | SortOrder
    publishedBy?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicYearId?: SortOrderInput | SortOrder
    _count?: NoticeCountOrderByAggregateInput
    _max?: NoticeMaxOrderByAggregateInput
    _min?: NoticeMinOrderByAggregateInput
  }

  export type NoticeScalarWhereWithAggregatesInput = {
    AND?: NoticeScalarWhereWithAggregatesInput | NoticeScalarWhereWithAggregatesInput[]
    OR?: NoticeScalarWhereWithAggregatesInput[]
    NOT?: NoticeScalarWhereWithAggregatesInput | NoticeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notice"> | string
    noticeType?: StringWithAggregatesFilter<"Notice"> | string
    title?: StringWithAggregatesFilter<"Notice"> | string
    startDate?: DateTimeWithAggregatesFilter<"Notice"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Notice"> | Date | string
    content?: StringWithAggregatesFilter<"Notice"> | string
    summary?: StringNullableWithAggregatesFilter<"Notice"> | string | null
    isNoticeApproved?: BoolWithAggregatesFilter<"Notice"> | boolean
    isDraft?: BoolWithAggregatesFilter<"Notice"> | boolean
    isPublished?: BoolWithAggregatesFilter<"Notice"> | boolean
    emailNotification?: BoolWithAggregatesFilter<"Notice"> | boolean
    pushNotification?: BoolWithAggregatesFilter<"Notice"> | boolean
    WhatsAppNotification?: BoolWithAggregatesFilter<"Notice"> | boolean
    smsNotification?: BoolWithAggregatesFilter<"Notice"> | boolean
    targetAudience?: StringNullableListFilter<"Notice">
    attachments?: JsonNullableWithAggregatesFilter<"Notice">
    publishedBy?: StringWithAggregatesFilter<"Notice"> | string
    organizationId?: StringWithAggregatesFilter<"Notice"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Notice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notice"> | Date | string
    academicYearId?: StringNullableWithAggregatesFilter<"Notice"> | string | null
  }

  export type NotificationLogWhereInput = {
    AND?: NotificationLogWhereInput | NotificationLogWhereInput[]
    OR?: NotificationLogWhereInput[]
    NOT?: NotificationLogWhereInput | NotificationLogWhereInput[]
    id?: StringFilter<"NotificationLog"> | string
    organizationId?: StringFilter<"NotificationLog"> | string
    userId?: StringNullableFilter<"NotificationLog"> | string | null
    parentId?: StringNullableFilter<"NotificationLog"> | string | null
    studentId?: StringNullableFilter<"NotificationLog"> | string | null
    channel?: EnumNotificationChannelFilter<"NotificationLog"> | $Enums.NotificationChannel
    status?: EnumNotificationStatusFilter<"NotificationLog"> | $Enums.NotificationStatus
    notificationType?: EnumNotificationTypeFilter<"NotificationLog"> | $Enums.NotificationType
    units?: IntFilter<"NotificationLog"> | number
    cost?: FloatFilter<"NotificationLog"> | number
    sentAt?: DateTimeFilter<"NotificationLog"> | Date | string
    createdAt?: DateTimeFilter<"NotificationLog"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationLog"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    parent?: XOR<ParentNullableScalarRelationFilter, ParentWhereInput> | null
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
  }

  export type NotificationLogOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    studentId?: SortOrderInput | SortOrder
    channel?: SortOrder
    status?: SortOrder
    notificationType?: SortOrder
    units?: SortOrder
    cost?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    parent?: ParentOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
    _relevance?: NotificationLogOrderByRelevanceInput
  }

  export type NotificationLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationLogWhereInput | NotificationLogWhereInput[]
    OR?: NotificationLogWhereInput[]
    NOT?: NotificationLogWhereInput | NotificationLogWhereInput[]
    organizationId?: StringFilter<"NotificationLog"> | string
    userId?: StringNullableFilter<"NotificationLog"> | string | null
    parentId?: StringNullableFilter<"NotificationLog"> | string | null
    studentId?: StringNullableFilter<"NotificationLog"> | string | null
    channel?: EnumNotificationChannelFilter<"NotificationLog"> | $Enums.NotificationChannel
    status?: EnumNotificationStatusFilter<"NotificationLog"> | $Enums.NotificationStatus
    notificationType?: EnumNotificationTypeFilter<"NotificationLog"> | $Enums.NotificationType
    units?: IntFilter<"NotificationLog"> | number
    cost?: FloatFilter<"NotificationLog"> | number
    sentAt?: DateTimeFilter<"NotificationLog"> | Date | string
    createdAt?: DateTimeFilter<"NotificationLog"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationLog"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    parent?: XOR<ParentNullableScalarRelationFilter, ParentWhereInput> | null
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
  }, "id">

  export type NotificationLogOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    studentId?: SortOrderInput | SortOrder
    channel?: SortOrder
    status?: SortOrder
    notificationType?: SortOrder
    units?: SortOrder
    cost?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationLogCountOrderByAggregateInput
    _avg?: NotificationLogAvgOrderByAggregateInput
    _max?: NotificationLogMaxOrderByAggregateInput
    _min?: NotificationLogMinOrderByAggregateInput
    _sum?: NotificationLogSumOrderByAggregateInput
  }

  export type NotificationLogScalarWhereWithAggregatesInput = {
    AND?: NotificationLogScalarWhereWithAggregatesInput | NotificationLogScalarWhereWithAggregatesInput[]
    OR?: NotificationLogScalarWhereWithAggregatesInput[]
    NOT?: NotificationLogScalarWhereWithAggregatesInput | NotificationLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationLog"> | string
    organizationId?: StringWithAggregatesFilter<"NotificationLog"> | string
    userId?: StringNullableWithAggregatesFilter<"NotificationLog"> | string | null
    parentId?: StringNullableWithAggregatesFilter<"NotificationLog"> | string | null
    studentId?: StringNullableWithAggregatesFilter<"NotificationLog"> | string | null
    channel?: EnumNotificationChannelWithAggregatesFilter<"NotificationLog"> | $Enums.NotificationChannel
    status?: EnumNotificationStatusWithAggregatesFilter<"NotificationLog"> | $Enums.NotificationStatus
    notificationType?: EnumNotificationTypeWithAggregatesFilter<"NotificationLog"> | $Enums.NotificationType
    units?: IntWithAggregatesFilter<"NotificationLog"> | number
    cost?: FloatWithAggregatesFilter<"NotificationLog"> | number
    sentAt?: DateTimeWithAggregatesFilter<"NotificationLog"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"NotificationLog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationLog"> | Date | string
  }

  export type ExamSessionWhereInput = {
    AND?: ExamSessionWhereInput | ExamSessionWhereInput[]
    OR?: ExamSessionWhereInput[]
    NOT?: ExamSessionWhereInput | ExamSessionWhereInput[]
    id?: StringFilter<"ExamSession"> | string
    title?: StringFilter<"ExamSession"> | string
    description?: StringNullableFilter<"ExamSession"> | string | null
    academicYearId?: StringFilter<"ExamSession"> | string
    startDate?: DateTimeFilter<"ExamSession"> | Date | string
    endDate?: DateTimeFilter<"ExamSession"> | Date | string
    createdBy?: StringFilter<"ExamSession"> | string
    createdAt?: DateTimeFilter<"ExamSession"> | Date | string
    updatedAt?: DateTimeFilter<"ExamSession"> | Date | string
    academicYear?: XOR<AcademicYearScalarRelationFilter, AcademicYearWhereInput>
    exams?: ExamListRelationFilter
    reportCards?: ReportCardListRelationFilter
    hallTickets?: HallTicketListRelationFilter
  }

  export type ExamSessionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    academicYearId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicYear?: AcademicYearOrderByWithRelationInput
    exams?: ExamOrderByRelationAggregateInput
    reportCards?: ReportCardOrderByRelationAggregateInput
    hallTickets?: HallTicketOrderByRelationAggregateInput
    _relevance?: ExamSessionOrderByRelevanceInput
  }

  export type ExamSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    academicYearId_title?: ExamSessionAcademicYearIdTitleCompoundUniqueInput
    AND?: ExamSessionWhereInput | ExamSessionWhereInput[]
    OR?: ExamSessionWhereInput[]
    NOT?: ExamSessionWhereInput | ExamSessionWhereInput[]
    title?: StringFilter<"ExamSession"> | string
    description?: StringNullableFilter<"ExamSession"> | string | null
    academicYearId?: StringFilter<"ExamSession"> | string
    startDate?: DateTimeFilter<"ExamSession"> | Date | string
    endDate?: DateTimeFilter<"ExamSession"> | Date | string
    createdBy?: StringFilter<"ExamSession"> | string
    createdAt?: DateTimeFilter<"ExamSession"> | Date | string
    updatedAt?: DateTimeFilter<"ExamSession"> | Date | string
    academicYear?: XOR<AcademicYearScalarRelationFilter, AcademicYearWhereInput>
    exams?: ExamListRelationFilter
    reportCards?: ReportCardListRelationFilter
    hallTickets?: HallTicketListRelationFilter
  }, "id" | "academicYearId_title">

  export type ExamSessionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    academicYearId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExamSessionCountOrderByAggregateInput
    _max?: ExamSessionMaxOrderByAggregateInput
    _min?: ExamSessionMinOrderByAggregateInput
  }

  export type ExamSessionScalarWhereWithAggregatesInput = {
    AND?: ExamSessionScalarWhereWithAggregatesInput | ExamSessionScalarWhereWithAggregatesInput[]
    OR?: ExamSessionScalarWhereWithAggregatesInput[]
    NOT?: ExamSessionScalarWhereWithAggregatesInput | ExamSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExamSession"> | string
    title?: StringWithAggregatesFilter<"ExamSession"> | string
    description?: StringNullableWithAggregatesFilter<"ExamSession"> | string | null
    academicYearId?: StringWithAggregatesFilter<"ExamSession"> | string
    startDate?: DateTimeWithAggregatesFilter<"ExamSession"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"ExamSession"> | Date | string
    createdBy?: StringWithAggregatesFilter<"ExamSession"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ExamSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExamSession"> | Date | string
  }

  export type ExamWhereInput = {
    AND?: ExamWhereInput | ExamWhereInput[]
    OR?: ExamWhereInput[]
    NOT?: ExamWhereInput | ExamWhereInput[]
    id?: StringFilter<"Exam"> | string
    title?: StringFilter<"Exam"> | string
    description?: StringNullableFilter<"Exam"> | string | null
    examSessionId?: StringFilter<"Exam"> | string
    subjectId?: StringFilter<"Exam"> | string
    gradeId?: StringFilter<"Exam"> | string
    sectionId?: StringFilter<"Exam"> | string
    organizationId?: StringFilter<"Exam"> | string
    maxMarks?: FloatFilter<"Exam"> | number
    passingMarks?: FloatNullableFilter<"Exam"> | number | null
    weightage?: FloatNullableFilter<"Exam"> | number | null
    evaluationType?: EnumEvaluationTypeFilter<"Exam"> | $Enums.EvaluationType
    mode?: EnumExamModeFilter<"Exam"> | $Enums.ExamMode
    status?: EnumExamStatusFilter<"Exam"> | $Enums.ExamStatus
    instructions?: StringNullableFilter<"Exam"> | string | null
    durationInMinutes?: IntNullableFilter<"Exam"> | number | null
    venueMapUrl?: StringNullableFilter<"Exam"> | string | null
    venue?: StringNullableFilter<"Exam"> | string | null
    isResultsPublished?: BoolFilter<"Exam"> | boolean
    supervisors?: StringNullableListFilter<"Exam">
    startDate?: DateTimeFilter<"Exam"> | Date | string
    endDate?: DateTimeFilter<"Exam"> | Date | string
    createdAt?: DateTimeFilter<"Exam"> | Date | string
    updatedAt?: DateTimeFilter<"Exam"> | Date | string
    examSession?: XOR<ExamSessionScalarRelationFilter, ExamSessionWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    hallTickets?: HallTicketListRelationFilter
    examResult?: ExamResultListRelationFilter
    examEnrollment?: ExamEnrollmentListRelationFilter
  }

  export type ExamOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    examSessionId?: SortOrder
    subjectId?: SortOrder
    gradeId?: SortOrder
    sectionId?: SortOrder
    organizationId?: SortOrder
    maxMarks?: SortOrder
    passingMarks?: SortOrderInput | SortOrder
    weightage?: SortOrderInput | SortOrder
    evaluationType?: SortOrder
    mode?: SortOrder
    status?: SortOrder
    instructions?: SortOrderInput | SortOrder
    durationInMinutes?: SortOrderInput | SortOrder
    venueMapUrl?: SortOrderInput | SortOrder
    venue?: SortOrderInput | SortOrder
    isResultsPublished?: SortOrder
    supervisors?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    examSession?: ExamSessionOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
    hallTickets?: HallTicketOrderByRelationAggregateInput
    examResult?: ExamResultOrderByRelationAggregateInput
    examEnrollment?: ExamEnrollmentOrderByRelationAggregateInput
    _relevance?: ExamOrderByRelevanceInput
  }

  export type ExamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    examSessionId_subjectId_gradeId_sectionId?: ExamExamSessionIdSubjectIdGradeIdSectionIdCompoundUniqueInput
    AND?: ExamWhereInput | ExamWhereInput[]
    OR?: ExamWhereInput[]
    NOT?: ExamWhereInput | ExamWhereInput[]
    title?: StringFilter<"Exam"> | string
    description?: StringNullableFilter<"Exam"> | string | null
    examSessionId?: StringFilter<"Exam"> | string
    subjectId?: StringFilter<"Exam"> | string
    gradeId?: StringFilter<"Exam"> | string
    sectionId?: StringFilter<"Exam"> | string
    organizationId?: StringFilter<"Exam"> | string
    maxMarks?: FloatFilter<"Exam"> | number
    passingMarks?: FloatNullableFilter<"Exam"> | number | null
    weightage?: FloatNullableFilter<"Exam"> | number | null
    evaluationType?: EnumEvaluationTypeFilter<"Exam"> | $Enums.EvaluationType
    mode?: EnumExamModeFilter<"Exam"> | $Enums.ExamMode
    status?: EnumExamStatusFilter<"Exam"> | $Enums.ExamStatus
    instructions?: StringNullableFilter<"Exam"> | string | null
    durationInMinutes?: IntNullableFilter<"Exam"> | number | null
    venueMapUrl?: StringNullableFilter<"Exam"> | string | null
    venue?: StringNullableFilter<"Exam"> | string | null
    isResultsPublished?: BoolFilter<"Exam"> | boolean
    supervisors?: StringNullableListFilter<"Exam">
    startDate?: DateTimeFilter<"Exam"> | Date | string
    endDate?: DateTimeFilter<"Exam"> | Date | string
    createdAt?: DateTimeFilter<"Exam"> | Date | string
    updatedAt?: DateTimeFilter<"Exam"> | Date | string
    examSession?: XOR<ExamSessionScalarRelationFilter, ExamSessionWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    hallTickets?: HallTicketListRelationFilter
    examResult?: ExamResultListRelationFilter
    examEnrollment?: ExamEnrollmentListRelationFilter
  }, "id" | "examSessionId_subjectId_gradeId_sectionId">

  export type ExamOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    examSessionId?: SortOrder
    subjectId?: SortOrder
    gradeId?: SortOrder
    sectionId?: SortOrder
    organizationId?: SortOrder
    maxMarks?: SortOrder
    passingMarks?: SortOrderInput | SortOrder
    weightage?: SortOrderInput | SortOrder
    evaluationType?: SortOrder
    mode?: SortOrder
    status?: SortOrder
    instructions?: SortOrderInput | SortOrder
    durationInMinutes?: SortOrderInput | SortOrder
    venueMapUrl?: SortOrderInput | SortOrder
    venue?: SortOrderInput | SortOrder
    isResultsPublished?: SortOrder
    supervisors?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExamCountOrderByAggregateInput
    _avg?: ExamAvgOrderByAggregateInput
    _max?: ExamMaxOrderByAggregateInput
    _min?: ExamMinOrderByAggregateInput
    _sum?: ExamSumOrderByAggregateInput
  }

  export type ExamScalarWhereWithAggregatesInput = {
    AND?: ExamScalarWhereWithAggregatesInput | ExamScalarWhereWithAggregatesInput[]
    OR?: ExamScalarWhereWithAggregatesInput[]
    NOT?: ExamScalarWhereWithAggregatesInput | ExamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Exam"> | string
    title?: StringWithAggregatesFilter<"Exam"> | string
    description?: StringNullableWithAggregatesFilter<"Exam"> | string | null
    examSessionId?: StringWithAggregatesFilter<"Exam"> | string
    subjectId?: StringWithAggregatesFilter<"Exam"> | string
    gradeId?: StringWithAggregatesFilter<"Exam"> | string
    sectionId?: StringWithAggregatesFilter<"Exam"> | string
    organizationId?: StringWithAggregatesFilter<"Exam"> | string
    maxMarks?: FloatWithAggregatesFilter<"Exam"> | number
    passingMarks?: FloatNullableWithAggregatesFilter<"Exam"> | number | null
    weightage?: FloatNullableWithAggregatesFilter<"Exam"> | number | null
    evaluationType?: EnumEvaluationTypeWithAggregatesFilter<"Exam"> | $Enums.EvaluationType
    mode?: EnumExamModeWithAggregatesFilter<"Exam"> | $Enums.ExamMode
    status?: EnumExamStatusWithAggregatesFilter<"Exam"> | $Enums.ExamStatus
    instructions?: StringNullableWithAggregatesFilter<"Exam"> | string | null
    durationInMinutes?: IntNullableWithAggregatesFilter<"Exam"> | number | null
    venueMapUrl?: StringNullableWithAggregatesFilter<"Exam"> | string | null
    venue?: StringNullableWithAggregatesFilter<"Exam"> | string | null
    isResultsPublished?: BoolWithAggregatesFilter<"Exam"> | boolean
    supervisors?: StringNullableListFilter<"Exam">
    startDate?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
  }

  export type ExamEnrollmentWhereInput = {
    AND?: ExamEnrollmentWhereInput | ExamEnrollmentWhereInput[]
    OR?: ExamEnrollmentWhereInput[]
    NOT?: ExamEnrollmentWhereInput | ExamEnrollmentWhereInput[]
    id?: StringFilter<"ExamEnrollment"> | string
    studentId?: StringFilter<"ExamEnrollment"> | string
    examId?: StringFilter<"ExamEnrollment"> | string
    status?: EnumStudentExamStatusFilter<"ExamEnrollment"> | $Enums.StudentExamStatus
    enrolledAt?: DateTimeFilter<"ExamEnrollment"> | Date | string
    exemptionReason?: StringNullableFilter<"ExamEnrollment"> | string | null
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    exam?: XOR<ExamScalarRelationFilter, ExamWhereInput>
  }

  export type ExamEnrollmentOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    examId?: SortOrder
    status?: SortOrder
    enrolledAt?: SortOrder
    exemptionReason?: SortOrderInput | SortOrder
    student?: StudentOrderByWithRelationInput
    exam?: ExamOrderByWithRelationInput
    _relevance?: ExamEnrollmentOrderByRelevanceInput
  }

  export type ExamEnrollmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_examId?: ExamEnrollmentStudentIdExamIdCompoundUniqueInput
    AND?: ExamEnrollmentWhereInput | ExamEnrollmentWhereInput[]
    OR?: ExamEnrollmentWhereInput[]
    NOT?: ExamEnrollmentWhereInput | ExamEnrollmentWhereInput[]
    studentId?: StringFilter<"ExamEnrollment"> | string
    examId?: StringFilter<"ExamEnrollment"> | string
    status?: EnumStudentExamStatusFilter<"ExamEnrollment"> | $Enums.StudentExamStatus
    enrolledAt?: DateTimeFilter<"ExamEnrollment"> | Date | string
    exemptionReason?: StringNullableFilter<"ExamEnrollment"> | string | null
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    exam?: XOR<ExamScalarRelationFilter, ExamWhereInput>
  }, "id" | "studentId_examId">

  export type ExamEnrollmentOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    examId?: SortOrder
    status?: SortOrder
    enrolledAt?: SortOrder
    exemptionReason?: SortOrderInput | SortOrder
    _count?: ExamEnrollmentCountOrderByAggregateInput
    _max?: ExamEnrollmentMaxOrderByAggregateInput
    _min?: ExamEnrollmentMinOrderByAggregateInput
  }

  export type ExamEnrollmentScalarWhereWithAggregatesInput = {
    AND?: ExamEnrollmentScalarWhereWithAggregatesInput | ExamEnrollmentScalarWhereWithAggregatesInput[]
    OR?: ExamEnrollmentScalarWhereWithAggregatesInput[]
    NOT?: ExamEnrollmentScalarWhereWithAggregatesInput | ExamEnrollmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExamEnrollment"> | string
    studentId?: StringWithAggregatesFilter<"ExamEnrollment"> | string
    examId?: StringWithAggregatesFilter<"ExamEnrollment"> | string
    status?: EnumStudentExamStatusWithAggregatesFilter<"ExamEnrollment"> | $Enums.StudentExamStatus
    enrolledAt?: DateTimeWithAggregatesFilter<"ExamEnrollment"> | Date | string
    exemptionReason?: StringNullableWithAggregatesFilter<"ExamEnrollment"> | string | null
  }

  export type ExamResultWhereInput = {
    AND?: ExamResultWhereInput | ExamResultWhereInput[]
    OR?: ExamResultWhereInput[]
    NOT?: ExamResultWhereInput | ExamResultWhereInput[]
    id?: StringFilter<"ExamResult"> | string
    studentId?: StringFilter<"ExamResult"> | string
    examId?: StringFilter<"ExamResult"> | string
    subjectId?: StringNullableFilter<"ExamResult"> | string | null
    maxMarks?: FloatFilter<"ExamResult"> | number
    obtainedMarks?: FloatNullableFilter<"ExamResult"> | number | null
    percentage?: FloatNullableFilter<"ExamResult"> | number | null
    gradeLabel?: StringNullableFilter<"ExamResult"> | string | null
    remarks?: StringNullableFilter<"ExamResult"> | string | null
    isPassed?: BoolNullableFilter<"ExamResult"> | boolean | null
    isAbsent?: BoolFilter<"ExamResult"> | boolean
    isResultsPublished?: BoolFilter<"ExamResult"> | boolean
    createdAt?: DateTimeFilter<"ExamResult"> | Date | string
    updatedAt?: DateTimeFilter<"ExamResult"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    exam?: XOR<ExamScalarRelationFilter, ExamWhereInput>
    subject?: XOR<SubjectNullableScalarRelationFilter, SubjectWhereInput> | null
  }

  export type ExamResultOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    examId?: SortOrder
    subjectId?: SortOrderInput | SortOrder
    maxMarks?: SortOrder
    obtainedMarks?: SortOrderInput | SortOrder
    percentage?: SortOrderInput | SortOrder
    gradeLabel?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    isPassed?: SortOrderInput | SortOrder
    isAbsent?: SortOrder
    isResultsPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    exam?: ExamOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
    _relevance?: ExamResultOrderByRelevanceInput
  }

  export type ExamResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    examId_studentId_subjectId?: ExamResultExamIdStudentIdSubjectIdCompoundUniqueInput
    AND?: ExamResultWhereInput | ExamResultWhereInput[]
    OR?: ExamResultWhereInput[]
    NOT?: ExamResultWhereInput | ExamResultWhereInput[]
    studentId?: StringFilter<"ExamResult"> | string
    examId?: StringFilter<"ExamResult"> | string
    subjectId?: StringNullableFilter<"ExamResult"> | string | null
    maxMarks?: FloatFilter<"ExamResult"> | number
    obtainedMarks?: FloatNullableFilter<"ExamResult"> | number | null
    percentage?: FloatNullableFilter<"ExamResult"> | number | null
    gradeLabel?: StringNullableFilter<"ExamResult"> | string | null
    remarks?: StringNullableFilter<"ExamResult"> | string | null
    isPassed?: BoolNullableFilter<"ExamResult"> | boolean | null
    isAbsent?: BoolFilter<"ExamResult"> | boolean
    isResultsPublished?: BoolFilter<"ExamResult"> | boolean
    createdAt?: DateTimeFilter<"ExamResult"> | Date | string
    updatedAt?: DateTimeFilter<"ExamResult"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    exam?: XOR<ExamScalarRelationFilter, ExamWhereInput>
    subject?: XOR<SubjectNullableScalarRelationFilter, SubjectWhereInput> | null
  }, "id" | "examId_studentId_subjectId">

  export type ExamResultOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    examId?: SortOrder
    subjectId?: SortOrderInput | SortOrder
    maxMarks?: SortOrder
    obtainedMarks?: SortOrderInput | SortOrder
    percentage?: SortOrderInput | SortOrder
    gradeLabel?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    isPassed?: SortOrderInput | SortOrder
    isAbsent?: SortOrder
    isResultsPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExamResultCountOrderByAggregateInput
    _avg?: ExamResultAvgOrderByAggregateInput
    _max?: ExamResultMaxOrderByAggregateInput
    _min?: ExamResultMinOrderByAggregateInput
    _sum?: ExamResultSumOrderByAggregateInput
  }

  export type ExamResultScalarWhereWithAggregatesInput = {
    AND?: ExamResultScalarWhereWithAggregatesInput | ExamResultScalarWhereWithAggregatesInput[]
    OR?: ExamResultScalarWhereWithAggregatesInput[]
    NOT?: ExamResultScalarWhereWithAggregatesInput | ExamResultScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExamResult"> | string
    studentId?: StringWithAggregatesFilter<"ExamResult"> | string
    examId?: StringWithAggregatesFilter<"ExamResult"> | string
    subjectId?: StringNullableWithAggregatesFilter<"ExamResult"> | string | null
    maxMarks?: FloatWithAggregatesFilter<"ExamResult"> | number
    obtainedMarks?: FloatNullableWithAggregatesFilter<"ExamResult"> | number | null
    percentage?: FloatNullableWithAggregatesFilter<"ExamResult"> | number | null
    gradeLabel?: StringNullableWithAggregatesFilter<"ExamResult"> | string | null
    remarks?: StringNullableWithAggregatesFilter<"ExamResult"> | string | null
    isPassed?: BoolNullableWithAggregatesFilter<"ExamResult"> | boolean | null
    isAbsent?: BoolWithAggregatesFilter<"ExamResult"> | boolean
    isResultsPublished?: BoolWithAggregatesFilter<"ExamResult"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ExamResult"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExamResult"> | Date | string
  }

  export type HallTicketWhereInput = {
    AND?: HallTicketWhereInput | HallTicketWhereInput[]
    OR?: HallTicketWhereInput[]
    NOT?: HallTicketWhereInput | HallTicketWhereInput[]
    id?: StringFilter<"HallTicket"> | string
    studentId?: StringFilter<"HallTicket"> | string
    examId?: StringNullableFilter<"HallTicket"> | string | null
    examSessionId?: StringNullableFilter<"HallTicket"> | string | null
    pdfUrl?: StringFilter<"HallTicket"> | string
    qrCode?: StringNullableFilter<"HallTicket"> | string | null
    generatedAt?: DateTimeFilter<"HallTicket"> | Date | string
    downloadedAt?: DateTimeNullableFilter<"HallTicket"> | Date | string | null
    expiryDate?: DateTimeNullableFilter<"HallTicket"> | Date | string | null
    organizationId?: StringFilter<"HallTicket"> | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    exam?: XOR<ExamNullableScalarRelationFilter, ExamWhereInput> | null
    examSession?: XOR<ExamSessionNullableScalarRelationFilter, ExamSessionWhereInput> | null
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type HallTicketOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    examId?: SortOrderInput | SortOrder
    examSessionId?: SortOrderInput | SortOrder
    pdfUrl?: SortOrder
    qrCode?: SortOrderInput | SortOrder
    generatedAt?: SortOrder
    downloadedAt?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    organizationId?: SortOrder
    student?: StudentOrderByWithRelationInput
    exam?: ExamOrderByWithRelationInput
    examSession?: ExamSessionOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
    _relevance?: HallTicketOrderByRelevanceInput
  }

  export type HallTicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_examId?: HallTicketStudentIdExamIdCompoundUniqueInput
    AND?: HallTicketWhereInput | HallTicketWhereInput[]
    OR?: HallTicketWhereInput[]
    NOT?: HallTicketWhereInput | HallTicketWhereInput[]
    studentId?: StringFilter<"HallTicket"> | string
    examId?: StringNullableFilter<"HallTicket"> | string | null
    examSessionId?: StringNullableFilter<"HallTicket"> | string | null
    pdfUrl?: StringFilter<"HallTicket"> | string
    qrCode?: StringNullableFilter<"HallTicket"> | string | null
    generatedAt?: DateTimeFilter<"HallTicket"> | Date | string
    downloadedAt?: DateTimeNullableFilter<"HallTicket"> | Date | string | null
    expiryDate?: DateTimeNullableFilter<"HallTicket"> | Date | string | null
    organizationId?: StringFilter<"HallTicket"> | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    exam?: XOR<ExamNullableScalarRelationFilter, ExamWhereInput> | null
    examSession?: XOR<ExamSessionNullableScalarRelationFilter, ExamSessionWhereInput> | null
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id" | "studentId_examId">

  export type HallTicketOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    examId?: SortOrderInput | SortOrder
    examSessionId?: SortOrderInput | SortOrder
    pdfUrl?: SortOrder
    qrCode?: SortOrderInput | SortOrder
    generatedAt?: SortOrder
    downloadedAt?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    organizationId?: SortOrder
    _count?: HallTicketCountOrderByAggregateInput
    _max?: HallTicketMaxOrderByAggregateInput
    _min?: HallTicketMinOrderByAggregateInput
  }

  export type HallTicketScalarWhereWithAggregatesInput = {
    AND?: HallTicketScalarWhereWithAggregatesInput | HallTicketScalarWhereWithAggregatesInput[]
    OR?: HallTicketScalarWhereWithAggregatesInput[]
    NOT?: HallTicketScalarWhereWithAggregatesInput | HallTicketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HallTicket"> | string
    studentId?: StringWithAggregatesFilter<"HallTicket"> | string
    examId?: StringNullableWithAggregatesFilter<"HallTicket"> | string | null
    examSessionId?: StringNullableWithAggregatesFilter<"HallTicket"> | string | null
    pdfUrl?: StringWithAggregatesFilter<"HallTicket"> | string
    qrCode?: StringNullableWithAggregatesFilter<"HallTicket"> | string | null
    generatedAt?: DateTimeWithAggregatesFilter<"HallTicket"> | Date | string
    downloadedAt?: DateTimeNullableWithAggregatesFilter<"HallTicket"> | Date | string | null
    expiryDate?: DateTimeNullableWithAggregatesFilter<"HallTicket"> | Date | string | null
    organizationId?: StringWithAggregatesFilter<"HallTicket"> | string
  }

  export type ReportCardWhereInput = {
    AND?: ReportCardWhereInput | ReportCardWhereInput[]
    OR?: ReportCardWhereInput[]
    NOT?: ReportCardWhereInput | ReportCardWhereInput[]
    id?: StringFilter<"ReportCard"> | string
    studentId?: StringFilter<"ReportCard"> | string
    examSessionId?: StringFilter<"ReportCard"> | string
    totalMaxMarks?: FloatFilter<"ReportCard"> | number
    totalObtained?: FloatFilter<"ReportCard"> | number
    percentage?: FloatFilter<"ReportCard"> | number
    cgpa?: FloatNullableFilter<"ReportCard"> | number | null
    overallGrade?: StringFilter<"ReportCard"> | string
    resultStatus?: EnumResultStatusFilter<"ReportCard"> | $Enums.ResultStatus
    classRank?: IntNullableFilter<"ReportCard"> | number | null
    gradeRank?: IntNullableFilter<"ReportCard"> | number | null
    attendancePercent?: FloatNullableFilter<"ReportCard"> | number | null
    conductGrade?: StringNullableFilter<"ReportCard"> | string | null
    remarks?: StringNullableFilter<"ReportCard"> | string | null
    principalRemarks?: StringNullableFilter<"ReportCard"> | string | null
    rank?: IntNullableFilter<"ReportCard"> | number | null
    pdfUrl?: StringNullableFilter<"ReportCard"> | string | null
    generatedAt?: DateTimeNullableFilter<"ReportCard"> | Date | string | null
    createdAt?: DateTimeFilter<"ReportCard"> | Date | string
    updatedAt?: DateTimeFilter<"ReportCard"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    examSession?: XOR<ExamSessionScalarRelationFilter, ExamSessionWhereInput>
  }

  export type ReportCardOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    examSessionId?: SortOrder
    totalMaxMarks?: SortOrder
    totalObtained?: SortOrder
    percentage?: SortOrder
    cgpa?: SortOrderInput | SortOrder
    overallGrade?: SortOrder
    resultStatus?: SortOrder
    classRank?: SortOrderInput | SortOrder
    gradeRank?: SortOrderInput | SortOrder
    attendancePercent?: SortOrderInput | SortOrder
    conductGrade?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    principalRemarks?: SortOrderInput | SortOrder
    rank?: SortOrderInput | SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    generatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    examSession?: ExamSessionOrderByWithRelationInput
    _relevance?: ReportCardOrderByRelevanceInput
  }

  export type ReportCardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_examSessionId?: ReportCardStudentIdExamSessionIdCompoundUniqueInput
    AND?: ReportCardWhereInput | ReportCardWhereInput[]
    OR?: ReportCardWhereInput[]
    NOT?: ReportCardWhereInput | ReportCardWhereInput[]
    studentId?: StringFilter<"ReportCard"> | string
    examSessionId?: StringFilter<"ReportCard"> | string
    totalMaxMarks?: FloatFilter<"ReportCard"> | number
    totalObtained?: FloatFilter<"ReportCard"> | number
    percentage?: FloatFilter<"ReportCard"> | number
    cgpa?: FloatNullableFilter<"ReportCard"> | number | null
    overallGrade?: StringFilter<"ReportCard"> | string
    resultStatus?: EnumResultStatusFilter<"ReportCard"> | $Enums.ResultStatus
    classRank?: IntNullableFilter<"ReportCard"> | number | null
    gradeRank?: IntNullableFilter<"ReportCard"> | number | null
    attendancePercent?: FloatNullableFilter<"ReportCard"> | number | null
    conductGrade?: StringNullableFilter<"ReportCard"> | string | null
    remarks?: StringNullableFilter<"ReportCard"> | string | null
    principalRemarks?: StringNullableFilter<"ReportCard"> | string | null
    rank?: IntNullableFilter<"ReportCard"> | number | null
    pdfUrl?: StringNullableFilter<"ReportCard"> | string | null
    generatedAt?: DateTimeNullableFilter<"ReportCard"> | Date | string | null
    createdAt?: DateTimeFilter<"ReportCard"> | Date | string
    updatedAt?: DateTimeFilter<"ReportCard"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    examSession?: XOR<ExamSessionScalarRelationFilter, ExamSessionWhereInput>
  }, "id" | "studentId_examSessionId">

  export type ReportCardOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    examSessionId?: SortOrder
    totalMaxMarks?: SortOrder
    totalObtained?: SortOrder
    percentage?: SortOrder
    cgpa?: SortOrderInput | SortOrder
    overallGrade?: SortOrder
    resultStatus?: SortOrder
    classRank?: SortOrderInput | SortOrder
    gradeRank?: SortOrderInput | SortOrder
    attendancePercent?: SortOrderInput | SortOrder
    conductGrade?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    principalRemarks?: SortOrderInput | SortOrder
    rank?: SortOrderInput | SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    generatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReportCardCountOrderByAggregateInput
    _avg?: ReportCardAvgOrderByAggregateInput
    _max?: ReportCardMaxOrderByAggregateInput
    _min?: ReportCardMinOrderByAggregateInput
    _sum?: ReportCardSumOrderByAggregateInput
  }

  export type ReportCardScalarWhereWithAggregatesInput = {
    AND?: ReportCardScalarWhereWithAggregatesInput | ReportCardScalarWhereWithAggregatesInput[]
    OR?: ReportCardScalarWhereWithAggregatesInput[]
    NOT?: ReportCardScalarWhereWithAggregatesInput | ReportCardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReportCard"> | string
    studentId?: StringWithAggregatesFilter<"ReportCard"> | string
    examSessionId?: StringWithAggregatesFilter<"ReportCard"> | string
    totalMaxMarks?: FloatWithAggregatesFilter<"ReportCard"> | number
    totalObtained?: FloatWithAggregatesFilter<"ReportCard"> | number
    percentage?: FloatWithAggregatesFilter<"ReportCard"> | number
    cgpa?: FloatNullableWithAggregatesFilter<"ReportCard"> | number | null
    overallGrade?: StringWithAggregatesFilter<"ReportCard"> | string
    resultStatus?: EnumResultStatusWithAggregatesFilter<"ReportCard"> | $Enums.ResultStatus
    classRank?: IntNullableWithAggregatesFilter<"ReportCard"> | number | null
    gradeRank?: IntNullableWithAggregatesFilter<"ReportCard"> | number | null
    attendancePercent?: FloatNullableWithAggregatesFilter<"ReportCard"> | number | null
    conductGrade?: StringNullableWithAggregatesFilter<"ReportCard"> | string | null
    remarks?: StringNullableWithAggregatesFilter<"ReportCard"> | string | null
    principalRemarks?: StringNullableWithAggregatesFilter<"ReportCard"> | string | null
    rank?: IntNullableWithAggregatesFilter<"ReportCard"> | number | null
    pdfUrl?: StringNullableWithAggregatesFilter<"ReportCard"> | string | null
    generatedAt?: DateTimeNullableWithAggregatesFilter<"ReportCard"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ReportCard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReportCard"> | Date | string
  }

  export type AcademicYearCreateInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    type?: $Enums.YearType
    isCurrent?: boolean
    description?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutAcademicYearInput
    complaints?: AnonymousComplaintCreateNestedManyWithoutAcademicYearInput
    notices?: NoticeCreateNestedManyWithoutAcademicYearInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutAcademicYearInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutAcademicYearInput
    AcademicCalendar?: AcademicCalendarCreateNestedManyWithoutAcademicYearInput
    ExamSession?: ExamSessionCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearUncheckedCreateInput = {
    id?: string
    organizationId: string
    name: string
    startDate: Date | string
    endDate: Date | string
    type?: $Enums.YearType
    isCurrent?: boolean
    description?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    complaints?: AnonymousComplaintUncheckedCreateNestedManyWithoutAcademicYearInput
    notices?: NoticeUncheckedCreateNestedManyWithoutAcademicYearInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutAcademicYearInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutAcademicYearInput
    AcademicCalendar?: AcademicCalendarUncheckedCreateNestedManyWithoutAcademicYearInput
    ExamSession?: ExamSessionUncheckedCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumYearTypeFieldUpdateOperationsInput | $Enums.YearType
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutAcademicYearNestedInput
    complaints?: AnonymousComplaintUpdateManyWithoutAcademicYearNestedInput
    notices?: NoticeUpdateManyWithoutAcademicYearNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutAcademicYearNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutAcademicYearNestedInput
    AcademicCalendar?: AcademicCalendarUpdateManyWithoutAcademicYearNestedInput
    ExamSession?: ExamSessionUpdateManyWithoutAcademicYearNestedInput
  }

  export type AcademicYearUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumYearTypeFieldUpdateOperationsInput | $Enums.YearType
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    complaints?: AnonymousComplaintUncheckedUpdateManyWithoutAcademicYearNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutAcademicYearNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutAcademicYearNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutAcademicYearNestedInput
    AcademicCalendar?: AcademicCalendarUncheckedUpdateManyWithoutAcademicYearNestedInput
    ExamSession?: ExamSessionUncheckedUpdateManyWithoutAcademicYearNestedInput
  }

  export type AcademicYearCreateManyInput = {
    id?: string
    organizationId: string
    name: string
    startDate: Date | string
    endDate: Date | string
    type?: $Enums.YearType
    isCurrent?: boolean
    description?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicYearUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumYearTypeFieldUpdateOperationsInput | $Enums.YearType
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicYearUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumYearTypeFieldUpdateOperationsInput | $Enums.YearType
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    notices?: NoticeCreateNestedManyWithoutOrganizationInput
    Student?: StudentCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentCreateNestedManyWithoutOrganizationInput
    Grade?: GradeCreateNestedManyWithoutOrganizationInput
    Section?: SectionCreateNestedManyWithoutOrganizationInput
    Fee?: FeeCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobCreateNestedManyWithoutOrganizationInput
    Exam?: ExamCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    notices?: NoticeUncheckedCreateNestedManyWithoutOrganizationInput
    Student?: StudentUncheckedCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutOrganizationInput
    Grade?: GradeUncheckedCreateNestedManyWithoutOrganizationInput
    Section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    Fee?: FeeUncheckedCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryUncheckedCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarUncheckedCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintUncheckedCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherUncheckedCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectUncheckedCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearUncheckedCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobUncheckedCreateNestedManyWithoutOrganizationInput
    Exam?: ExamUncheckedCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUncheckedUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUncheckedUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUncheckedUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUncheckedUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUncheckedUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUncheckedUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUncheckedUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUncheckedUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUncheckedUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password?: string | null
    profileImage: string
    role?: $Enums.Role
    clerkId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    parent?: ParentCreateNestedOneWithoutUserInput
    FeePayment?: FeePaymentCreateNestedManyWithoutPayerInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password?: string | null
    profileImage: string
    role?: $Enums.Role
    clerkId: string
    isActive?: boolean
    organizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    parent?: ParentUncheckedCreateNestedOneWithoutUserInput
    FeePayment?: FeePaymentUncheckedCreateNestedManyWithoutPayerInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    clerkId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    parent?: ParentUpdateOneWithoutUserNestedInput
    FeePayment?: FeePaymentUpdateManyWithoutPayerNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    clerkId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    parent?: ParentUncheckedUpdateOneWithoutUserNestedInput
    FeePayment?: FeePaymentUncheckedUpdateManyWithoutPayerNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password?: string | null
    profileImage: string
    role?: $Enums.Role
    clerkId: string
    isActive?: boolean
    organizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    clerkId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    clerkId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeCreateInput = {
    id?: string
    grade: string
    organization: OrganizationCreateNestedOneWithoutGradeInput
    students?: StudentCreateNestedManyWithoutGradeInput
    section?: SectionCreateNestedManyWithoutGradeInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutGradeInput
  }

  export type GradeUncheckedCreateInput = {
    id?: string
    grade: string
    organizationId: string
    students?: StudentUncheckedCreateNestedManyWithoutGradeInput
    section?: SectionUncheckedCreateNestedManyWithoutGradeInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutGradeInput
  }

  export type GradeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    organization?: OrganizationUpdateOneRequiredWithoutGradeNestedInput
    students?: StudentUpdateManyWithoutGradeNestedInput
    section?: SectionUpdateManyWithoutGradeNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutGradeNestedInput
  }

  export type GradeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    students?: StudentUncheckedUpdateManyWithoutGradeNestedInput
    section?: SectionUncheckedUpdateManyWithoutGradeNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutGradeNestedInput
  }

  export type GradeCreateManyInput = {
    id?: string
    grade: string
    organizationId: string
  }

  export type GradeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
  }

  export type GradeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type SectionCreateInput = {
    id?: string
    name: string
    grade: GradeCreateNestedOneWithoutSectionInput
    organization: OrganizationCreateNestedOneWithoutSectionInput
    classTeacher?: TeacherCreateNestedOneWithoutSectionInput
    students?: StudentCreateNestedManyWithoutSectionInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutSectionInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateInput = {
    id?: string
    name: string
    gradeId: string
    organizationId: string
    classTeacherId?: string | null
    students?: StudentUncheckedCreateNestedManyWithoutSectionInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutSectionInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    grade?: GradeUpdateOneRequiredWithoutSectionNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutSectionNestedInput
    classTeacher?: TeacherUpdateOneWithoutSectionNestedInput
    students?: StudentUpdateManyWithoutSectionNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutSectionNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    classTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    students?: StudentUncheckedUpdateManyWithoutSectionNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutSectionNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type SectionCreateManyInput = {
    id?: string
    name: string
    gradeId: string
    organizationId: string
    classTeacherId?: string | null
  }

  export type SectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    classTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeacherCreateInput = {
    id?: string
    employeeCode?: string | null
    employmentStatus?: $Enums.EmploymentStatus
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTeacherInput
    organization: OrganizationCreateNestedOneWithoutTeacherInput
    profile?: TeacherProfileCreateNestedOneWithoutTeacherInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutTeacherInput
    Section?: SectionCreateNestedManyWithoutClassTeacherInput
  }

  export type TeacherUncheckedCreateInput = {
    id?: string
    userId: string
    employeeCode?: string | null
    employmentStatus?: $Enums.EmploymentStatus
    isActive?: boolean
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: TeacherProfileUncheckedCreateNestedOneWithoutTeacherInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutTeacherInput
    Section?: SectionUncheckedCreateNestedManyWithoutClassTeacherInput
  }

  export type TeacherUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutTeacherNestedInput
    profile?: TeacherProfileUpdateOneWithoutTeacherNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutTeacherNestedInput
    Section?: SectionUpdateManyWithoutClassTeacherNestedInput
  }

  export type TeacherUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: TeacherProfileUncheckedUpdateOneWithoutTeacherNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    Section?: SectionUncheckedUpdateManyWithoutClassTeacherNestedInput
  }

  export type TeacherCreateManyInput = {
    id?: string
    userId: string
    employeeCode?: string | null
    employmentStatus?: $Enums.EmploymentStatus
    isActive?: boolean
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherProfileCreateInput = {
    id?: string
    contactEmail: string
    contactPhone: string
    address: string
    city?: string | null
    state?: string | null
    dateOfBirth: Date | string
    qualification: string
    experienceInYears: number
    resumeUrl?: string | null
    joinedAt: Date | string
    bio?: string | null
    teachingPhilosophy?: string | null
    specializedSubjects?: TeacherProfileCreatespecializedSubjectsInput | string[]
    preferredGrades?: TeacherProfileCreatepreferredGradesInput | string[]
    idProofUrl: string
    linkedinPortfolio?: string | null
    languagesKnown?: TeacherProfileCreatelanguagesKnownInput | string[]
    certificateUrls?: TeacherProfileCreatecertificateUrlsInput | string[]
    teacher: TeacherCreateNestedOneWithoutProfileInput
  }

  export type TeacherProfileUncheckedCreateInput = {
    id?: string
    teacherId: string
    contactEmail: string
    contactPhone: string
    address: string
    city?: string | null
    state?: string | null
    dateOfBirth: Date | string
    qualification: string
    experienceInYears: number
    resumeUrl?: string | null
    joinedAt: Date | string
    bio?: string | null
    teachingPhilosophy?: string | null
    specializedSubjects?: TeacherProfileCreatespecializedSubjectsInput | string[]
    preferredGrades?: TeacherProfileCreatepreferredGradesInput | string[]
    idProofUrl: string
    linkedinPortfolio?: string | null
    languagesKnown?: TeacherProfileCreatelanguagesKnownInput | string[]
    certificateUrls?: TeacherProfileCreatecertificateUrlsInput | string[]
  }

  export type TeacherProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    qualification?: StringFieldUpdateOperationsInput | string
    experienceInYears?: IntFieldUpdateOperationsInput | number
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    teachingPhilosophy?: NullableStringFieldUpdateOperationsInput | string | null
    specializedSubjects?: TeacherProfileUpdatespecializedSubjectsInput | string[]
    preferredGrades?: TeacherProfileUpdatepreferredGradesInput | string[]
    idProofUrl?: StringFieldUpdateOperationsInput | string
    linkedinPortfolio?: NullableStringFieldUpdateOperationsInput | string | null
    languagesKnown?: TeacherProfileUpdatelanguagesKnownInput | string[]
    certificateUrls?: TeacherProfileUpdatecertificateUrlsInput | string[]
    teacher?: TeacherUpdateOneRequiredWithoutProfileNestedInput
  }

  export type TeacherProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    qualification?: StringFieldUpdateOperationsInput | string
    experienceInYears?: IntFieldUpdateOperationsInput | number
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    teachingPhilosophy?: NullableStringFieldUpdateOperationsInput | string | null
    specializedSubjects?: TeacherProfileUpdatespecializedSubjectsInput | string[]
    preferredGrades?: TeacherProfileUpdatepreferredGradesInput | string[]
    idProofUrl?: StringFieldUpdateOperationsInput | string
    linkedinPortfolio?: NullableStringFieldUpdateOperationsInput | string | null
    languagesKnown?: TeacherProfileUpdatelanguagesKnownInput | string[]
    certificateUrls?: TeacherProfileUpdatecertificateUrlsInput | string[]
  }

  export type TeacherProfileCreateManyInput = {
    id?: string
    teacherId: string
    contactEmail: string
    contactPhone: string
    address: string
    city?: string | null
    state?: string | null
    dateOfBirth: Date | string
    qualification: string
    experienceInYears: number
    resumeUrl?: string | null
    joinedAt: Date | string
    bio?: string | null
    teachingPhilosophy?: string | null
    specializedSubjects?: TeacherProfileCreatespecializedSubjectsInput | string[]
    preferredGrades?: TeacherProfileCreatepreferredGradesInput | string[]
    idProofUrl: string
    linkedinPortfolio?: string | null
    languagesKnown?: TeacherProfileCreatelanguagesKnownInput | string[]
    certificateUrls?: TeacherProfileCreatecertificateUrlsInput | string[]
  }

  export type TeacherProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    qualification?: StringFieldUpdateOperationsInput | string
    experienceInYears?: IntFieldUpdateOperationsInput | number
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    teachingPhilosophy?: NullableStringFieldUpdateOperationsInput | string | null
    specializedSubjects?: TeacherProfileUpdatespecializedSubjectsInput | string[]
    preferredGrades?: TeacherProfileUpdatepreferredGradesInput | string[]
    idProofUrl?: StringFieldUpdateOperationsInput | string
    linkedinPortfolio?: NullableStringFieldUpdateOperationsInput | string | null
    languagesKnown?: TeacherProfileUpdatelanguagesKnownInput | string[]
    certificateUrls?: TeacherProfileUpdatecertificateUrlsInput | string[]
  }

  export type TeacherProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    qualification?: StringFieldUpdateOperationsInput | string
    experienceInYears?: IntFieldUpdateOperationsInput | number
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    teachingPhilosophy?: NullableStringFieldUpdateOperationsInput | string | null
    specializedSubjects?: TeacherProfileUpdatespecializedSubjectsInput | string[]
    preferredGrades?: TeacherProfileUpdatepreferredGradesInput | string[]
    idProofUrl?: StringFieldUpdateOperationsInput | string
    linkedinPortfolio?: NullableStringFieldUpdateOperationsInput | string | null
    languagesKnown?: TeacherProfileUpdatelanguagesKnownInput | string[]
    certificateUrls?: TeacherProfileUpdatecertificateUrlsInput | string[]
  }

  export type SubjectCreateInput = {
    id?: string
    name: string
    code: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutSubjectInput
    teachingAssignments?: TeachingAssignmentCreateNestedManyWithoutSubjectInput
    exam?: ExamCreateNestedManyWithoutSubjectInput
    examResult?: ExamResultCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    description: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teachingAssignments?: TeachingAssignmentUncheckedCreateNestedManyWithoutSubjectInput
    exam?: ExamUncheckedCreateNestedManyWithoutSubjectInput
    examResult?: ExamResultUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutSubjectNestedInput
    teachingAssignments?: TeachingAssignmentUpdateManyWithoutSubjectNestedInput
    exam?: ExamUpdateManyWithoutSubjectNestedInput
    examResult?: ExamResultUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teachingAssignments?: TeachingAssignmentUncheckedUpdateManyWithoutSubjectNestedInput
    exam?: ExamUncheckedUpdateManyWithoutSubjectNestedInput
    examResult?: ExamResultUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectCreateManyInput = {
    id?: string
    name: string
    code: string
    description: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeachingAssignmentCreateInput = {
    id?: string
    academicYear?: string | null
    status?: $Enums.AssignmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: TeacherCreateNestedOneWithoutTeachingAssignmentInput
    subject: SubjectCreateNestedOneWithoutTeachingAssignmentsInput
    grade: GradeCreateNestedOneWithoutTeachingAssignmentInput
    section: SectionCreateNestedOneWithoutTeachingAssignmentInput
    organization: OrganizationCreateNestedOneWithoutTeachingAssignmentInput
    AcademicYear?: AcademicYearCreateNestedOneWithoutTeachingAssignmentInput
  }

  export type TeachingAssignmentUncheckedCreateInput = {
    id?: string
    teacherId: string
    subjectId: string
    gradeId: string
    sectionId: string
    organizationId: string
    academicYear?: string | null
    status?: $Enums.AssignmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    academicYearId?: string | null
  }

  export type TeachingAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneRequiredWithoutTeachingAssignmentNestedInput
    subject?: SubjectUpdateOneRequiredWithoutTeachingAssignmentsNestedInput
    grade?: GradeUpdateOneRequiredWithoutTeachingAssignmentNestedInput
    section?: SectionUpdateOneRequiredWithoutTeachingAssignmentNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutTeachingAssignmentNestedInput
    AcademicYear?: AcademicYearUpdateOneWithoutTeachingAssignmentNestedInput
  }

  export type TeachingAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeachingAssignmentCreateManyInput = {
    id?: string
    teacherId: string
    subjectId: string
    gradeId: string
    sectionId: string
    organizationId: string
    academicYear?: string | null
    status?: $Enums.AssignmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    academicYearId?: string | null
  }

  export type TeachingAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeachingAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentCreateInput = {
    id?: string
    firstName: string
    lastName: string
    middleName?: string | null
    motherName?: string | null
    fullName?: string | null
    dateOfBirth: Date | string
    profileImage?: string | null
    rollNumber: string
    phoneNumber: string
    whatsAppNumber: string
    email: string
    emergencyContact: string
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    section: SectionCreateNestedOneWithoutStudentsInput
    grade: GradeCreateNestedOneWithoutStudentsInput
    organization: OrganizationCreateNestedOneWithoutStudentInput
    Fee?: FeeCreateNestedManyWithoutStudentInput
    parents?: ParentStudentCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutStudentInput
    StudentDocument?: StudentDocumentCreateNestedManyWithoutStudentInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutStudentInput
    reportCard?: ReportCardCreateNestedManyWithoutStudentInput
    hallTicket?: HallTicketCreateNestedManyWithoutStudentInput
    examResult?: ExamResultCreateNestedManyWithoutStudentInput
    examEnrollment?: ExamEnrollmentCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    middleName?: string | null
    motherName?: string | null
    fullName?: string | null
    dateOfBirth: Date | string
    profileImage?: string | null
    rollNumber: string
    phoneNumber: string
    whatsAppNumber: string
    email: string
    emergencyContact: string
    gender: $Enums.Gender
    sectionId: string
    gradeId: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Fee?: FeeUncheckedCreateNestedManyWithoutStudentInput
    parents?: ParentStudentUncheckedCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutStudentInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutStudentInput
    reportCard?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
    hallTicket?: HallTicketUncheckedCreateNestedManyWithoutStudentInput
    examResult?: ExamResultUncheckedCreateNestedManyWithoutStudentInput
    examEnrollment?: ExamEnrollmentUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emergencyContact?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    section?: SectionUpdateOneRequiredWithoutStudentsNestedInput
    grade?: GradeUpdateOneRequiredWithoutStudentsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutStudentNestedInput
    Fee?: FeeUpdateManyWithoutStudentNestedInput
    parents?: ParentStudentUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    StudentDocument?: StudentDocumentUpdateManyWithoutStudentNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutStudentNestedInput
    reportCard?: ReportCardUpdateManyWithoutStudentNestedInput
    hallTicket?: HallTicketUpdateManyWithoutStudentNestedInput
    examResult?: ExamResultUpdateManyWithoutStudentNestedInput
    examEnrollment?: ExamEnrollmentUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emergencyContact?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    sectionId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Fee?: FeeUncheckedUpdateManyWithoutStudentNestedInput
    parents?: ParentStudentUncheckedUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutStudentNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutStudentNestedInput
    reportCard?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
    hallTicket?: HallTicketUncheckedUpdateManyWithoutStudentNestedInput
    examResult?: ExamResultUncheckedUpdateManyWithoutStudentNestedInput
    examEnrollment?: ExamEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateManyInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    middleName?: string | null
    motherName?: string | null
    fullName?: string | null
    dateOfBirth: Date | string
    profileImage?: string | null
    rollNumber: string
    phoneNumber: string
    whatsAppNumber: string
    email: string
    emergencyContact: string
    gender: $Enums.Gender
    sectionId: string
    gradeId: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emergencyContact?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emergencyContact?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    sectionId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phoneNumber: string
    whatsAppNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutParentInput
    students?: ParentStudentCreateNestedManyWithoutParentInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutParentInput
  }

  export type ParentUncheckedCreateInput = {
    id?: string
    userId?: string | null
    firstName: string
    lastName: string
    email: string
    phoneNumber: string
    whatsAppNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: ParentStudentUncheckedCreateNestedManyWithoutParentInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutParentInput
  }

  export type ParentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutParentNestedInput
    students?: ParentStudentUpdateManyWithoutParentNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutParentNestedInput
  }

  export type ParentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: ParentStudentUncheckedUpdateManyWithoutParentNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ParentCreateManyInput = {
    id?: string
    userId?: string | null
    firstName: string
    lastName: string
    email: string
    phoneNumber: string
    whatsAppNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentStudentCreateInput = {
    id?: string
    relationship: string
    isPrimary?: boolean | null
    student: StudentCreateNestedOneWithoutParentsInput
    parent: ParentCreateNestedOneWithoutStudentsInput
  }

  export type ParentStudentUncheckedCreateInput = {
    id?: string
    relationship: string
    studentId: string
    parentId: string
    isPrimary?: boolean | null
  }

  export type ParentStudentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    isPrimary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    student?: StudentUpdateOneRequiredWithoutParentsNestedInput
    parent?: ParentUpdateOneRequiredWithoutStudentsNestedInput
  }

  export type ParentStudentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    isPrimary?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ParentStudentCreateManyInput = {
    id?: string
    relationship: string
    studentId: string
    parentId: string
    isPrimary?: boolean | null
  }

  export type ParentStudentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    isPrimary?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ParentStudentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    isPrimary?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type StudentAttendanceCreateInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    note?: string | null
    recordedBy: string
    present?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    section: SectionCreateNestedOneWithoutStudentAttendanceInput
    student: StudentCreateNestedOneWithoutStudentAttendanceInput
    academicYear?: AcademicYearCreateNestedOneWithoutStudentAttendanceInput
  }

  export type StudentAttendanceUncheckedCreateInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    note?: string | null
    recordedBy: string
    studentId: string
    present?: boolean
    sectionId: string
    academicYearId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAttendanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    present?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    section?: SectionUpdateOneRequiredWithoutStudentAttendanceNestedInput
    student?: StudentUpdateOneRequiredWithoutStudentAttendanceNestedInput
    academicYear?: AcademicYearUpdateOneWithoutStudentAttendanceNestedInput
  }

  export type StudentAttendanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    present?: BoolFieldUpdateOperationsInput | boolean
    sectionId?: StringFieldUpdateOperationsInput | string
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceCreateManyInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    note?: string | null
    recordedBy: string
    studentId: string
    present?: boolean
    sectionId: string
    academicYearId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAttendanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    present?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    present?: BoolFieldUpdateOperationsInput | boolean
    sectionId?: StringFieldUpdateOperationsInput | string
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentDocumentCreateInput = {
    id?: string
    type: $Enums.DocumentType
    fileName?: string | null
    fileSize?: number | null
    fileType?: string | null
    documentUrl: string
    verified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    rejected?: boolean
    rejectedBy?: string | null
    rejectedAt?: Date | string | null
    rejectReason?: string | null
    uploadedBy?: string | null
    uploadedAt?: Date | string
    note?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentDocumentInput
    Organization?: OrganizationCreateNestedOneWithoutStudentDocumentInput
  }

  export type StudentDocumentUncheckedCreateInput = {
    id?: string
    type: $Enums.DocumentType
    fileName?: string | null
    fileSize?: number | null
    fileType?: string | null
    documentUrl: string
    studentId: string
    verified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    rejected?: boolean
    rejectedBy?: string | null
    rejectedAt?: Date | string | null
    rejectReason?: string | null
    uploadedBy?: string | null
    uploadedAt?: Date | string
    note?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId: string
  }

  export type StudentDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected?: BoolFieldUpdateOperationsInput | boolean
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentDocumentNestedInput
    Organization?: OrganizationUpdateOneWithoutStudentDocumentNestedInput
  }

  export type StudentDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected?: BoolFieldUpdateOperationsInput | boolean
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentDocumentCreateManyInput = {
    id?: string
    type: $Enums.DocumentType
    fileName?: string | null
    fileSize?: number | null
    fileType?: string | null
    documentUrl: string
    studentId: string
    verified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    rejected?: boolean
    rejectedBy?: string | null
    rejectedAt?: Date | string | null
    rejectReason?: string | null
    uploadedBy?: string | null
    uploadedAt?: Date | string
    note?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId: string
  }

  export type StudentDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected?: BoolFieldUpdateOperationsInput | boolean
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected?: BoolFieldUpdateOperationsInput | boolean
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type FeeCreateInput = {
    id?: string
    totalFee: number
    paidAmount?: number
    pendingAmount?: number | null
    dueDate: Date | string
    status?: $Enums.FeeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutFeeInput
    feeCategory: FeeCategoryCreateNestedOneWithoutFeesInput
    Organization: OrganizationCreateNestedOneWithoutFeeInput
    payments?: FeePaymentCreateNestedManyWithoutFeeInput
  }

  export type FeeUncheckedCreateInput = {
    id?: string
    totalFee: number
    paidAmount?: number
    pendingAmount?: number | null
    dueDate: Date | string
    status?: $Enums.FeeStatus
    studentId: string
    feeCategoryId: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: FeePaymentUncheckedCreateNestedManyWithoutFeeInput
  }

  export type FeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalFee?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFeeStatusFieldUpdateOperationsInput | $Enums.FeeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutFeeNestedInput
    feeCategory?: FeeCategoryUpdateOneRequiredWithoutFeesNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutFeeNestedInput
    payments?: FeePaymentUpdateManyWithoutFeeNestedInput
  }

  export type FeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalFee?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFeeStatusFieldUpdateOperationsInput | $Enums.FeeStatus
    studentId?: StringFieldUpdateOperationsInput | string
    feeCategoryId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: FeePaymentUncheckedUpdateManyWithoutFeeNestedInput
  }

  export type FeeCreateManyInput = {
    id?: string
    totalFee: number
    paidAmount?: number
    pendingAmount?: number | null
    dueDate: Date | string
    status?: $Enums.FeeStatus
    studentId: string
    feeCategoryId: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalFee?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFeeStatusFieldUpdateOperationsInput | $Enums.FeeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalFee?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFeeStatusFieldUpdateOperationsInput | $Enums.FeeStatus
    studentId?: StringFieldUpdateOperationsInput | string
    feeCategoryId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeePaymentCreateInput = {
    id?: string
    amount: number
    status?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    receiptNumber: string
    note?: string | null
    transactionId?: string | null
    platformFee?: number | null
    recordedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fee: FeeCreateNestedOneWithoutPaymentsInput
    payer: UserCreateNestedOneWithoutFeePaymentInput
    organization: OrganizationCreateNestedOneWithoutFeePaymentInput
  }

  export type FeePaymentUncheckedCreateInput = {
    id?: string
    feeId: string
    amount: number
    status?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    receiptNumber: string
    note?: string | null
    transactionId?: string | null
    payerId: string
    platformFee?: number | null
    recordedBy?: string | null
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeePaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fee?: FeeUpdateOneRequiredWithoutPaymentsNestedInput
    payer?: UserUpdateOneRequiredWithoutFeePaymentNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutFeePaymentNestedInput
  }

  export type FeePaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    feeId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    payerId?: StringFieldUpdateOperationsInput | string
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeePaymentCreateManyInput = {
    id?: string
    feeId: string
    amount: number
    status?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    receiptNumber: string
    note?: string | null
    transactionId?: string | null
    payerId: string
    platformFee?: number | null
    recordedBy?: string | null
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeePaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeePaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    feeId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    payerId?: StringFieldUpdateOperationsInput | string
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledJobCreateInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    type: $Enums.scheduledJobType
    scheduledAt: Date | string
    channels?: ScheduledJobCreatechannelsInput | $Enums.NotificationChannel[]
    status?: string
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutScheduledJobInput
  }

  export type ScheduledJobUncheckedCreateInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    type: $Enums.scheduledJobType
    scheduledAt: Date | string
    channels?: ScheduledJobCreatechannelsInput | $Enums.NotificationChannel[]
    status?: string
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId: string
  }

  export type ScheduledJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    type?: EnumscheduledJobTypeFieldUpdateOperationsInput | $Enums.scheduledJobType
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channels?: ScheduledJobUpdatechannelsInput | $Enums.NotificationChannel[]
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutScheduledJobNestedInput
  }

  export type ScheduledJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    type?: EnumscheduledJobTypeFieldUpdateOperationsInput | $Enums.scheduledJobType
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channels?: ScheduledJobUpdatechannelsInput | $Enums.NotificationChannel[]
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type ScheduledJobCreateManyInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    type: $Enums.scheduledJobType
    scheduledAt: Date | string
    channels?: ScheduledJobCreatechannelsInput | $Enums.NotificationChannel[]
    status?: string
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId: string
  }

  export type ScheduledJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    type?: EnumscheduledJobTypeFieldUpdateOperationsInput | $Enums.scheduledJobType
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channels?: ScheduledJobUpdatechannelsInput | $Enums.NotificationChannel[]
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    type?: EnumscheduledJobTypeFieldUpdateOperationsInput | $Enums.scheduledJobType
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channels?: ScheduledJobUpdatechannelsInput | $Enums.NotificationChannel[]
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type FeeCategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fees?: FeeCreateNestedManyWithoutFeeCategoryInput
    Organization: OrganizationCreateNestedOneWithoutFeeCategoryInput
  }

  export type FeeCategoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId: string
    fees?: FeeUncheckedCreateNestedManyWithoutFeeCategoryInput
  }

  export type FeeCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fees?: FeeUpdateManyWithoutFeeCategoryNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutFeeCategoryNestedInput
  }

  export type FeeCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
    fees?: FeeUncheckedUpdateManyWithoutFeeCategoryNestedInput
  }

  export type FeeCategoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId: string
  }

  export type FeeCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type AcademicCalendarCreateInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    type: $Enums.CalendarEventType
    reason?: string | null
    isRecurring?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutAcademicCalendarInput
    academicYear?: AcademicYearCreateNestedOneWithoutAcademicCalendarInput
  }

  export type AcademicCalendarUncheckedCreateInput = {
    id?: string
    organizationId: string
    name: string
    startDate: Date | string
    endDate: Date | string
    type: $Enums.CalendarEventType
    reason?: string | null
    isRecurring?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicYearId?: string | null
  }

  export type AcademicCalendarUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCalendarEventTypeFieldUpdateOperationsInput | $Enums.CalendarEventType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutAcademicCalendarNestedInput
    academicYear?: AcademicYearUpdateOneWithoutAcademicCalendarNestedInput
  }

  export type AcademicCalendarUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCalendarEventTypeFieldUpdateOperationsInput | $Enums.CalendarEventType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AcademicCalendarCreateManyInput = {
    id?: string
    organizationId: string
    name: string
    startDate: Date | string
    endDate: Date | string
    type: $Enums.CalendarEventType
    reason?: string | null
    isRecurring?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicYearId?: string | null
  }

  export type AcademicCalendarUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCalendarEventTypeFieldUpdateOperationsInput | $Enums.CalendarEventType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicCalendarUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCalendarEventTypeFieldUpdateOperationsInput | $Enums.CalendarEventType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnonymousComplaintCreateInput = {
    id?: string
    trackingId: string
    category: string
    severity?: $Enums.Severity
    subject: string
    description: string
    evidenceUrls?: AnonymousComplaintCreateevidenceUrlsInput | string[]
    submittedAt?: Date | string
    currentStatus?: $Enums.ComplaintStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutAnonymousComplaintInput
    ComplaintStatusTimeline?: ComplaintStatusTimelineCreateNestedManyWithoutComplaintInput
    academicYear?: AcademicYearCreateNestedOneWithoutComplaintsInput
  }

  export type AnonymousComplaintUncheckedCreateInput = {
    id?: string
    trackingId: string
    category: string
    severity?: $Enums.Severity
    subject: string
    description: string
    evidenceUrls?: AnonymousComplaintCreateevidenceUrlsInput | string[]
    submittedAt?: Date | string
    currentStatus?: $Enums.ComplaintStatus
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicYearId?: string | null
    ComplaintStatusTimeline?: ComplaintStatusTimelineUncheckedCreateNestedManyWithoutComplaintInput
  }

  export type AnonymousComplaintUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    evidenceUrls?: AnonymousComplaintUpdateevidenceUrlsInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentStatus?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutAnonymousComplaintNestedInput
    ComplaintStatusTimeline?: ComplaintStatusTimelineUpdateManyWithoutComplaintNestedInput
    academicYear?: AcademicYearUpdateOneWithoutComplaintsNestedInput
  }

  export type AnonymousComplaintUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    evidenceUrls?: AnonymousComplaintUpdateevidenceUrlsInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentStatus?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null
    ComplaintStatusTimeline?: ComplaintStatusTimelineUncheckedUpdateManyWithoutComplaintNestedInput
  }

  export type AnonymousComplaintCreateManyInput = {
    id?: string
    trackingId: string
    category: string
    severity?: $Enums.Severity
    subject: string
    description: string
    evidenceUrls?: AnonymousComplaintCreateevidenceUrlsInput | string[]
    submittedAt?: Date | string
    currentStatus?: $Enums.ComplaintStatus
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicYearId?: string | null
  }

  export type AnonymousComplaintUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    evidenceUrls?: AnonymousComplaintUpdateevidenceUrlsInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentStatus?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnonymousComplaintUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    evidenceUrls?: AnonymousComplaintUpdateevidenceUrlsInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentStatus?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ComplaintStatusTimelineCreateInput = {
    id?: string
    note?: string | null
    status?: $Enums.ComplaintStatus
    changedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    complaint: AnonymousComplaintCreateNestedOneWithoutComplaintStatusTimelineInput
  }

  export type ComplaintStatusTimelineUncheckedCreateInput = {
    id?: string
    complaintId: string
    note?: string | null
    status?: $Enums.ComplaintStatus
    changedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplaintStatusTimelineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    complaint?: AnonymousComplaintUpdateOneRequiredWithoutComplaintStatusTimelineNestedInput
  }

  export type ComplaintStatusTimelineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    complaintId?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintStatusTimelineCreateManyInput = {
    id?: string
    complaintId: string
    note?: string | null
    status?: $Enums.ComplaintStatus
    changedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplaintStatusTimelineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintStatusTimelineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    complaintId?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoticeCreateInput = {
    id?: string
    noticeType: string
    title: string
    startDate: Date | string
    endDate: Date | string
    content: string
    summary?: string | null
    isNoticeApproved?: boolean
    isDraft?: boolean
    isPublished?: boolean
    emailNotification?: boolean
    pushNotification?: boolean
    WhatsAppNotification?: boolean
    smsNotification?: boolean
    targetAudience?: NoticeCreatetargetAudienceInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    publishedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Organization: OrganizationCreateNestedOneWithoutNoticesInput
    academicYear?: AcademicYearCreateNestedOneWithoutNoticesInput
  }

  export type NoticeUncheckedCreateInput = {
    id?: string
    noticeType: string
    title: string
    startDate: Date | string
    endDate: Date | string
    content: string
    summary?: string | null
    isNoticeApproved?: boolean
    isDraft?: boolean
    isPublished?: boolean
    emailNotification?: boolean
    pushNotification?: boolean
    WhatsAppNotification?: boolean
    smsNotification?: boolean
    targetAudience?: NoticeCreatetargetAudienceInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    publishedBy: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicYearId?: string | null
  }

  export type NoticeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    noticeType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isNoticeApproved?: BoolFieldUpdateOperationsInput | boolean
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    emailNotification?: BoolFieldUpdateOperationsInput | boolean
    pushNotification?: BoolFieldUpdateOperationsInput | boolean
    WhatsAppNotification?: BoolFieldUpdateOperationsInput | boolean
    smsNotification?: BoolFieldUpdateOperationsInput | boolean
    targetAudience?: NoticeUpdatetargetAudienceInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    publishedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Organization?: OrganizationUpdateOneRequiredWithoutNoticesNestedInput
    academicYear?: AcademicYearUpdateOneWithoutNoticesNestedInput
  }

  export type NoticeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    noticeType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isNoticeApproved?: BoolFieldUpdateOperationsInput | boolean
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    emailNotification?: BoolFieldUpdateOperationsInput | boolean
    pushNotification?: BoolFieldUpdateOperationsInput | boolean
    WhatsAppNotification?: BoolFieldUpdateOperationsInput | boolean
    smsNotification?: BoolFieldUpdateOperationsInput | boolean
    targetAudience?: NoticeUpdatetargetAudienceInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    publishedBy?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NoticeCreateManyInput = {
    id?: string
    noticeType: string
    title: string
    startDate: Date | string
    endDate: Date | string
    content: string
    summary?: string | null
    isNoticeApproved?: boolean
    isDraft?: boolean
    isPublished?: boolean
    emailNotification?: boolean
    pushNotification?: boolean
    WhatsAppNotification?: boolean
    smsNotification?: boolean
    targetAudience?: NoticeCreatetargetAudienceInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    publishedBy: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicYearId?: string | null
  }

  export type NoticeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    noticeType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isNoticeApproved?: BoolFieldUpdateOperationsInput | boolean
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    emailNotification?: BoolFieldUpdateOperationsInput | boolean
    pushNotification?: BoolFieldUpdateOperationsInput | boolean
    WhatsAppNotification?: BoolFieldUpdateOperationsInput | boolean
    smsNotification?: BoolFieldUpdateOperationsInput | boolean
    targetAudience?: NoticeUpdatetargetAudienceInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    publishedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoticeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    noticeType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isNoticeApproved?: BoolFieldUpdateOperationsInput | boolean
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    emailNotification?: BoolFieldUpdateOperationsInput | boolean
    pushNotification?: BoolFieldUpdateOperationsInput | boolean
    WhatsAppNotification?: BoolFieldUpdateOperationsInput | boolean
    smsNotification?: BoolFieldUpdateOperationsInput | boolean
    targetAudience?: NoticeUpdatetargetAudienceInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    publishedBy?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationLogCreateInput = {
    id?: string
    channel: $Enums.NotificationChannel
    status?: $Enums.NotificationStatus
    notificationType: $Enums.NotificationType
    units?: number
    cost?: number
    sentAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutNotificationLogInput
    user?: UserCreateNestedOneWithoutNotificationLogInput
    parent?: ParentCreateNestedOneWithoutNotificationLogInput
    student?: StudentCreateNestedOneWithoutNotificationLogInput
  }

  export type NotificationLogUncheckedCreateInput = {
    id?: string
    organizationId: string
    userId?: string | null
    parentId?: string | null
    studentId?: string | null
    channel: $Enums.NotificationChannel
    status?: $Enums.NotificationStatus
    notificationType: $Enums.NotificationType
    units?: number
    cost?: number
    sentAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    units?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutNotificationLogNestedInput
    user?: UserUpdateOneWithoutNotificationLogNestedInput
    parent?: ParentUpdateOneWithoutNotificationLogNestedInput
    student?: StudentUpdateOneWithoutNotificationLogNestedInput
  }

  export type NotificationLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    units?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogCreateManyInput = {
    id?: string
    organizationId: string
    userId?: string | null
    parentId?: string | null
    studentId?: string | null
    channel: $Enums.NotificationChannel
    status?: $Enums.NotificationStatus
    notificationType: $Enums.NotificationType
    units?: number
    cost?: number
    sentAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    units?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    units?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamSessionCreateInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicYear: AcademicYearCreateNestedOneWithoutExamSessionInput
    exams?: ExamCreateNestedManyWithoutExamSessionInput
    reportCards?: ReportCardCreateNestedManyWithoutExamSessionInput
    hallTickets?: HallTicketCreateNestedManyWithoutExamSessionInput
  }

  export type ExamSessionUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    academicYearId: string
    startDate: Date | string
    endDate: Date | string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    exams?: ExamUncheckedCreateNestedManyWithoutExamSessionInput
    reportCards?: ReportCardUncheckedCreateNestedManyWithoutExamSessionInput
    hallTickets?: HallTicketUncheckedCreateNestedManyWithoutExamSessionInput
  }

  export type ExamSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYear?: AcademicYearUpdateOneRequiredWithoutExamSessionNestedInput
    exams?: ExamUpdateManyWithoutExamSessionNestedInput
    reportCards?: ReportCardUpdateManyWithoutExamSessionNestedInput
    hallTickets?: HallTicketUpdateManyWithoutExamSessionNestedInput
  }

  export type ExamSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    academicYearId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exams?: ExamUncheckedUpdateManyWithoutExamSessionNestedInput
    reportCards?: ReportCardUncheckedUpdateManyWithoutExamSessionNestedInput
    hallTickets?: HallTicketUncheckedUpdateManyWithoutExamSessionNestedInput
  }

  export type ExamSessionCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    academicYearId: string
    startDate: Date | string
    endDate: Date | string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    academicYearId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamCreateInput = {
    id?: string
    title: string
    description?: string | null
    gradeId: string
    sectionId: string
    maxMarks: number
    passingMarks?: number | null
    weightage?: number | null
    evaluationType: $Enums.EvaluationType
    mode: $Enums.ExamMode
    status?: $Enums.ExamStatus
    instructions?: string | null
    durationInMinutes?: number | null
    venueMapUrl?: string | null
    venue?: string | null
    isResultsPublished?: boolean
    supervisors?: ExamCreatesupervisorsInput | string[]
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    examSession: ExamSessionCreateNestedOneWithoutExamsInput
    subject: SubjectCreateNestedOneWithoutExamInput
    organization: OrganizationCreateNestedOneWithoutExamInput
    hallTickets?: HallTicketCreateNestedManyWithoutExamInput
    examResult?: ExamResultCreateNestedManyWithoutExamInput
    examEnrollment?: ExamEnrollmentCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    examSessionId: string
    subjectId: string
    gradeId: string
    sectionId: string
    organizationId: string
    maxMarks: number
    passingMarks?: number | null
    weightage?: number | null
    evaluationType: $Enums.EvaluationType
    mode: $Enums.ExamMode
    status?: $Enums.ExamStatus
    instructions?: string | null
    durationInMinutes?: number | null
    venueMapUrl?: string | null
    venue?: string | null
    isResultsPublished?: boolean
    supervisors?: ExamCreatesupervisorsInput | string[]
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    hallTickets?: HallTicketUncheckedCreateNestedManyWithoutExamInput
    examResult?: ExamResultUncheckedCreateNestedManyWithoutExamInput
    examEnrollment?: ExamEnrollmentUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gradeId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    maxMarks?: FloatFieldUpdateOperationsInput | number
    passingMarks?: NullableFloatFieldUpdateOperationsInput | number | null
    weightage?: NullableFloatFieldUpdateOperationsInput | number | null
    evaluationType?: EnumEvaluationTypeFieldUpdateOperationsInput | $Enums.EvaluationType
    mode?: EnumExamModeFieldUpdateOperationsInput | $Enums.ExamMode
    status?: EnumExamStatusFieldUpdateOperationsInput | $Enums.ExamStatus
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    venueMapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    isResultsPublished?: BoolFieldUpdateOperationsInput | boolean
    supervisors?: ExamUpdatesupervisorsInput | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examSession?: ExamSessionUpdateOneRequiredWithoutExamsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutExamNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutExamNestedInput
    hallTickets?: HallTicketUpdateManyWithoutExamNestedInput
    examResult?: ExamResultUpdateManyWithoutExamNestedInput
    examEnrollment?: ExamEnrollmentUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    examSessionId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    maxMarks?: FloatFieldUpdateOperationsInput | number
    passingMarks?: NullableFloatFieldUpdateOperationsInput | number | null
    weightage?: NullableFloatFieldUpdateOperationsInput | number | null
    evaluationType?: EnumEvaluationTypeFieldUpdateOperationsInput | $Enums.EvaluationType
    mode?: EnumExamModeFieldUpdateOperationsInput | $Enums.ExamMode
    status?: EnumExamStatusFieldUpdateOperationsInput | $Enums.ExamStatus
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    venueMapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    isResultsPublished?: BoolFieldUpdateOperationsInput | boolean
    supervisors?: ExamUpdatesupervisorsInput | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hallTickets?: HallTicketUncheckedUpdateManyWithoutExamNestedInput
    examResult?: ExamResultUncheckedUpdateManyWithoutExamNestedInput
    examEnrollment?: ExamEnrollmentUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ExamCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    examSessionId: string
    subjectId: string
    gradeId: string
    sectionId: string
    organizationId: string
    maxMarks: number
    passingMarks?: number | null
    weightage?: number | null
    evaluationType: $Enums.EvaluationType
    mode: $Enums.ExamMode
    status?: $Enums.ExamStatus
    instructions?: string | null
    durationInMinutes?: number | null
    venueMapUrl?: string | null
    venue?: string | null
    isResultsPublished?: boolean
    supervisors?: ExamCreatesupervisorsInput | string[]
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gradeId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    maxMarks?: FloatFieldUpdateOperationsInput | number
    passingMarks?: NullableFloatFieldUpdateOperationsInput | number | null
    weightage?: NullableFloatFieldUpdateOperationsInput | number | null
    evaluationType?: EnumEvaluationTypeFieldUpdateOperationsInput | $Enums.EvaluationType
    mode?: EnumExamModeFieldUpdateOperationsInput | $Enums.ExamMode
    status?: EnumExamStatusFieldUpdateOperationsInput | $Enums.ExamStatus
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    venueMapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    isResultsPublished?: BoolFieldUpdateOperationsInput | boolean
    supervisors?: ExamUpdatesupervisorsInput | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    examSessionId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    maxMarks?: FloatFieldUpdateOperationsInput | number
    passingMarks?: NullableFloatFieldUpdateOperationsInput | number | null
    weightage?: NullableFloatFieldUpdateOperationsInput | number | null
    evaluationType?: EnumEvaluationTypeFieldUpdateOperationsInput | $Enums.EvaluationType
    mode?: EnumExamModeFieldUpdateOperationsInput | $Enums.ExamMode
    status?: EnumExamStatusFieldUpdateOperationsInput | $Enums.ExamStatus
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    venueMapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    isResultsPublished?: BoolFieldUpdateOperationsInput | boolean
    supervisors?: ExamUpdatesupervisorsInput | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamEnrollmentCreateInput = {
    id?: string
    status?: $Enums.StudentExamStatus
    enrolledAt?: Date | string
    exemptionReason?: string | null
    student: StudentCreateNestedOneWithoutExamEnrollmentInput
    exam: ExamCreateNestedOneWithoutExamEnrollmentInput
  }

  export type ExamEnrollmentUncheckedCreateInput = {
    id?: string
    studentId: string
    examId: string
    status?: $Enums.StudentExamStatus
    enrolledAt?: Date | string
    exemptionReason?: string | null
  }

  export type ExamEnrollmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStudentExamStatusFieldUpdateOperationsInput | $Enums.StudentExamStatus
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exemptionReason?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneRequiredWithoutExamEnrollmentNestedInput
    exam?: ExamUpdateOneRequiredWithoutExamEnrollmentNestedInput
  }

  export type ExamEnrollmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    status?: EnumStudentExamStatusFieldUpdateOperationsInput | $Enums.StudentExamStatus
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exemptionReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExamEnrollmentCreateManyInput = {
    id?: string
    studentId: string
    examId: string
    status?: $Enums.StudentExamStatus
    enrolledAt?: Date | string
    exemptionReason?: string | null
  }

  export type ExamEnrollmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStudentExamStatusFieldUpdateOperationsInput | $Enums.StudentExamStatus
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exemptionReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExamEnrollmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    status?: EnumStudentExamStatusFieldUpdateOperationsInput | $Enums.StudentExamStatus
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exemptionReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExamResultCreateInput = {
    id?: string
    maxMarks: number
    obtainedMarks?: number | null
    percentage?: number | null
    gradeLabel?: string | null
    remarks?: string | null
    isPassed?: boolean | null
    isAbsent?: boolean
    isResultsPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutExamResultInput
    exam: ExamCreateNestedOneWithoutExamResultInput
    subject?: SubjectCreateNestedOneWithoutExamResultInput
  }

  export type ExamResultUncheckedCreateInput = {
    id?: string
    studentId: string
    examId: string
    subjectId?: string | null
    maxMarks: number
    obtainedMarks?: number | null
    percentage?: number | null
    gradeLabel?: string | null
    remarks?: string | null
    isPassed?: boolean | null
    isAbsent?: boolean
    isResultsPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    maxMarks?: FloatFieldUpdateOperationsInput | number
    obtainedMarks?: NullableFloatFieldUpdateOperationsInput | number | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    gradeLabel?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAbsent?: BoolFieldUpdateOperationsInput | boolean
    isResultsPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutExamResultNestedInput
    exam?: ExamUpdateOneRequiredWithoutExamResultNestedInput
    subject?: SubjectUpdateOneWithoutExamResultNestedInput
  }

  export type ExamResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMarks?: FloatFieldUpdateOperationsInput | number
    obtainedMarks?: NullableFloatFieldUpdateOperationsInput | number | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    gradeLabel?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAbsent?: BoolFieldUpdateOperationsInput | boolean
    isResultsPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamResultCreateManyInput = {
    id?: string
    studentId: string
    examId: string
    subjectId?: string | null
    maxMarks: number
    obtainedMarks?: number | null
    percentage?: number | null
    gradeLabel?: string | null
    remarks?: string | null
    isPassed?: boolean | null
    isAbsent?: boolean
    isResultsPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    maxMarks?: FloatFieldUpdateOperationsInput | number
    obtainedMarks?: NullableFloatFieldUpdateOperationsInput | number | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    gradeLabel?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAbsent?: BoolFieldUpdateOperationsInput | boolean
    isResultsPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMarks?: FloatFieldUpdateOperationsInput | number
    obtainedMarks?: NullableFloatFieldUpdateOperationsInput | number | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    gradeLabel?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAbsent?: BoolFieldUpdateOperationsInput | boolean
    isResultsPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HallTicketCreateInput = {
    id?: string
    pdfUrl: string
    qrCode?: string | null
    generatedAt?: Date | string
    downloadedAt?: Date | string | null
    expiryDate?: Date | string | null
    student: StudentCreateNestedOneWithoutHallTicketInput
    exam?: ExamCreateNestedOneWithoutHallTicketsInput
    examSession?: ExamSessionCreateNestedOneWithoutHallTicketsInput
    organization: OrganizationCreateNestedOneWithoutHallTicketInput
  }

  export type HallTicketUncheckedCreateInput = {
    id?: string
    studentId: string
    examId?: string | null
    examSessionId?: string | null
    pdfUrl: string
    qrCode?: string | null
    generatedAt?: Date | string
    downloadedAt?: Date | string | null
    expiryDate?: Date | string | null
    organizationId: string
  }

  export type HallTicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pdfUrl?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student?: StudentUpdateOneRequiredWithoutHallTicketNestedInput
    exam?: ExamUpdateOneWithoutHallTicketsNestedInput
    examSession?: ExamSessionUpdateOneWithoutHallTicketsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutHallTicketNestedInput
  }

  export type HallTicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    examSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type HallTicketCreateManyInput = {
    id?: string
    studentId: string
    examId?: string | null
    examSessionId?: string | null
    pdfUrl: string
    qrCode?: string | null
    generatedAt?: Date | string
    downloadedAt?: Date | string | null
    expiryDate?: Date | string | null
    organizationId: string
  }

  export type HallTicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pdfUrl?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HallTicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    examSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type ReportCardCreateInput = {
    id?: string
    totalMaxMarks: number
    totalObtained: number
    percentage: number
    cgpa?: number | null
    overallGrade: string
    resultStatus: $Enums.ResultStatus
    classRank?: number | null
    gradeRank?: number | null
    attendancePercent?: number | null
    conductGrade?: string | null
    remarks?: string | null
    principalRemarks?: string | null
    rank?: number | null
    pdfUrl?: string | null
    generatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutReportCardInput
    examSession: ExamSessionCreateNestedOneWithoutReportCardsInput
  }

  export type ReportCardUncheckedCreateInput = {
    id?: string
    studentId: string
    examSessionId: string
    totalMaxMarks: number
    totalObtained: number
    percentage: number
    cgpa?: number | null
    overallGrade: string
    resultStatus: $Enums.ResultStatus
    classRank?: number | null
    gradeRank?: number | null
    attendancePercent?: number | null
    conductGrade?: string | null
    remarks?: string | null
    principalRemarks?: string | null
    rank?: number | null
    pdfUrl?: string | null
    generatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalMaxMarks?: FloatFieldUpdateOperationsInput | number
    totalObtained?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    overallGrade?: StringFieldUpdateOperationsInput | string
    resultStatus?: EnumResultStatusFieldUpdateOperationsInput | $Enums.ResultStatus
    classRank?: NullableIntFieldUpdateOperationsInput | number | null
    gradeRank?: NullableIntFieldUpdateOperationsInput | number | null
    attendancePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    conductGrade?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    principalRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutReportCardNestedInput
    examSession?: ExamSessionUpdateOneRequiredWithoutReportCardsNestedInput
  }

  export type ReportCardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    examSessionId?: StringFieldUpdateOperationsInput | string
    totalMaxMarks?: FloatFieldUpdateOperationsInput | number
    totalObtained?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    overallGrade?: StringFieldUpdateOperationsInput | string
    resultStatus?: EnumResultStatusFieldUpdateOperationsInput | $Enums.ResultStatus
    classRank?: NullableIntFieldUpdateOperationsInput | number | null
    gradeRank?: NullableIntFieldUpdateOperationsInput | number | null
    attendancePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    conductGrade?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    principalRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCardCreateManyInput = {
    id?: string
    studentId: string
    examSessionId: string
    totalMaxMarks: number
    totalObtained: number
    percentage: number
    cgpa?: number | null
    overallGrade: string
    resultStatus: $Enums.ResultStatus
    classRank?: number | null
    gradeRank?: number | null
    attendancePercent?: number | null
    conductGrade?: string | null
    remarks?: string | null
    principalRemarks?: string | null
    rank?: number | null
    pdfUrl?: string | null
    generatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalMaxMarks?: FloatFieldUpdateOperationsInput | number
    totalObtained?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    overallGrade?: StringFieldUpdateOperationsInput | string
    resultStatus?: EnumResultStatusFieldUpdateOperationsInput | $Enums.ResultStatus
    classRank?: NullableIntFieldUpdateOperationsInput | number | null
    gradeRank?: NullableIntFieldUpdateOperationsInput | number | null
    attendancePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    conductGrade?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    principalRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    examSessionId?: StringFieldUpdateOperationsInput | string
    totalMaxMarks?: FloatFieldUpdateOperationsInput | number
    totalObtained?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    overallGrade?: StringFieldUpdateOperationsInput | string
    resultStatus?: EnumResultStatusFieldUpdateOperationsInput | $Enums.ResultStatus
    classRank?: NullableIntFieldUpdateOperationsInput | number | null
    gradeRank?: NullableIntFieldUpdateOperationsInput | number | null
    attendancePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    conductGrade?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    principalRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumYearTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.YearType | EnumYearTypeFieldRefInput<$PrismaModel>
    in?: $Enums.YearType[] | ListEnumYearTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.YearType[] | ListEnumYearTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumYearTypeFilter<$PrismaModel> | $Enums.YearType
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type OrganizationScalarRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type AnonymousComplaintListRelationFilter = {
    every?: AnonymousComplaintWhereInput
    some?: AnonymousComplaintWhereInput
    none?: AnonymousComplaintWhereInput
  }

  export type NoticeListRelationFilter = {
    every?: NoticeWhereInput
    some?: NoticeWhereInput
    none?: NoticeWhereInput
  }

  export type TeachingAssignmentListRelationFilter = {
    every?: TeachingAssignmentWhereInput
    some?: TeachingAssignmentWhereInput
    none?: TeachingAssignmentWhereInput
  }

  export type StudentAttendanceListRelationFilter = {
    every?: StudentAttendanceWhereInput
    some?: StudentAttendanceWhereInput
    none?: StudentAttendanceWhereInput
  }

  export type AcademicCalendarListRelationFilter = {
    every?: AcademicCalendarWhereInput
    some?: AcademicCalendarWhereInput
    none?: AcademicCalendarWhereInput
  }

  export type ExamSessionListRelationFilter = {
    every?: ExamSessionWhereInput
    some?: ExamSessionWhereInput
    none?: ExamSessionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AnonymousComplaintOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NoticeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeachingAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentAttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AcademicCalendarOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AcademicYearOrderByRelevanceInput = {
    fields: AcademicYearOrderByRelevanceFieldEnum | AcademicYearOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AcademicYearOrganizationIdNameCompoundUniqueInput = {
    organizationId: string
    name: string
  }

  export type AcademicYearCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    type?: SortOrder
    isCurrent?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicYearMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    type?: SortOrder
    isCurrent?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicYearMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    type?: SortOrder
    isCurrent?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumYearTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.YearType | EnumYearTypeFieldRefInput<$PrismaModel>
    in?: $Enums.YearType[] | ListEnumYearTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.YearType[] | ListEnumYearTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumYearTypeWithAggregatesFilter<$PrismaModel> | $Enums.YearType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumYearTypeFilter<$PrismaModel>
    _max?: NestedEnumYearTypeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumPlanTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeFilter<$PrismaModel> | $Enums.PlanType
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumOrganizationTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OrganizationType | EnumOrganizationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrganizationType[] | ListEnumOrganizationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrganizationType[] | ListEnumOrganizationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrganizationTypeNullableFilter<$PrismaModel> | $Enums.OrganizationType | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type StudentListRelationFilter = {
    every?: StudentWhereInput
    some?: StudentWhereInput
    none?: StudentWhereInput
  }

  export type StudentDocumentListRelationFilter = {
    every?: StudentDocumentWhereInput
    some?: StudentDocumentWhereInput
    none?: StudentDocumentWhereInput
  }

  export type GradeListRelationFilter = {
    every?: GradeWhereInput
    some?: GradeWhereInput
    none?: GradeWhereInput
  }

  export type SectionListRelationFilter = {
    every?: SectionWhereInput
    some?: SectionWhereInput
    none?: SectionWhereInput
  }

  export type FeeListRelationFilter = {
    every?: FeeWhereInput
    some?: FeeWhereInput
    none?: FeeWhereInput
  }

  export type FeeCategoryListRelationFilter = {
    every?: FeeCategoryWhereInput
    some?: FeeCategoryWhereInput
    none?: FeeCategoryWhereInput
  }

  export type FeePaymentListRelationFilter = {
    every?: FeePaymentWhereInput
    some?: FeePaymentWhereInput
    none?: FeePaymentWhereInput
  }

  export type TeacherListRelationFilter = {
    every?: TeacherWhereInput
    some?: TeacherWhereInput
    none?: TeacherWhereInput
  }

  export type SubjectListRelationFilter = {
    every?: SubjectWhereInput
    some?: SubjectWhereInput
    none?: SubjectWhereInput
  }

  export type NotificationLogListRelationFilter = {
    every?: NotificationLogWhereInput
    some?: NotificationLogWhereInput
    none?: NotificationLogWhereInput
  }

  export type AcademicYearListRelationFilter = {
    every?: AcademicYearWhereInput
    some?: AcademicYearWhereInput
    none?: AcademicYearWhereInput
  }

  export type ScheduledJobListRelationFilter = {
    every?: ScheduledJobWhereInput
    some?: ScheduledJobWhereInput
    none?: ScheduledJobWhereInput
  }

  export type ExamListRelationFilter = {
    every?: ExamWhereInput
    some?: ExamWhereInput
    none?: ExamWhereInput
  }

  export type HallTicketListRelationFilter = {
    every?: HallTicketWhereInput
    some?: HallTicketWhereInput
    none?: HallTicketWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GradeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeeCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeePaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeacherOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AcademicYearOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduledJobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HallTicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationOrderByRelevanceInput = {
    fields: OrganizationOrderByRelevanceFieldEnum | OrganizationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    organizationSlug?: SortOrder
    organizationLogo?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    website?: SortOrder
    isActive?: SortOrder
    isPaid?: SortOrder
    plan?: SortOrder
    planStartedAt?: SortOrder
    planExpiresAt?: SortOrder
    maxStudents?: SortOrder
    organizationType?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationAvgOrderByAggregateInput = {
    maxStudents?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    organizationSlug?: SortOrder
    organizationLogo?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    website?: SortOrder
    isActive?: SortOrder
    isPaid?: SortOrder
    plan?: SortOrder
    planStartedAt?: SortOrder
    planExpiresAt?: SortOrder
    maxStudents?: SortOrder
    organizationType?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    organizationSlug?: SortOrder
    organizationLogo?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    website?: SortOrder
    isActive?: SortOrder
    isPaid?: SortOrder
    plan?: SortOrder
    planStartedAt?: SortOrder
    planExpiresAt?: SortOrder
    maxStudents?: SortOrder
    organizationType?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationSumOrderByAggregateInput = {
    maxStudents?: SortOrder
  }

  export type EnumPlanTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeWithAggregatesFilter<$PrismaModel> | $Enums.PlanType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanTypeFilter<$PrismaModel>
    _max?: NestedEnumPlanTypeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumOrganizationTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrganizationType | EnumOrganizationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrganizationType[] | ListEnumOrganizationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrganizationType[] | ListEnumOrganizationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrganizationTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.OrganizationType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOrganizationTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumOrganizationTypeNullableFilter<$PrismaModel>
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type OrganizationNullableScalarRelationFilter = {
    is?: OrganizationWhereInput | null
    isNot?: OrganizationWhereInput | null
  }

  export type TeacherNullableScalarRelationFilter = {
    is?: TeacherWhereInput | null
    isNot?: TeacherWhereInput | null
  }

  export type StudentNullableScalarRelationFilter = {
    is?: StudentWhereInput | null
    isNot?: StudentWhereInput | null
  }

  export type ParentNullableScalarRelationFilter = {
    is?: ParentWhereInput | null
    isNot?: ParentWhereInput | null
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    profileImage?: SortOrder
    role?: SortOrder
    clerkId?: SortOrder
    isActive?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    profileImage?: SortOrder
    role?: SortOrder
    clerkId?: SortOrder
    isActive?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    profileImage?: SortOrder
    role?: SortOrder
    clerkId?: SortOrder
    isActive?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type GradeOrderByRelevanceInput = {
    fields: GradeOrderByRelevanceFieldEnum | GradeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type GradeCountOrderByAggregateInput = {
    id?: SortOrder
    grade?: SortOrder
    organizationId?: SortOrder
  }

  export type GradeMaxOrderByAggregateInput = {
    id?: SortOrder
    grade?: SortOrder
    organizationId?: SortOrder
  }

  export type GradeMinOrderByAggregateInput = {
    id?: SortOrder
    grade?: SortOrder
    organizationId?: SortOrder
  }

  export type GradeScalarRelationFilter = {
    is?: GradeWhereInput
    isNot?: GradeWhereInput
  }

  export type SectionOrderByRelevanceInput = {
    fields: SectionOrderByRelevanceFieldEnum | SectionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SectionNameGradeIdCompoundUniqueInput = {
    name: string
    gradeId: string
  }

  export type SectionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    gradeId?: SortOrder
    organizationId?: SortOrder
    classTeacherId?: SortOrder
  }

  export type SectionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    gradeId?: SortOrder
    organizationId?: SortOrder
    classTeacherId?: SortOrder
  }

  export type SectionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    gradeId?: SortOrder
    organizationId?: SortOrder
    classTeacherId?: SortOrder
  }

  export type EnumEmploymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EmploymentStatus | EnumEmploymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmploymentStatus[] | ListEnumEmploymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmploymentStatus[] | ListEnumEmploymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmploymentStatusFilter<$PrismaModel> | $Enums.EmploymentStatus
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type TeacherProfileNullableScalarRelationFilter = {
    is?: TeacherProfileWhereInput | null
    isNot?: TeacherProfileWhereInput | null
  }

  export type TeacherOrderByRelevanceInput = {
    fields: TeacherOrderByRelevanceFieldEnum | TeacherOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TeacherCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    employeeCode?: SortOrder
    employmentStatus?: SortOrder
    isActive?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    employeeCode?: SortOrder
    employmentStatus?: SortOrder
    isActive?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    employeeCode?: SortOrder
    employmentStatus?: SortOrder
    isActive?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEmploymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmploymentStatus | EnumEmploymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmploymentStatus[] | ListEnumEmploymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmploymentStatus[] | ListEnumEmploymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmploymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.EmploymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmploymentStatusFilter<$PrismaModel>
    _max?: NestedEnumEmploymentStatusFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type TeacherScalarRelationFilter = {
    is?: TeacherWhereInput
    isNot?: TeacherWhereInput
  }

  export type TeacherProfileOrderByRelevanceInput = {
    fields: TeacherProfileOrderByRelevanceFieldEnum | TeacherProfileOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TeacherProfileCountOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    dateOfBirth?: SortOrder
    qualification?: SortOrder
    experienceInYears?: SortOrder
    resumeUrl?: SortOrder
    joinedAt?: SortOrder
    bio?: SortOrder
    teachingPhilosophy?: SortOrder
    specializedSubjects?: SortOrder
    preferredGrades?: SortOrder
    idProofUrl?: SortOrder
    linkedinPortfolio?: SortOrder
    languagesKnown?: SortOrder
    certificateUrls?: SortOrder
  }

  export type TeacherProfileAvgOrderByAggregateInput = {
    experienceInYears?: SortOrder
  }

  export type TeacherProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    dateOfBirth?: SortOrder
    qualification?: SortOrder
    experienceInYears?: SortOrder
    resumeUrl?: SortOrder
    joinedAt?: SortOrder
    bio?: SortOrder
    teachingPhilosophy?: SortOrder
    idProofUrl?: SortOrder
    linkedinPortfolio?: SortOrder
  }

  export type TeacherProfileMinOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    dateOfBirth?: SortOrder
    qualification?: SortOrder
    experienceInYears?: SortOrder
    resumeUrl?: SortOrder
    joinedAt?: SortOrder
    bio?: SortOrder
    teachingPhilosophy?: SortOrder
    idProofUrl?: SortOrder
    linkedinPortfolio?: SortOrder
  }

  export type TeacherProfileSumOrderByAggregateInput = {
    experienceInYears?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ExamResultListRelationFilter = {
    every?: ExamResultWhereInput
    some?: ExamResultWhereInput
    none?: ExamResultWhereInput
  }

  export type ExamResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubjectOrderByRelevanceInput = {
    fields: SubjectOrderByRelevanceFieldEnum | SubjectOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SubjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAssignmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentStatus | EnumAssignmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentStatusFilter<$PrismaModel> | $Enums.AssignmentStatus
  }

  export type SubjectScalarRelationFilter = {
    is?: SubjectWhereInput
    isNot?: SubjectWhereInput
  }

  export type SectionScalarRelationFilter = {
    is?: SectionWhereInput
    isNot?: SectionWhereInput
  }

  export type AcademicYearNullableScalarRelationFilter = {
    is?: AcademicYearWhereInput | null
    isNot?: AcademicYearWhereInput | null
  }

  export type TeachingAssignmentOrderByRelevanceInput = {
    fields: TeachingAssignmentOrderByRelevanceFieldEnum | TeachingAssignmentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TeachingAssignmentTeacherIdSubjectIdGradeIdSectionIdAcademicYearIdCompoundUniqueInput = {
    teacherId: string
    subjectId: string
    gradeId: string
    sectionId: string
    academicYearId: string
  }

  export type TeachingAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    gradeId?: SortOrder
    sectionId?: SortOrder
    organizationId?: SortOrder
    academicYear?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicYearId?: SortOrder
  }

  export type TeachingAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    gradeId?: SortOrder
    sectionId?: SortOrder
    organizationId?: SortOrder
    academicYear?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicYearId?: SortOrder
  }

  export type TeachingAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    gradeId?: SortOrder
    sectionId?: SortOrder
    organizationId?: SortOrder
    academicYear?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicYearId?: SortOrder
  }

  export type EnumAssignmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentStatus | EnumAssignmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AssignmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssignmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAssignmentStatusFilter<$PrismaModel>
  }

  export type EnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type ParentStudentListRelationFilter = {
    every?: ParentStudentWhereInput
    some?: ParentStudentWhereInput
    none?: ParentStudentWhereInput
  }

  export type ReportCardListRelationFilter = {
    every?: ReportCardWhereInput
    some?: ReportCardWhereInput
    none?: ReportCardWhereInput
  }

  export type ExamEnrollmentListRelationFilter = {
    every?: ExamEnrollmentWhereInput
    some?: ExamEnrollmentWhereInput
    none?: ExamEnrollmentWhereInput
  }

  export type ParentStudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportCardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamEnrollmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentOrderByRelevanceInput = {
    fields: StudentOrderByRelevanceFieldEnum | StudentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StudentOrganizationIdRollNumberCompoundUniqueInput = {
    organizationId: string
    rollNumber: string
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    middleName?: SortOrder
    motherName?: SortOrder
    fullName?: SortOrder
    dateOfBirth?: SortOrder
    profileImage?: SortOrder
    rollNumber?: SortOrder
    phoneNumber?: SortOrder
    whatsAppNumber?: SortOrder
    email?: SortOrder
    emergencyContact?: SortOrder
    gender?: SortOrder
    sectionId?: SortOrder
    gradeId?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    middleName?: SortOrder
    motherName?: SortOrder
    fullName?: SortOrder
    dateOfBirth?: SortOrder
    profileImage?: SortOrder
    rollNumber?: SortOrder
    phoneNumber?: SortOrder
    whatsAppNumber?: SortOrder
    email?: SortOrder
    emergencyContact?: SortOrder
    gender?: SortOrder
    sectionId?: SortOrder
    gradeId?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    middleName?: SortOrder
    motherName?: SortOrder
    fullName?: SortOrder
    dateOfBirth?: SortOrder
    profileImage?: SortOrder
    rollNumber?: SortOrder
    phoneNumber?: SortOrder
    whatsAppNumber?: SortOrder
    email?: SortOrder
    emergencyContact?: SortOrder
    gender?: SortOrder
    sectionId?: SortOrder
    gradeId?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ParentOrderByRelevanceInput = {
    fields: ParentOrderByRelevanceFieldEnum | ParentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ParentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    whatsAppNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    whatsAppNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    whatsAppNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type StudentScalarRelationFilter = {
    is?: StudentWhereInput
    isNot?: StudentWhereInput
  }

  export type ParentScalarRelationFilter = {
    is?: ParentWhereInput
    isNot?: ParentWhereInput
  }

  export type ParentStudentOrderByRelevanceInput = {
    fields: ParentStudentOrderByRelevanceFieldEnum | ParentStudentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ParentStudentCountOrderByAggregateInput = {
    id?: SortOrder
    relationship?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    isPrimary?: SortOrder
  }

  export type ParentStudentMaxOrderByAggregateInput = {
    id?: SortOrder
    relationship?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    isPrimary?: SortOrder
  }

  export type ParentStudentMinOrderByAggregateInput = {
    id?: SortOrder
    relationship?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    isPrimary?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type StudentAttendanceOrderByRelevanceInput = {
    fields: StudentAttendanceOrderByRelevanceFieldEnum | StudentAttendanceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StudentAttendanceStudentIdDateCompoundUniqueInput = {
    studentId: string
    date: Date | string
  }

  export type StudentAttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    note?: SortOrder
    recordedBy?: SortOrder
    studentId?: SortOrder
    present?: SortOrder
    sectionId?: SortOrder
    academicYearId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentAttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    note?: SortOrder
    recordedBy?: SortOrder
    studentId?: SortOrder
    present?: SortOrder
    sectionId?: SortOrder
    academicYearId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentAttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    note?: SortOrder
    recordedBy?: SortOrder
    studentId?: SortOrder
    present?: SortOrder
    sectionId?: SortOrder
    academicYearId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type StudentDocumentOrderByRelevanceInput = {
    fields: StudentDocumentOrderByRelevanceFieldEnum | StudentDocumentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StudentDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    fileType?: SortOrder
    documentUrl?: SortOrder
    studentId?: SortOrder
    verified?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
    rejected?: SortOrder
    rejectedBy?: SortOrder
    rejectedAt?: SortOrder
    rejectReason?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    note?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
  }

  export type StudentDocumentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type StudentDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    fileType?: SortOrder
    documentUrl?: SortOrder
    studentId?: SortOrder
    verified?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
    rejected?: SortOrder
    rejectedBy?: SortOrder
    rejectedAt?: SortOrder
    rejectReason?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    note?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
  }

  export type StudentDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    fileType?: SortOrder
    documentUrl?: SortOrder
    studentId?: SortOrder
    verified?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
    rejected?: SortOrder
    rejectedBy?: SortOrder
    rejectedAt?: SortOrder
    rejectReason?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    note?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
  }

  export type StudentDocumentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumFeeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FeeStatus | EnumFeeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FeeStatus[] | ListEnumFeeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeeStatus[] | ListEnumFeeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFeeStatusFilter<$PrismaModel> | $Enums.FeeStatus
  }

  export type FeeCategoryScalarRelationFilter = {
    is?: FeeCategoryWhereInput
    isNot?: FeeCategoryWhereInput
  }

  export type FeeOrderByRelevanceInput = {
    fields: FeeOrderByRelevanceFieldEnum | FeeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FeeCountOrderByAggregateInput = {
    id?: SortOrder
    totalFee?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    studentId?: SortOrder
    feeCategoryId?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeeAvgOrderByAggregateInput = {
    totalFee?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrder
  }

  export type FeeMaxOrderByAggregateInput = {
    id?: SortOrder
    totalFee?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    studentId?: SortOrder
    feeCategoryId?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeeMinOrderByAggregateInput = {
    id?: SortOrder
    totalFee?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    studentId?: SortOrder
    feeCategoryId?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeeSumOrderByAggregateInput = {
    totalFee?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumFeeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeeStatus | EnumFeeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FeeStatus[] | ListEnumFeeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeeStatus[] | ListEnumFeeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFeeStatusWithAggregatesFilter<$PrismaModel> | $Enums.FeeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeeStatusFilter<$PrismaModel>
    _max?: NestedEnumFeeStatusFilter<$PrismaModel>
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type FeeScalarRelationFilter = {
    is?: FeeWhereInput
    isNot?: FeeWhereInput
  }

  export type FeePaymentOrderByRelevanceInput = {
    fields: FeePaymentOrderByRelevanceFieldEnum | FeePaymentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FeePaymentCountOrderByAggregateInput = {
    id?: SortOrder
    feeId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    receiptNumber?: SortOrder
    note?: SortOrder
    transactionId?: SortOrder
    payerId?: SortOrder
    platformFee?: SortOrder
    recordedBy?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeePaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
    platformFee?: SortOrder
  }

  export type FeePaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    feeId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    receiptNumber?: SortOrder
    note?: SortOrder
    transactionId?: SortOrder
    payerId?: SortOrder
    platformFee?: SortOrder
    recordedBy?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeePaymentMinOrderByAggregateInput = {
    id?: SortOrder
    feeId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    receiptNumber?: SortOrder
    note?: SortOrder
    transactionId?: SortOrder
    payerId?: SortOrder
    platformFee?: SortOrder
    recordedBy?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeePaymentSumOrderByAggregateInput = {
    amount?: SortOrder
    platformFee?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumscheduledJobTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.scheduledJobType | EnumscheduledJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.scheduledJobType[] | ListEnumscheduledJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.scheduledJobType[] | ListEnumscheduledJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumscheduledJobTypeFilter<$PrismaModel> | $Enums.scheduledJobType
  }

  export type EnumNotificationChannelNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel> | null
    has?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    hasSome?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ScheduledJobOrderByRelevanceInput = {
    fields: ScheduledJobOrderByRelevanceFieldEnum | ScheduledJobOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ScheduledJobCountOrderByAggregateInput = {
    id?: SortOrder
    data?: SortOrder
    type?: SortOrder
    scheduledAt?: SortOrder
    channels?: SortOrder
    status?: SortOrder
    result?: SortOrder
    error?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
  }

  export type ScheduledJobMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    scheduledAt?: SortOrder
    status?: SortOrder
    error?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
  }

  export type ScheduledJobMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    scheduledAt?: SortOrder
    status?: SortOrder
    error?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumscheduledJobTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.scheduledJobType | EnumscheduledJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.scheduledJobType[] | ListEnumscheduledJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.scheduledJobType[] | ListEnumscheduledJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumscheduledJobTypeWithAggregatesFilter<$PrismaModel> | $Enums.scheduledJobType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumscheduledJobTypeFilter<$PrismaModel>
    _max?: NestedEnumscheduledJobTypeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type FeeCategoryOrderByRelevanceInput = {
    fields: FeeCategoryOrderByRelevanceFieldEnum | FeeCategoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FeeCategoryNameOrganizationIdCompoundUniqueInput = {
    name: string
    organizationId: string
  }

  export type FeeCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
  }

  export type FeeCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
  }

  export type FeeCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
  }

  export type EnumCalendarEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CalendarEventType | EnumCalendarEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CalendarEventType[] | ListEnumCalendarEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalendarEventType[] | ListEnumCalendarEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCalendarEventTypeFilter<$PrismaModel> | $Enums.CalendarEventType
  }

  export type AcademicCalendarOrderByRelevanceInput = {
    fields: AcademicCalendarOrderByRelevanceFieldEnum | AcademicCalendarOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AcademicCalendarOrganizationIdStartDateEndDateCompoundUniqueInput = {
    organizationId: string
    startDate: Date | string
    endDate: Date | string
  }

  export type AcademicCalendarCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    isRecurring?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicYearId?: SortOrder
  }

  export type AcademicCalendarMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    isRecurring?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicYearId?: SortOrder
  }

  export type AcademicCalendarMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    isRecurring?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicYearId?: SortOrder
  }

  export type EnumCalendarEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CalendarEventType | EnumCalendarEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CalendarEventType[] | ListEnumCalendarEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalendarEventType[] | ListEnumCalendarEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCalendarEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.CalendarEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCalendarEventTypeFilter<$PrismaModel>
    _max?: NestedEnumCalendarEventTypeFilter<$PrismaModel>
  }

  export type EnumSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.Severity | EnumSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSeverityFilter<$PrismaModel> | $Enums.Severity
  }

  export type EnumComplaintStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintStatus | EnumComplaintStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintStatus[] | ListEnumComplaintStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplaintStatus[] | ListEnumComplaintStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumComplaintStatusFilter<$PrismaModel> | $Enums.ComplaintStatus
  }

  export type ComplaintStatusTimelineListRelationFilter = {
    every?: ComplaintStatusTimelineWhereInput
    some?: ComplaintStatusTimelineWhereInput
    none?: ComplaintStatusTimelineWhereInput
  }

  export type ComplaintStatusTimelineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnonymousComplaintOrderByRelevanceInput = {
    fields: AnonymousComplaintOrderByRelevanceFieldEnum | AnonymousComplaintOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AnonymousComplaintCountOrderByAggregateInput = {
    id?: SortOrder
    trackingId?: SortOrder
    category?: SortOrder
    severity?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    evidenceUrls?: SortOrder
    submittedAt?: SortOrder
    currentStatus?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicYearId?: SortOrder
  }

  export type AnonymousComplaintMaxOrderByAggregateInput = {
    id?: SortOrder
    trackingId?: SortOrder
    category?: SortOrder
    severity?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    submittedAt?: SortOrder
    currentStatus?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicYearId?: SortOrder
  }

  export type AnonymousComplaintMinOrderByAggregateInput = {
    id?: SortOrder
    trackingId?: SortOrder
    category?: SortOrder
    severity?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    submittedAt?: SortOrder
    currentStatus?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicYearId?: SortOrder
  }

  export type EnumSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Severity | EnumSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSeverityWithAggregatesFilter<$PrismaModel> | $Enums.Severity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSeverityFilter<$PrismaModel>
    _max?: NestedEnumSeverityFilter<$PrismaModel>
  }

  export type EnumComplaintStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintStatus | EnumComplaintStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintStatus[] | ListEnumComplaintStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplaintStatus[] | ListEnumComplaintStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumComplaintStatusWithAggregatesFilter<$PrismaModel> | $Enums.ComplaintStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComplaintStatusFilter<$PrismaModel>
    _max?: NestedEnumComplaintStatusFilter<$PrismaModel>
  }

  export type AnonymousComplaintScalarRelationFilter = {
    is?: AnonymousComplaintWhereInput
    isNot?: AnonymousComplaintWhereInput
  }

  export type ComplaintStatusTimelineOrderByRelevanceInput = {
    fields: ComplaintStatusTimelineOrderByRelevanceFieldEnum | ComplaintStatusTimelineOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ComplaintStatusTimelineCountOrderByAggregateInput = {
    id?: SortOrder
    complaintId?: SortOrder
    note?: SortOrder
    status?: SortOrder
    changedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplaintStatusTimelineMaxOrderByAggregateInput = {
    id?: SortOrder
    complaintId?: SortOrder
    note?: SortOrder
    status?: SortOrder
    changedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplaintStatusTimelineMinOrderByAggregateInput = {
    id?: SortOrder
    complaintId?: SortOrder
    note?: SortOrder
    status?: SortOrder
    changedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NoticeOrderByRelevanceInput = {
    fields: NoticeOrderByRelevanceFieldEnum | NoticeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NoticeCountOrderByAggregateInput = {
    id?: SortOrder
    noticeType?: SortOrder
    title?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    content?: SortOrder
    summary?: SortOrder
    isNoticeApproved?: SortOrder
    isDraft?: SortOrder
    isPublished?: SortOrder
    emailNotification?: SortOrder
    pushNotification?: SortOrder
    WhatsAppNotification?: SortOrder
    smsNotification?: SortOrder
    targetAudience?: SortOrder
    attachments?: SortOrder
    publishedBy?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicYearId?: SortOrder
  }

  export type NoticeMaxOrderByAggregateInput = {
    id?: SortOrder
    noticeType?: SortOrder
    title?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    content?: SortOrder
    summary?: SortOrder
    isNoticeApproved?: SortOrder
    isDraft?: SortOrder
    isPublished?: SortOrder
    emailNotification?: SortOrder
    pushNotification?: SortOrder
    WhatsAppNotification?: SortOrder
    smsNotification?: SortOrder
    publishedBy?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicYearId?: SortOrder
  }

  export type NoticeMinOrderByAggregateInput = {
    id?: SortOrder
    noticeType?: SortOrder
    title?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    content?: SortOrder
    summary?: SortOrder
    isNoticeApproved?: SortOrder
    isDraft?: SortOrder
    isPublished?: SortOrder
    emailNotification?: SortOrder
    pushNotification?: SortOrder
    WhatsAppNotification?: SortOrder
    smsNotification?: SortOrder
    publishedBy?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicYearId?: SortOrder
  }

  export type EnumNotificationChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationChannelFilter<$PrismaModel> | $Enums.NotificationChannel
  }

  export type EnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationLogOrderByRelevanceInput = {
    fields: NotificationLogOrderByRelevanceFieldEnum | NotificationLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NotificationLogCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
    studentId?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    notificationType?: SortOrder
    units?: SortOrder
    cost?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationLogAvgOrderByAggregateInput = {
    units?: SortOrder
    cost?: SortOrder
  }

  export type NotificationLogMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
    studentId?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    notificationType?: SortOrder
    units?: SortOrder
    cost?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationLogMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
    studentId?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    notificationType?: SortOrder
    units?: SortOrder
    cost?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationLogSumOrderByAggregateInput = {
    units?: SortOrder
    cost?: SortOrder
  }

  export type EnumNotificationChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationChannelWithAggregatesFilter<$PrismaModel> | $Enums.NotificationChannel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationChannelFilter<$PrismaModel>
    _max?: NestedEnumNotificationChannelFilter<$PrismaModel>
  }

  export type EnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type AcademicYearScalarRelationFilter = {
    is?: AcademicYearWhereInput
    isNot?: AcademicYearWhereInput
  }

  export type ExamSessionOrderByRelevanceInput = {
    fields: ExamSessionOrderByRelevanceFieldEnum | ExamSessionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ExamSessionAcademicYearIdTitleCompoundUniqueInput = {
    academicYearId: string
    title: string
  }

  export type ExamSessionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    academicYearId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    academicYearId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamSessionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    academicYearId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEvaluationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EvaluationType | EnumEvaluationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EvaluationType[] | ListEnumEvaluationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EvaluationType[] | ListEnumEvaluationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEvaluationTypeFilter<$PrismaModel> | $Enums.EvaluationType
  }

  export type EnumExamModeFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamMode | EnumExamModeFieldRefInput<$PrismaModel>
    in?: $Enums.ExamMode[] | ListEnumExamModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExamMode[] | ListEnumExamModeFieldRefInput<$PrismaModel>
    not?: NestedEnumExamModeFilter<$PrismaModel> | $Enums.ExamMode
  }

  export type EnumExamStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamStatus | EnumExamStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExamStatus[] | ListEnumExamStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExamStatus[] | ListEnumExamStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExamStatusFilter<$PrismaModel> | $Enums.ExamStatus
  }

  export type ExamSessionScalarRelationFilter = {
    is?: ExamSessionWhereInput
    isNot?: ExamSessionWhereInput
  }

  export type ExamOrderByRelevanceInput = {
    fields: ExamOrderByRelevanceFieldEnum | ExamOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ExamExamSessionIdSubjectIdGradeIdSectionIdCompoundUniqueInput = {
    examSessionId: string
    subjectId: string
    gradeId: string
    sectionId: string
  }

  export type ExamCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    examSessionId?: SortOrder
    subjectId?: SortOrder
    gradeId?: SortOrder
    sectionId?: SortOrder
    organizationId?: SortOrder
    maxMarks?: SortOrder
    passingMarks?: SortOrder
    weightage?: SortOrder
    evaluationType?: SortOrder
    mode?: SortOrder
    status?: SortOrder
    instructions?: SortOrder
    durationInMinutes?: SortOrder
    venueMapUrl?: SortOrder
    venue?: SortOrder
    isResultsPublished?: SortOrder
    supervisors?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamAvgOrderByAggregateInput = {
    maxMarks?: SortOrder
    passingMarks?: SortOrder
    weightage?: SortOrder
    durationInMinutes?: SortOrder
  }

  export type ExamMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    examSessionId?: SortOrder
    subjectId?: SortOrder
    gradeId?: SortOrder
    sectionId?: SortOrder
    organizationId?: SortOrder
    maxMarks?: SortOrder
    passingMarks?: SortOrder
    weightage?: SortOrder
    evaluationType?: SortOrder
    mode?: SortOrder
    status?: SortOrder
    instructions?: SortOrder
    durationInMinutes?: SortOrder
    venueMapUrl?: SortOrder
    venue?: SortOrder
    isResultsPublished?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    examSessionId?: SortOrder
    subjectId?: SortOrder
    gradeId?: SortOrder
    sectionId?: SortOrder
    organizationId?: SortOrder
    maxMarks?: SortOrder
    passingMarks?: SortOrder
    weightage?: SortOrder
    evaluationType?: SortOrder
    mode?: SortOrder
    status?: SortOrder
    instructions?: SortOrder
    durationInMinutes?: SortOrder
    venueMapUrl?: SortOrder
    venue?: SortOrder
    isResultsPublished?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamSumOrderByAggregateInput = {
    maxMarks?: SortOrder
    passingMarks?: SortOrder
    weightage?: SortOrder
    durationInMinutes?: SortOrder
  }

  export type EnumEvaluationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EvaluationType | EnumEvaluationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EvaluationType[] | ListEnumEvaluationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EvaluationType[] | ListEnumEvaluationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEvaluationTypeWithAggregatesFilter<$PrismaModel> | $Enums.EvaluationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEvaluationTypeFilter<$PrismaModel>
    _max?: NestedEnumEvaluationTypeFilter<$PrismaModel>
  }

  export type EnumExamModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamMode | EnumExamModeFieldRefInput<$PrismaModel>
    in?: $Enums.ExamMode[] | ListEnumExamModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExamMode[] | ListEnumExamModeFieldRefInput<$PrismaModel>
    not?: NestedEnumExamModeWithAggregatesFilter<$PrismaModel> | $Enums.ExamMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExamModeFilter<$PrismaModel>
    _max?: NestedEnumExamModeFilter<$PrismaModel>
  }

  export type EnumExamStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamStatus | EnumExamStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExamStatus[] | ListEnumExamStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExamStatus[] | ListEnumExamStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExamStatusWithAggregatesFilter<$PrismaModel> | $Enums.ExamStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExamStatusFilter<$PrismaModel>
    _max?: NestedEnumExamStatusFilter<$PrismaModel>
  }

  export type EnumStudentExamStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentExamStatus | EnumStudentExamStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentExamStatus[] | ListEnumStudentExamStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudentExamStatus[] | ListEnumStudentExamStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudentExamStatusFilter<$PrismaModel> | $Enums.StudentExamStatus
  }

  export type ExamScalarRelationFilter = {
    is?: ExamWhereInput
    isNot?: ExamWhereInput
  }

  export type ExamEnrollmentOrderByRelevanceInput = {
    fields: ExamEnrollmentOrderByRelevanceFieldEnum | ExamEnrollmentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ExamEnrollmentStudentIdExamIdCompoundUniqueInput = {
    studentId: string
    examId: string
  }

  export type ExamEnrollmentCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    examId?: SortOrder
    status?: SortOrder
    enrolledAt?: SortOrder
    exemptionReason?: SortOrder
  }

  export type ExamEnrollmentMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    examId?: SortOrder
    status?: SortOrder
    enrolledAt?: SortOrder
    exemptionReason?: SortOrder
  }

  export type ExamEnrollmentMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    examId?: SortOrder
    status?: SortOrder
    enrolledAt?: SortOrder
    exemptionReason?: SortOrder
  }

  export type EnumStudentExamStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentExamStatus | EnumStudentExamStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentExamStatus[] | ListEnumStudentExamStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudentExamStatus[] | ListEnumStudentExamStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudentExamStatusWithAggregatesFilter<$PrismaModel> | $Enums.StudentExamStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStudentExamStatusFilter<$PrismaModel>
    _max?: NestedEnumStudentExamStatusFilter<$PrismaModel>
  }

  export type SubjectNullableScalarRelationFilter = {
    is?: SubjectWhereInput | null
    isNot?: SubjectWhereInput | null
  }

  export type ExamResultOrderByRelevanceInput = {
    fields: ExamResultOrderByRelevanceFieldEnum | ExamResultOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ExamResultExamIdStudentIdSubjectIdCompoundUniqueInput = {
    examId: string
    studentId: string
    subjectId: string
  }

  export type ExamResultCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    examId?: SortOrder
    subjectId?: SortOrder
    maxMarks?: SortOrder
    obtainedMarks?: SortOrder
    percentage?: SortOrder
    gradeLabel?: SortOrder
    remarks?: SortOrder
    isPassed?: SortOrder
    isAbsent?: SortOrder
    isResultsPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamResultAvgOrderByAggregateInput = {
    maxMarks?: SortOrder
    obtainedMarks?: SortOrder
    percentage?: SortOrder
  }

  export type ExamResultMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    examId?: SortOrder
    subjectId?: SortOrder
    maxMarks?: SortOrder
    obtainedMarks?: SortOrder
    percentage?: SortOrder
    gradeLabel?: SortOrder
    remarks?: SortOrder
    isPassed?: SortOrder
    isAbsent?: SortOrder
    isResultsPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamResultMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    examId?: SortOrder
    subjectId?: SortOrder
    maxMarks?: SortOrder
    obtainedMarks?: SortOrder
    percentage?: SortOrder
    gradeLabel?: SortOrder
    remarks?: SortOrder
    isPassed?: SortOrder
    isAbsent?: SortOrder
    isResultsPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamResultSumOrderByAggregateInput = {
    maxMarks?: SortOrder
    obtainedMarks?: SortOrder
    percentage?: SortOrder
  }

  export type ExamNullableScalarRelationFilter = {
    is?: ExamWhereInput | null
    isNot?: ExamWhereInput | null
  }

  export type ExamSessionNullableScalarRelationFilter = {
    is?: ExamSessionWhereInput | null
    isNot?: ExamSessionWhereInput | null
  }

  export type HallTicketOrderByRelevanceInput = {
    fields: HallTicketOrderByRelevanceFieldEnum | HallTicketOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type HallTicketStudentIdExamIdCompoundUniqueInput = {
    studentId: string
    examId: string
  }

  export type HallTicketCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    examId?: SortOrder
    examSessionId?: SortOrder
    pdfUrl?: SortOrder
    qrCode?: SortOrder
    generatedAt?: SortOrder
    downloadedAt?: SortOrder
    expiryDate?: SortOrder
    organizationId?: SortOrder
  }

  export type HallTicketMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    examId?: SortOrder
    examSessionId?: SortOrder
    pdfUrl?: SortOrder
    qrCode?: SortOrder
    generatedAt?: SortOrder
    downloadedAt?: SortOrder
    expiryDate?: SortOrder
    organizationId?: SortOrder
  }

  export type HallTicketMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    examId?: SortOrder
    examSessionId?: SortOrder
    pdfUrl?: SortOrder
    qrCode?: SortOrder
    generatedAt?: SortOrder
    downloadedAt?: SortOrder
    expiryDate?: SortOrder
    organizationId?: SortOrder
  }

  export type EnumResultStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ResultStatus | EnumResultStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ResultStatus[] | ListEnumResultStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResultStatus[] | ListEnumResultStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumResultStatusFilter<$PrismaModel> | $Enums.ResultStatus
  }

  export type ReportCardOrderByRelevanceInput = {
    fields: ReportCardOrderByRelevanceFieldEnum | ReportCardOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ReportCardStudentIdExamSessionIdCompoundUniqueInput = {
    studentId: string
    examSessionId: string
  }

  export type ReportCardCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    examSessionId?: SortOrder
    totalMaxMarks?: SortOrder
    totalObtained?: SortOrder
    percentage?: SortOrder
    cgpa?: SortOrder
    overallGrade?: SortOrder
    resultStatus?: SortOrder
    classRank?: SortOrder
    gradeRank?: SortOrder
    attendancePercent?: SortOrder
    conductGrade?: SortOrder
    remarks?: SortOrder
    principalRemarks?: SortOrder
    rank?: SortOrder
    pdfUrl?: SortOrder
    generatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportCardAvgOrderByAggregateInput = {
    totalMaxMarks?: SortOrder
    totalObtained?: SortOrder
    percentage?: SortOrder
    cgpa?: SortOrder
    classRank?: SortOrder
    gradeRank?: SortOrder
    attendancePercent?: SortOrder
    rank?: SortOrder
  }

  export type ReportCardMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    examSessionId?: SortOrder
    totalMaxMarks?: SortOrder
    totalObtained?: SortOrder
    percentage?: SortOrder
    cgpa?: SortOrder
    overallGrade?: SortOrder
    resultStatus?: SortOrder
    classRank?: SortOrder
    gradeRank?: SortOrder
    attendancePercent?: SortOrder
    conductGrade?: SortOrder
    remarks?: SortOrder
    principalRemarks?: SortOrder
    rank?: SortOrder
    pdfUrl?: SortOrder
    generatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportCardMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    examSessionId?: SortOrder
    totalMaxMarks?: SortOrder
    totalObtained?: SortOrder
    percentage?: SortOrder
    cgpa?: SortOrder
    overallGrade?: SortOrder
    resultStatus?: SortOrder
    classRank?: SortOrder
    gradeRank?: SortOrder
    attendancePercent?: SortOrder
    conductGrade?: SortOrder
    remarks?: SortOrder
    principalRemarks?: SortOrder
    rank?: SortOrder
    pdfUrl?: SortOrder
    generatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportCardSumOrderByAggregateInput = {
    totalMaxMarks?: SortOrder
    totalObtained?: SortOrder
    percentage?: SortOrder
    cgpa?: SortOrder
    classRank?: SortOrder
    gradeRank?: SortOrder
    attendancePercent?: SortOrder
    rank?: SortOrder
  }

  export type EnumResultStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResultStatus | EnumResultStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ResultStatus[] | ListEnumResultStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResultStatus[] | ListEnumResultStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumResultStatusWithAggregatesFilter<$PrismaModel> | $Enums.ResultStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResultStatusFilter<$PrismaModel>
    _max?: NestedEnumResultStatusFilter<$PrismaModel>
  }

  export type OrganizationCreateNestedOneWithoutAcademicYearInput = {
    create?: XOR<OrganizationCreateWithoutAcademicYearInput, OrganizationUncheckedCreateWithoutAcademicYearInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutAcademicYearInput
    connect?: OrganizationWhereUniqueInput
  }

  export type AnonymousComplaintCreateNestedManyWithoutAcademicYearInput = {
    create?: XOR<AnonymousComplaintCreateWithoutAcademicYearInput, AnonymousComplaintUncheckedCreateWithoutAcademicYearInput> | AnonymousComplaintCreateWithoutAcademicYearInput[] | AnonymousComplaintUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: AnonymousComplaintCreateOrConnectWithoutAcademicYearInput | AnonymousComplaintCreateOrConnectWithoutAcademicYearInput[]
    createMany?: AnonymousComplaintCreateManyAcademicYearInputEnvelope
    connect?: AnonymousComplaintWhereUniqueInput | AnonymousComplaintWhereUniqueInput[]
  }

  export type NoticeCreateNestedManyWithoutAcademicYearInput = {
    create?: XOR<NoticeCreateWithoutAcademicYearInput, NoticeUncheckedCreateWithoutAcademicYearInput> | NoticeCreateWithoutAcademicYearInput[] | NoticeUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: NoticeCreateOrConnectWithoutAcademicYearInput | NoticeCreateOrConnectWithoutAcademicYearInput[]
    createMany?: NoticeCreateManyAcademicYearInputEnvelope
    connect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
  }

  export type TeachingAssignmentCreateNestedManyWithoutAcademicYearInput = {
    create?: XOR<TeachingAssignmentCreateWithoutAcademicYearInput, TeachingAssignmentUncheckedCreateWithoutAcademicYearInput> | TeachingAssignmentCreateWithoutAcademicYearInput[] | TeachingAssignmentUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: TeachingAssignmentCreateOrConnectWithoutAcademicYearInput | TeachingAssignmentCreateOrConnectWithoutAcademicYearInput[]
    createMany?: TeachingAssignmentCreateManyAcademicYearInputEnvelope
    connect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
  }

  export type StudentAttendanceCreateNestedManyWithoutAcademicYearInput = {
    create?: XOR<StudentAttendanceCreateWithoutAcademicYearInput, StudentAttendanceUncheckedCreateWithoutAcademicYearInput> | StudentAttendanceCreateWithoutAcademicYearInput[] | StudentAttendanceUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutAcademicYearInput | StudentAttendanceCreateOrConnectWithoutAcademicYearInput[]
    createMany?: StudentAttendanceCreateManyAcademicYearInputEnvelope
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
  }

  export type AcademicCalendarCreateNestedManyWithoutAcademicYearInput = {
    create?: XOR<AcademicCalendarCreateWithoutAcademicYearInput, AcademicCalendarUncheckedCreateWithoutAcademicYearInput> | AcademicCalendarCreateWithoutAcademicYearInput[] | AcademicCalendarUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: AcademicCalendarCreateOrConnectWithoutAcademicYearInput | AcademicCalendarCreateOrConnectWithoutAcademicYearInput[]
    createMany?: AcademicCalendarCreateManyAcademicYearInputEnvelope
    connect?: AcademicCalendarWhereUniqueInput | AcademicCalendarWhereUniqueInput[]
  }

  export type ExamSessionCreateNestedManyWithoutAcademicYearInput = {
    create?: XOR<ExamSessionCreateWithoutAcademicYearInput, ExamSessionUncheckedCreateWithoutAcademicYearInput> | ExamSessionCreateWithoutAcademicYearInput[] | ExamSessionUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: ExamSessionCreateOrConnectWithoutAcademicYearInput | ExamSessionCreateOrConnectWithoutAcademicYearInput[]
    createMany?: ExamSessionCreateManyAcademicYearInputEnvelope
    connect?: ExamSessionWhereUniqueInput | ExamSessionWhereUniqueInput[]
  }

  export type AnonymousComplaintUncheckedCreateNestedManyWithoutAcademicYearInput = {
    create?: XOR<AnonymousComplaintCreateWithoutAcademicYearInput, AnonymousComplaintUncheckedCreateWithoutAcademicYearInput> | AnonymousComplaintCreateWithoutAcademicYearInput[] | AnonymousComplaintUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: AnonymousComplaintCreateOrConnectWithoutAcademicYearInput | AnonymousComplaintCreateOrConnectWithoutAcademicYearInput[]
    createMany?: AnonymousComplaintCreateManyAcademicYearInputEnvelope
    connect?: AnonymousComplaintWhereUniqueInput | AnonymousComplaintWhereUniqueInput[]
  }

  export type NoticeUncheckedCreateNestedManyWithoutAcademicYearInput = {
    create?: XOR<NoticeCreateWithoutAcademicYearInput, NoticeUncheckedCreateWithoutAcademicYearInput> | NoticeCreateWithoutAcademicYearInput[] | NoticeUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: NoticeCreateOrConnectWithoutAcademicYearInput | NoticeCreateOrConnectWithoutAcademicYearInput[]
    createMany?: NoticeCreateManyAcademicYearInputEnvelope
    connect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
  }

  export type TeachingAssignmentUncheckedCreateNestedManyWithoutAcademicYearInput = {
    create?: XOR<TeachingAssignmentCreateWithoutAcademicYearInput, TeachingAssignmentUncheckedCreateWithoutAcademicYearInput> | TeachingAssignmentCreateWithoutAcademicYearInput[] | TeachingAssignmentUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: TeachingAssignmentCreateOrConnectWithoutAcademicYearInput | TeachingAssignmentCreateOrConnectWithoutAcademicYearInput[]
    createMany?: TeachingAssignmentCreateManyAcademicYearInputEnvelope
    connect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
  }

  export type StudentAttendanceUncheckedCreateNestedManyWithoutAcademicYearInput = {
    create?: XOR<StudentAttendanceCreateWithoutAcademicYearInput, StudentAttendanceUncheckedCreateWithoutAcademicYearInput> | StudentAttendanceCreateWithoutAcademicYearInput[] | StudentAttendanceUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutAcademicYearInput | StudentAttendanceCreateOrConnectWithoutAcademicYearInput[]
    createMany?: StudentAttendanceCreateManyAcademicYearInputEnvelope
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
  }

  export type AcademicCalendarUncheckedCreateNestedManyWithoutAcademicYearInput = {
    create?: XOR<AcademicCalendarCreateWithoutAcademicYearInput, AcademicCalendarUncheckedCreateWithoutAcademicYearInput> | AcademicCalendarCreateWithoutAcademicYearInput[] | AcademicCalendarUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: AcademicCalendarCreateOrConnectWithoutAcademicYearInput | AcademicCalendarCreateOrConnectWithoutAcademicYearInput[]
    createMany?: AcademicCalendarCreateManyAcademicYearInputEnvelope
    connect?: AcademicCalendarWhereUniqueInput | AcademicCalendarWhereUniqueInput[]
  }

  export type ExamSessionUncheckedCreateNestedManyWithoutAcademicYearInput = {
    create?: XOR<ExamSessionCreateWithoutAcademicYearInput, ExamSessionUncheckedCreateWithoutAcademicYearInput> | ExamSessionCreateWithoutAcademicYearInput[] | ExamSessionUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: ExamSessionCreateOrConnectWithoutAcademicYearInput | ExamSessionCreateOrConnectWithoutAcademicYearInput[]
    createMany?: ExamSessionCreateManyAcademicYearInputEnvelope
    connect?: ExamSessionWhereUniqueInput | ExamSessionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumYearTypeFieldUpdateOperationsInput = {
    set?: $Enums.YearType
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type OrganizationUpdateOneRequiredWithoutAcademicYearNestedInput = {
    create?: XOR<OrganizationCreateWithoutAcademicYearInput, OrganizationUncheckedCreateWithoutAcademicYearInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutAcademicYearInput
    upsert?: OrganizationUpsertWithoutAcademicYearInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutAcademicYearInput, OrganizationUpdateWithoutAcademicYearInput>, OrganizationUncheckedUpdateWithoutAcademicYearInput>
  }

  export type AnonymousComplaintUpdateManyWithoutAcademicYearNestedInput = {
    create?: XOR<AnonymousComplaintCreateWithoutAcademicYearInput, AnonymousComplaintUncheckedCreateWithoutAcademicYearInput> | AnonymousComplaintCreateWithoutAcademicYearInput[] | AnonymousComplaintUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: AnonymousComplaintCreateOrConnectWithoutAcademicYearInput | AnonymousComplaintCreateOrConnectWithoutAcademicYearInput[]
    upsert?: AnonymousComplaintUpsertWithWhereUniqueWithoutAcademicYearInput | AnonymousComplaintUpsertWithWhereUniqueWithoutAcademicYearInput[]
    createMany?: AnonymousComplaintCreateManyAcademicYearInputEnvelope
    set?: AnonymousComplaintWhereUniqueInput | AnonymousComplaintWhereUniqueInput[]
    disconnect?: AnonymousComplaintWhereUniqueInput | AnonymousComplaintWhereUniqueInput[]
    delete?: AnonymousComplaintWhereUniqueInput | AnonymousComplaintWhereUniqueInput[]
    connect?: AnonymousComplaintWhereUniqueInput | AnonymousComplaintWhereUniqueInput[]
    update?: AnonymousComplaintUpdateWithWhereUniqueWithoutAcademicYearInput | AnonymousComplaintUpdateWithWhereUniqueWithoutAcademicYearInput[]
    updateMany?: AnonymousComplaintUpdateManyWithWhereWithoutAcademicYearInput | AnonymousComplaintUpdateManyWithWhereWithoutAcademicYearInput[]
    deleteMany?: AnonymousComplaintScalarWhereInput | AnonymousComplaintScalarWhereInput[]
  }

  export type NoticeUpdateManyWithoutAcademicYearNestedInput = {
    create?: XOR<NoticeCreateWithoutAcademicYearInput, NoticeUncheckedCreateWithoutAcademicYearInput> | NoticeCreateWithoutAcademicYearInput[] | NoticeUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: NoticeCreateOrConnectWithoutAcademicYearInput | NoticeCreateOrConnectWithoutAcademicYearInput[]
    upsert?: NoticeUpsertWithWhereUniqueWithoutAcademicYearInput | NoticeUpsertWithWhereUniqueWithoutAcademicYearInput[]
    createMany?: NoticeCreateManyAcademicYearInputEnvelope
    set?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    disconnect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    delete?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    connect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    update?: NoticeUpdateWithWhereUniqueWithoutAcademicYearInput | NoticeUpdateWithWhereUniqueWithoutAcademicYearInput[]
    updateMany?: NoticeUpdateManyWithWhereWithoutAcademicYearInput | NoticeUpdateManyWithWhereWithoutAcademicYearInput[]
    deleteMany?: NoticeScalarWhereInput | NoticeScalarWhereInput[]
  }

  export type TeachingAssignmentUpdateManyWithoutAcademicYearNestedInput = {
    create?: XOR<TeachingAssignmentCreateWithoutAcademicYearInput, TeachingAssignmentUncheckedCreateWithoutAcademicYearInput> | TeachingAssignmentCreateWithoutAcademicYearInput[] | TeachingAssignmentUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: TeachingAssignmentCreateOrConnectWithoutAcademicYearInput | TeachingAssignmentCreateOrConnectWithoutAcademicYearInput[]
    upsert?: TeachingAssignmentUpsertWithWhereUniqueWithoutAcademicYearInput | TeachingAssignmentUpsertWithWhereUniqueWithoutAcademicYearInput[]
    createMany?: TeachingAssignmentCreateManyAcademicYearInputEnvelope
    set?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    disconnect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    delete?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    connect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    update?: TeachingAssignmentUpdateWithWhereUniqueWithoutAcademicYearInput | TeachingAssignmentUpdateWithWhereUniqueWithoutAcademicYearInput[]
    updateMany?: TeachingAssignmentUpdateManyWithWhereWithoutAcademicYearInput | TeachingAssignmentUpdateManyWithWhereWithoutAcademicYearInput[]
    deleteMany?: TeachingAssignmentScalarWhereInput | TeachingAssignmentScalarWhereInput[]
  }

  export type StudentAttendanceUpdateManyWithoutAcademicYearNestedInput = {
    create?: XOR<StudentAttendanceCreateWithoutAcademicYearInput, StudentAttendanceUncheckedCreateWithoutAcademicYearInput> | StudentAttendanceCreateWithoutAcademicYearInput[] | StudentAttendanceUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutAcademicYearInput | StudentAttendanceCreateOrConnectWithoutAcademicYearInput[]
    upsert?: StudentAttendanceUpsertWithWhereUniqueWithoutAcademicYearInput | StudentAttendanceUpsertWithWhereUniqueWithoutAcademicYearInput[]
    createMany?: StudentAttendanceCreateManyAcademicYearInputEnvelope
    set?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    disconnect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    delete?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    update?: StudentAttendanceUpdateWithWhereUniqueWithoutAcademicYearInput | StudentAttendanceUpdateWithWhereUniqueWithoutAcademicYearInput[]
    updateMany?: StudentAttendanceUpdateManyWithWhereWithoutAcademicYearInput | StudentAttendanceUpdateManyWithWhereWithoutAcademicYearInput[]
    deleteMany?: StudentAttendanceScalarWhereInput | StudentAttendanceScalarWhereInput[]
  }

  export type AcademicCalendarUpdateManyWithoutAcademicYearNestedInput = {
    create?: XOR<AcademicCalendarCreateWithoutAcademicYearInput, AcademicCalendarUncheckedCreateWithoutAcademicYearInput> | AcademicCalendarCreateWithoutAcademicYearInput[] | AcademicCalendarUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: AcademicCalendarCreateOrConnectWithoutAcademicYearInput | AcademicCalendarCreateOrConnectWithoutAcademicYearInput[]
    upsert?: AcademicCalendarUpsertWithWhereUniqueWithoutAcademicYearInput | AcademicCalendarUpsertWithWhereUniqueWithoutAcademicYearInput[]
    createMany?: AcademicCalendarCreateManyAcademicYearInputEnvelope
    set?: AcademicCalendarWhereUniqueInput | AcademicCalendarWhereUniqueInput[]
    disconnect?: AcademicCalendarWhereUniqueInput | AcademicCalendarWhereUniqueInput[]
    delete?: AcademicCalendarWhereUniqueInput | AcademicCalendarWhereUniqueInput[]
    connect?: AcademicCalendarWhereUniqueInput | AcademicCalendarWhereUniqueInput[]
    update?: AcademicCalendarUpdateWithWhereUniqueWithoutAcademicYearInput | AcademicCalendarUpdateWithWhereUniqueWithoutAcademicYearInput[]
    updateMany?: AcademicCalendarUpdateManyWithWhereWithoutAcademicYearInput | AcademicCalendarUpdateManyWithWhereWithoutAcademicYearInput[]
    deleteMany?: AcademicCalendarScalarWhereInput | AcademicCalendarScalarWhereInput[]
  }

  export type ExamSessionUpdateManyWithoutAcademicYearNestedInput = {
    create?: XOR<ExamSessionCreateWithoutAcademicYearInput, ExamSessionUncheckedCreateWithoutAcademicYearInput> | ExamSessionCreateWithoutAcademicYearInput[] | ExamSessionUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: ExamSessionCreateOrConnectWithoutAcademicYearInput | ExamSessionCreateOrConnectWithoutAcademicYearInput[]
    upsert?: ExamSessionUpsertWithWhereUniqueWithoutAcademicYearInput | ExamSessionUpsertWithWhereUniqueWithoutAcademicYearInput[]
    createMany?: ExamSessionCreateManyAcademicYearInputEnvelope
    set?: ExamSessionWhereUniqueInput | ExamSessionWhereUniqueInput[]
    disconnect?: ExamSessionWhereUniqueInput | ExamSessionWhereUniqueInput[]
    delete?: ExamSessionWhereUniqueInput | ExamSessionWhereUniqueInput[]
    connect?: ExamSessionWhereUniqueInput | ExamSessionWhereUniqueInput[]
    update?: ExamSessionUpdateWithWhereUniqueWithoutAcademicYearInput | ExamSessionUpdateWithWhereUniqueWithoutAcademicYearInput[]
    updateMany?: ExamSessionUpdateManyWithWhereWithoutAcademicYearInput | ExamSessionUpdateManyWithWhereWithoutAcademicYearInput[]
    deleteMany?: ExamSessionScalarWhereInput | ExamSessionScalarWhereInput[]
  }

  export type AnonymousComplaintUncheckedUpdateManyWithoutAcademicYearNestedInput = {
    create?: XOR<AnonymousComplaintCreateWithoutAcademicYearInput, AnonymousComplaintUncheckedCreateWithoutAcademicYearInput> | AnonymousComplaintCreateWithoutAcademicYearInput[] | AnonymousComplaintUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: AnonymousComplaintCreateOrConnectWithoutAcademicYearInput | AnonymousComplaintCreateOrConnectWithoutAcademicYearInput[]
    upsert?: AnonymousComplaintUpsertWithWhereUniqueWithoutAcademicYearInput | AnonymousComplaintUpsertWithWhereUniqueWithoutAcademicYearInput[]
    createMany?: AnonymousComplaintCreateManyAcademicYearInputEnvelope
    set?: AnonymousComplaintWhereUniqueInput | AnonymousComplaintWhereUniqueInput[]
    disconnect?: AnonymousComplaintWhereUniqueInput | AnonymousComplaintWhereUniqueInput[]
    delete?: AnonymousComplaintWhereUniqueInput | AnonymousComplaintWhereUniqueInput[]
    connect?: AnonymousComplaintWhereUniqueInput | AnonymousComplaintWhereUniqueInput[]
    update?: AnonymousComplaintUpdateWithWhereUniqueWithoutAcademicYearInput | AnonymousComplaintUpdateWithWhereUniqueWithoutAcademicYearInput[]
    updateMany?: AnonymousComplaintUpdateManyWithWhereWithoutAcademicYearInput | AnonymousComplaintUpdateManyWithWhereWithoutAcademicYearInput[]
    deleteMany?: AnonymousComplaintScalarWhereInput | AnonymousComplaintScalarWhereInput[]
  }

  export type NoticeUncheckedUpdateManyWithoutAcademicYearNestedInput = {
    create?: XOR<NoticeCreateWithoutAcademicYearInput, NoticeUncheckedCreateWithoutAcademicYearInput> | NoticeCreateWithoutAcademicYearInput[] | NoticeUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: NoticeCreateOrConnectWithoutAcademicYearInput | NoticeCreateOrConnectWithoutAcademicYearInput[]
    upsert?: NoticeUpsertWithWhereUniqueWithoutAcademicYearInput | NoticeUpsertWithWhereUniqueWithoutAcademicYearInput[]
    createMany?: NoticeCreateManyAcademicYearInputEnvelope
    set?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    disconnect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    delete?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    connect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    update?: NoticeUpdateWithWhereUniqueWithoutAcademicYearInput | NoticeUpdateWithWhereUniqueWithoutAcademicYearInput[]
    updateMany?: NoticeUpdateManyWithWhereWithoutAcademicYearInput | NoticeUpdateManyWithWhereWithoutAcademicYearInput[]
    deleteMany?: NoticeScalarWhereInput | NoticeScalarWhereInput[]
  }

  export type TeachingAssignmentUncheckedUpdateManyWithoutAcademicYearNestedInput = {
    create?: XOR<TeachingAssignmentCreateWithoutAcademicYearInput, TeachingAssignmentUncheckedCreateWithoutAcademicYearInput> | TeachingAssignmentCreateWithoutAcademicYearInput[] | TeachingAssignmentUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: TeachingAssignmentCreateOrConnectWithoutAcademicYearInput | TeachingAssignmentCreateOrConnectWithoutAcademicYearInput[]
    upsert?: TeachingAssignmentUpsertWithWhereUniqueWithoutAcademicYearInput | TeachingAssignmentUpsertWithWhereUniqueWithoutAcademicYearInput[]
    createMany?: TeachingAssignmentCreateManyAcademicYearInputEnvelope
    set?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    disconnect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    delete?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    connect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    update?: TeachingAssignmentUpdateWithWhereUniqueWithoutAcademicYearInput | TeachingAssignmentUpdateWithWhereUniqueWithoutAcademicYearInput[]
    updateMany?: TeachingAssignmentUpdateManyWithWhereWithoutAcademicYearInput | TeachingAssignmentUpdateManyWithWhereWithoutAcademicYearInput[]
    deleteMany?: TeachingAssignmentScalarWhereInput | TeachingAssignmentScalarWhereInput[]
  }

  export type StudentAttendanceUncheckedUpdateManyWithoutAcademicYearNestedInput = {
    create?: XOR<StudentAttendanceCreateWithoutAcademicYearInput, StudentAttendanceUncheckedCreateWithoutAcademicYearInput> | StudentAttendanceCreateWithoutAcademicYearInput[] | StudentAttendanceUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutAcademicYearInput | StudentAttendanceCreateOrConnectWithoutAcademicYearInput[]
    upsert?: StudentAttendanceUpsertWithWhereUniqueWithoutAcademicYearInput | StudentAttendanceUpsertWithWhereUniqueWithoutAcademicYearInput[]
    createMany?: StudentAttendanceCreateManyAcademicYearInputEnvelope
    set?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    disconnect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    delete?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    update?: StudentAttendanceUpdateWithWhereUniqueWithoutAcademicYearInput | StudentAttendanceUpdateWithWhereUniqueWithoutAcademicYearInput[]
    updateMany?: StudentAttendanceUpdateManyWithWhereWithoutAcademicYearInput | StudentAttendanceUpdateManyWithWhereWithoutAcademicYearInput[]
    deleteMany?: StudentAttendanceScalarWhereInput | StudentAttendanceScalarWhereInput[]
  }

  export type AcademicCalendarUncheckedUpdateManyWithoutAcademicYearNestedInput = {
    create?: XOR<AcademicCalendarCreateWithoutAcademicYearInput, AcademicCalendarUncheckedCreateWithoutAcademicYearInput> | AcademicCalendarCreateWithoutAcademicYearInput[] | AcademicCalendarUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: AcademicCalendarCreateOrConnectWithoutAcademicYearInput | AcademicCalendarCreateOrConnectWithoutAcademicYearInput[]
    upsert?: AcademicCalendarUpsertWithWhereUniqueWithoutAcademicYearInput | AcademicCalendarUpsertWithWhereUniqueWithoutAcademicYearInput[]
    createMany?: AcademicCalendarCreateManyAcademicYearInputEnvelope
    set?: AcademicCalendarWhereUniqueInput | AcademicCalendarWhereUniqueInput[]
    disconnect?: AcademicCalendarWhereUniqueInput | AcademicCalendarWhereUniqueInput[]
    delete?: AcademicCalendarWhereUniqueInput | AcademicCalendarWhereUniqueInput[]
    connect?: AcademicCalendarWhereUniqueInput | AcademicCalendarWhereUniqueInput[]
    update?: AcademicCalendarUpdateWithWhereUniqueWithoutAcademicYearInput | AcademicCalendarUpdateWithWhereUniqueWithoutAcademicYearInput[]
    updateMany?: AcademicCalendarUpdateManyWithWhereWithoutAcademicYearInput | AcademicCalendarUpdateManyWithWhereWithoutAcademicYearInput[]
    deleteMany?: AcademicCalendarScalarWhereInput | AcademicCalendarScalarWhereInput[]
  }

  export type ExamSessionUncheckedUpdateManyWithoutAcademicYearNestedInput = {
    create?: XOR<ExamSessionCreateWithoutAcademicYearInput, ExamSessionUncheckedCreateWithoutAcademicYearInput> | ExamSessionCreateWithoutAcademicYearInput[] | ExamSessionUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: ExamSessionCreateOrConnectWithoutAcademicYearInput | ExamSessionCreateOrConnectWithoutAcademicYearInput[]
    upsert?: ExamSessionUpsertWithWhereUniqueWithoutAcademicYearInput | ExamSessionUpsertWithWhereUniqueWithoutAcademicYearInput[]
    createMany?: ExamSessionCreateManyAcademicYearInputEnvelope
    set?: ExamSessionWhereUniqueInput | ExamSessionWhereUniqueInput[]
    disconnect?: ExamSessionWhereUniqueInput | ExamSessionWhereUniqueInput[]
    delete?: ExamSessionWhereUniqueInput | ExamSessionWhereUniqueInput[]
    connect?: ExamSessionWhereUniqueInput | ExamSessionWhereUniqueInput[]
    update?: ExamSessionUpdateWithWhereUniqueWithoutAcademicYearInput | ExamSessionUpdateWithWhereUniqueWithoutAcademicYearInput[]
    updateMany?: ExamSessionUpdateManyWithWhereWithoutAcademicYearInput | ExamSessionUpdateManyWithWhereWithoutAcademicYearInput[]
    deleteMany?: ExamSessionScalarWhereInput | ExamSessionScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type NoticeCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<NoticeCreateWithoutOrganizationInput, NoticeUncheckedCreateWithoutOrganizationInput> | NoticeCreateWithoutOrganizationInput[] | NoticeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: NoticeCreateOrConnectWithoutOrganizationInput | NoticeCreateOrConnectWithoutOrganizationInput[]
    createMany?: NoticeCreateManyOrganizationInputEnvelope
    connect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<StudentCreateWithoutOrganizationInput, StudentUncheckedCreateWithoutOrganizationInput> | StudentCreateWithoutOrganizationInput[] | StudentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutOrganizationInput | StudentCreateOrConnectWithoutOrganizationInput[]
    createMany?: StudentCreateManyOrganizationInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type StudentDocumentCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<StudentDocumentCreateWithoutOrganizationInput, StudentDocumentUncheckedCreateWithoutOrganizationInput> | StudentDocumentCreateWithoutOrganizationInput[] | StudentDocumentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: StudentDocumentCreateOrConnectWithoutOrganizationInput | StudentDocumentCreateOrConnectWithoutOrganizationInput[]
    createMany?: StudentDocumentCreateManyOrganizationInputEnvelope
    connect?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
  }

  export type GradeCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<GradeCreateWithoutOrganizationInput, GradeUncheckedCreateWithoutOrganizationInput> | GradeCreateWithoutOrganizationInput[] | GradeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutOrganizationInput | GradeCreateOrConnectWithoutOrganizationInput[]
    createMany?: GradeCreateManyOrganizationInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type SectionCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<SectionCreateWithoutOrganizationInput, SectionUncheckedCreateWithoutOrganizationInput> | SectionCreateWithoutOrganizationInput[] | SectionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutOrganizationInput | SectionCreateOrConnectWithoutOrganizationInput[]
    createMany?: SectionCreateManyOrganizationInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type FeeCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<FeeCreateWithoutOrganizationInput, FeeUncheckedCreateWithoutOrganizationInput> | FeeCreateWithoutOrganizationInput[] | FeeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: FeeCreateOrConnectWithoutOrganizationInput | FeeCreateOrConnectWithoutOrganizationInput[]
    createMany?: FeeCreateManyOrganizationInputEnvelope
    connect?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
  }

  export type FeeCategoryCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<FeeCategoryCreateWithoutOrganizationInput, FeeCategoryUncheckedCreateWithoutOrganizationInput> | FeeCategoryCreateWithoutOrganizationInput[] | FeeCategoryUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: FeeCategoryCreateOrConnectWithoutOrganizationInput | FeeCategoryCreateOrConnectWithoutOrganizationInput[]
    createMany?: FeeCategoryCreateManyOrganizationInputEnvelope
    connect?: FeeCategoryWhereUniqueInput | FeeCategoryWhereUniqueInput[]
  }

  export type FeePaymentCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<FeePaymentCreateWithoutOrganizationInput, FeePaymentUncheckedCreateWithoutOrganizationInput> | FeePaymentCreateWithoutOrganizationInput[] | FeePaymentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: FeePaymentCreateOrConnectWithoutOrganizationInput | FeePaymentCreateOrConnectWithoutOrganizationInput[]
    createMany?: FeePaymentCreateManyOrganizationInputEnvelope
    connect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
  }

  export type AcademicCalendarCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<AcademicCalendarCreateWithoutOrganizationInput, AcademicCalendarUncheckedCreateWithoutOrganizationInput> | AcademicCalendarCreateWithoutOrganizationInput[] | AcademicCalendarUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AcademicCalendarCreateOrConnectWithoutOrganizationInput | AcademicCalendarCreateOrConnectWithoutOrganizationInput[]
    createMany?: AcademicCalendarCreateManyOrganizationInputEnvelope
    connect?: AcademicCalendarWhereUniqueInput | AcademicCalendarWhereUniqueInput[]
  }

  export type AnonymousComplaintCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<AnonymousComplaintCreateWithoutOrganizationInput, AnonymousComplaintUncheckedCreateWithoutOrganizationInput> | AnonymousComplaintCreateWithoutOrganizationInput[] | AnonymousComplaintUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AnonymousComplaintCreateOrConnectWithoutOrganizationInput | AnonymousComplaintCreateOrConnectWithoutOrganizationInput[]
    createMany?: AnonymousComplaintCreateManyOrganizationInputEnvelope
    connect?: AnonymousComplaintWhereUniqueInput | AnonymousComplaintWhereUniqueInput[]
  }

  export type TeacherCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<TeacherCreateWithoutOrganizationInput, TeacherUncheckedCreateWithoutOrganizationInput> | TeacherCreateWithoutOrganizationInput[] | TeacherUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: TeacherCreateOrConnectWithoutOrganizationInput | TeacherCreateOrConnectWithoutOrganizationInput[]
    createMany?: TeacherCreateManyOrganizationInputEnvelope
    connect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
  }

  export type SubjectCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<SubjectCreateWithoutOrganizationInput, SubjectUncheckedCreateWithoutOrganizationInput> | SubjectCreateWithoutOrganizationInput[] | SubjectUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutOrganizationInput | SubjectCreateOrConnectWithoutOrganizationInput[]
    createMany?: SubjectCreateManyOrganizationInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type TeachingAssignmentCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<TeachingAssignmentCreateWithoutOrganizationInput, TeachingAssignmentUncheckedCreateWithoutOrganizationInput> | TeachingAssignmentCreateWithoutOrganizationInput[] | TeachingAssignmentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: TeachingAssignmentCreateOrConnectWithoutOrganizationInput | TeachingAssignmentCreateOrConnectWithoutOrganizationInput[]
    createMany?: TeachingAssignmentCreateManyOrganizationInputEnvelope
    connect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
  }

  export type NotificationLogCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<NotificationLogCreateWithoutOrganizationInput, NotificationLogUncheckedCreateWithoutOrganizationInput> | NotificationLogCreateWithoutOrganizationInput[] | NotificationLogUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutOrganizationInput | NotificationLogCreateOrConnectWithoutOrganizationInput[]
    createMany?: NotificationLogCreateManyOrganizationInputEnvelope
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
  }

  export type AcademicYearCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<AcademicYearCreateWithoutOrganizationInput, AcademicYearUncheckedCreateWithoutOrganizationInput> | AcademicYearCreateWithoutOrganizationInput[] | AcademicYearUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AcademicYearCreateOrConnectWithoutOrganizationInput | AcademicYearCreateOrConnectWithoutOrganizationInput[]
    createMany?: AcademicYearCreateManyOrganizationInputEnvelope
    connect?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
  }

  export type ScheduledJobCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ScheduledJobCreateWithoutOrganizationInput, ScheduledJobUncheckedCreateWithoutOrganizationInput> | ScheduledJobCreateWithoutOrganizationInput[] | ScheduledJobUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ScheduledJobCreateOrConnectWithoutOrganizationInput | ScheduledJobCreateOrConnectWithoutOrganizationInput[]
    createMany?: ScheduledJobCreateManyOrganizationInputEnvelope
    connect?: ScheduledJobWhereUniqueInput | ScheduledJobWhereUniqueInput[]
  }

  export type ExamCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ExamCreateWithoutOrganizationInput, ExamUncheckedCreateWithoutOrganizationInput> | ExamCreateWithoutOrganizationInput[] | ExamUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutOrganizationInput | ExamCreateOrConnectWithoutOrganizationInput[]
    createMany?: ExamCreateManyOrganizationInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type HallTicketCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<HallTicketCreateWithoutOrganizationInput, HallTicketUncheckedCreateWithoutOrganizationInput> | HallTicketCreateWithoutOrganizationInput[] | HallTicketUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: HallTicketCreateOrConnectWithoutOrganizationInput | HallTicketCreateOrConnectWithoutOrganizationInput[]
    createMany?: HallTicketCreateManyOrganizationInputEnvelope
    connect?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type NoticeUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<NoticeCreateWithoutOrganizationInput, NoticeUncheckedCreateWithoutOrganizationInput> | NoticeCreateWithoutOrganizationInput[] | NoticeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: NoticeCreateOrConnectWithoutOrganizationInput | NoticeCreateOrConnectWithoutOrganizationInput[]
    createMany?: NoticeCreateManyOrganizationInputEnvelope
    connect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<StudentCreateWithoutOrganizationInput, StudentUncheckedCreateWithoutOrganizationInput> | StudentCreateWithoutOrganizationInput[] | StudentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutOrganizationInput | StudentCreateOrConnectWithoutOrganizationInput[]
    createMany?: StudentCreateManyOrganizationInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type StudentDocumentUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<StudentDocumentCreateWithoutOrganizationInput, StudentDocumentUncheckedCreateWithoutOrganizationInput> | StudentDocumentCreateWithoutOrganizationInput[] | StudentDocumentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: StudentDocumentCreateOrConnectWithoutOrganizationInput | StudentDocumentCreateOrConnectWithoutOrganizationInput[]
    createMany?: StudentDocumentCreateManyOrganizationInputEnvelope
    connect?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
  }

  export type GradeUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<GradeCreateWithoutOrganizationInput, GradeUncheckedCreateWithoutOrganizationInput> | GradeCreateWithoutOrganizationInput[] | GradeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutOrganizationInput | GradeCreateOrConnectWithoutOrganizationInput[]
    createMany?: GradeCreateManyOrganizationInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type SectionUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<SectionCreateWithoutOrganizationInput, SectionUncheckedCreateWithoutOrganizationInput> | SectionCreateWithoutOrganizationInput[] | SectionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutOrganizationInput | SectionCreateOrConnectWithoutOrganizationInput[]
    createMany?: SectionCreateManyOrganizationInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type FeeUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<FeeCreateWithoutOrganizationInput, FeeUncheckedCreateWithoutOrganizationInput> | FeeCreateWithoutOrganizationInput[] | FeeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: FeeCreateOrConnectWithoutOrganizationInput | FeeCreateOrConnectWithoutOrganizationInput[]
    createMany?: FeeCreateManyOrganizationInputEnvelope
    connect?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
  }

  export type FeeCategoryUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<FeeCategoryCreateWithoutOrganizationInput, FeeCategoryUncheckedCreateWithoutOrganizationInput> | FeeCategoryCreateWithoutOrganizationInput[] | FeeCategoryUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: FeeCategoryCreateOrConnectWithoutOrganizationInput | FeeCategoryCreateOrConnectWithoutOrganizationInput[]
    createMany?: FeeCategoryCreateManyOrganizationInputEnvelope
    connect?: FeeCategoryWhereUniqueInput | FeeCategoryWhereUniqueInput[]
  }

  export type FeePaymentUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<FeePaymentCreateWithoutOrganizationInput, FeePaymentUncheckedCreateWithoutOrganizationInput> | FeePaymentCreateWithoutOrganizationInput[] | FeePaymentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: FeePaymentCreateOrConnectWithoutOrganizationInput | FeePaymentCreateOrConnectWithoutOrganizationInput[]
    createMany?: FeePaymentCreateManyOrganizationInputEnvelope
    connect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
  }

  export type AcademicCalendarUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<AcademicCalendarCreateWithoutOrganizationInput, AcademicCalendarUncheckedCreateWithoutOrganizationInput> | AcademicCalendarCreateWithoutOrganizationInput[] | AcademicCalendarUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AcademicCalendarCreateOrConnectWithoutOrganizationInput | AcademicCalendarCreateOrConnectWithoutOrganizationInput[]
    createMany?: AcademicCalendarCreateManyOrganizationInputEnvelope
    connect?: AcademicCalendarWhereUniqueInput | AcademicCalendarWhereUniqueInput[]
  }

  export type AnonymousComplaintUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<AnonymousComplaintCreateWithoutOrganizationInput, AnonymousComplaintUncheckedCreateWithoutOrganizationInput> | AnonymousComplaintCreateWithoutOrganizationInput[] | AnonymousComplaintUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AnonymousComplaintCreateOrConnectWithoutOrganizationInput | AnonymousComplaintCreateOrConnectWithoutOrganizationInput[]
    createMany?: AnonymousComplaintCreateManyOrganizationInputEnvelope
    connect?: AnonymousComplaintWhereUniqueInput | AnonymousComplaintWhereUniqueInput[]
  }

  export type TeacherUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<TeacherCreateWithoutOrganizationInput, TeacherUncheckedCreateWithoutOrganizationInput> | TeacherCreateWithoutOrganizationInput[] | TeacherUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: TeacherCreateOrConnectWithoutOrganizationInput | TeacherCreateOrConnectWithoutOrganizationInput[]
    createMany?: TeacherCreateManyOrganizationInputEnvelope
    connect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
  }

  export type SubjectUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<SubjectCreateWithoutOrganizationInput, SubjectUncheckedCreateWithoutOrganizationInput> | SubjectCreateWithoutOrganizationInput[] | SubjectUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutOrganizationInput | SubjectCreateOrConnectWithoutOrganizationInput[]
    createMany?: SubjectCreateManyOrganizationInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type TeachingAssignmentUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<TeachingAssignmentCreateWithoutOrganizationInput, TeachingAssignmentUncheckedCreateWithoutOrganizationInput> | TeachingAssignmentCreateWithoutOrganizationInput[] | TeachingAssignmentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: TeachingAssignmentCreateOrConnectWithoutOrganizationInput | TeachingAssignmentCreateOrConnectWithoutOrganizationInput[]
    createMany?: TeachingAssignmentCreateManyOrganizationInputEnvelope
    connect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
  }

  export type NotificationLogUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<NotificationLogCreateWithoutOrganizationInput, NotificationLogUncheckedCreateWithoutOrganizationInput> | NotificationLogCreateWithoutOrganizationInput[] | NotificationLogUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutOrganizationInput | NotificationLogCreateOrConnectWithoutOrganizationInput[]
    createMany?: NotificationLogCreateManyOrganizationInputEnvelope
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
  }

  export type AcademicYearUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<AcademicYearCreateWithoutOrganizationInput, AcademicYearUncheckedCreateWithoutOrganizationInput> | AcademicYearCreateWithoutOrganizationInput[] | AcademicYearUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AcademicYearCreateOrConnectWithoutOrganizationInput | AcademicYearCreateOrConnectWithoutOrganizationInput[]
    createMany?: AcademicYearCreateManyOrganizationInputEnvelope
    connect?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
  }

  export type ScheduledJobUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ScheduledJobCreateWithoutOrganizationInput, ScheduledJobUncheckedCreateWithoutOrganizationInput> | ScheduledJobCreateWithoutOrganizationInput[] | ScheduledJobUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ScheduledJobCreateOrConnectWithoutOrganizationInput | ScheduledJobCreateOrConnectWithoutOrganizationInput[]
    createMany?: ScheduledJobCreateManyOrganizationInputEnvelope
    connect?: ScheduledJobWhereUniqueInput | ScheduledJobWhereUniqueInput[]
  }

  export type ExamUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ExamCreateWithoutOrganizationInput, ExamUncheckedCreateWithoutOrganizationInput> | ExamCreateWithoutOrganizationInput[] | ExamUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutOrganizationInput | ExamCreateOrConnectWithoutOrganizationInput[]
    createMany?: ExamCreateManyOrganizationInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type HallTicketUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<HallTicketCreateWithoutOrganizationInput, HallTicketUncheckedCreateWithoutOrganizationInput> | HallTicketCreateWithoutOrganizationInput[] | HallTicketUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: HallTicketCreateOrConnectWithoutOrganizationInput | HallTicketCreateOrConnectWithoutOrganizationInput[]
    createMany?: HallTicketCreateManyOrganizationInputEnvelope
    connect?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
  }

  export type EnumPlanTypeFieldUpdateOperationsInput = {
    set?: $Enums.PlanType
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumOrganizationTypeFieldUpdateOperationsInput = {
    set?: $Enums.OrganizationType | null
  }

  export type UserUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOrganizationInput | UserUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOrganizationInput | UserUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOrganizationInput | UserUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type NoticeUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<NoticeCreateWithoutOrganizationInput, NoticeUncheckedCreateWithoutOrganizationInput> | NoticeCreateWithoutOrganizationInput[] | NoticeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: NoticeCreateOrConnectWithoutOrganizationInput | NoticeCreateOrConnectWithoutOrganizationInput[]
    upsert?: NoticeUpsertWithWhereUniqueWithoutOrganizationInput | NoticeUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: NoticeCreateManyOrganizationInputEnvelope
    set?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    disconnect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    delete?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    connect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    update?: NoticeUpdateWithWhereUniqueWithoutOrganizationInput | NoticeUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: NoticeUpdateManyWithWhereWithoutOrganizationInput | NoticeUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: NoticeScalarWhereInput | NoticeScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<StudentCreateWithoutOrganizationInput, StudentUncheckedCreateWithoutOrganizationInput> | StudentCreateWithoutOrganizationInput[] | StudentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutOrganizationInput | StudentCreateOrConnectWithoutOrganizationInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutOrganizationInput | StudentUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: StudentCreateManyOrganizationInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutOrganizationInput | StudentUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutOrganizationInput | StudentUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type StudentDocumentUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<StudentDocumentCreateWithoutOrganizationInput, StudentDocumentUncheckedCreateWithoutOrganizationInput> | StudentDocumentCreateWithoutOrganizationInput[] | StudentDocumentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: StudentDocumentCreateOrConnectWithoutOrganizationInput | StudentDocumentCreateOrConnectWithoutOrganizationInput[]
    upsert?: StudentDocumentUpsertWithWhereUniqueWithoutOrganizationInput | StudentDocumentUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: StudentDocumentCreateManyOrganizationInputEnvelope
    set?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
    disconnect?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
    delete?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
    connect?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
    update?: StudentDocumentUpdateWithWhereUniqueWithoutOrganizationInput | StudentDocumentUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: StudentDocumentUpdateManyWithWhereWithoutOrganizationInput | StudentDocumentUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: StudentDocumentScalarWhereInput | StudentDocumentScalarWhereInput[]
  }

  export type GradeUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<GradeCreateWithoutOrganizationInput, GradeUncheckedCreateWithoutOrganizationInput> | GradeCreateWithoutOrganizationInput[] | GradeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutOrganizationInput | GradeCreateOrConnectWithoutOrganizationInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutOrganizationInput | GradeUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: GradeCreateManyOrganizationInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutOrganizationInput | GradeUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutOrganizationInput | GradeUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type SectionUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<SectionCreateWithoutOrganizationInput, SectionUncheckedCreateWithoutOrganizationInput> | SectionCreateWithoutOrganizationInput[] | SectionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutOrganizationInput | SectionCreateOrConnectWithoutOrganizationInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutOrganizationInput | SectionUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: SectionCreateManyOrganizationInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutOrganizationInput | SectionUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutOrganizationInput | SectionUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type FeeUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<FeeCreateWithoutOrganizationInput, FeeUncheckedCreateWithoutOrganizationInput> | FeeCreateWithoutOrganizationInput[] | FeeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: FeeCreateOrConnectWithoutOrganizationInput | FeeCreateOrConnectWithoutOrganizationInput[]
    upsert?: FeeUpsertWithWhereUniqueWithoutOrganizationInput | FeeUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: FeeCreateManyOrganizationInputEnvelope
    set?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
    disconnect?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
    delete?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
    connect?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
    update?: FeeUpdateWithWhereUniqueWithoutOrganizationInput | FeeUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: FeeUpdateManyWithWhereWithoutOrganizationInput | FeeUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: FeeScalarWhereInput | FeeScalarWhereInput[]
  }

  export type FeeCategoryUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<FeeCategoryCreateWithoutOrganizationInput, FeeCategoryUncheckedCreateWithoutOrganizationInput> | FeeCategoryCreateWithoutOrganizationInput[] | FeeCategoryUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: FeeCategoryCreateOrConnectWithoutOrganizationInput | FeeCategoryCreateOrConnectWithoutOrganizationInput[]
    upsert?: FeeCategoryUpsertWithWhereUniqueWithoutOrganizationInput | FeeCategoryUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: FeeCategoryCreateManyOrganizationInputEnvelope
    set?: FeeCategoryWhereUniqueInput | FeeCategoryWhereUniqueInput[]
    disconnect?: FeeCategoryWhereUniqueInput | FeeCategoryWhereUniqueInput[]
    delete?: FeeCategoryWhereUniqueInput | FeeCategoryWhereUniqueInput[]
    connect?: FeeCategoryWhereUniqueInput | FeeCategoryWhereUniqueInput[]
    update?: FeeCategoryUpdateWithWhereUniqueWithoutOrganizationInput | FeeCategoryUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: FeeCategoryUpdateManyWithWhereWithoutOrganizationInput | FeeCategoryUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: FeeCategoryScalarWhereInput | FeeCategoryScalarWhereInput[]
  }

  export type FeePaymentUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<FeePaymentCreateWithoutOrganizationInput, FeePaymentUncheckedCreateWithoutOrganizationInput> | FeePaymentCreateWithoutOrganizationInput[] | FeePaymentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: FeePaymentCreateOrConnectWithoutOrganizationInput | FeePaymentCreateOrConnectWithoutOrganizationInput[]
    upsert?: FeePaymentUpsertWithWhereUniqueWithoutOrganizationInput | FeePaymentUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: FeePaymentCreateManyOrganizationInputEnvelope
    set?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    disconnect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    delete?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    connect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    update?: FeePaymentUpdateWithWhereUniqueWithoutOrganizationInput | FeePaymentUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: FeePaymentUpdateManyWithWhereWithoutOrganizationInput | FeePaymentUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: FeePaymentScalarWhereInput | FeePaymentScalarWhereInput[]
  }

  export type AcademicCalendarUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<AcademicCalendarCreateWithoutOrganizationInput, AcademicCalendarUncheckedCreateWithoutOrganizationInput> | AcademicCalendarCreateWithoutOrganizationInput[] | AcademicCalendarUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AcademicCalendarCreateOrConnectWithoutOrganizationInput | AcademicCalendarCreateOrConnectWithoutOrganizationInput[]
    upsert?: AcademicCalendarUpsertWithWhereUniqueWithoutOrganizationInput | AcademicCalendarUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: AcademicCalendarCreateManyOrganizationInputEnvelope
    set?: AcademicCalendarWhereUniqueInput | AcademicCalendarWhereUniqueInput[]
    disconnect?: AcademicCalendarWhereUniqueInput | AcademicCalendarWhereUniqueInput[]
    delete?: AcademicCalendarWhereUniqueInput | AcademicCalendarWhereUniqueInput[]
    connect?: AcademicCalendarWhereUniqueInput | AcademicCalendarWhereUniqueInput[]
    update?: AcademicCalendarUpdateWithWhereUniqueWithoutOrganizationInput | AcademicCalendarUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: AcademicCalendarUpdateManyWithWhereWithoutOrganizationInput | AcademicCalendarUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: AcademicCalendarScalarWhereInput | AcademicCalendarScalarWhereInput[]
  }

  export type AnonymousComplaintUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<AnonymousComplaintCreateWithoutOrganizationInput, AnonymousComplaintUncheckedCreateWithoutOrganizationInput> | AnonymousComplaintCreateWithoutOrganizationInput[] | AnonymousComplaintUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AnonymousComplaintCreateOrConnectWithoutOrganizationInput | AnonymousComplaintCreateOrConnectWithoutOrganizationInput[]
    upsert?: AnonymousComplaintUpsertWithWhereUniqueWithoutOrganizationInput | AnonymousComplaintUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: AnonymousComplaintCreateManyOrganizationInputEnvelope
    set?: AnonymousComplaintWhereUniqueInput | AnonymousComplaintWhereUniqueInput[]
    disconnect?: AnonymousComplaintWhereUniqueInput | AnonymousComplaintWhereUniqueInput[]
    delete?: AnonymousComplaintWhereUniqueInput | AnonymousComplaintWhereUniqueInput[]
    connect?: AnonymousComplaintWhereUniqueInput | AnonymousComplaintWhereUniqueInput[]
    update?: AnonymousComplaintUpdateWithWhereUniqueWithoutOrganizationInput | AnonymousComplaintUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: AnonymousComplaintUpdateManyWithWhereWithoutOrganizationInput | AnonymousComplaintUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: AnonymousComplaintScalarWhereInput | AnonymousComplaintScalarWhereInput[]
  }

  export type TeacherUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<TeacherCreateWithoutOrganizationInput, TeacherUncheckedCreateWithoutOrganizationInput> | TeacherCreateWithoutOrganizationInput[] | TeacherUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: TeacherCreateOrConnectWithoutOrganizationInput | TeacherCreateOrConnectWithoutOrganizationInput[]
    upsert?: TeacherUpsertWithWhereUniqueWithoutOrganizationInput | TeacherUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: TeacherCreateManyOrganizationInputEnvelope
    set?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    disconnect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    delete?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    connect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    update?: TeacherUpdateWithWhereUniqueWithoutOrganizationInput | TeacherUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: TeacherUpdateManyWithWhereWithoutOrganizationInput | TeacherUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: TeacherScalarWhereInput | TeacherScalarWhereInput[]
  }

  export type SubjectUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<SubjectCreateWithoutOrganizationInput, SubjectUncheckedCreateWithoutOrganizationInput> | SubjectCreateWithoutOrganizationInput[] | SubjectUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutOrganizationInput | SubjectCreateOrConnectWithoutOrganizationInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutOrganizationInput | SubjectUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: SubjectCreateManyOrganizationInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutOrganizationInput | SubjectUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutOrganizationInput | SubjectUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type TeachingAssignmentUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<TeachingAssignmentCreateWithoutOrganizationInput, TeachingAssignmentUncheckedCreateWithoutOrganizationInput> | TeachingAssignmentCreateWithoutOrganizationInput[] | TeachingAssignmentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: TeachingAssignmentCreateOrConnectWithoutOrganizationInput | TeachingAssignmentCreateOrConnectWithoutOrganizationInput[]
    upsert?: TeachingAssignmentUpsertWithWhereUniqueWithoutOrganizationInput | TeachingAssignmentUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: TeachingAssignmentCreateManyOrganizationInputEnvelope
    set?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    disconnect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    delete?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    connect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    update?: TeachingAssignmentUpdateWithWhereUniqueWithoutOrganizationInput | TeachingAssignmentUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: TeachingAssignmentUpdateManyWithWhereWithoutOrganizationInput | TeachingAssignmentUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: TeachingAssignmentScalarWhereInput | TeachingAssignmentScalarWhereInput[]
  }

  export type NotificationLogUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<NotificationLogCreateWithoutOrganizationInput, NotificationLogUncheckedCreateWithoutOrganizationInput> | NotificationLogCreateWithoutOrganizationInput[] | NotificationLogUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutOrganizationInput | NotificationLogCreateOrConnectWithoutOrganizationInput[]
    upsert?: NotificationLogUpsertWithWhereUniqueWithoutOrganizationInput | NotificationLogUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: NotificationLogCreateManyOrganizationInputEnvelope
    set?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    disconnect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    delete?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    update?: NotificationLogUpdateWithWhereUniqueWithoutOrganizationInput | NotificationLogUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: NotificationLogUpdateManyWithWhereWithoutOrganizationInput | NotificationLogUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
  }

  export type AcademicYearUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<AcademicYearCreateWithoutOrganizationInput, AcademicYearUncheckedCreateWithoutOrganizationInput> | AcademicYearCreateWithoutOrganizationInput[] | AcademicYearUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AcademicYearCreateOrConnectWithoutOrganizationInput | AcademicYearCreateOrConnectWithoutOrganizationInput[]
    upsert?: AcademicYearUpsertWithWhereUniqueWithoutOrganizationInput | AcademicYearUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: AcademicYearCreateManyOrganizationInputEnvelope
    set?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
    disconnect?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
    delete?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
    connect?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
    update?: AcademicYearUpdateWithWhereUniqueWithoutOrganizationInput | AcademicYearUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: AcademicYearUpdateManyWithWhereWithoutOrganizationInput | AcademicYearUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: AcademicYearScalarWhereInput | AcademicYearScalarWhereInput[]
  }

  export type ScheduledJobUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ScheduledJobCreateWithoutOrganizationInput, ScheduledJobUncheckedCreateWithoutOrganizationInput> | ScheduledJobCreateWithoutOrganizationInput[] | ScheduledJobUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ScheduledJobCreateOrConnectWithoutOrganizationInput | ScheduledJobCreateOrConnectWithoutOrganizationInput[]
    upsert?: ScheduledJobUpsertWithWhereUniqueWithoutOrganizationInput | ScheduledJobUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ScheduledJobCreateManyOrganizationInputEnvelope
    set?: ScheduledJobWhereUniqueInput | ScheduledJobWhereUniqueInput[]
    disconnect?: ScheduledJobWhereUniqueInput | ScheduledJobWhereUniqueInput[]
    delete?: ScheduledJobWhereUniqueInput | ScheduledJobWhereUniqueInput[]
    connect?: ScheduledJobWhereUniqueInput | ScheduledJobWhereUniqueInput[]
    update?: ScheduledJobUpdateWithWhereUniqueWithoutOrganizationInput | ScheduledJobUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ScheduledJobUpdateManyWithWhereWithoutOrganizationInput | ScheduledJobUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ScheduledJobScalarWhereInput | ScheduledJobScalarWhereInput[]
  }

  export type ExamUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ExamCreateWithoutOrganizationInput, ExamUncheckedCreateWithoutOrganizationInput> | ExamCreateWithoutOrganizationInput[] | ExamUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutOrganizationInput | ExamCreateOrConnectWithoutOrganizationInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutOrganizationInput | ExamUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ExamCreateManyOrganizationInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutOrganizationInput | ExamUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutOrganizationInput | ExamUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type HallTicketUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<HallTicketCreateWithoutOrganizationInput, HallTicketUncheckedCreateWithoutOrganizationInput> | HallTicketCreateWithoutOrganizationInput[] | HallTicketUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: HallTicketCreateOrConnectWithoutOrganizationInput | HallTicketCreateOrConnectWithoutOrganizationInput[]
    upsert?: HallTicketUpsertWithWhereUniqueWithoutOrganizationInput | HallTicketUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: HallTicketCreateManyOrganizationInputEnvelope
    set?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
    disconnect?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
    delete?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
    connect?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
    update?: HallTicketUpdateWithWhereUniqueWithoutOrganizationInput | HallTicketUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: HallTicketUpdateManyWithWhereWithoutOrganizationInput | HallTicketUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: HallTicketScalarWhereInput | HallTicketScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOrganizationInput | UserUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOrganizationInput | UserUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOrganizationInput | UserUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type NoticeUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<NoticeCreateWithoutOrganizationInput, NoticeUncheckedCreateWithoutOrganizationInput> | NoticeCreateWithoutOrganizationInput[] | NoticeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: NoticeCreateOrConnectWithoutOrganizationInput | NoticeCreateOrConnectWithoutOrganizationInput[]
    upsert?: NoticeUpsertWithWhereUniqueWithoutOrganizationInput | NoticeUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: NoticeCreateManyOrganizationInputEnvelope
    set?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    disconnect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    delete?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    connect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    update?: NoticeUpdateWithWhereUniqueWithoutOrganizationInput | NoticeUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: NoticeUpdateManyWithWhereWithoutOrganizationInput | NoticeUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: NoticeScalarWhereInput | NoticeScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<StudentCreateWithoutOrganizationInput, StudentUncheckedCreateWithoutOrganizationInput> | StudentCreateWithoutOrganizationInput[] | StudentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutOrganizationInput | StudentCreateOrConnectWithoutOrganizationInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutOrganizationInput | StudentUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: StudentCreateManyOrganizationInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutOrganizationInput | StudentUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutOrganizationInput | StudentUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type StudentDocumentUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<StudentDocumentCreateWithoutOrganizationInput, StudentDocumentUncheckedCreateWithoutOrganizationInput> | StudentDocumentCreateWithoutOrganizationInput[] | StudentDocumentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: StudentDocumentCreateOrConnectWithoutOrganizationInput | StudentDocumentCreateOrConnectWithoutOrganizationInput[]
    upsert?: StudentDocumentUpsertWithWhereUniqueWithoutOrganizationInput | StudentDocumentUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: StudentDocumentCreateManyOrganizationInputEnvelope
    set?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
    disconnect?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
    delete?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
    connect?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
    update?: StudentDocumentUpdateWithWhereUniqueWithoutOrganizationInput | StudentDocumentUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: StudentDocumentUpdateManyWithWhereWithoutOrganizationInput | StudentDocumentUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: StudentDocumentScalarWhereInput | StudentDocumentScalarWhereInput[]
  }

  export type GradeUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<GradeCreateWithoutOrganizationInput, GradeUncheckedCreateWithoutOrganizationInput> | GradeCreateWithoutOrganizationInput[] | GradeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutOrganizationInput | GradeCreateOrConnectWithoutOrganizationInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutOrganizationInput | GradeUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: GradeCreateManyOrganizationInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutOrganizationInput | GradeUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutOrganizationInput | GradeUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type SectionUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<SectionCreateWithoutOrganizationInput, SectionUncheckedCreateWithoutOrganizationInput> | SectionCreateWithoutOrganizationInput[] | SectionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutOrganizationInput | SectionCreateOrConnectWithoutOrganizationInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutOrganizationInput | SectionUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: SectionCreateManyOrganizationInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutOrganizationInput | SectionUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutOrganizationInput | SectionUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type FeeUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<FeeCreateWithoutOrganizationInput, FeeUncheckedCreateWithoutOrganizationInput> | FeeCreateWithoutOrganizationInput[] | FeeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: FeeCreateOrConnectWithoutOrganizationInput | FeeCreateOrConnectWithoutOrganizationInput[]
    upsert?: FeeUpsertWithWhereUniqueWithoutOrganizationInput | FeeUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: FeeCreateManyOrganizationInputEnvelope
    set?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
    disconnect?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
    delete?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
    connect?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
    update?: FeeUpdateWithWhereUniqueWithoutOrganizationInput | FeeUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: FeeUpdateManyWithWhereWithoutOrganizationInput | FeeUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: FeeScalarWhereInput | FeeScalarWhereInput[]
  }

  export type FeeCategoryUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<FeeCategoryCreateWithoutOrganizationInput, FeeCategoryUncheckedCreateWithoutOrganizationInput> | FeeCategoryCreateWithoutOrganizationInput[] | FeeCategoryUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: FeeCategoryCreateOrConnectWithoutOrganizationInput | FeeCategoryCreateOrConnectWithoutOrganizationInput[]
    upsert?: FeeCategoryUpsertWithWhereUniqueWithoutOrganizationInput | FeeCategoryUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: FeeCategoryCreateManyOrganizationInputEnvelope
    set?: FeeCategoryWhereUniqueInput | FeeCategoryWhereUniqueInput[]
    disconnect?: FeeCategoryWhereUniqueInput | FeeCategoryWhereUniqueInput[]
    delete?: FeeCategoryWhereUniqueInput | FeeCategoryWhereUniqueInput[]
    connect?: FeeCategoryWhereUniqueInput | FeeCategoryWhereUniqueInput[]
    update?: FeeCategoryUpdateWithWhereUniqueWithoutOrganizationInput | FeeCategoryUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: FeeCategoryUpdateManyWithWhereWithoutOrganizationInput | FeeCategoryUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: FeeCategoryScalarWhereInput | FeeCategoryScalarWhereInput[]
  }

  export type FeePaymentUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<FeePaymentCreateWithoutOrganizationInput, FeePaymentUncheckedCreateWithoutOrganizationInput> | FeePaymentCreateWithoutOrganizationInput[] | FeePaymentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: FeePaymentCreateOrConnectWithoutOrganizationInput | FeePaymentCreateOrConnectWithoutOrganizationInput[]
    upsert?: FeePaymentUpsertWithWhereUniqueWithoutOrganizationInput | FeePaymentUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: FeePaymentCreateManyOrganizationInputEnvelope
    set?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    disconnect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    delete?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    connect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    update?: FeePaymentUpdateWithWhereUniqueWithoutOrganizationInput | FeePaymentUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: FeePaymentUpdateManyWithWhereWithoutOrganizationInput | FeePaymentUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: FeePaymentScalarWhereInput | FeePaymentScalarWhereInput[]
  }

  export type AcademicCalendarUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<AcademicCalendarCreateWithoutOrganizationInput, AcademicCalendarUncheckedCreateWithoutOrganizationInput> | AcademicCalendarCreateWithoutOrganizationInput[] | AcademicCalendarUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AcademicCalendarCreateOrConnectWithoutOrganizationInput | AcademicCalendarCreateOrConnectWithoutOrganizationInput[]
    upsert?: AcademicCalendarUpsertWithWhereUniqueWithoutOrganizationInput | AcademicCalendarUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: AcademicCalendarCreateManyOrganizationInputEnvelope
    set?: AcademicCalendarWhereUniqueInput | AcademicCalendarWhereUniqueInput[]
    disconnect?: AcademicCalendarWhereUniqueInput | AcademicCalendarWhereUniqueInput[]
    delete?: AcademicCalendarWhereUniqueInput | AcademicCalendarWhereUniqueInput[]
    connect?: AcademicCalendarWhereUniqueInput | AcademicCalendarWhereUniqueInput[]
    update?: AcademicCalendarUpdateWithWhereUniqueWithoutOrganizationInput | AcademicCalendarUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: AcademicCalendarUpdateManyWithWhereWithoutOrganizationInput | AcademicCalendarUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: AcademicCalendarScalarWhereInput | AcademicCalendarScalarWhereInput[]
  }

  export type AnonymousComplaintUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<AnonymousComplaintCreateWithoutOrganizationInput, AnonymousComplaintUncheckedCreateWithoutOrganizationInput> | AnonymousComplaintCreateWithoutOrganizationInput[] | AnonymousComplaintUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AnonymousComplaintCreateOrConnectWithoutOrganizationInput | AnonymousComplaintCreateOrConnectWithoutOrganizationInput[]
    upsert?: AnonymousComplaintUpsertWithWhereUniqueWithoutOrganizationInput | AnonymousComplaintUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: AnonymousComplaintCreateManyOrganizationInputEnvelope
    set?: AnonymousComplaintWhereUniqueInput | AnonymousComplaintWhereUniqueInput[]
    disconnect?: AnonymousComplaintWhereUniqueInput | AnonymousComplaintWhereUniqueInput[]
    delete?: AnonymousComplaintWhereUniqueInput | AnonymousComplaintWhereUniqueInput[]
    connect?: AnonymousComplaintWhereUniqueInput | AnonymousComplaintWhereUniqueInput[]
    update?: AnonymousComplaintUpdateWithWhereUniqueWithoutOrganizationInput | AnonymousComplaintUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: AnonymousComplaintUpdateManyWithWhereWithoutOrganizationInput | AnonymousComplaintUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: AnonymousComplaintScalarWhereInput | AnonymousComplaintScalarWhereInput[]
  }

  export type TeacherUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<TeacherCreateWithoutOrganizationInput, TeacherUncheckedCreateWithoutOrganizationInput> | TeacherCreateWithoutOrganizationInput[] | TeacherUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: TeacherCreateOrConnectWithoutOrganizationInput | TeacherCreateOrConnectWithoutOrganizationInput[]
    upsert?: TeacherUpsertWithWhereUniqueWithoutOrganizationInput | TeacherUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: TeacherCreateManyOrganizationInputEnvelope
    set?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    disconnect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    delete?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    connect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    update?: TeacherUpdateWithWhereUniqueWithoutOrganizationInput | TeacherUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: TeacherUpdateManyWithWhereWithoutOrganizationInput | TeacherUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: TeacherScalarWhereInput | TeacherScalarWhereInput[]
  }

  export type SubjectUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<SubjectCreateWithoutOrganizationInput, SubjectUncheckedCreateWithoutOrganizationInput> | SubjectCreateWithoutOrganizationInput[] | SubjectUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutOrganizationInput | SubjectCreateOrConnectWithoutOrganizationInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutOrganizationInput | SubjectUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: SubjectCreateManyOrganizationInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutOrganizationInput | SubjectUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutOrganizationInput | SubjectUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type TeachingAssignmentUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<TeachingAssignmentCreateWithoutOrganizationInput, TeachingAssignmentUncheckedCreateWithoutOrganizationInput> | TeachingAssignmentCreateWithoutOrganizationInput[] | TeachingAssignmentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: TeachingAssignmentCreateOrConnectWithoutOrganizationInput | TeachingAssignmentCreateOrConnectWithoutOrganizationInput[]
    upsert?: TeachingAssignmentUpsertWithWhereUniqueWithoutOrganizationInput | TeachingAssignmentUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: TeachingAssignmentCreateManyOrganizationInputEnvelope
    set?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    disconnect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    delete?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    connect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    update?: TeachingAssignmentUpdateWithWhereUniqueWithoutOrganizationInput | TeachingAssignmentUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: TeachingAssignmentUpdateManyWithWhereWithoutOrganizationInput | TeachingAssignmentUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: TeachingAssignmentScalarWhereInput | TeachingAssignmentScalarWhereInput[]
  }

  export type NotificationLogUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<NotificationLogCreateWithoutOrganizationInput, NotificationLogUncheckedCreateWithoutOrganizationInput> | NotificationLogCreateWithoutOrganizationInput[] | NotificationLogUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutOrganizationInput | NotificationLogCreateOrConnectWithoutOrganizationInput[]
    upsert?: NotificationLogUpsertWithWhereUniqueWithoutOrganizationInput | NotificationLogUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: NotificationLogCreateManyOrganizationInputEnvelope
    set?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    disconnect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    delete?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    update?: NotificationLogUpdateWithWhereUniqueWithoutOrganizationInput | NotificationLogUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: NotificationLogUpdateManyWithWhereWithoutOrganizationInput | NotificationLogUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
  }

  export type AcademicYearUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<AcademicYearCreateWithoutOrganizationInput, AcademicYearUncheckedCreateWithoutOrganizationInput> | AcademicYearCreateWithoutOrganizationInput[] | AcademicYearUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AcademicYearCreateOrConnectWithoutOrganizationInput | AcademicYearCreateOrConnectWithoutOrganizationInput[]
    upsert?: AcademicYearUpsertWithWhereUniqueWithoutOrganizationInput | AcademicYearUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: AcademicYearCreateManyOrganizationInputEnvelope
    set?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
    disconnect?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
    delete?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
    connect?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
    update?: AcademicYearUpdateWithWhereUniqueWithoutOrganizationInput | AcademicYearUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: AcademicYearUpdateManyWithWhereWithoutOrganizationInput | AcademicYearUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: AcademicYearScalarWhereInput | AcademicYearScalarWhereInput[]
  }

  export type ScheduledJobUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ScheduledJobCreateWithoutOrganizationInput, ScheduledJobUncheckedCreateWithoutOrganizationInput> | ScheduledJobCreateWithoutOrganizationInput[] | ScheduledJobUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ScheduledJobCreateOrConnectWithoutOrganizationInput | ScheduledJobCreateOrConnectWithoutOrganizationInput[]
    upsert?: ScheduledJobUpsertWithWhereUniqueWithoutOrganizationInput | ScheduledJobUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ScheduledJobCreateManyOrganizationInputEnvelope
    set?: ScheduledJobWhereUniqueInput | ScheduledJobWhereUniqueInput[]
    disconnect?: ScheduledJobWhereUniqueInput | ScheduledJobWhereUniqueInput[]
    delete?: ScheduledJobWhereUniqueInput | ScheduledJobWhereUniqueInput[]
    connect?: ScheduledJobWhereUniqueInput | ScheduledJobWhereUniqueInput[]
    update?: ScheduledJobUpdateWithWhereUniqueWithoutOrganizationInput | ScheduledJobUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ScheduledJobUpdateManyWithWhereWithoutOrganizationInput | ScheduledJobUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ScheduledJobScalarWhereInput | ScheduledJobScalarWhereInput[]
  }

  export type ExamUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ExamCreateWithoutOrganizationInput, ExamUncheckedCreateWithoutOrganizationInput> | ExamCreateWithoutOrganizationInput[] | ExamUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutOrganizationInput | ExamCreateOrConnectWithoutOrganizationInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutOrganizationInput | ExamUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ExamCreateManyOrganizationInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutOrganizationInput | ExamUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutOrganizationInput | ExamUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type HallTicketUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<HallTicketCreateWithoutOrganizationInput, HallTicketUncheckedCreateWithoutOrganizationInput> | HallTicketCreateWithoutOrganizationInput[] | HallTicketUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: HallTicketCreateOrConnectWithoutOrganizationInput | HallTicketCreateOrConnectWithoutOrganizationInput[]
    upsert?: HallTicketUpsertWithWhereUniqueWithoutOrganizationInput | HallTicketUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: HallTicketCreateManyOrganizationInputEnvelope
    set?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
    disconnect?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
    delete?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
    connect?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
    update?: HallTicketUpdateWithWhereUniqueWithoutOrganizationInput | HallTicketUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: HallTicketUpdateManyWithWhereWithoutOrganizationInput | HallTicketUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: HallTicketScalarWhereInput | HallTicketScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutUsersInput = {
    create?: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsersInput
    connect?: OrganizationWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutUserInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput
    connect?: TeacherWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type ParentCreateNestedOneWithoutUserInput = {
    create?: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParentCreateOrConnectWithoutUserInput
    connect?: ParentWhereUniqueInput
  }

  export type FeePaymentCreateNestedManyWithoutPayerInput = {
    create?: XOR<FeePaymentCreateWithoutPayerInput, FeePaymentUncheckedCreateWithoutPayerInput> | FeePaymentCreateWithoutPayerInput[] | FeePaymentUncheckedCreateWithoutPayerInput[]
    connectOrCreate?: FeePaymentCreateOrConnectWithoutPayerInput | FeePaymentCreateOrConnectWithoutPayerInput[]
    createMany?: FeePaymentCreateManyPayerInputEnvelope
    connect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
  }

  export type NotificationLogCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationLogCreateWithoutUserInput, NotificationLogUncheckedCreateWithoutUserInput> | NotificationLogCreateWithoutUserInput[] | NotificationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutUserInput | NotificationLogCreateOrConnectWithoutUserInput[]
    createMany?: NotificationLogCreateManyUserInputEnvelope
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
  }

  export type TeacherUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput
    connect?: TeacherWhereUniqueInput
  }

  export type StudentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type ParentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParentCreateOrConnectWithoutUserInput
    connect?: ParentWhereUniqueInput
  }

  export type FeePaymentUncheckedCreateNestedManyWithoutPayerInput = {
    create?: XOR<FeePaymentCreateWithoutPayerInput, FeePaymentUncheckedCreateWithoutPayerInput> | FeePaymentCreateWithoutPayerInput[] | FeePaymentUncheckedCreateWithoutPayerInput[]
    connectOrCreate?: FeePaymentCreateOrConnectWithoutPayerInput | FeePaymentCreateOrConnectWithoutPayerInput[]
    createMany?: FeePaymentCreateManyPayerInputEnvelope
    connect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
  }

  export type NotificationLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationLogCreateWithoutUserInput, NotificationLogUncheckedCreateWithoutUserInput> | NotificationLogCreateWithoutUserInput[] | NotificationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutUserInput | NotificationLogCreateOrConnectWithoutUserInput[]
    createMany?: NotificationLogCreateManyUserInputEnvelope
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type OrganizationUpdateOneWithoutUsersNestedInput = {
    create?: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsersInput
    upsert?: OrganizationUpsertWithoutUsersInput
    disconnect?: OrganizationWhereInput | boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutUsersInput, OrganizationUpdateWithoutUsersInput>, OrganizationUncheckedUpdateWithoutUsersInput>
  }

  export type TeacherUpdateOneWithoutUserNestedInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput
    upsert?: TeacherUpsertWithoutUserInput
    disconnect?: TeacherWhereInput | boolean
    delete?: TeacherWhereInput | boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutUserInput, TeacherUpdateWithoutUserInput>, TeacherUncheckedUpdateWithoutUserInput>
  }

  export type StudentUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUserInput, StudentUpdateWithoutUserInput>, StudentUncheckedUpdateWithoutUserInput>
  }

  export type ParentUpdateOneWithoutUserNestedInput = {
    create?: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParentCreateOrConnectWithoutUserInput
    upsert?: ParentUpsertWithoutUserInput
    disconnect?: ParentWhereInput | boolean
    delete?: ParentWhereInput | boolean
    connect?: ParentWhereUniqueInput
    update?: XOR<XOR<ParentUpdateToOneWithWhereWithoutUserInput, ParentUpdateWithoutUserInput>, ParentUncheckedUpdateWithoutUserInput>
  }

  export type FeePaymentUpdateManyWithoutPayerNestedInput = {
    create?: XOR<FeePaymentCreateWithoutPayerInput, FeePaymentUncheckedCreateWithoutPayerInput> | FeePaymentCreateWithoutPayerInput[] | FeePaymentUncheckedCreateWithoutPayerInput[]
    connectOrCreate?: FeePaymentCreateOrConnectWithoutPayerInput | FeePaymentCreateOrConnectWithoutPayerInput[]
    upsert?: FeePaymentUpsertWithWhereUniqueWithoutPayerInput | FeePaymentUpsertWithWhereUniqueWithoutPayerInput[]
    createMany?: FeePaymentCreateManyPayerInputEnvelope
    set?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    disconnect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    delete?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    connect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    update?: FeePaymentUpdateWithWhereUniqueWithoutPayerInput | FeePaymentUpdateWithWhereUniqueWithoutPayerInput[]
    updateMany?: FeePaymentUpdateManyWithWhereWithoutPayerInput | FeePaymentUpdateManyWithWhereWithoutPayerInput[]
    deleteMany?: FeePaymentScalarWhereInput | FeePaymentScalarWhereInput[]
  }

  export type NotificationLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationLogCreateWithoutUserInput, NotificationLogUncheckedCreateWithoutUserInput> | NotificationLogCreateWithoutUserInput[] | NotificationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutUserInput | NotificationLogCreateOrConnectWithoutUserInput[]
    upsert?: NotificationLogUpsertWithWhereUniqueWithoutUserInput | NotificationLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationLogCreateManyUserInputEnvelope
    set?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    disconnect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    delete?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    update?: NotificationLogUpdateWithWhereUniqueWithoutUserInput | NotificationLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationLogUpdateManyWithWhereWithoutUserInput | NotificationLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
  }

  export type TeacherUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput
    upsert?: TeacherUpsertWithoutUserInput
    disconnect?: TeacherWhereInput | boolean
    delete?: TeacherWhereInput | boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutUserInput, TeacherUpdateWithoutUserInput>, TeacherUncheckedUpdateWithoutUserInput>
  }

  export type StudentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUserInput, StudentUpdateWithoutUserInput>, StudentUncheckedUpdateWithoutUserInput>
  }

  export type ParentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParentCreateOrConnectWithoutUserInput
    upsert?: ParentUpsertWithoutUserInput
    disconnect?: ParentWhereInput | boolean
    delete?: ParentWhereInput | boolean
    connect?: ParentWhereUniqueInput
    update?: XOR<XOR<ParentUpdateToOneWithWhereWithoutUserInput, ParentUpdateWithoutUserInput>, ParentUncheckedUpdateWithoutUserInput>
  }

  export type FeePaymentUncheckedUpdateManyWithoutPayerNestedInput = {
    create?: XOR<FeePaymentCreateWithoutPayerInput, FeePaymentUncheckedCreateWithoutPayerInput> | FeePaymentCreateWithoutPayerInput[] | FeePaymentUncheckedCreateWithoutPayerInput[]
    connectOrCreate?: FeePaymentCreateOrConnectWithoutPayerInput | FeePaymentCreateOrConnectWithoutPayerInput[]
    upsert?: FeePaymentUpsertWithWhereUniqueWithoutPayerInput | FeePaymentUpsertWithWhereUniqueWithoutPayerInput[]
    createMany?: FeePaymentCreateManyPayerInputEnvelope
    set?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    disconnect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    delete?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    connect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    update?: FeePaymentUpdateWithWhereUniqueWithoutPayerInput | FeePaymentUpdateWithWhereUniqueWithoutPayerInput[]
    updateMany?: FeePaymentUpdateManyWithWhereWithoutPayerInput | FeePaymentUpdateManyWithWhereWithoutPayerInput[]
    deleteMany?: FeePaymentScalarWhereInput | FeePaymentScalarWhereInput[]
  }

  export type NotificationLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationLogCreateWithoutUserInput, NotificationLogUncheckedCreateWithoutUserInput> | NotificationLogCreateWithoutUserInput[] | NotificationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutUserInput | NotificationLogCreateOrConnectWithoutUserInput[]
    upsert?: NotificationLogUpsertWithWhereUniqueWithoutUserInput | NotificationLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationLogCreateManyUserInputEnvelope
    set?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    disconnect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    delete?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    update?: NotificationLogUpdateWithWhereUniqueWithoutUserInput | NotificationLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationLogUpdateManyWithWhereWithoutUserInput | NotificationLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutGradeInput = {
    create?: XOR<OrganizationCreateWithoutGradeInput, OrganizationUncheckedCreateWithoutGradeInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutGradeInput
    connect?: OrganizationWhereUniqueInput
  }

  export type StudentCreateNestedManyWithoutGradeInput = {
    create?: XOR<StudentCreateWithoutGradeInput, StudentUncheckedCreateWithoutGradeInput> | StudentCreateWithoutGradeInput[] | StudentUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutGradeInput | StudentCreateOrConnectWithoutGradeInput[]
    createMany?: StudentCreateManyGradeInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type SectionCreateNestedManyWithoutGradeInput = {
    create?: XOR<SectionCreateWithoutGradeInput, SectionUncheckedCreateWithoutGradeInput> | SectionCreateWithoutGradeInput[] | SectionUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutGradeInput | SectionCreateOrConnectWithoutGradeInput[]
    createMany?: SectionCreateManyGradeInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type TeachingAssignmentCreateNestedManyWithoutGradeInput = {
    create?: XOR<TeachingAssignmentCreateWithoutGradeInput, TeachingAssignmentUncheckedCreateWithoutGradeInput> | TeachingAssignmentCreateWithoutGradeInput[] | TeachingAssignmentUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: TeachingAssignmentCreateOrConnectWithoutGradeInput | TeachingAssignmentCreateOrConnectWithoutGradeInput[]
    createMany?: TeachingAssignmentCreateManyGradeInputEnvelope
    connect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutGradeInput = {
    create?: XOR<StudentCreateWithoutGradeInput, StudentUncheckedCreateWithoutGradeInput> | StudentCreateWithoutGradeInput[] | StudentUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutGradeInput | StudentCreateOrConnectWithoutGradeInput[]
    createMany?: StudentCreateManyGradeInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type SectionUncheckedCreateNestedManyWithoutGradeInput = {
    create?: XOR<SectionCreateWithoutGradeInput, SectionUncheckedCreateWithoutGradeInput> | SectionCreateWithoutGradeInput[] | SectionUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutGradeInput | SectionCreateOrConnectWithoutGradeInput[]
    createMany?: SectionCreateManyGradeInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type TeachingAssignmentUncheckedCreateNestedManyWithoutGradeInput = {
    create?: XOR<TeachingAssignmentCreateWithoutGradeInput, TeachingAssignmentUncheckedCreateWithoutGradeInput> | TeachingAssignmentCreateWithoutGradeInput[] | TeachingAssignmentUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: TeachingAssignmentCreateOrConnectWithoutGradeInput | TeachingAssignmentCreateOrConnectWithoutGradeInput[]
    createMany?: TeachingAssignmentCreateManyGradeInputEnvelope
    connect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutGradeNestedInput = {
    create?: XOR<OrganizationCreateWithoutGradeInput, OrganizationUncheckedCreateWithoutGradeInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutGradeInput
    upsert?: OrganizationUpsertWithoutGradeInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutGradeInput, OrganizationUpdateWithoutGradeInput>, OrganizationUncheckedUpdateWithoutGradeInput>
  }

  export type StudentUpdateManyWithoutGradeNestedInput = {
    create?: XOR<StudentCreateWithoutGradeInput, StudentUncheckedCreateWithoutGradeInput> | StudentCreateWithoutGradeInput[] | StudentUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutGradeInput | StudentCreateOrConnectWithoutGradeInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutGradeInput | StudentUpsertWithWhereUniqueWithoutGradeInput[]
    createMany?: StudentCreateManyGradeInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutGradeInput | StudentUpdateWithWhereUniqueWithoutGradeInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutGradeInput | StudentUpdateManyWithWhereWithoutGradeInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type SectionUpdateManyWithoutGradeNestedInput = {
    create?: XOR<SectionCreateWithoutGradeInput, SectionUncheckedCreateWithoutGradeInput> | SectionCreateWithoutGradeInput[] | SectionUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutGradeInput | SectionCreateOrConnectWithoutGradeInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutGradeInput | SectionUpsertWithWhereUniqueWithoutGradeInput[]
    createMany?: SectionCreateManyGradeInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutGradeInput | SectionUpdateWithWhereUniqueWithoutGradeInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutGradeInput | SectionUpdateManyWithWhereWithoutGradeInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type TeachingAssignmentUpdateManyWithoutGradeNestedInput = {
    create?: XOR<TeachingAssignmentCreateWithoutGradeInput, TeachingAssignmentUncheckedCreateWithoutGradeInput> | TeachingAssignmentCreateWithoutGradeInput[] | TeachingAssignmentUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: TeachingAssignmentCreateOrConnectWithoutGradeInput | TeachingAssignmentCreateOrConnectWithoutGradeInput[]
    upsert?: TeachingAssignmentUpsertWithWhereUniqueWithoutGradeInput | TeachingAssignmentUpsertWithWhereUniqueWithoutGradeInput[]
    createMany?: TeachingAssignmentCreateManyGradeInputEnvelope
    set?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    disconnect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    delete?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    connect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    update?: TeachingAssignmentUpdateWithWhereUniqueWithoutGradeInput | TeachingAssignmentUpdateWithWhereUniqueWithoutGradeInput[]
    updateMany?: TeachingAssignmentUpdateManyWithWhereWithoutGradeInput | TeachingAssignmentUpdateManyWithWhereWithoutGradeInput[]
    deleteMany?: TeachingAssignmentScalarWhereInput | TeachingAssignmentScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutGradeNestedInput = {
    create?: XOR<StudentCreateWithoutGradeInput, StudentUncheckedCreateWithoutGradeInput> | StudentCreateWithoutGradeInput[] | StudentUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutGradeInput | StudentCreateOrConnectWithoutGradeInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutGradeInput | StudentUpsertWithWhereUniqueWithoutGradeInput[]
    createMany?: StudentCreateManyGradeInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutGradeInput | StudentUpdateWithWhereUniqueWithoutGradeInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutGradeInput | StudentUpdateManyWithWhereWithoutGradeInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type SectionUncheckedUpdateManyWithoutGradeNestedInput = {
    create?: XOR<SectionCreateWithoutGradeInput, SectionUncheckedCreateWithoutGradeInput> | SectionCreateWithoutGradeInput[] | SectionUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutGradeInput | SectionCreateOrConnectWithoutGradeInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutGradeInput | SectionUpsertWithWhereUniqueWithoutGradeInput[]
    createMany?: SectionCreateManyGradeInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutGradeInput | SectionUpdateWithWhereUniqueWithoutGradeInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutGradeInput | SectionUpdateManyWithWhereWithoutGradeInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type TeachingAssignmentUncheckedUpdateManyWithoutGradeNestedInput = {
    create?: XOR<TeachingAssignmentCreateWithoutGradeInput, TeachingAssignmentUncheckedCreateWithoutGradeInput> | TeachingAssignmentCreateWithoutGradeInput[] | TeachingAssignmentUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: TeachingAssignmentCreateOrConnectWithoutGradeInput | TeachingAssignmentCreateOrConnectWithoutGradeInput[]
    upsert?: TeachingAssignmentUpsertWithWhereUniqueWithoutGradeInput | TeachingAssignmentUpsertWithWhereUniqueWithoutGradeInput[]
    createMany?: TeachingAssignmentCreateManyGradeInputEnvelope
    set?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    disconnect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    delete?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    connect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    update?: TeachingAssignmentUpdateWithWhereUniqueWithoutGradeInput | TeachingAssignmentUpdateWithWhereUniqueWithoutGradeInput[]
    updateMany?: TeachingAssignmentUpdateManyWithWhereWithoutGradeInput | TeachingAssignmentUpdateManyWithWhereWithoutGradeInput[]
    deleteMany?: TeachingAssignmentScalarWhereInput | TeachingAssignmentScalarWhereInput[]
  }

  export type GradeCreateNestedOneWithoutSectionInput = {
    create?: XOR<GradeCreateWithoutSectionInput, GradeUncheckedCreateWithoutSectionInput>
    connectOrCreate?: GradeCreateOrConnectWithoutSectionInput
    connect?: GradeWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutSectionInput = {
    create?: XOR<OrganizationCreateWithoutSectionInput, OrganizationUncheckedCreateWithoutSectionInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSectionInput
    connect?: OrganizationWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutSectionInput = {
    create?: XOR<TeacherCreateWithoutSectionInput, TeacherUncheckedCreateWithoutSectionInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutSectionInput
    connect?: TeacherWhereUniqueInput
  }

  export type StudentCreateNestedManyWithoutSectionInput = {
    create?: XOR<StudentCreateWithoutSectionInput, StudentUncheckedCreateWithoutSectionInput> | StudentCreateWithoutSectionInput[] | StudentUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutSectionInput | StudentCreateOrConnectWithoutSectionInput[]
    createMany?: StudentCreateManySectionInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type StudentAttendanceCreateNestedManyWithoutSectionInput = {
    create?: XOR<StudentAttendanceCreateWithoutSectionInput, StudentAttendanceUncheckedCreateWithoutSectionInput> | StudentAttendanceCreateWithoutSectionInput[] | StudentAttendanceUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutSectionInput | StudentAttendanceCreateOrConnectWithoutSectionInput[]
    createMany?: StudentAttendanceCreateManySectionInputEnvelope
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
  }

  export type TeachingAssignmentCreateNestedManyWithoutSectionInput = {
    create?: XOR<TeachingAssignmentCreateWithoutSectionInput, TeachingAssignmentUncheckedCreateWithoutSectionInput> | TeachingAssignmentCreateWithoutSectionInput[] | TeachingAssignmentUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: TeachingAssignmentCreateOrConnectWithoutSectionInput | TeachingAssignmentCreateOrConnectWithoutSectionInput[]
    createMany?: TeachingAssignmentCreateManySectionInputEnvelope
    connect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<StudentCreateWithoutSectionInput, StudentUncheckedCreateWithoutSectionInput> | StudentCreateWithoutSectionInput[] | StudentUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutSectionInput | StudentCreateOrConnectWithoutSectionInput[]
    createMany?: StudentCreateManySectionInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type StudentAttendanceUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<StudentAttendanceCreateWithoutSectionInput, StudentAttendanceUncheckedCreateWithoutSectionInput> | StudentAttendanceCreateWithoutSectionInput[] | StudentAttendanceUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutSectionInput | StudentAttendanceCreateOrConnectWithoutSectionInput[]
    createMany?: StudentAttendanceCreateManySectionInputEnvelope
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
  }

  export type TeachingAssignmentUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<TeachingAssignmentCreateWithoutSectionInput, TeachingAssignmentUncheckedCreateWithoutSectionInput> | TeachingAssignmentCreateWithoutSectionInput[] | TeachingAssignmentUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: TeachingAssignmentCreateOrConnectWithoutSectionInput | TeachingAssignmentCreateOrConnectWithoutSectionInput[]
    createMany?: TeachingAssignmentCreateManySectionInputEnvelope
    connect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
  }

  export type GradeUpdateOneRequiredWithoutSectionNestedInput = {
    create?: XOR<GradeCreateWithoutSectionInput, GradeUncheckedCreateWithoutSectionInput>
    connectOrCreate?: GradeCreateOrConnectWithoutSectionInput
    upsert?: GradeUpsertWithoutSectionInput
    connect?: GradeWhereUniqueInput
    update?: XOR<XOR<GradeUpdateToOneWithWhereWithoutSectionInput, GradeUpdateWithoutSectionInput>, GradeUncheckedUpdateWithoutSectionInput>
  }

  export type OrganizationUpdateOneRequiredWithoutSectionNestedInput = {
    create?: XOR<OrganizationCreateWithoutSectionInput, OrganizationUncheckedCreateWithoutSectionInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSectionInput
    upsert?: OrganizationUpsertWithoutSectionInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutSectionInput, OrganizationUpdateWithoutSectionInput>, OrganizationUncheckedUpdateWithoutSectionInput>
  }

  export type TeacherUpdateOneWithoutSectionNestedInput = {
    create?: XOR<TeacherCreateWithoutSectionInput, TeacherUncheckedCreateWithoutSectionInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutSectionInput
    upsert?: TeacherUpsertWithoutSectionInput
    disconnect?: TeacherWhereInput | boolean
    delete?: TeacherWhereInput | boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutSectionInput, TeacherUpdateWithoutSectionInput>, TeacherUncheckedUpdateWithoutSectionInput>
  }

  export type StudentUpdateManyWithoutSectionNestedInput = {
    create?: XOR<StudentCreateWithoutSectionInput, StudentUncheckedCreateWithoutSectionInput> | StudentCreateWithoutSectionInput[] | StudentUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutSectionInput | StudentCreateOrConnectWithoutSectionInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutSectionInput | StudentUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: StudentCreateManySectionInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutSectionInput | StudentUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutSectionInput | StudentUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type StudentAttendanceUpdateManyWithoutSectionNestedInput = {
    create?: XOR<StudentAttendanceCreateWithoutSectionInput, StudentAttendanceUncheckedCreateWithoutSectionInput> | StudentAttendanceCreateWithoutSectionInput[] | StudentAttendanceUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutSectionInput | StudentAttendanceCreateOrConnectWithoutSectionInput[]
    upsert?: StudentAttendanceUpsertWithWhereUniqueWithoutSectionInput | StudentAttendanceUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: StudentAttendanceCreateManySectionInputEnvelope
    set?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    disconnect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    delete?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    update?: StudentAttendanceUpdateWithWhereUniqueWithoutSectionInput | StudentAttendanceUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: StudentAttendanceUpdateManyWithWhereWithoutSectionInput | StudentAttendanceUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: StudentAttendanceScalarWhereInput | StudentAttendanceScalarWhereInput[]
  }

  export type TeachingAssignmentUpdateManyWithoutSectionNestedInput = {
    create?: XOR<TeachingAssignmentCreateWithoutSectionInput, TeachingAssignmentUncheckedCreateWithoutSectionInput> | TeachingAssignmentCreateWithoutSectionInput[] | TeachingAssignmentUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: TeachingAssignmentCreateOrConnectWithoutSectionInput | TeachingAssignmentCreateOrConnectWithoutSectionInput[]
    upsert?: TeachingAssignmentUpsertWithWhereUniqueWithoutSectionInput | TeachingAssignmentUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: TeachingAssignmentCreateManySectionInputEnvelope
    set?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    disconnect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    delete?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    connect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    update?: TeachingAssignmentUpdateWithWhereUniqueWithoutSectionInput | TeachingAssignmentUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: TeachingAssignmentUpdateManyWithWhereWithoutSectionInput | TeachingAssignmentUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: TeachingAssignmentScalarWhereInput | TeachingAssignmentScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutSectionNestedInput = {
    create?: XOR<StudentCreateWithoutSectionInput, StudentUncheckedCreateWithoutSectionInput> | StudentCreateWithoutSectionInput[] | StudentUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutSectionInput | StudentCreateOrConnectWithoutSectionInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutSectionInput | StudentUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: StudentCreateManySectionInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutSectionInput | StudentUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutSectionInput | StudentUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type StudentAttendanceUncheckedUpdateManyWithoutSectionNestedInput = {
    create?: XOR<StudentAttendanceCreateWithoutSectionInput, StudentAttendanceUncheckedCreateWithoutSectionInput> | StudentAttendanceCreateWithoutSectionInput[] | StudentAttendanceUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutSectionInput | StudentAttendanceCreateOrConnectWithoutSectionInput[]
    upsert?: StudentAttendanceUpsertWithWhereUniqueWithoutSectionInput | StudentAttendanceUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: StudentAttendanceCreateManySectionInputEnvelope
    set?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    disconnect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    delete?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    update?: StudentAttendanceUpdateWithWhereUniqueWithoutSectionInput | StudentAttendanceUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: StudentAttendanceUpdateManyWithWhereWithoutSectionInput | StudentAttendanceUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: StudentAttendanceScalarWhereInput | StudentAttendanceScalarWhereInput[]
  }

  export type TeachingAssignmentUncheckedUpdateManyWithoutSectionNestedInput = {
    create?: XOR<TeachingAssignmentCreateWithoutSectionInput, TeachingAssignmentUncheckedCreateWithoutSectionInput> | TeachingAssignmentCreateWithoutSectionInput[] | TeachingAssignmentUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: TeachingAssignmentCreateOrConnectWithoutSectionInput | TeachingAssignmentCreateOrConnectWithoutSectionInput[]
    upsert?: TeachingAssignmentUpsertWithWhereUniqueWithoutSectionInput | TeachingAssignmentUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: TeachingAssignmentCreateManySectionInputEnvelope
    set?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    disconnect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    delete?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    connect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    update?: TeachingAssignmentUpdateWithWhereUniqueWithoutSectionInput | TeachingAssignmentUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: TeachingAssignmentUpdateManyWithWhereWithoutSectionInput | TeachingAssignmentUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: TeachingAssignmentScalarWhereInput | TeachingAssignmentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTeacherInput = {
    create?: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeacherInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutTeacherInput = {
    create?: XOR<OrganizationCreateWithoutTeacherInput, OrganizationUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutTeacherInput
    connect?: OrganizationWhereUniqueInput
  }

  export type TeacherProfileCreateNestedOneWithoutTeacherInput = {
    create?: XOR<TeacherProfileCreateWithoutTeacherInput, TeacherProfileUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: TeacherProfileCreateOrConnectWithoutTeacherInput
    connect?: TeacherProfileWhereUniqueInput
  }

  export type TeachingAssignmentCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TeachingAssignmentCreateWithoutTeacherInput, TeachingAssignmentUncheckedCreateWithoutTeacherInput> | TeachingAssignmentCreateWithoutTeacherInput[] | TeachingAssignmentUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeachingAssignmentCreateOrConnectWithoutTeacherInput | TeachingAssignmentCreateOrConnectWithoutTeacherInput[]
    createMany?: TeachingAssignmentCreateManyTeacherInputEnvelope
    connect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
  }

  export type SectionCreateNestedManyWithoutClassTeacherInput = {
    create?: XOR<SectionCreateWithoutClassTeacherInput, SectionUncheckedCreateWithoutClassTeacherInput> | SectionCreateWithoutClassTeacherInput[] | SectionUncheckedCreateWithoutClassTeacherInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutClassTeacherInput | SectionCreateOrConnectWithoutClassTeacherInput[]
    createMany?: SectionCreateManyClassTeacherInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type TeacherProfileUncheckedCreateNestedOneWithoutTeacherInput = {
    create?: XOR<TeacherProfileCreateWithoutTeacherInput, TeacherProfileUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: TeacherProfileCreateOrConnectWithoutTeacherInput
    connect?: TeacherProfileWhereUniqueInput
  }

  export type TeachingAssignmentUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TeachingAssignmentCreateWithoutTeacherInput, TeachingAssignmentUncheckedCreateWithoutTeacherInput> | TeachingAssignmentCreateWithoutTeacherInput[] | TeachingAssignmentUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeachingAssignmentCreateOrConnectWithoutTeacherInput | TeachingAssignmentCreateOrConnectWithoutTeacherInput[]
    createMany?: TeachingAssignmentCreateManyTeacherInputEnvelope
    connect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
  }

  export type SectionUncheckedCreateNestedManyWithoutClassTeacherInput = {
    create?: XOR<SectionCreateWithoutClassTeacherInput, SectionUncheckedCreateWithoutClassTeacherInput> | SectionCreateWithoutClassTeacherInput[] | SectionUncheckedCreateWithoutClassTeacherInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutClassTeacherInput | SectionCreateOrConnectWithoutClassTeacherInput[]
    createMany?: SectionCreateManyClassTeacherInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type EnumEmploymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.EmploymentStatus
  }

  export type UserUpdateOneRequiredWithoutTeacherNestedInput = {
    create?: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeacherInput
    upsert?: UserUpsertWithoutTeacherInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeacherInput, UserUpdateWithoutTeacherInput>, UserUncheckedUpdateWithoutTeacherInput>
  }

  export type OrganizationUpdateOneRequiredWithoutTeacherNestedInput = {
    create?: XOR<OrganizationCreateWithoutTeacherInput, OrganizationUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutTeacherInput
    upsert?: OrganizationUpsertWithoutTeacherInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutTeacherInput, OrganizationUpdateWithoutTeacherInput>, OrganizationUncheckedUpdateWithoutTeacherInput>
  }

  export type TeacherProfileUpdateOneWithoutTeacherNestedInput = {
    create?: XOR<TeacherProfileCreateWithoutTeacherInput, TeacherProfileUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: TeacherProfileCreateOrConnectWithoutTeacherInput
    upsert?: TeacherProfileUpsertWithoutTeacherInput
    disconnect?: TeacherProfileWhereInput | boolean
    delete?: TeacherProfileWhereInput | boolean
    connect?: TeacherProfileWhereUniqueInput
    update?: XOR<XOR<TeacherProfileUpdateToOneWithWhereWithoutTeacherInput, TeacherProfileUpdateWithoutTeacherInput>, TeacherProfileUncheckedUpdateWithoutTeacherInput>
  }

  export type TeachingAssignmentUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TeachingAssignmentCreateWithoutTeacherInput, TeachingAssignmentUncheckedCreateWithoutTeacherInput> | TeachingAssignmentCreateWithoutTeacherInput[] | TeachingAssignmentUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeachingAssignmentCreateOrConnectWithoutTeacherInput | TeachingAssignmentCreateOrConnectWithoutTeacherInput[]
    upsert?: TeachingAssignmentUpsertWithWhereUniqueWithoutTeacherInput | TeachingAssignmentUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TeachingAssignmentCreateManyTeacherInputEnvelope
    set?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    disconnect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    delete?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    connect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    update?: TeachingAssignmentUpdateWithWhereUniqueWithoutTeacherInput | TeachingAssignmentUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TeachingAssignmentUpdateManyWithWhereWithoutTeacherInput | TeachingAssignmentUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TeachingAssignmentScalarWhereInput | TeachingAssignmentScalarWhereInput[]
  }

  export type SectionUpdateManyWithoutClassTeacherNestedInput = {
    create?: XOR<SectionCreateWithoutClassTeacherInput, SectionUncheckedCreateWithoutClassTeacherInput> | SectionCreateWithoutClassTeacherInput[] | SectionUncheckedCreateWithoutClassTeacherInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutClassTeacherInput | SectionCreateOrConnectWithoutClassTeacherInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutClassTeacherInput | SectionUpsertWithWhereUniqueWithoutClassTeacherInput[]
    createMany?: SectionCreateManyClassTeacherInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutClassTeacherInput | SectionUpdateWithWhereUniqueWithoutClassTeacherInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutClassTeacherInput | SectionUpdateManyWithWhereWithoutClassTeacherInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type TeacherProfileUncheckedUpdateOneWithoutTeacherNestedInput = {
    create?: XOR<TeacherProfileCreateWithoutTeacherInput, TeacherProfileUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: TeacherProfileCreateOrConnectWithoutTeacherInput
    upsert?: TeacherProfileUpsertWithoutTeacherInput
    disconnect?: TeacherProfileWhereInput | boolean
    delete?: TeacherProfileWhereInput | boolean
    connect?: TeacherProfileWhereUniqueInput
    update?: XOR<XOR<TeacherProfileUpdateToOneWithWhereWithoutTeacherInput, TeacherProfileUpdateWithoutTeacherInput>, TeacherProfileUncheckedUpdateWithoutTeacherInput>
  }

  export type TeachingAssignmentUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TeachingAssignmentCreateWithoutTeacherInput, TeachingAssignmentUncheckedCreateWithoutTeacherInput> | TeachingAssignmentCreateWithoutTeacherInput[] | TeachingAssignmentUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeachingAssignmentCreateOrConnectWithoutTeacherInput | TeachingAssignmentCreateOrConnectWithoutTeacherInput[]
    upsert?: TeachingAssignmentUpsertWithWhereUniqueWithoutTeacherInput | TeachingAssignmentUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TeachingAssignmentCreateManyTeacherInputEnvelope
    set?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    disconnect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    delete?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    connect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    update?: TeachingAssignmentUpdateWithWhereUniqueWithoutTeacherInput | TeachingAssignmentUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TeachingAssignmentUpdateManyWithWhereWithoutTeacherInput | TeachingAssignmentUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TeachingAssignmentScalarWhereInput | TeachingAssignmentScalarWhereInput[]
  }

  export type SectionUncheckedUpdateManyWithoutClassTeacherNestedInput = {
    create?: XOR<SectionCreateWithoutClassTeacherInput, SectionUncheckedCreateWithoutClassTeacherInput> | SectionCreateWithoutClassTeacherInput[] | SectionUncheckedCreateWithoutClassTeacherInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutClassTeacherInput | SectionCreateOrConnectWithoutClassTeacherInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutClassTeacherInput | SectionUpsertWithWhereUniqueWithoutClassTeacherInput[]
    createMany?: SectionCreateManyClassTeacherInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutClassTeacherInput | SectionUpdateWithWhereUniqueWithoutClassTeacherInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutClassTeacherInput | SectionUpdateManyWithWhereWithoutClassTeacherInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type TeacherProfileCreatespecializedSubjectsInput = {
    set: string[]
  }

  export type TeacherProfileCreatepreferredGradesInput = {
    set: string[]
  }

  export type TeacherProfileCreatelanguagesKnownInput = {
    set: string[]
  }

  export type TeacherProfileCreatecertificateUrlsInput = {
    set: string[]
  }

  export type TeacherCreateNestedOneWithoutProfileInput = {
    create?: XOR<TeacherCreateWithoutProfileInput, TeacherUncheckedCreateWithoutProfileInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutProfileInput
    connect?: TeacherWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TeacherProfileUpdatespecializedSubjectsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TeacherProfileUpdatepreferredGradesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TeacherProfileUpdatelanguagesKnownInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TeacherProfileUpdatecertificateUrlsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TeacherUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<TeacherCreateWithoutProfileInput, TeacherUncheckedCreateWithoutProfileInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutProfileInput
    upsert?: TeacherUpsertWithoutProfileInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutProfileInput, TeacherUpdateWithoutProfileInput>, TeacherUncheckedUpdateWithoutProfileInput>
  }

  export type OrganizationCreateNestedOneWithoutSubjectInput = {
    create?: XOR<OrganizationCreateWithoutSubjectInput, OrganizationUncheckedCreateWithoutSubjectInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSubjectInput
    connect?: OrganizationWhereUniqueInput
  }

  export type TeachingAssignmentCreateNestedManyWithoutSubjectInput = {
    create?: XOR<TeachingAssignmentCreateWithoutSubjectInput, TeachingAssignmentUncheckedCreateWithoutSubjectInput> | TeachingAssignmentCreateWithoutSubjectInput[] | TeachingAssignmentUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TeachingAssignmentCreateOrConnectWithoutSubjectInput | TeachingAssignmentCreateOrConnectWithoutSubjectInput[]
    createMany?: TeachingAssignmentCreateManySubjectInputEnvelope
    connect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
  }

  export type ExamCreateNestedManyWithoutSubjectInput = {
    create?: XOR<ExamCreateWithoutSubjectInput, ExamUncheckedCreateWithoutSubjectInput> | ExamCreateWithoutSubjectInput[] | ExamUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutSubjectInput | ExamCreateOrConnectWithoutSubjectInput[]
    createMany?: ExamCreateManySubjectInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type ExamResultCreateNestedManyWithoutSubjectInput = {
    create?: XOR<ExamResultCreateWithoutSubjectInput, ExamResultUncheckedCreateWithoutSubjectInput> | ExamResultCreateWithoutSubjectInput[] | ExamResultUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ExamResultCreateOrConnectWithoutSubjectInput | ExamResultCreateOrConnectWithoutSubjectInput[]
    createMany?: ExamResultCreateManySubjectInputEnvelope
    connect?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
  }

  export type TeachingAssignmentUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<TeachingAssignmentCreateWithoutSubjectInput, TeachingAssignmentUncheckedCreateWithoutSubjectInput> | TeachingAssignmentCreateWithoutSubjectInput[] | TeachingAssignmentUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TeachingAssignmentCreateOrConnectWithoutSubjectInput | TeachingAssignmentCreateOrConnectWithoutSubjectInput[]
    createMany?: TeachingAssignmentCreateManySubjectInputEnvelope
    connect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
  }

  export type ExamUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<ExamCreateWithoutSubjectInput, ExamUncheckedCreateWithoutSubjectInput> | ExamCreateWithoutSubjectInput[] | ExamUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutSubjectInput | ExamCreateOrConnectWithoutSubjectInput[]
    createMany?: ExamCreateManySubjectInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type ExamResultUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<ExamResultCreateWithoutSubjectInput, ExamResultUncheckedCreateWithoutSubjectInput> | ExamResultCreateWithoutSubjectInput[] | ExamResultUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ExamResultCreateOrConnectWithoutSubjectInput | ExamResultCreateOrConnectWithoutSubjectInput[]
    createMany?: ExamResultCreateManySubjectInputEnvelope
    connect?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutSubjectNestedInput = {
    create?: XOR<OrganizationCreateWithoutSubjectInput, OrganizationUncheckedCreateWithoutSubjectInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSubjectInput
    upsert?: OrganizationUpsertWithoutSubjectInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutSubjectInput, OrganizationUpdateWithoutSubjectInput>, OrganizationUncheckedUpdateWithoutSubjectInput>
  }

  export type TeachingAssignmentUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<TeachingAssignmentCreateWithoutSubjectInput, TeachingAssignmentUncheckedCreateWithoutSubjectInput> | TeachingAssignmentCreateWithoutSubjectInput[] | TeachingAssignmentUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TeachingAssignmentCreateOrConnectWithoutSubjectInput | TeachingAssignmentCreateOrConnectWithoutSubjectInput[]
    upsert?: TeachingAssignmentUpsertWithWhereUniqueWithoutSubjectInput | TeachingAssignmentUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: TeachingAssignmentCreateManySubjectInputEnvelope
    set?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    disconnect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    delete?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    connect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    update?: TeachingAssignmentUpdateWithWhereUniqueWithoutSubjectInput | TeachingAssignmentUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: TeachingAssignmentUpdateManyWithWhereWithoutSubjectInput | TeachingAssignmentUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: TeachingAssignmentScalarWhereInput | TeachingAssignmentScalarWhereInput[]
  }

  export type ExamUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<ExamCreateWithoutSubjectInput, ExamUncheckedCreateWithoutSubjectInput> | ExamCreateWithoutSubjectInput[] | ExamUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutSubjectInput | ExamCreateOrConnectWithoutSubjectInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutSubjectInput | ExamUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: ExamCreateManySubjectInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutSubjectInput | ExamUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutSubjectInput | ExamUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type ExamResultUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<ExamResultCreateWithoutSubjectInput, ExamResultUncheckedCreateWithoutSubjectInput> | ExamResultCreateWithoutSubjectInput[] | ExamResultUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ExamResultCreateOrConnectWithoutSubjectInput | ExamResultCreateOrConnectWithoutSubjectInput[]
    upsert?: ExamResultUpsertWithWhereUniqueWithoutSubjectInput | ExamResultUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: ExamResultCreateManySubjectInputEnvelope
    set?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
    disconnect?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
    delete?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
    connect?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
    update?: ExamResultUpdateWithWhereUniqueWithoutSubjectInput | ExamResultUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: ExamResultUpdateManyWithWhereWithoutSubjectInput | ExamResultUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: ExamResultScalarWhereInput | ExamResultScalarWhereInput[]
  }

  export type TeachingAssignmentUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<TeachingAssignmentCreateWithoutSubjectInput, TeachingAssignmentUncheckedCreateWithoutSubjectInput> | TeachingAssignmentCreateWithoutSubjectInput[] | TeachingAssignmentUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TeachingAssignmentCreateOrConnectWithoutSubjectInput | TeachingAssignmentCreateOrConnectWithoutSubjectInput[]
    upsert?: TeachingAssignmentUpsertWithWhereUniqueWithoutSubjectInput | TeachingAssignmentUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: TeachingAssignmentCreateManySubjectInputEnvelope
    set?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    disconnect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    delete?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    connect?: TeachingAssignmentWhereUniqueInput | TeachingAssignmentWhereUniqueInput[]
    update?: TeachingAssignmentUpdateWithWhereUniqueWithoutSubjectInput | TeachingAssignmentUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: TeachingAssignmentUpdateManyWithWhereWithoutSubjectInput | TeachingAssignmentUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: TeachingAssignmentScalarWhereInput | TeachingAssignmentScalarWhereInput[]
  }

  export type ExamUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<ExamCreateWithoutSubjectInput, ExamUncheckedCreateWithoutSubjectInput> | ExamCreateWithoutSubjectInput[] | ExamUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutSubjectInput | ExamCreateOrConnectWithoutSubjectInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutSubjectInput | ExamUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: ExamCreateManySubjectInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutSubjectInput | ExamUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutSubjectInput | ExamUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type ExamResultUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<ExamResultCreateWithoutSubjectInput, ExamResultUncheckedCreateWithoutSubjectInput> | ExamResultCreateWithoutSubjectInput[] | ExamResultUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ExamResultCreateOrConnectWithoutSubjectInput | ExamResultCreateOrConnectWithoutSubjectInput[]
    upsert?: ExamResultUpsertWithWhereUniqueWithoutSubjectInput | ExamResultUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: ExamResultCreateManySubjectInputEnvelope
    set?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
    disconnect?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
    delete?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
    connect?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
    update?: ExamResultUpdateWithWhereUniqueWithoutSubjectInput | ExamResultUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: ExamResultUpdateManyWithWhereWithoutSubjectInput | ExamResultUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: ExamResultScalarWhereInput | ExamResultScalarWhereInput[]
  }

  export type TeacherCreateNestedOneWithoutTeachingAssignmentInput = {
    create?: XOR<TeacherCreateWithoutTeachingAssignmentInput, TeacherUncheckedCreateWithoutTeachingAssignmentInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutTeachingAssignmentInput
    connect?: TeacherWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutTeachingAssignmentsInput = {
    create?: XOR<SubjectCreateWithoutTeachingAssignmentsInput, SubjectUncheckedCreateWithoutTeachingAssignmentsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutTeachingAssignmentsInput
    connect?: SubjectWhereUniqueInput
  }

  export type GradeCreateNestedOneWithoutTeachingAssignmentInput = {
    create?: XOR<GradeCreateWithoutTeachingAssignmentInput, GradeUncheckedCreateWithoutTeachingAssignmentInput>
    connectOrCreate?: GradeCreateOrConnectWithoutTeachingAssignmentInput
    connect?: GradeWhereUniqueInput
  }

  export type SectionCreateNestedOneWithoutTeachingAssignmentInput = {
    create?: XOR<SectionCreateWithoutTeachingAssignmentInput, SectionUncheckedCreateWithoutTeachingAssignmentInput>
    connectOrCreate?: SectionCreateOrConnectWithoutTeachingAssignmentInput
    connect?: SectionWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutTeachingAssignmentInput = {
    create?: XOR<OrganizationCreateWithoutTeachingAssignmentInput, OrganizationUncheckedCreateWithoutTeachingAssignmentInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutTeachingAssignmentInput
    connect?: OrganizationWhereUniqueInput
  }

  export type AcademicYearCreateNestedOneWithoutTeachingAssignmentInput = {
    create?: XOR<AcademicYearCreateWithoutTeachingAssignmentInput, AcademicYearUncheckedCreateWithoutTeachingAssignmentInput>
    connectOrCreate?: AcademicYearCreateOrConnectWithoutTeachingAssignmentInput
    connect?: AcademicYearWhereUniqueInput
  }

  export type EnumAssignmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.AssignmentStatus
  }

  export type TeacherUpdateOneRequiredWithoutTeachingAssignmentNestedInput = {
    create?: XOR<TeacherCreateWithoutTeachingAssignmentInput, TeacherUncheckedCreateWithoutTeachingAssignmentInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutTeachingAssignmentInput
    upsert?: TeacherUpsertWithoutTeachingAssignmentInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutTeachingAssignmentInput, TeacherUpdateWithoutTeachingAssignmentInput>, TeacherUncheckedUpdateWithoutTeachingAssignmentInput>
  }

  export type SubjectUpdateOneRequiredWithoutTeachingAssignmentsNestedInput = {
    create?: XOR<SubjectCreateWithoutTeachingAssignmentsInput, SubjectUncheckedCreateWithoutTeachingAssignmentsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutTeachingAssignmentsInput
    upsert?: SubjectUpsertWithoutTeachingAssignmentsInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutTeachingAssignmentsInput, SubjectUpdateWithoutTeachingAssignmentsInput>, SubjectUncheckedUpdateWithoutTeachingAssignmentsInput>
  }

  export type GradeUpdateOneRequiredWithoutTeachingAssignmentNestedInput = {
    create?: XOR<GradeCreateWithoutTeachingAssignmentInput, GradeUncheckedCreateWithoutTeachingAssignmentInput>
    connectOrCreate?: GradeCreateOrConnectWithoutTeachingAssignmentInput
    upsert?: GradeUpsertWithoutTeachingAssignmentInput
    connect?: GradeWhereUniqueInput
    update?: XOR<XOR<GradeUpdateToOneWithWhereWithoutTeachingAssignmentInput, GradeUpdateWithoutTeachingAssignmentInput>, GradeUncheckedUpdateWithoutTeachingAssignmentInput>
  }

  export type SectionUpdateOneRequiredWithoutTeachingAssignmentNestedInput = {
    create?: XOR<SectionCreateWithoutTeachingAssignmentInput, SectionUncheckedCreateWithoutTeachingAssignmentInput>
    connectOrCreate?: SectionCreateOrConnectWithoutTeachingAssignmentInput
    upsert?: SectionUpsertWithoutTeachingAssignmentInput
    connect?: SectionWhereUniqueInput
    update?: XOR<XOR<SectionUpdateToOneWithWhereWithoutTeachingAssignmentInput, SectionUpdateWithoutTeachingAssignmentInput>, SectionUncheckedUpdateWithoutTeachingAssignmentInput>
  }

  export type OrganizationUpdateOneRequiredWithoutTeachingAssignmentNestedInput = {
    create?: XOR<OrganizationCreateWithoutTeachingAssignmentInput, OrganizationUncheckedCreateWithoutTeachingAssignmentInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutTeachingAssignmentInput
    upsert?: OrganizationUpsertWithoutTeachingAssignmentInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutTeachingAssignmentInput, OrganizationUpdateWithoutTeachingAssignmentInput>, OrganizationUncheckedUpdateWithoutTeachingAssignmentInput>
  }

  export type AcademicYearUpdateOneWithoutTeachingAssignmentNestedInput = {
    create?: XOR<AcademicYearCreateWithoutTeachingAssignmentInput, AcademicYearUncheckedCreateWithoutTeachingAssignmentInput>
    connectOrCreate?: AcademicYearCreateOrConnectWithoutTeachingAssignmentInput
    upsert?: AcademicYearUpsertWithoutTeachingAssignmentInput
    disconnect?: AcademicYearWhereInput | boolean
    delete?: AcademicYearWhereInput | boolean
    connect?: AcademicYearWhereUniqueInput
    update?: XOR<XOR<AcademicYearUpdateToOneWithWhereWithoutTeachingAssignmentInput, AcademicYearUpdateWithoutTeachingAssignmentInput>, AcademicYearUncheckedUpdateWithoutTeachingAssignmentInput>
  }

  export type UserCreateNestedOneWithoutStudentInput = {
    create?: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput
    connect?: UserWhereUniqueInput
  }

  export type SectionCreateNestedOneWithoutStudentsInput = {
    create?: XOR<SectionCreateWithoutStudentsInput, SectionUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: SectionCreateOrConnectWithoutStudentsInput
    connect?: SectionWhereUniqueInput
  }

  export type GradeCreateNestedOneWithoutStudentsInput = {
    create?: XOR<GradeCreateWithoutStudentsInput, GradeUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: GradeCreateOrConnectWithoutStudentsInput
    connect?: GradeWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutStudentInput = {
    create?: XOR<OrganizationCreateWithoutStudentInput, OrganizationUncheckedCreateWithoutStudentInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutStudentInput
    connect?: OrganizationWhereUniqueInput
  }

  export type FeeCreateNestedManyWithoutStudentInput = {
    create?: XOR<FeeCreateWithoutStudentInput, FeeUncheckedCreateWithoutStudentInput> | FeeCreateWithoutStudentInput[] | FeeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: FeeCreateOrConnectWithoutStudentInput | FeeCreateOrConnectWithoutStudentInput[]
    createMany?: FeeCreateManyStudentInputEnvelope
    connect?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
  }

  export type ParentStudentCreateNestedManyWithoutStudentInput = {
    create?: XOR<ParentStudentCreateWithoutStudentInput, ParentStudentUncheckedCreateWithoutStudentInput> | ParentStudentCreateWithoutStudentInput[] | ParentStudentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ParentStudentCreateOrConnectWithoutStudentInput | ParentStudentCreateOrConnectWithoutStudentInput[]
    createMany?: ParentStudentCreateManyStudentInputEnvelope
    connect?: ParentStudentWhereUniqueInput | ParentStudentWhereUniqueInput[]
  }

  export type StudentAttendanceCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentAttendanceCreateWithoutStudentInput, StudentAttendanceUncheckedCreateWithoutStudentInput> | StudentAttendanceCreateWithoutStudentInput[] | StudentAttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutStudentInput | StudentAttendanceCreateOrConnectWithoutStudentInput[]
    createMany?: StudentAttendanceCreateManyStudentInputEnvelope
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
  }

  export type StudentDocumentCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentDocumentCreateWithoutStudentInput, StudentDocumentUncheckedCreateWithoutStudentInput> | StudentDocumentCreateWithoutStudentInput[] | StudentDocumentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentDocumentCreateOrConnectWithoutStudentInput | StudentDocumentCreateOrConnectWithoutStudentInput[]
    createMany?: StudentDocumentCreateManyStudentInputEnvelope
    connect?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
  }

  export type NotificationLogCreateNestedManyWithoutStudentInput = {
    create?: XOR<NotificationLogCreateWithoutStudentInput, NotificationLogUncheckedCreateWithoutStudentInput> | NotificationLogCreateWithoutStudentInput[] | NotificationLogUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutStudentInput | NotificationLogCreateOrConnectWithoutStudentInput[]
    createMany?: NotificationLogCreateManyStudentInputEnvelope
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
  }

  export type ReportCardCreateNestedManyWithoutStudentInput = {
    create?: XOR<ReportCardCreateWithoutStudentInput, ReportCardUncheckedCreateWithoutStudentInput> | ReportCardCreateWithoutStudentInput[] | ReportCardUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ReportCardCreateOrConnectWithoutStudentInput | ReportCardCreateOrConnectWithoutStudentInput[]
    createMany?: ReportCardCreateManyStudentInputEnvelope
    connect?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
  }

  export type HallTicketCreateNestedManyWithoutStudentInput = {
    create?: XOR<HallTicketCreateWithoutStudentInput, HallTicketUncheckedCreateWithoutStudentInput> | HallTicketCreateWithoutStudentInput[] | HallTicketUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: HallTicketCreateOrConnectWithoutStudentInput | HallTicketCreateOrConnectWithoutStudentInput[]
    createMany?: HallTicketCreateManyStudentInputEnvelope
    connect?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
  }

  export type ExamResultCreateNestedManyWithoutStudentInput = {
    create?: XOR<ExamResultCreateWithoutStudentInput, ExamResultUncheckedCreateWithoutStudentInput> | ExamResultCreateWithoutStudentInput[] | ExamResultUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ExamResultCreateOrConnectWithoutStudentInput | ExamResultCreateOrConnectWithoutStudentInput[]
    createMany?: ExamResultCreateManyStudentInputEnvelope
    connect?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
  }

  export type ExamEnrollmentCreateNestedManyWithoutStudentInput = {
    create?: XOR<ExamEnrollmentCreateWithoutStudentInput, ExamEnrollmentUncheckedCreateWithoutStudentInput> | ExamEnrollmentCreateWithoutStudentInput[] | ExamEnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ExamEnrollmentCreateOrConnectWithoutStudentInput | ExamEnrollmentCreateOrConnectWithoutStudentInput[]
    createMany?: ExamEnrollmentCreateManyStudentInputEnvelope
    connect?: ExamEnrollmentWhereUniqueInput | ExamEnrollmentWhereUniqueInput[]
  }

  export type FeeUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<FeeCreateWithoutStudentInput, FeeUncheckedCreateWithoutStudentInput> | FeeCreateWithoutStudentInput[] | FeeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: FeeCreateOrConnectWithoutStudentInput | FeeCreateOrConnectWithoutStudentInput[]
    createMany?: FeeCreateManyStudentInputEnvelope
    connect?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
  }

  export type ParentStudentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<ParentStudentCreateWithoutStudentInput, ParentStudentUncheckedCreateWithoutStudentInput> | ParentStudentCreateWithoutStudentInput[] | ParentStudentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ParentStudentCreateOrConnectWithoutStudentInput | ParentStudentCreateOrConnectWithoutStudentInput[]
    createMany?: ParentStudentCreateManyStudentInputEnvelope
    connect?: ParentStudentWhereUniqueInput | ParentStudentWhereUniqueInput[]
  }

  export type StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentAttendanceCreateWithoutStudentInput, StudentAttendanceUncheckedCreateWithoutStudentInput> | StudentAttendanceCreateWithoutStudentInput[] | StudentAttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutStudentInput | StudentAttendanceCreateOrConnectWithoutStudentInput[]
    createMany?: StudentAttendanceCreateManyStudentInputEnvelope
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
  }

  export type StudentDocumentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentDocumentCreateWithoutStudentInput, StudentDocumentUncheckedCreateWithoutStudentInput> | StudentDocumentCreateWithoutStudentInput[] | StudentDocumentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentDocumentCreateOrConnectWithoutStudentInput | StudentDocumentCreateOrConnectWithoutStudentInput[]
    createMany?: StudentDocumentCreateManyStudentInputEnvelope
    connect?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
  }

  export type NotificationLogUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<NotificationLogCreateWithoutStudentInput, NotificationLogUncheckedCreateWithoutStudentInput> | NotificationLogCreateWithoutStudentInput[] | NotificationLogUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutStudentInput | NotificationLogCreateOrConnectWithoutStudentInput[]
    createMany?: NotificationLogCreateManyStudentInputEnvelope
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
  }

  export type ReportCardUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<ReportCardCreateWithoutStudentInput, ReportCardUncheckedCreateWithoutStudentInput> | ReportCardCreateWithoutStudentInput[] | ReportCardUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ReportCardCreateOrConnectWithoutStudentInput | ReportCardCreateOrConnectWithoutStudentInput[]
    createMany?: ReportCardCreateManyStudentInputEnvelope
    connect?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
  }

  export type HallTicketUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<HallTicketCreateWithoutStudentInput, HallTicketUncheckedCreateWithoutStudentInput> | HallTicketCreateWithoutStudentInput[] | HallTicketUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: HallTicketCreateOrConnectWithoutStudentInput | HallTicketCreateOrConnectWithoutStudentInput[]
    createMany?: HallTicketCreateManyStudentInputEnvelope
    connect?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
  }

  export type ExamResultUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<ExamResultCreateWithoutStudentInput, ExamResultUncheckedCreateWithoutStudentInput> | ExamResultCreateWithoutStudentInput[] | ExamResultUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ExamResultCreateOrConnectWithoutStudentInput | ExamResultCreateOrConnectWithoutStudentInput[]
    createMany?: ExamResultCreateManyStudentInputEnvelope
    connect?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
  }

  export type ExamEnrollmentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<ExamEnrollmentCreateWithoutStudentInput, ExamEnrollmentUncheckedCreateWithoutStudentInput> | ExamEnrollmentCreateWithoutStudentInput[] | ExamEnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ExamEnrollmentCreateOrConnectWithoutStudentInput | ExamEnrollmentCreateOrConnectWithoutStudentInput[]
    createMany?: ExamEnrollmentCreateManyStudentInputEnvelope
    connect?: ExamEnrollmentWhereUniqueInput | ExamEnrollmentWhereUniqueInput[]
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender
  }

  export type UserUpdateOneRequiredWithoutStudentNestedInput = {
    create?: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput
    upsert?: UserUpsertWithoutStudentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudentInput, UserUpdateWithoutStudentInput>, UserUncheckedUpdateWithoutStudentInput>
  }

  export type SectionUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<SectionCreateWithoutStudentsInput, SectionUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: SectionCreateOrConnectWithoutStudentsInput
    upsert?: SectionUpsertWithoutStudentsInput
    connect?: SectionWhereUniqueInput
    update?: XOR<XOR<SectionUpdateToOneWithWhereWithoutStudentsInput, SectionUpdateWithoutStudentsInput>, SectionUncheckedUpdateWithoutStudentsInput>
  }

  export type GradeUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<GradeCreateWithoutStudentsInput, GradeUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: GradeCreateOrConnectWithoutStudentsInput
    upsert?: GradeUpsertWithoutStudentsInput
    connect?: GradeWhereUniqueInput
    update?: XOR<XOR<GradeUpdateToOneWithWhereWithoutStudentsInput, GradeUpdateWithoutStudentsInput>, GradeUncheckedUpdateWithoutStudentsInput>
  }

  export type OrganizationUpdateOneRequiredWithoutStudentNestedInput = {
    create?: XOR<OrganizationCreateWithoutStudentInput, OrganizationUncheckedCreateWithoutStudentInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutStudentInput
    upsert?: OrganizationUpsertWithoutStudentInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutStudentInput, OrganizationUpdateWithoutStudentInput>, OrganizationUncheckedUpdateWithoutStudentInput>
  }

  export type FeeUpdateManyWithoutStudentNestedInput = {
    create?: XOR<FeeCreateWithoutStudentInput, FeeUncheckedCreateWithoutStudentInput> | FeeCreateWithoutStudentInput[] | FeeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: FeeCreateOrConnectWithoutStudentInput | FeeCreateOrConnectWithoutStudentInput[]
    upsert?: FeeUpsertWithWhereUniqueWithoutStudentInput | FeeUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: FeeCreateManyStudentInputEnvelope
    set?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
    disconnect?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
    delete?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
    connect?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
    update?: FeeUpdateWithWhereUniqueWithoutStudentInput | FeeUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: FeeUpdateManyWithWhereWithoutStudentInput | FeeUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: FeeScalarWhereInput | FeeScalarWhereInput[]
  }

  export type ParentStudentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ParentStudentCreateWithoutStudentInput, ParentStudentUncheckedCreateWithoutStudentInput> | ParentStudentCreateWithoutStudentInput[] | ParentStudentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ParentStudentCreateOrConnectWithoutStudentInput | ParentStudentCreateOrConnectWithoutStudentInput[]
    upsert?: ParentStudentUpsertWithWhereUniqueWithoutStudentInput | ParentStudentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ParentStudentCreateManyStudentInputEnvelope
    set?: ParentStudentWhereUniqueInput | ParentStudentWhereUniqueInput[]
    disconnect?: ParentStudentWhereUniqueInput | ParentStudentWhereUniqueInput[]
    delete?: ParentStudentWhereUniqueInput | ParentStudentWhereUniqueInput[]
    connect?: ParentStudentWhereUniqueInput | ParentStudentWhereUniqueInput[]
    update?: ParentStudentUpdateWithWhereUniqueWithoutStudentInput | ParentStudentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ParentStudentUpdateManyWithWhereWithoutStudentInput | ParentStudentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ParentStudentScalarWhereInput | ParentStudentScalarWhereInput[]
  }

  export type StudentAttendanceUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentAttendanceCreateWithoutStudentInput, StudentAttendanceUncheckedCreateWithoutStudentInput> | StudentAttendanceCreateWithoutStudentInput[] | StudentAttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutStudentInput | StudentAttendanceCreateOrConnectWithoutStudentInput[]
    upsert?: StudentAttendanceUpsertWithWhereUniqueWithoutStudentInput | StudentAttendanceUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentAttendanceCreateManyStudentInputEnvelope
    set?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    disconnect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    delete?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    update?: StudentAttendanceUpdateWithWhereUniqueWithoutStudentInput | StudentAttendanceUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentAttendanceUpdateManyWithWhereWithoutStudentInput | StudentAttendanceUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentAttendanceScalarWhereInput | StudentAttendanceScalarWhereInput[]
  }

  export type StudentDocumentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentDocumentCreateWithoutStudentInput, StudentDocumentUncheckedCreateWithoutStudentInput> | StudentDocumentCreateWithoutStudentInput[] | StudentDocumentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentDocumentCreateOrConnectWithoutStudentInput | StudentDocumentCreateOrConnectWithoutStudentInput[]
    upsert?: StudentDocumentUpsertWithWhereUniqueWithoutStudentInput | StudentDocumentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentDocumentCreateManyStudentInputEnvelope
    set?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
    disconnect?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
    delete?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
    connect?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
    update?: StudentDocumentUpdateWithWhereUniqueWithoutStudentInput | StudentDocumentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentDocumentUpdateManyWithWhereWithoutStudentInput | StudentDocumentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentDocumentScalarWhereInput | StudentDocumentScalarWhereInput[]
  }

  export type NotificationLogUpdateManyWithoutStudentNestedInput = {
    create?: XOR<NotificationLogCreateWithoutStudentInput, NotificationLogUncheckedCreateWithoutStudentInput> | NotificationLogCreateWithoutStudentInput[] | NotificationLogUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutStudentInput | NotificationLogCreateOrConnectWithoutStudentInput[]
    upsert?: NotificationLogUpsertWithWhereUniqueWithoutStudentInput | NotificationLogUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: NotificationLogCreateManyStudentInputEnvelope
    set?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    disconnect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    delete?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    update?: NotificationLogUpdateWithWhereUniqueWithoutStudentInput | NotificationLogUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: NotificationLogUpdateManyWithWhereWithoutStudentInput | NotificationLogUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
  }

  export type ReportCardUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ReportCardCreateWithoutStudentInput, ReportCardUncheckedCreateWithoutStudentInput> | ReportCardCreateWithoutStudentInput[] | ReportCardUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ReportCardCreateOrConnectWithoutStudentInput | ReportCardCreateOrConnectWithoutStudentInput[]
    upsert?: ReportCardUpsertWithWhereUniqueWithoutStudentInput | ReportCardUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ReportCardCreateManyStudentInputEnvelope
    set?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    disconnect?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    delete?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    connect?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    update?: ReportCardUpdateWithWhereUniqueWithoutStudentInput | ReportCardUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ReportCardUpdateManyWithWhereWithoutStudentInput | ReportCardUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ReportCardScalarWhereInput | ReportCardScalarWhereInput[]
  }

  export type HallTicketUpdateManyWithoutStudentNestedInput = {
    create?: XOR<HallTicketCreateWithoutStudentInput, HallTicketUncheckedCreateWithoutStudentInput> | HallTicketCreateWithoutStudentInput[] | HallTicketUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: HallTicketCreateOrConnectWithoutStudentInput | HallTicketCreateOrConnectWithoutStudentInput[]
    upsert?: HallTicketUpsertWithWhereUniqueWithoutStudentInput | HallTicketUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: HallTicketCreateManyStudentInputEnvelope
    set?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
    disconnect?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
    delete?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
    connect?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
    update?: HallTicketUpdateWithWhereUniqueWithoutStudentInput | HallTicketUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: HallTicketUpdateManyWithWhereWithoutStudentInput | HallTicketUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: HallTicketScalarWhereInput | HallTicketScalarWhereInput[]
  }

  export type ExamResultUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ExamResultCreateWithoutStudentInput, ExamResultUncheckedCreateWithoutStudentInput> | ExamResultCreateWithoutStudentInput[] | ExamResultUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ExamResultCreateOrConnectWithoutStudentInput | ExamResultCreateOrConnectWithoutStudentInput[]
    upsert?: ExamResultUpsertWithWhereUniqueWithoutStudentInput | ExamResultUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ExamResultCreateManyStudentInputEnvelope
    set?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
    disconnect?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
    delete?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
    connect?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
    update?: ExamResultUpdateWithWhereUniqueWithoutStudentInput | ExamResultUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ExamResultUpdateManyWithWhereWithoutStudentInput | ExamResultUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ExamResultScalarWhereInput | ExamResultScalarWhereInput[]
  }

  export type ExamEnrollmentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ExamEnrollmentCreateWithoutStudentInput, ExamEnrollmentUncheckedCreateWithoutStudentInput> | ExamEnrollmentCreateWithoutStudentInput[] | ExamEnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ExamEnrollmentCreateOrConnectWithoutStudentInput | ExamEnrollmentCreateOrConnectWithoutStudentInput[]
    upsert?: ExamEnrollmentUpsertWithWhereUniqueWithoutStudentInput | ExamEnrollmentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ExamEnrollmentCreateManyStudentInputEnvelope
    set?: ExamEnrollmentWhereUniqueInput | ExamEnrollmentWhereUniqueInput[]
    disconnect?: ExamEnrollmentWhereUniqueInput | ExamEnrollmentWhereUniqueInput[]
    delete?: ExamEnrollmentWhereUniqueInput | ExamEnrollmentWhereUniqueInput[]
    connect?: ExamEnrollmentWhereUniqueInput | ExamEnrollmentWhereUniqueInput[]
    update?: ExamEnrollmentUpdateWithWhereUniqueWithoutStudentInput | ExamEnrollmentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ExamEnrollmentUpdateManyWithWhereWithoutStudentInput | ExamEnrollmentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ExamEnrollmentScalarWhereInput | ExamEnrollmentScalarWhereInput[]
  }

  export type FeeUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<FeeCreateWithoutStudentInput, FeeUncheckedCreateWithoutStudentInput> | FeeCreateWithoutStudentInput[] | FeeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: FeeCreateOrConnectWithoutStudentInput | FeeCreateOrConnectWithoutStudentInput[]
    upsert?: FeeUpsertWithWhereUniqueWithoutStudentInput | FeeUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: FeeCreateManyStudentInputEnvelope
    set?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
    disconnect?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
    delete?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
    connect?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
    update?: FeeUpdateWithWhereUniqueWithoutStudentInput | FeeUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: FeeUpdateManyWithWhereWithoutStudentInput | FeeUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: FeeScalarWhereInput | FeeScalarWhereInput[]
  }

  export type ParentStudentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ParentStudentCreateWithoutStudentInput, ParentStudentUncheckedCreateWithoutStudentInput> | ParentStudentCreateWithoutStudentInput[] | ParentStudentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ParentStudentCreateOrConnectWithoutStudentInput | ParentStudentCreateOrConnectWithoutStudentInput[]
    upsert?: ParentStudentUpsertWithWhereUniqueWithoutStudentInput | ParentStudentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ParentStudentCreateManyStudentInputEnvelope
    set?: ParentStudentWhereUniqueInput | ParentStudentWhereUniqueInput[]
    disconnect?: ParentStudentWhereUniqueInput | ParentStudentWhereUniqueInput[]
    delete?: ParentStudentWhereUniqueInput | ParentStudentWhereUniqueInput[]
    connect?: ParentStudentWhereUniqueInput | ParentStudentWhereUniqueInput[]
    update?: ParentStudentUpdateWithWhereUniqueWithoutStudentInput | ParentStudentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ParentStudentUpdateManyWithWhereWithoutStudentInput | ParentStudentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ParentStudentScalarWhereInput | ParentStudentScalarWhereInput[]
  }

  export type StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentAttendanceCreateWithoutStudentInput, StudentAttendanceUncheckedCreateWithoutStudentInput> | StudentAttendanceCreateWithoutStudentInput[] | StudentAttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutStudentInput | StudentAttendanceCreateOrConnectWithoutStudentInput[]
    upsert?: StudentAttendanceUpsertWithWhereUniqueWithoutStudentInput | StudentAttendanceUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentAttendanceCreateManyStudentInputEnvelope
    set?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    disconnect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    delete?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    update?: StudentAttendanceUpdateWithWhereUniqueWithoutStudentInput | StudentAttendanceUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentAttendanceUpdateManyWithWhereWithoutStudentInput | StudentAttendanceUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentAttendanceScalarWhereInput | StudentAttendanceScalarWhereInput[]
  }

  export type StudentDocumentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentDocumentCreateWithoutStudentInput, StudentDocumentUncheckedCreateWithoutStudentInput> | StudentDocumentCreateWithoutStudentInput[] | StudentDocumentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentDocumentCreateOrConnectWithoutStudentInput | StudentDocumentCreateOrConnectWithoutStudentInput[]
    upsert?: StudentDocumentUpsertWithWhereUniqueWithoutStudentInput | StudentDocumentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentDocumentCreateManyStudentInputEnvelope
    set?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
    disconnect?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
    delete?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
    connect?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
    update?: StudentDocumentUpdateWithWhereUniqueWithoutStudentInput | StudentDocumentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentDocumentUpdateManyWithWhereWithoutStudentInput | StudentDocumentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentDocumentScalarWhereInput | StudentDocumentScalarWhereInput[]
  }

  export type NotificationLogUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<NotificationLogCreateWithoutStudentInput, NotificationLogUncheckedCreateWithoutStudentInput> | NotificationLogCreateWithoutStudentInput[] | NotificationLogUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutStudentInput | NotificationLogCreateOrConnectWithoutStudentInput[]
    upsert?: NotificationLogUpsertWithWhereUniqueWithoutStudentInput | NotificationLogUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: NotificationLogCreateManyStudentInputEnvelope
    set?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    disconnect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    delete?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    update?: NotificationLogUpdateWithWhereUniqueWithoutStudentInput | NotificationLogUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: NotificationLogUpdateManyWithWhereWithoutStudentInput | NotificationLogUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
  }

  export type ReportCardUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ReportCardCreateWithoutStudentInput, ReportCardUncheckedCreateWithoutStudentInput> | ReportCardCreateWithoutStudentInput[] | ReportCardUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ReportCardCreateOrConnectWithoutStudentInput | ReportCardCreateOrConnectWithoutStudentInput[]
    upsert?: ReportCardUpsertWithWhereUniqueWithoutStudentInput | ReportCardUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ReportCardCreateManyStudentInputEnvelope
    set?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    disconnect?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    delete?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    connect?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    update?: ReportCardUpdateWithWhereUniqueWithoutStudentInput | ReportCardUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ReportCardUpdateManyWithWhereWithoutStudentInput | ReportCardUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ReportCardScalarWhereInput | ReportCardScalarWhereInput[]
  }

  export type HallTicketUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<HallTicketCreateWithoutStudentInput, HallTicketUncheckedCreateWithoutStudentInput> | HallTicketCreateWithoutStudentInput[] | HallTicketUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: HallTicketCreateOrConnectWithoutStudentInput | HallTicketCreateOrConnectWithoutStudentInput[]
    upsert?: HallTicketUpsertWithWhereUniqueWithoutStudentInput | HallTicketUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: HallTicketCreateManyStudentInputEnvelope
    set?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
    disconnect?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
    delete?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
    connect?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
    update?: HallTicketUpdateWithWhereUniqueWithoutStudentInput | HallTicketUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: HallTicketUpdateManyWithWhereWithoutStudentInput | HallTicketUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: HallTicketScalarWhereInput | HallTicketScalarWhereInput[]
  }

  export type ExamResultUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ExamResultCreateWithoutStudentInput, ExamResultUncheckedCreateWithoutStudentInput> | ExamResultCreateWithoutStudentInput[] | ExamResultUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ExamResultCreateOrConnectWithoutStudentInput | ExamResultCreateOrConnectWithoutStudentInput[]
    upsert?: ExamResultUpsertWithWhereUniqueWithoutStudentInput | ExamResultUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ExamResultCreateManyStudentInputEnvelope
    set?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
    disconnect?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
    delete?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
    connect?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
    update?: ExamResultUpdateWithWhereUniqueWithoutStudentInput | ExamResultUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ExamResultUpdateManyWithWhereWithoutStudentInput | ExamResultUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ExamResultScalarWhereInput | ExamResultScalarWhereInput[]
  }

  export type ExamEnrollmentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ExamEnrollmentCreateWithoutStudentInput, ExamEnrollmentUncheckedCreateWithoutStudentInput> | ExamEnrollmentCreateWithoutStudentInput[] | ExamEnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ExamEnrollmentCreateOrConnectWithoutStudentInput | ExamEnrollmentCreateOrConnectWithoutStudentInput[]
    upsert?: ExamEnrollmentUpsertWithWhereUniqueWithoutStudentInput | ExamEnrollmentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ExamEnrollmentCreateManyStudentInputEnvelope
    set?: ExamEnrollmentWhereUniqueInput | ExamEnrollmentWhereUniqueInput[]
    disconnect?: ExamEnrollmentWhereUniqueInput | ExamEnrollmentWhereUniqueInput[]
    delete?: ExamEnrollmentWhereUniqueInput | ExamEnrollmentWhereUniqueInput[]
    connect?: ExamEnrollmentWhereUniqueInput | ExamEnrollmentWhereUniqueInput[]
    update?: ExamEnrollmentUpdateWithWhereUniqueWithoutStudentInput | ExamEnrollmentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ExamEnrollmentUpdateManyWithWhereWithoutStudentInput | ExamEnrollmentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ExamEnrollmentScalarWhereInput | ExamEnrollmentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutParentInput = {
    create?: XOR<UserCreateWithoutParentInput, UserUncheckedCreateWithoutParentInput>
    connectOrCreate?: UserCreateOrConnectWithoutParentInput
    connect?: UserWhereUniqueInput
  }

  export type ParentStudentCreateNestedManyWithoutParentInput = {
    create?: XOR<ParentStudentCreateWithoutParentInput, ParentStudentUncheckedCreateWithoutParentInput> | ParentStudentCreateWithoutParentInput[] | ParentStudentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ParentStudentCreateOrConnectWithoutParentInput | ParentStudentCreateOrConnectWithoutParentInput[]
    createMany?: ParentStudentCreateManyParentInputEnvelope
    connect?: ParentStudentWhereUniqueInput | ParentStudentWhereUniqueInput[]
  }

  export type NotificationLogCreateNestedManyWithoutParentInput = {
    create?: XOR<NotificationLogCreateWithoutParentInput, NotificationLogUncheckedCreateWithoutParentInput> | NotificationLogCreateWithoutParentInput[] | NotificationLogUncheckedCreateWithoutParentInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutParentInput | NotificationLogCreateOrConnectWithoutParentInput[]
    createMany?: NotificationLogCreateManyParentInputEnvelope
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
  }

  export type ParentStudentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<ParentStudentCreateWithoutParentInput, ParentStudentUncheckedCreateWithoutParentInput> | ParentStudentCreateWithoutParentInput[] | ParentStudentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ParentStudentCreateOrConnectWithoutParentInput | ParentStudentCreateOrConnectWithoutParentInput[]
    createMany?: ParentStudentCreateManyParentInputEnvelope
    connect?: ParentStudentWhereUniqueInput | ParentStudentWhereUniqueInput[]
  }

  export type NotificationLogUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<NotificationLogCreateWithoutParentInput, NotificationLogUncheckedCreateWithoutParentInput> | NotificationLogCreateWithoutParentInput[] | NotificationLogUncheckedCreateWithoutParentInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutParentInput | NotificationLogCreateOrConnectWithoutParentInput[]
    createMany?: NotificationLogCreateManyParentInputEnvelope
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutParentNestedInput = {
    create?: XOR<UserCreateWithoutParentInput, UserUncheckedCreateWithoutParentInput>
    connectOrCreate?: UserCreateOrConnectWithoutParentInput
    upsert?: UserUpsertWithoutParentInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutParentInput, UserUpdateWithoutParentInput>, UserUncheckedUpdateWithoutParentInput>
  }

  export type ParentStudentUpdateManyWithoutParentNestedInput = {
    create?: XOR<ParentStudentCreateWithoutParentInput, ParentStudentUncheckedCreateWithoutParentInput> | ParentStudentCreateWithoutParentInput[] | ParentStudentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ParentStudentCreateOrConnectWithoutParentInput | ParentStudentCreateOrConnectWithoutParentInput[]
    upsert?: ParentStudentUpsertWithWhereUniqueWithoutParentInput | ParentStudentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ParentStudentCreateManyParentInputEnvelope
    set?: ParentStudentWhereUniqueInput | ParentStudentWhereUniqueInput[]
    disconnect?: ParentStudentWhereUniqueInput | ParentStudentWhereUniqueInput[]
    delete?: ParentStudentWhereUniqueInput | ParentStudentWhereUniqueInput[]
    connect?: ParentStudentWhereUniqueInput | ParentStudentWhereUniqueInput[]
    update?: ParentStudentUpdateWithWhereUniqueWithoutParentInput | ParentStudentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ParentStudentUpdateManyWithWhereWithoutParentInput | ParentStudentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ParentStudentScalarWhereInput | ParentStudentScalarWhereInput[]
  }

  export type NotificationLogUpdateManyWithoutParentNestedInput = {
    create?: XOR<NotificationLogCreateWithoutParentInput, NotificationLogUncheckedCreateWithoutParentInput> | NotificationLogCreateWithoutParentInput[] | NotificationLogUncheckedCreateWithoutParentInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutParentInput | NotificationLogCreateOrConnectWithoutParentInput[]
    upsert?: NotificationLogUpsertWithWhereUniqueWithoutParentInput | NotificationLogUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: NotificationLogCreateManyParentInputEnvelope
    set?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    disconnect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    delete?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    update?: NotificationLogUpdateWithWhereUniqueWithoutParentInput | NotificationLogUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: NotificationLogUpdateManyWithWhereWithoutParentInput | NotificationLogUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
  }

  export type ParentStudentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<ParentStudentCreateWithoutParentInput, ParentStudentUncheckedCreateWithoutParentInput> | ParentStudentCreateWithoutParentInput[] | ParentStudentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ParentStudentCreateOrConnectWithoutParentInput | ParentStudentCreateOrConnectWithoutParentInput[]
    upsert?: ParentStudentUpsertWithWhereUniqueWithoutParentInput | ParentStudentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ParentStudentCreateManyParentInputEnvelope
    set?: ParentStudentWhereUniqueInput | ParentStudentWhereUniqueInput[]
    disconnect?: ParentStudentWhereUniqueInput | ParentStudentWhereUniqueInput[]
    delete?: ParentStudentWhereUniqueInput | ParentStudentWhereUniqueInput[]
    connect?: ParentStudentWhereUniqueInput | ParentStudentWhereUniqueInput[]
    update?: ParentStudentUpdateWithWhereUniqueWithoutParentInput | ParentStudentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ParentStudentUpdateManyWithWhereWithoutParentInput | ParentStudentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ParentStudentScalarWhereInput | ParentStudentScalarWhereInput[]
  }

  export type NotificationLogUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<NotificationLogCreateWithoutParentInput, NotificationLogUncheckedCreateWithoutParentInput> | NotificationLogCreateWithoutParentInput[] | NotificationLogUncheckedCreateWithoutParentInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutParentInput | NotificationLogCreateOrConnectWithoutParentInput[]
    upsert?: NotificationLogUpsertWithWhereUniqueWithoutParentInput | NotificationLogUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: NotificationLogCreateManyParentInputEnvelope
    set?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    disconnect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    delete?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    update?: NotificationLogUpdateWithWhereUniqueWithoutParentInput | NotificationLogUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: NotificationLogUpdateManyWithWhereWithoutParentInput | NotificationLogUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutParentsInput = {
    create?: XOR<StudentCreateWithoutParentsInput, StudentUncheckedCreateWithoutParentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutParentsInput
    connect?: StudentWhereUniqueInput
  }

  export type ParentCreateNestedOneWithoutStudentsInput = {
    create?: XOR<ParentCreateWithoutStudentsInput, ParentUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: ParentCreateOrConnectWithoutStudentsInput
    connect?: ParentWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type StudentUpdateOneRequiredWithoutParentsNestedInput = {
    create?: XOR<StudentCreateWithoutParentsInput, StudentUncheckedCreateWithoutParentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutParentsInput
    upsert?: StudentUpsertWithoutParentsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutParentsInput, StudentUpdateWithoutParentsInput>, StudentUncheckedUpdateWithoutParentsInput>
  }

  export type ParentUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<ParentCreateWithoutStudentsInput, ParentUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: ParentCreateOrConnectWithoutStudentsInput
    upsert?: ParentUpsertWithoutStudentsInput
    connect?: ParentWhereUniqueInput
    update?: XOR<XOR<ParentUpdateToOneWithWhereWithoutStudentsInput, ParentUpdateWithoutStudentsInput>, ParentUncheckedUpdateWithoutStudentsInput>
  }

  export type SectionCreateNestedOneWithoutStudentAttendanceInput = {
    create?: XOR<SectionCreateWithoutStudentAttendanceInput, SectionUncheckedCreateWithoutStudentAttendanceInput>
    connectOrCreate?: SectionCreateOrConnectWithoutStudentAttendanceInput
    connect?: SectionWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutStudentAttendanceInput = {
    create?: XOR<StudentCreateWithoutStudentAttendanceInput, StudentUncheckedCreateWithoutStudentAttendanceInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentAttendanceInput
    connect?: StudentWhereUniqueInput
  }

  export type AcademicYearCreateNestedOneWithoutStudentAttendanceInput = {
    create?: XOR<AcademicYearCreateWithoutStudentAttendanceInput, AcademicYearUncheckedCreateWithoutStudentAttendanceInput>
    connectOrCreate?: AcademicYearCreateOrConnectWithoutStudentAttendanceInput
    connect?: AcademicYearWhereUniqueInput
  }

  export type EnumAttendanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.AttendanceStatus
  }

  export type SectionUpdateOneRequiredWithoutStudentAttendanceNestedInput = {
    create?: XOR<SectionCreateWithoutStudentAttendanceInput, SectionUncheckedCreateWithoutStudentAttendanceInput>
    connectOrCreate?: SectionCreateOrConnectWithoutStudentAttendanceInput
    upsert?: SectionUpsertWithoutStudentAttendanceInput
    connect?: SectionWhereUniqueInput
    update?: XOR<XOR<SectionUpdateToOneWithWhereWithoutStudentAttendanceInput, SectionUpdateWithoutStudentAttendanceInput>, SectionUncheckedUpdateWithoutStudentAttendanceInput>
  }

  export type StudentUpdateOneRequiredWithoutStudentAttendanceNestedInput = {
    create?: XOR<StudentCreateWithoutStudentAttendanceInput, StudentUncheckedCreateWithoutStudentAttendanceInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentAttendanceInput
    upsert?: StudentUpsertWithoutStudentAttendanceInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutStudentAttendanceInput, StudentUpdateWithoutStudentAttendanceInput>, StudentUncheckedUpdateWithoutStudentAttendanceInput>
  }

  export type AcademicYearUpdateOneWithoutStudentAttendanceNestedInput = {
    create?: XOR<AcademicYearCreateWithoutStudentAttendanceInput, AcademicYearUncheckedCreateWithoutStudentAttendanceInput>
    connectOrCreate?: AcademicYearCreateOrConnectWithoutStudentAttendanceInput
    upsert?: AcademicYearUpsertWithoutStudentAttendanceInput
    disconnect?: AcademicYearWhereInput | boolean
    delete?: AcademicYearWhereInput | boolean
    connect?: AcademicYearWhereUniqueInput
    update?: XOR<XOR<AcademicYearUpdateToOneWithWhereWithoutStudentAttendanceInput, AcademicYearUpdateWithoutStudentAttendanceInput>, AcademicYearUncheckedUpdateWithoutStudentAttendanceInput>
  }

  export type StudentCreateNestedOneWithoutStudentDocumentInput = {
    create?: XOR<StudentCreateWithoutStudentDocumentInput, StudentUncheckedCreateWithoutStudentDocumentInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentDocumentInput
    connect?: StudentWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutStudentDocumentInput = {
    create?: XOR<OrganizationCreateWithoutStudentDocumentInput, OrganizationUncheckedCreateWithoutStudentDocumentInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutStudentDocumentInput
    connect?: OrganizationWhereUniqueInput
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType
  }

  export type StudentUpdateOneRequiredWithoutStudentDocumentNestedInput = {
    create?: XOR<StudentCreateWithoutStudentDocumentInput, StudentUncheckedCreateWithoutStudentDocumentInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentDocumentInput
    upsert?: StudentUpsertWithoutStudentDocumentInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutStudentDocumentInput, StudentUpdateWithoutStudentDocumentInput>, StudentUncheckedUpdateWithoutStudentDocumentInput>
  }

  export type OrganizationUpdateOneWithoutStudentDocumentNestedInput = {
    create?: XOR<OrganizationCreateWithoutStudentDocumentInput, OrganizationUncheckedCreateWithoutStudentDocumentInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutStudentDocumentInput
    upsert?: OrganizationUpsertWithoutStudentDocumentInput
    disconnect?: OrganizationWhereInput | boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutStudentDocumentInput, OrganizationUpdateWithoutStudentDocumentInput>, OrganizationUncheckedUpdateWithoutStudentDocumentInput>
  }

  export type StudentCreateNestedOneWithoutFeeInput = {
    create?: XOR<StudentCreateWithoutFeeInput, StudentUncheckedCreateWithoutFeeInput>
    connectOrCreate?: StudentCreateOrConnectWithoutFeeInput
    connect?: StudentWhereUniqueInput
  }

  export type FeeCategoryCreateNestedOneWithoutFeesInput = {
    create?: XOR<FeeCategoryCreateWithoutFeesInput, FeeCategoryUncheckedCreateWithoutFeesInput>
    connectOrCreate?: FeeCategoryCreateOrConnectWithoutFeesInput
    connect?: FeeCategoryWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutFeeInput = {
    create?: XOR<OrganizationCreateWithoutFeeInput, OrganizationUncheckedCreateWithoutFeeInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutFeeInput
    connect?: OrganizationWhereUniqueInput
  }

  export type FeePaymentCreateNestedManyWithoutFeeInput = {
    create?: XOR<FeePaymentCreateWithoutFeeInput, FeePaymentUncheckedCreateWithoutFeeInput> | FeePaymentCreateWithoutFeeInput[] | FeePaymentUncheckedCreateWithoutFeeInput[]
    connectOrCreate?: FeePaymentCreateOrConnectWithoutFeeInput | FeePaymentCreateOrConnectWithoutFeeInput[]
    createMany?: FeePaymentCreateManyFeeInputEnvelope
    connect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
  }

  export type FeePaymentUncheckedCreateNestedManyWithoutFeeInput = {
    create?: XOR<FeePaymentCreateWithoutFeeInput, FeePaymentUncheckedCreateWithoutFeeInput> | FeePaymentCreateWithoutFeeInput[] | FeePaymentUncheckedCreateWithoutFeeInput[]
    connectOrCreate?: FeePaymentCreateOrConnectWithoutFeeInput | FeePaymentCreateOrConnectWithoutFeeInput[]
    createMany?: FeePaymentCreateManyFeeInputEnvelope
    connect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumFeeStatusFieldUpdateOperationsInput = {
    set?: $Enums.FeeStatus
  }

  export type StudentUpdateOneRequiredWithoutFeeNestedInput = {
    create?: XOR<StudentCreateWithoutFeeInput, StudentUncheckedCreateWithoutFeeInput>
    connectOrCreate?: StudentCreateOrConnectWithoutFeeInput
    upsert?: StudentUpsertWithoutFeeInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutFeeInput, StudentUpdateWithoutFeeInput>, StudentUncheckedUpdateWithoutFeeInput>
  }

  export type FeeCategoryUpdateOneRequiredWithoutFeesNestedInput = {
    create?: XOR<FeeCategoryCreateWithoutFeesInput, FeeCategoryUncheckedCreateWithoutFeesInput>
    connectOrCreate?: FeeCategoryCreateOrConnectWithoutFeesInput
    upsert?: FeeCategoryUpsertWithoutFeesInput
    connect?: FeeCategoryWhereUniqueInput
    update?: XOR<XOR<FeeCategoryUpdateToOneWithWhereWithoutFeesInput, FeeCategoryUpdateWithoutFeesInput>, FeeCategoryUncheckedUpdateWithoutFeesInput>
  }

  export type OrganizationUpdateOneRequiredWithoutFeeNestedInput = {
    create?: XOR<OrganizationCreateWithoutFeeInput, OrganizationUncheckedCreateWithoutFeeInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutFeeInput
    upsert?: OrganizationUpsertWithoutFeeInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutFeeInput, OrganizationUpdateWithoutFeeInput>, OrganizationUncheckedUpdateWithoutFeeInput>
  }

  export type FeePaymentUpdateManyWithoutFeeNestedInput = {
    create?: XOR<FeePaymentCreateWithoutFeeInput, FeePaymentUncheckedCreateWithoutFeeInput> | FeePaymentCreateWithoutFeeInput[] | FeePaymentUncheckedCreateWithoutFeeInput[]
    connectOrCreate?: FeePaymentCreateOrConnectWithoutFeeInput | FeePaymentCreateOrConnectWithoutFeeInput[]
    upsert?: FeePaymentUpsertWithWhereUniqueWithoutFeeInput | FeePaymentUpsertWithWhereUniqueWithoutFeeInput[]
    createMany?: FeePaymentCreateManyFeeInputEnvelope
    set?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    disconnect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    delete?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    connect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    update?: FeePaymentUpdateWithWhereUniqueWithoutFeeInput | FeePaymentUpdateWithWhereUniqueWithoutFeeInput[]
    updateMany?: FeePaymentUpdateManyWithWhereWithoutFeeInput | FeePaymentUpdateManyWithWhereWithoutFeeInput[]
    deleteMany?: FeePaymentScalarWhereInput | FeePaymentScalarWhereInput[]
  }

  export type FeePaymentUncheckedUpdateManyWithoutFeeNestedInput = {
    create?: XOR<FeePaymentCreateWithoutFeeInput, FeePaymentUncheckedCreateWithoutFeeInput> | FeePaymentCreateWithoutFeeInput[] | FeePaymentUncheckedCreateWithoutFeeInput[]
    connectOrCreate?: FeePaymentCreateOrConnectWithoutFeeInput | FeePaymentCreateOrConnectWithoutFeeInput[]
    upsert?: FeePaymentUpsertWithWhereUniqueWithoutFeeInput | FeePaymentUpsertWithWhereUniqueWithoutFeeInput[]
    createMany?: FeePaymentCreateManyFeeInputEnvelope
    set?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    disconnect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    delete?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    connect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    update?: FeePaymentUpdateWithWhereUniqueWithoutFeeInput | FeePaymentUpdateWithWhereUniqueWithoutFeeInput[]
    updateMany?: FeePaymentUpdateManyWithWhereWithoutFeeInput | FeePaymentUpdateManyWithWhereWithoutFeeInput[]
    deleteMany?: FeePaymentScalarWhereInput | FeePaymentScalarWhereInput[]
  }

  export type FeeCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<FeeCreateWithoutPaymentsInput, FeeUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: FeeCreateOrConnectWithoutPaymentsInput
    connect?: FeeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFeePaymentInput = {
    create?: XOR<UserCreateWithoutFeePaymentInput, UserUncheckedCreateWithoutFeePaymentInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeePaymentInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutFeePaymentInput = {
    create?: XOR<OrganizationCreateWithoutFeePaymentInput, OrganizationUncheckedCreateWithoutFeePaymentInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutFeePaymentInput
    connect?: OrganizationWhereUniqueInput
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type FeeUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<FeeCreateWithoutPaymentsInput, FeeUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: FeeCreateOrConnectWithoutPaymentsInput
    upsert?: FeeUpsertWithoutPaymentsInput
    connect?: FeeWhereUniqueInput
    update?: XOR<XOR<FeeUpdateToOneWithWhereWithoutPaymentsInput, FeeUpdateWithoutPaymentsInput>, FeeUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateOneRequiredWithoutFeePaymentNestedInput = {
    create?: XOR<UserCreateWithoutFeePaymentInput, UserUncheckedCreateWithoutFeePaymentInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeePaymentInput
    upsert?: UserUpsertWithoutFeePaymentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFeePaymentInput, UserUpdateWithoutFeePaymentInput>, UserUncheckedUpdateWithoutFeePaymentInput>
  }

  export type OrganizationUpdateOneRequiredWithoutFeePaymentNestedInput = {
    create?: XOR<OrganizationCreateWithoutFeePaymentInput, OrganizationUncheckedCreateWithoutFeePaymentInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutFeePaymentInput
    upsert?: OrganizationUpsertWithoutFeePaymentInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutFeePaymentInput, OrganizationUpdateWithoutFeePaymentInput>, OrganizationUncheckedUpdateWithoutFeePaymentInput>
  }

  export type ScheduledJobCreatechannelsInput = {
    set: $Enums.NotificationChannel[]
  }

  export type OrganizationCreateNestedOneWithoutScheduledJobInput = {
    create?: XOR<OrganizationCreateWithoutScheduledJobInput, OrganizationUncheckedCreateWithoutScheduledJobInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutScheduledJobInput
    connect?: OrganizationWhereUniqueInput
  }

  export type EnumscheduledJobTypeFieldUpdateOperationsInput = {
    set?: $Enums.scheduledJobType
  }

  export type ScheduledJobUpdatechannelsInput = {
    set?: $Enums.NotificationChannel[]
    push?: $Enums.NotificationChannel | $Enums.NotificationChannel[]
  }

  export type OrganizationUpdateOneRequiredWithoutScheduledJobNestedInput = {
    create?: XOR<OrganizationCreateWithoutScheduledJobInput, OrganizationUncheckedCreateWithoutScheduledJobInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutScheduledJobInput
    upsert?: OrganizationUpsertWithoutScheduledJobInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutScheduledJobInput, OrganizationUpdateWithoutScheduledJobInput>, OrganizationUncheckedUpdateWithoutScheduledJobInput>
  }

  export type FeeCreateNestedManyWithoutFeeCategoryInput = {
    create?: XOR<FeeCreateWithoutFeeCategoryInput, FeeUncheckedCreateWithoutFeeCategoryInput> | FeeCreateWithoutFeeCategoryInput[] | FeeUncheckedCreateWithoutFeeCategoryInput[]
    connectOrCreate?: FeeCreateOrConnectWithoutFeeCategoryInput | FeeCreateOrConnectWithoutFeeCategoryInput[]
    createMany?: FeeCreateManyFeeCategoryInputEnvelope
    connect?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
  }

  export type OrganizationCreateNestedOneWithoutFeeCategoryInput = {
    create?: XOR<OrganizationCreateWithoutFeeCategoryInput, OrganizationUncheckedCreateWithoutFeeCategoryInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutFeeCategoryInput
    connect?: OrganizationWhereUniqueInput
  }

  export type FeeUncheckedCreateNestedManyWithoutFeeCategoryInput = {
    create?: XOR<FeeCreateWithoutFeeCategoryInput, FeeUncheckedCreateWithoutFeeCategoryInput> | FeeCreateWithoutFeeCategoryInput[] | FeeUncheckedCreateWithoutFeeCategoryInput[]
    connectOrCreate?: FeeCreateOrConnectWithoutFeeCategoryInput | FeeCreateOrConnectWithoutFeeCategoryInput[]
    createMany?: FeeCreateManyFeeCategoryInputEnvelope
    connect?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
  }

  export type FeeUpdateManyWithoutFeeCategoryNestedInput = {
    create?: XOR<FeeCreateWithoutFeeCategoryInput, FeeUncheckedCreateWithoutFeeCategoryInput> | FeeCreateWithoutFeeCategoryInput[] | FeeUncheckedCreateWithoutFeeCategoryInput[]
    connectOrCreate?: FeeCreateOrConnectWithoutFeeCategoryInput | FeeCreateOrConnectWithoutFeeCategoryInput[]
    upsert?: FeeUpsertWithWhereUniqueWithoutFeeCategoryInput | FeeUpsertWithWhereUniqueWithoutFeeCategoryInput[]
    createMany?: FeeCreateManyFeeCategoryInputEnvelope
    set?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
    disconnect?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
    delete?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
    connect?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
    update?: FeeUpdateWithWhereUniqueWithoutFeeCategoryInput | FeeUpdateWithWhereUniqueWithoutFeeCategoryInput[]
    updateMany?: FeeUpdateManyWithWhereWithoutFeeCategoryInput | FeeUpdateManyWithWhereWithoutFeeCategoryInput[]
    deleteMany?: FeeScalarWhereInput | FeeScalarWhereInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutFeeCategoryNestedInput = {
    create?: XOR<OrganizationCreateWithoutFeeCategoryInput, OrganizationUncheckedCreateWithoutFeeCategoryInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutFeeCategoryInput
    upsert?: OrganizationUpsertWithoutFeeCategoryInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutFeeCategoryInput, OrganizationUpdateWithoutFeeCategoryInput>, OrganizationUncheckedUpdateWithoutFeeCategoryInput>
  }

  export type FeeUncheckedUpdateManyWithoutFeeCategoryNestedInput = {
    create?: XOR<FeeCreateWithoutFeeCategoryInput, FeeUncheckedCreateWithoutFeeCategoryInput> | FeeCreateWithoutFeeCategoryInput[] | FeeUncheckedCreateWithoutFeeCategoryInput[]
    connectOrCreate?: FeeCreateOrConnectWithoutFeeCategoryInput | FeeCreateOrConnectWithoutFeeCategoryInput[]
    upsert?: FeeUpsertWithWhereUniqueWithoutFeeCategoryInput | FeeUpsertWithWhereUniqueWithoutFeeCategoryInput[]
    createMany?: FeeCreateManyFeeCategoryInputEnvelope
    set?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
    disconnect?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
    delete?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
    connect?: FeeWhereUniqueInput | FeeWhereUniqueInput[]
    update?: FeeUpdateWithWhereUniqueWithoutFeeCategoryInput | FeeUpdateWithWhereUniqueWithoutFeeCategoryInput[]
    updateMany?: FeeUpdateManyWithWhereWithoutFeeCategoryInput | FeeUpdateManyWithWhereWithoutFeeCategoryInput[]
    deleteMany?: FeeScalarWhereInput | FeeScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutAcademicCalendarInput = {
    create?: XOR<OrganizationCreateWithoutAcademicCalendarInput, OrganizationUncheckedCreateWithoutAcademicCalendarInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutAcademicCalendarInput
    connect?: OrganizationWhereUniqueInput
  }

  export type AcademicYearCreateNestedOneWithoutAcademicCalendarInput = {
    create?: XOR<AcademicYearCreateWithoutAcademicCalendarInput, AcademicYearUncheckedCreateWithoutAcademicCalendarInput>
    connectOrCreate?: AcademicYearCreateOrConnectWithoutAcademicCalendarInput
    connect?: AcademicYearWhereUniqueInput
  }

  export type EnumCalendarEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.CalendarEventType
  }

  export type OrganizationUpdateOneRequiredWithoutAcademicCalendarNestedInput = {
    create?: XOR<OrganizationCreateWithoutAcademicCalendarInput, OrganizationUncheckedCreateWithoutAcademicCalendarInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutAcademicCalendarInput
    upsert?: OrganizationUpsertWithoutAcademicCalendarInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutAcademicCalendarInput, OrganizationUpdateWithoutAcademicCalendarInput>, OrganizationUncheckedUpdateWithoutAcademicCalendarInput>
  }

  export type AcademicYearUpdateOneWithoutAcademicCalendarNestedInput = {
    create?: XOR<AcademicYearCreateWithoutAcademicCalendarInput, AcademicYearUncheckedCreateWithoutAcademicCalendarInput>
    connectOrCreate?: AcademicYearCreateOrConnectWithoutAcademicCalendarInput
    upsert?: AcademicYearUpsertWithoutAcademicCalendarInput
    disconnect?: AcademicYearWhereInput | boolean
    delete?: AcademicYearWhereInput | boolean
    connect?: AcademicYearWhereUniqueInput
    update?: XOR<XOR<AcademicYearUpdateToOneWithWhereWithoutAcademicCalendarInput, AcademicYearUpdateWithoutAcademicCalendarInput>, AcademicYearUncheckedUpdateWithoutAcademicCalendarInput>
  }

  export type AnonymousComplaintCreateevidenceUrlsInput = {
    set: string[]
  }

  export type OrganizationCreateNestedOneWithoutAnonymousComplaintInput = {
    create?: XOR<OrganizationCreateWithoutAnonymousComplaintInput, OrganizationUncheckedCreateWithoutAnonymousComplaintInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutAnonymousComplaintInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ComplaintStatusTimelineCreateNestedManyWithoutComplaintInput = {
    create?: XOR<ComplaintStatusTimelineCreateWithoutComplaintInput, ComplaintStatusTimelineUncheckedCreateWithoutComplaintInput> | ComplaintStatusTimelineCreateWithoutComplaintInput[] | ComplaintStatusTimelineUncheckedCreateWithoutComplaintInput[]
    connectOrCreate?: ComplaintStatusTimelineCreateOrConnectWithoutComplaintInput | ComplaintStatusTimelineCreateOrConnectWithoutComplaintInput[]
    createMany?: ComplaintStatusTimelineCreateManyComplaintInputEnvelope
    connect?: ComplaintStatusTimelineWhereUniqueInput | ComplaintStatusTimelineWhereUniqueInput[]
  }

  export type AcademicYearCreateNestedOneWithoutComplaintsInput = {
    create?: XOR<AcademicYearCreateWithoutComplaintsInput, AcademicYearUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: AcademicYearCreateOrConnectWithoutComplaintsInput
    connect?: AcademicYearWhereUniqueInput
  }

  export type ComplaintStatusTimelineUncheckedCreateNestedManyWithoutComplaintInput = {
    create?: XOR<ComplaintStatusTimelineCreateWithoutComplaintInput, ComplaintStatusTimelineUncheckedCreateWithoutComplaintInput> | ComplaintStatusTimelineCreateWithoutComplaintInput[] | ComplaintStatusTimelineUncheckedCreateWithoutComplaintInput[]
    connectOrCreate?: ComplaintStatusTimelineCreateOrConnectWithoutComplaintInput | ComplaintStatusTimelineCreateOrConnectWithoutComplaintInput[]
    createMany?: ComplaintStatusTimelineCreateManyComplaintInputEnvelope
    connect?: ComplaintStatusTimelineWhereUniqueInput | ComplaintStatusTimelineWhereUniqueInput[]
  }

  export type EnumSeverityFieldUpdateOperationsInput = {
    set?: $Enums.Severity
  }

  export type AnonymousComplaintUpdateevidenceUrlsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumComplaintStatusFieldUpdateOperationsInput = {
    set?: $Enums.ComplaintStatus
  }

  export type OrganizationUpdateOneRequiredWithoutAnonymousComplaintNestedInput = {
    create?: XOR<OrganizationCreateWithoutAnonymousComplaintInput, OrganizationUncheckedCreateWithoutAnonymousComplaintInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutAnonymousComplaintInput
    upsert?: OrganizationUpsertWithoutAnonymousComplaintInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutAnonymousComplaintInput, OrganizationUpdateWithoutAnonymousComplaintInput>, OrganizationUncheckedUpdateWithoutAnonymousComplaintInput>
  }

  export type ComplaintStatusTimelineUpdateManyWithoutComplaintNestedInput = {
    create?: XOR<ComplaintStatusTimelineCreateWithoutComplaintInput, ComplaintStatusTimelineUncheckedCreateWithoutComplaintInput> | ComplaintStatusTimelineCreateWithoutComplaintInput[] | ComplaintStatusTimelineUncheckedCreateWithoutComplaintInput[]
    connectOrCreate?: ComplaintStatusTimelineCreateOrConnectWithoutComplaintInput | ComplaintStatusTimelineCreateOrConnectWithoutComplaintInput[]
    upsert?: ComplaintStatusTimelineUpsertWithWhereUniqueWithoutComplaintInput | ComplaintStatusTimelineUpsertWithWhereUniqueWithoutComplaintInput[]
    createMany?: ComplaintStatusTimelineCreateManyComplaintInputEnvelope
    set?: ComplaintStatusTimelineWhereUniqueInput | ComplaintStatusTimelineWhereUniqueInput[]
    disconnect?: ComplaintStatusTimelineWhereUniqueInput | ComplaintStatusTimelineWhereUniqueInput[]
    delete?: ComplaintStatusTimelineWhereUniqueInput | ComplaintStatusTimelineWhereUniqueInput[]
    connect?: ComplaintStatusTimelineWhereUniqueInput | ComplaintStatusTimelineWhereUniqueInput[]
    update?: ComplaintStatusTimelineUpdateWithWhereUniqueWithoutComplaintInput | ComplaintStatusTimelineUpdateWithWhereUniqueWithoutComplaintInput[]
    updateMany?: ComplaintStatusTimelineUpdateManyWithWhereWithoutComplaintInput | ComplaintStatusTimelineUpdateManyWithWhereWithoutComplaintInput[]
    deleteMany?: ComplaintStatusTimelineScalarWhereInput | ComplaintStatusTimelineScalarWhereInput[]
  }

  export type AcademicYearUpdateOneWithoutComplaintsNestedInput = {
    create?: XOR<AcademicYearCreateWithoutComplaintsInput, AcademicYearUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: AcademicYearCreateOrConnectWithoutComplaintsInput
    upsert?: AcademicYearUpsertWithoutComplaintsInput
    disconnect?: AcademicYearWhereInput | boolean
    delete?: AcademicYearWhereInput | boolean
    connect?: AcademicYearWhereUniqueInput
    update?: XOR<XOR<AcademicYearUpdateToOneWithWhereWithoutComplaintsInput, AcademicYearUpdateWithoutComplaintsInput>, AcademicYearUncheckedUpdateWithoutComplaintsInput>
  }

  export type ComplaintStatusTimelineUncheckedUpdateManyWithoutComplaintNestedInput = {
    create?: XOR<ComplaintStatusTimelineCreateWithoutComplaintInput, ComplaintStatusTimelineUncheckedCreateWithoutComplaintInput> | ComplaintStatusTimelineCreateWithoutComplaintInput[] | ComplaintStatusTimelineUncheckedCreateWithoutComplaintInput[]
    connectOrCreate?: ComplaintStatusTimelineCreateOrConnectWithoutComplaintInput | ComplaintStatusTimelineCreateOrConnectWithoutComplaintInput[]
    upsert?: ComplaintStatusTimelineUpsertWithWhereUniqueWithoutComplaintInput | ComplaintStatusTimelineUpsertWithWhereUniqueWithoutComplaintInput[]
    createMany?: ComplaintStatusTimelineCreateManyComplaintInputEnvelope
    set?: ComplaintStatusTimelineWhereUniqueInput | ComplaintStatusTimelineWhereUniqueInput[]
    disconnect?: ComplaintStatusTimelineWhereUniqueInput | ComplaintStatusTimelineWhereUniqueInput[]
    delete?: ComplaintStatusTimelineWhereUniqueInput | ComplaintStatusTimelineWhereUniqueInput[]
    connect?: ComplaintStatusTimelineWhereUniqueInput | ComplaintStatusTimelineWhereUniqueInput[]
    update?: ComplaintStatusTimelineUpdateWithWhereUniqueWithoutComplaintInput | ComplaintStatusTimelineUpdateWithWhereUniqueWithoutComplaintInput[]
    updateMany?: ComplaintStatusTimelineUpdateManyWithWhereWithoutComplaintInput | ComplaintStatusTimelineUpdateManyWithWhereWithoutComplaintInput[]
    deleteMany?: ComplaintStatusTimelineScalarWhereInput | ComplaintStatusTimelineScalarWhereInput[]
  }

  export type AnonymousComplaintCreateNestedOneWithoutComplaintStatusTimelineInput = {
    create?: XOR<AnonymousComplaintCreateWithoutComplaintStatusTimelineInput, AnonymousComplaintUncheckedCreateWithoutComplaintStatusTimelineInput>
    connectOrCreate?: AnonymousComplaintCreateOrConnectWithoutComplaintStatusTimelineInput
    connect?: AnonymousComplaintWhereUniqueInput
  }

  export type AnonymousComplaintUpdateOneRequiredWithoutComplaintStatusTimelineNestedInput = {
    create?: XOR<AnonymousComplaintCreateWithoutComplaintStatusTimelineInput, AnonymousComplaintUncheckedCreateWithoutComplaintStatusTimelineInput>
    connectOrCreate?: AnonymousComplaintCreateOrConnectWithoutComplaintStatusTimelineInput
    upsert?: AnonymousComplaintUpsertWithoutComplaintStatusTimelineInput
    connect?: AnonymousComplaintWhereUniqueInput
    update?: XOR<XOR<AnonymousComplaintUpdateToOneWithWhereWithoutComplaintStatusTimelineInput, AnonymousComplaintUpdateWithoutComplaintStatusTimelineInput>, AnonymousComplaintUncheckedUpdateWithoutComplaintStatusTimelineInput>
  }

  export type NoticeCreatetargetAudienceInput = {
    set: string[]
  }

  export type OrganizationCreateNestedOneWithoutNoticesInput = {
    create?: XOR<OrganizationCreateWithoutNoticesInput, OrganizationUncheckedCreateWithoutNoticesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutNoticesInput
    connect?: OrganizationWhereUniqueInput
  }

  export type AcademicYearCreateNestedOneWithoutNoticesInput = {
    create?: XOR<AcademicYearCreateWithoutNoticesInput, AcademicYearUncheckedCreateWithoutNoticesInput>
    connectOrCreate?: AcademicYearCreateOrConnectWithoutNoticesInput
    connect?: AcademicYearWhereUniqueInput
  }

  export type NoticeUpdatetargetAudienceInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OrganizationUpdateOneRequiredWithoutNoticesNestedInput = {
    create?: XOR<OrganizationCreateWithoutNoticesInput, OrganizationUncheckedCreateWithoutNoticesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutNoticesInput
    upsert?: OrganizationUpsertWithoutNoticesInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutNoticesInput, OrganizationUpdateWithoutNoticesInput>, OrganizationUncheckedUpdateWithoutNoticesInput>
  }

  export type AcademicYearUpdateOneWithoutNoticesNestedInput = {
    create?: XOR<AcademicYearCreateWithoutNoticesInput, AcademicYearUncheckedCreateWithoutNoticesInput>
    connectOrCreate?: AcademicYearCreateOrConnectWithoutNoticesInput
    upsert?: AcademicYearUpsertWithoutNoticesInput
    disconnect?: AcademicYearWhereInput | boolean
    delete?: AcademicYearWhereInput | boolean
    connect?: AcademicYearWhereUniqueInput
    update?: XOR<XOR<AcademicYearUpdateToOneWithWhereWithoutNoticesInput, AcademicYearUpdateWithoutNoticesInput>, AcademicYearUncheckedUpdateWithoutNoticesInput>
  }

  export type OrganizationCreateNestedOneWithoutNotificationLogInput = {
    create?: XOR<OrganizationCreateWithoutNotificationLogInput, OrganizationUncheckedCreateWithoutNotificationLogInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutNotificationLogInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotificationLogInput = {
    create?: XOR<UserCreateWithoutNotificationLogInput, UserUncheckedCreateWithoutNotificationLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationLogInput
    connect?: UserWhereUniqueInput
  }

  export type ParentCreateNestedOneWithoutNotificationLogInput = {
    create?: XOR<ParentCreateWithoutNotificationLogInput, ParentUncheckedCreateWithoutNotificationLogInput>
    connectOrCreate?: ParentCreateOrConnectWithoutNotificationLogInput
    connect?: ParentWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutNotificationLogInput = {
    create?: XOR<StudentCreateWithoutNotificationLogInput, StudentUncheckedCreateWithoutNotificationLogInput>
    connectOrCreate?: StudentCreateOrConnectWithoutNotificationLogInput
    connect?: StudentWhereUniqueInput
  }

  export type EnumNotificationChannelFieldUpdateOperationsInput = {
    set?: $Enums.NotificationChannel
  }

  export type EnumNotificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.NotificationStatus
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type OrganizationUpdateOneRequiredWithoutNotificationLogNestedInput = {
    create?: XOR<OrganizationCreateWithoutNotificationLogInput, OrganizationUncheckedCreateWithoutNotificationLogInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutNotificationLogInput
    upsert?: OrganizationUpsertWithoutNotificationLogInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutNotificationLogInput, OrganizationUpdateWithoutNotificationLogInput>, OrganizationUncheckedUpdateWithoutNotificationLogInput>
  }

  export type UserUpdateOneWithoutNotificationLogNestedInput = {
    create?: XOR<UserCreateWithoutNotificationLogInput, UserUncheckedCreateWithoutNotificationLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationLogInput
    upsert?: UserUpsertWithoutNotificationLogInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationLogInput, UserUpdateWithoutNotificationLogInput>, UserUncheckedUpdateWithoutNotificationLogInput>
  }

  export type ParentUpdateOneWithoutNotificationLogNestedInput = {
    create?: XOR<ParentCreateWithoutNotificationLogInput, ParentUncheckedCreateWithoutNotificationLogInput>
    connectOrCreate?: ParentCreateOrConnectWithoutNotificationLogInput
    upsert?: ParentUpsertWithoutNotificationLogInput
    disconnect?: ParentWhereInput | boolean
    delete?: ParentWhereInput | boolean
    connect?: ParentWhereUniqueInput
    update?: XOR<XOR<ParentUpdateToOneWithWhereWithoutNotificationLogInput, ParentUpdateWithoutNotificationLogInput>, ParentUncheckedUpdateWithoutNotificationLogInput>
  }

  export type StudentUpdateOneWithoutNotificationLogNestedInput = {
    create?: XOR<StudentCreateWithoutNotificationLogInput, StudentUncheckedCreateWithoutNotificationLogInput>
    connectOrCreate?: StudentCreateOrConnectWithoutNotificationLogInput
    upsert?: StudentUpsertWithoutNotificationLogInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutNotificationLogInput, StudentUpdateWithoutNotificationLogInput>, StudentUncheckedUpdateWithoutNotificationLogInput>
  }

  export type AcademicYearCreateNestedOneWithoutExamSessionInput = {
    create?: XOR<AcademicYearCreateWithoutExamSessionInput, AcademicYearUncheckedCreateWithoutExamSessionInput>
    connectOrCreate?: AcademicYearCreateOrConnectWithoutExamSessionInput
    connect?: AcademicYearWhereUniqueInput
  }

  export type ExamCreateNestedManyWithoutExamSessionInput = {
    create?: XOR<ExamCreateWithoutExamSessionInput, ExamUncheckedCreateWithoutExamSessionInput> | ExamCreateWithoutExamSessionInput[] | ExamUncheckedCreateWithoutExamSessionInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutExamSessionInput | ExamCreateOrConnectWithoutExamSessionInput[]
    createMany?: ExamCreateManyExamSessionInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type ReportCardCreateNestedManyWithoutExamSessionInput = {
    create?: XOR<ReportCardCreateWithoutExamSessionInput, ReportCardUncheckedCreateWithoutExamSessionInput> | ReportCardCreateWithoutExamSessionInput[] | ReportCardUncheckedCreateWithoutExamSessionInput[]
    connectOrCreate?: ReportCardCreateOrConnectWithoutExamSessionInput | ReportCardCreateOrConnectWithoutExamSessionInput[]
    createMany?: ReportCardCreateManyExamSessionInputEnvelope
    connect?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
  }

  export type HallTicketCreateNestedManyWithoutExamSessionInput = {
    create?: XOR<HallTicketCreateWithoutExamSessionInput, HallTicketUncheckedCreateWithoutExamSessionInput> | HallTicketCreateWithoutExamSessionInput[] | HallTicketUncheckedCreateWithoutExamSessionInput[]
    connectOrCreate?: HallTicketCreateOrConnectWithoutExamSessionInput | HallTicketCreateOrConnectWithoutExamSessionInput[]
    createMany?: HallTicketCreateManyExamSessionInputEnvelope
    connect?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
  }

  export type ExamUncheckedCreateNestedManyWithoutExamSessionInput = {
    create?: XOR<ExamCreateWithoutExamSessionInput, ExamUncheckedCreateWithoutExamSessionInput> | ExamCreateWithoutExamSessionInput[] | ExamUncheckedCreateWithoutExamSessionInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutExamSessionInput | ExamCreateOrConnectWithoutExamSessionInput[]
    createMany?: ExamCreateManyExamSessionInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type ReportCardUncheckedCreateNestedManyWithoutExamSessionInput = {
    create?: XOR<ReportCardCreateWithoutExamSessionInput, ReportCardUncheckedCreateWithoutExamSessionInput> | ReportCardCreateWithoutExamSessionInput[] | ReportCardUncheckedCreateWithoutExamSessionInput[]
    connectOrCreate?: ReportCardCreateOrConnectWithoutExamSessionInput | ReportCardCreateOrConnectWithoutExamSessionInput[]
    createMany?: ReportCardCreateManyExamSessionInputEnvelope
    connect?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
  }

  export type HallTicketUncheckedCreateNestedManyWithoutExamSessionInput = {
    create?: XOR<HallTicketCreateWithoutExamSessionInput, HallTicketUncheckedCreateWithoutExamSessionInput> | HallTicketCreateWithoutExamSessionInput[] | HallTicketUncheckedCreateWithoutExamSessionInput[]
    connectOrCreate?: HallTicketCreateOrConnectWithoutExamSessionInput | HallTicketCreateOrConnectWithoutExamSessionInput[]
    createMany?: HallTicketCreateManyExamSessionInputEnvelope
    connect?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
  }

  export type AcademicYearUpdateOneRequiredWithoutExamSessionNestedInput = {
    create?: XOR<AcademicYearCreateWithoutExamSessionInput, AcademicYearUncheckedCreateWithoutExamSessionInput>
    connectOrCreate?: AcademicYearCreateOrConnectWithoutExamSessionInput
    upsert?: AcademicYearUpsertWithoutExamSessionInput
    connect?: AcademicYearWhereUniqueInput
    update?: XOR<XOR<AcademicYearUpdateToOneWithWhereWithoutExamSessionInput, AcademicYearUpdateWithoutExamSessionInput>, AcademicYearUncheckedUpdateWithoutExamSessionInput>
  }

  export type ExamUpdateManyWithoutExamSessionNestedInput = {
    create?: XOR<ExamCreateWithoutExamSessionInput, ExamUncheckedCreateWithoutExamSessionInput> | ExamCreateWithoutExamSessionInput[] | ExamUncheckedCreateWithoutExamSessionInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutExamSessionInput | ExamCreateOrConnectWithoutExamSessionInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutExamSessionInput | ExamUpsertWithWhereUniqueWithoutExamSessionInput[]
    createMany?: ExamCreateManyExamSessionInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutExamSessionInput | ExamUpdateWithWhereUniqueWithoutExamSessionInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutExamSessionInput | ExamUpdateManyWithWhereWithoutExamSessionInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type ReportCardUpdateManyWithoutExamSessionNestedInput = {
    create?: XOR<ReportCardCreateWithoutExamSessionInput, ReportCardUncheckedCreateWithoutExamSessionInput> | ReportCardCreateWithoutExamSessionInput[] | ReportCardUncheckedCreateWithoutExamSessionInput[]
    connectOrCreate?: ReportCardCreateOrConnectWithoutExamSessionInput | ReportCardCreateOrConnectWithoutExamSessionInput[]
    upsert?: ReportCardUpsertWithWhereUniqueWithoutExamSessionInput | ReportCardUpsertWithWhereUniqueWithoutExamSessionInput[]
    createMany?: ReportCardCreateManyExamSessionInputEnvelope
    set?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    disconnect?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    delete?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    connect?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    update?: ReportCardUpdateWithWhereUniqueWithoutExamSessionInput | ReportCardUpdateWithWhereUniqueWithoutExamSessionInput[]
    updateMany?: ReportCardUpdateManyWithWhereWithoutExamSessionInput | ReportCardUpdateManyWithWhereWithoutExamSessionInput[]
    deleteMany?: ReportCardScalarWhereInput | ReportCardScalarWhereInput[]
  }

  export type HallTicketUpdateManyWithoutExamSessionNestedInput = {
    create?: XOR<HallTicketCreateWithoutExamSessionInput, HallTicketUncheckedCreateWithoutExamSessionInput> | HallTicketCreateWithoutExamSessionInput[] | HallTicketUncheckedCreateWithoutExamSessionInput[]
    connectOrCreate?: HallTicketCreateOrConnectWithoutExamSessionInput | HallTicketCreateOrConnectWithoutExamSessionInput[]
    upsert?: HallTicketUpsertWithWhereUniqueWithoutExamSessionInput | HallTicketUpsertWithWhereUniqueWithoutExamSessionInput[]
    createMany?: HallTicketCreateManyExamSessionInputEnvelope
    set?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
    disconnect?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
    delete?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
    connect?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
    update?: HallTicketUpdateWithWhereUniqueWithoutExamSessionInput | HallTicketUpdateWithWhereUniqueWithoutExamSessionInput[]
    updateMany?: HallTicketUpdateManyWithWhereWithoutExamSessionInput | HallTicketUpdateManyWithWhereWithoutExamSessionInput[]
    deleteMany?: HallTicketScalarWhereInput | HallTicketScalarWhereInput[]
  }

  export type ExamUncheckedUpdateManyWithoutExamSessionNestedInput = {
    create?: XOR<ExamCreateWithoutExamSessionInput, ExamUncheckedCreateWithoutExamSessionInput> | ExamCreateWithoutExamSessionInput[] | ExamUncheckedCreateWithoutExamSessionInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutExamSessionInput | ExamCreateOrConnectWithoutExamSessionInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutExamSessionInput | ExamUpsertWithWhereUniqueWithoutExamSessionInput[]
    createMany?: ExamCreateManyExamSessionInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutExamSessionInput | ExamUpdateWithWhereUniqueWithoutExamSessionInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutExamSessionInput | ExamUpdateManyWithWhereWithoutExamSessionInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type ReportCardUncheckedUpdateManyWithoutExamSessionNestedInput = {
    create?: XOR<ReportCardCreateWithoutExamSessionInput, ReportCardUncheckedCreateWithoutExamSessionInput> | ReportCardCreateWithoutExamSessionInput[] | ReportCardUncheckedCreateWithoutExamSessionInput[]
    connectOrCreate?: ReportCardCreateOrConnectWithoutExamSessionInput | ReportCardCreateOrConnectWithoutExamSessionInput[]
    upsert?: ReportCardUpsertWithWhereUniqueWithoutExamSessionInput | ReportCardUpsertWithWhereUniqueWithoutExamSessionInput[]
    createMany?: ReportCardCreateManyExamSessionInputEnvelope
    set?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    disconnect?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    delete?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    connect?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    update?: ReportCardUpdateWithWhereUniqueWithoutExamSessionInput | ReportCardUpdateWithWhereUniqueWithoutExamSessionInput[]
    updateMany?: ReportCardUpdateManyWithWhereWithoutExamSessionInput | ReportCardUpdateManyWithWhereWithoutExamSessionInput[]
    deleteMany?: ReportCardScalarWhereInput | ReportCardScalarWhereInput[]
  }

  export type HallTicketUncheckedUpdateManyWithoutExamSessionNestedInput = {
    create?: XOR<HallTicketCreateWithoutExamSessionInput, HallTicketUncheckedCreateWithoutExamSessionInput> | HallTicketCreateWithoutExamSessionInput[] | HallTicketUncheckedCreateWithoutExamSessionInput[]
    connectOrCreate?: HallTicketCreateOrConnectWithoutExamSessionInput | HallTicketCreateOrConnectWithoutExamSessionInput[]
    upsert?: HallTicketUpsertWithWhereUniqueWithoutExamSessionInput | HallTicketUpsertWithWhereUniqueWithoutExamSessionInput[]
    createMany?: HallTicketCreateManyExamSessionInputEnvelope
    set?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
    disconnect?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
    delete?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
    connect?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
    update?: HallTicketUpdateWithWhereUniqueWithoutExamSessionInput | HallTicketUpdateWithWhereUniqueWithoutExamSessionInput[]
    updateMany?: HallTicketUpdateManyWithWhereWithoutExamSessionInput | HallTicketUpdateManyWithWhereWithoutExamSessionInput[]
    deleteMany?: HallTicketScalarWhereInput | HallTicketScalarWhereInput[]
  }

  export type ExamCreatesupervisorsInput = {
    set: string[]
  }

  export type ExamSessionCreateNestedOneWithoutExamsInput = {
    create?: XOR<ExamSessionCreateWithoutExamsInput, ExamSessionUncheckedCreateWithoutExamsInput>
    connectOrCreate?: ExamSessionCreateOrConnectWithoutExamsInput
    connect?: ExamSessionWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutExamInput = {
    create?: XOR<SubjectCreateWithoutExamInput, SubjectUncheckedCreateWithoutExamInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutExamInput
    connect?: SubjectWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutExamInput = {
    create?: XOR<OrganizationCreateWithoutExamInput, OrganizationUncheckedCreateWithoutExamInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutExamInput
    connect?: OrganizationWhereUniqueInput
  }

  export type HallTicketCreateNestedManyWithoutExamInput = {
    create?: XOR<HallTicketCreateWithoutExamInput, HallTicketUncheckedCreateWithoutExamInput> | HallTicketCreateWithoutExamInput[] | HallTicketUncheckedCreateWithoutExamInput[]
    connectOrCreate?: HallTicketCreateOrConnectWithoutExamInput | HallTicketCreateOrConnectWithoutExamInput[]
    createMany?: HallTicketCreateManyExamInputEnvelope
    connect?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
  }

  export type ExamResultCreateNestedManyWithoutExamInput = {
    create?: XOR<ExamResultCreateWithoutExamInput, ExamResultUncheckedCreateWithoutExamInput> | ExamResultCreateWithoutExamInput[] | ExamResultUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamResultCreateOrConnectWithoutExamInput | ExamResultCreateOrConnectWithoutExamInput[]
    createMany?: ExamResultCreateManyExamInputEnvelope
    connect?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
  }

  export type ExamEnrollmentCreateNestedManyWithoutExamInput = {
    create?: XOR<ExamEnrollmentCreateWithoutExamInput, ExamEnrollmentUncheckedCreateWithoutExamInput> | ExamEnrollmentCreateWithoutExamInput[] | ExamEnrollmentUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamEnrollmentCreateOrConnectWithoutExamInput | ExamEnrollmentCreateOrConnectWithoutExamInput[]
    createMany?: ExamEnrollmentCreateManyExamInputEnvelope
    connect?: ExamEnrollmentWhereUniqueInput | ExamEnrollmentWhereUniqueInput[]
  }

  export type HallTicketUncheckedCreateNestedManyWithoutExamInput = {
    create?: XOR<HallTicketCreateWithoutExamInput, HallTicketUncheckedCreateWithoutExamInput> | HallTicketCreateWithoutExamInput[] | HallTicketUncheckedCreateWithoutExamInput[]
    connectOrCreate?: HallTicketCreateOrConnectWithoutExamInput | HallTicketCreateOrConnectWithoutExamInput[]
    createMany?: HallTicketCreateManyExamInputEnvelope
    connect?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
  }

  export type ExamResultUncheckedCreateNestedManyWithoutExamInput = {
    create?: XOR<ExamResultCreateWithoutExamInput, ExamResultUncheckedCreateWithoutExamInput> | ExamResultCreateWithoutExamInput[] | ExamResultUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamResultCreateOrConnectWithoutExamInput | ExamResultCreateOrConnectWithoutExamInput[]
    createMany?: ExamResultCreateManyExamInputEnvelope
    connect?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
  }

  export type ExamEnrollmentUncheckedCreateNestedManyWithoutExamInput = {
    create?: XOR<ExamEnrollmentCreateWithoutExamInput, ExamEnrollmentUncheckedCreateWithoutExamInput> | ExamEnrollmentCreateWithoutExamInput[] | ExamEnrollmentUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamEnrollmentCreateOrConnectWithoutExamInput | ExamEnrollmentCreateOrConnectWithoutExamInput[]
    createMany?: ExamEnrollmentCreateManyExamInputEnvelope
    connect?: ExamEnrollmentWhereUniqueInput | ExamEnrollmentWhereUniqueInput[]
  }

  export type EnumEvaluationTypeFieldUpdateOperationsInput = {
    set?: $Enums.EvaluationType
  }

  export type EnumExamModeFieldUpdateOperationsInput = {
    set?: $Enums.ExamMode
  }

  export type EnumExamStatusFieldUpdateOperationsInput = {
    set?: $Enums.ExamStatus
  }

  export type ExamUpdatesupervisorsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ExamSessionUpdateOneRequiredWithoutExamsNestedInput = {
    create?: XOR<ExamSessionCreateWithoutExamsInput, ExamSessionUncheckedCreateWithoutExamsInput>
    connectOrCreate?: ExamSessionCreateOrConnectWithoutExamsInput
    upsert?: ExamSessionUpsertWithoutExamsInput
    connect?: ExamSessionWhereUniqueInput
    update?: XOR<XOR<ExamSessionUpdateToOneWithWhereWithoutExamsInput, ExamSessionUpdateWithoutExamsInput>, ExamSessionUncheckedUpdateWithoutExamsInput>
  }

  export type SubjectUpdateOneRequiredWithoutExamNestedInput = {
    create?: XOR<SubjectCreateWithoutExamInput, SubjectUncheckedCreateWithoutExamInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutExamInput
    upsert?: SubjectUpsertWithoutExamInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutExamInput, SubjectUpdateWithoutExamInput>, SubjectUncheckedUpdateWithoutExamInput>
  }

  export type OrganizationUpdateOneRequiredWithoutExamNestedInput = {
    create?: XOR<OrganizationCreateWithoutExamInput, OrganizationUncheckedCreateWithoutExamInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutExamInput
    upsert?: OrganizationUpsertWithoutExamInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutExamInput, OrganizationUpdateWithoutExamInput>, OrganizationUncheckedUpdateWithoutExamInput>
  }

  export type HallTicketUpdateManyWithoutExamNestedInput = {
    create?: XOR<HallTicketCreateWithoutExamInput, HallTicketUncheckedCreateWithoutExamInput> | HallTicketCreateWithoutExamInput[] | HallTicketUncheckedCreateWithoutExamInput[]
    connectOrCreate?: HallTicketCreateOrConnectWithoutExamInput | HallTicketCreateOrConnectWithoutExamInput[]
    upsert?: HallTicketUpsertWithWhereUniqueWithoutExamInput | HallTicketUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: HallTicketCreateManyExamInputEnvelope
    set?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
    disconnect?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
    delete?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
    connect?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
    update?: HallTicketUpdateWithWhereUniqueWithoutExamInput | HallTicketUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: HallTicketUpdateManyWithWhereWithoutExamInput | HallTicketUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: HallTicketScalarWhereInput | HallTicketScalarWhereInput[]
  }

  export type ExamResultUpdateManyWithoutExamNestedInput = {
    create?: XOR<ExamResultCreateWithoutExamInput, ExamResultUncheckedCreateWithoutExamInput> | ExamResultCreateWithoutExamInput[] | ExamResultUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamResultCreateOrConnectWithoutExamInput | ExamResultCreateOrConnectWithoutExamInput[]
    upsert?: ExamResultUpsertWithWhereUniqueWithoutExamInput | ExamResultUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: ExamResultCreateManyExamInputEnvelope
    set?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
    disconnect?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
    delete?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
    connect?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
    update?: ExamResultUpdateWithWhereUniqueWithoutExamInput | ExamResultUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: ExamResultUpdateManyWithWhereWithoutExamInput | ExamResultUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: ExamResultScalarWhereInput | ExamResultScalarWhereInput[]
  }

  export type ExamEnrollmentUpdateManyWithoutExamNestedInput = {
    create?: XOR<ExamEnrollmentCreateWithoutExamInput, ExamEnrollmentUncheckedCreateWithoutExamInput> | ExamEnrollmentCreateWithoutExamInput[] | ExamEnrollmentUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamEnrollmentCreateOrConnectWithoutExamInput | ExamEnrollmentCreateOrConnectWithoutExamInput[]
    upsert?: ExamEnrollmentUpsertWithWhereUniqueWithoutExamInput | ExamEnrollmentUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: ExamEnrollmentCreateManyExamInputEnvelope
    set?: ExamEnrollmentWhereUniqueInput | ExamEnrollmentWhereUniqueInput[]
    disconnect?: ExamEnrollmentWhereUniqueInput | ExamEnrollmentWhereUniqueInput[]
    delete?: ExamEnrollmentWhereUniqueInput | ExamEnrollmentWhereUniqueInput[]
    connect?: ExamEnrollmentWhereUniqueInput | ExamEnrollmentWhereUniqueInput[]
    update?: ExamEnrollmentUpdateWithWhereUniqueWithoutExamInput | ExamEnrollmentUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: ExamEnrollmentUpdateManyWithWhereWithoutExamInput | ExamEnrollmentUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: ExamEnrollmentScalarWhereInput | ExamEnrollmentScalarWhereInput[]
  }

  export type HallTicketUncheckedUpdateManyWithoutExamNestedInput = {
    create?: XOR<HallTicketCreateWithoutExamInput, HallTicketUncheckedCreateWithoutExamInput> | HallTicketCreateWithoutExamInput[] | HallTicketUncheckedCreateWithoutExamInput[]
    connectOrCreate?: HallTicketCreateOrConnectWithoutExamInput | HallTicketCreateOrConnectWithoutExamInput[]
    upsert?: HallTicketUpsertWithWhereUniqueWithoutExamInput | HallTicketUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: HallTicketCreateManyExamInputEnvelope
    set?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
    disconnect?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
    delete?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
    connect?: HallTicketWhereUniqueInput | HallTicketWhereUniqueInput[]
    update?: HallTicketUpdateWithWhereUniqueWithoutExamInput | HallTicketUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: HallTicketUpdateManyWithWhereWithoutExamInput | HallTicketUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: HallTicketScalarWhereInput | HallTicketScalarWhereInput[]
  }

  export type ExamResultUncheckedUpdateManyWithoutExamNestedInput = {
    create?: XOR<ExamResultCreateWithoutExamInput, ExamResultUncheckedCreateWithoutExamInput> | ExamResultCreateWithoutExamInput[] | ExamResultUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamResultCreateOrConnectWithoutExamInput | ExamResultCreateOrConnectWithoutExamInput[]
    upsert?: ExamResultUpsertWithWhereUniqueWithoutExamInput | ExamResultUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: ExamResultCreateManyExamInputEnvelope
    set?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
    disconnect?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
    delete?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
    connect?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
    update?: ExamResultUpdateWithWhereUniqueWithoutExamInput | ExamResultUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: ExamResultUpdateManyWithWhereWithoutExamInput | ExamResultUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: ExamResultScalarWhereInput | ExamResultScalarWhereInput[]
  }

  export type ExamEnrollmentUncheckedUpdateManyWithoutExamNestedInput = {
    create?: XOR<ExamEnrollmentCreateWithoutExamInput, ExamEnrollmentUncheckedCreateWithoutExamInput> | ExamEnrollmentCreateWithoutExamInput[] | ExamEnrollmentUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamEnrollmentCreateOrConnectWithoutExamInput | ExamEnrollmentCreateOrConnectWithoutExamInput[]
    upsert?: ExamEnrollmentUpsertWithWhereUniqueWithoutExamInput | ExamEnrollmentUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: ExamEnrollmentCreateManyExamInputEnvelope
    set?: ExamEnrollmentWhereUniqueInput | ExamEnrollmentWhereUniqueInput[]
    disconnect?: ExamEnrollmentWhereUniqueInput | ExamEnrollmentWhereUniqueInput[]
    delete?: ExamEnrollmentWhereUniqueInput | ExamEnrollmentWhereUniqueInput[]
    connect?: ExamEnrollmentWhereUniqueInput | ExamEnrollmentWhereUniqueInput[]
    update?: ExamEnrollmentUpdateWithWhereUniqueWithoutExamInput | ExamEnrollmentUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: ExamEnrollmentUpdateManyWithWhereWithoutExamInput | ExamEnrollmentUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: ExamEnrollmentScalarWhereInput | ExamEnrollmentScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutExamEnrollmentInput = {
    create?: XOR<StudentCreateWithoutExamEnrollmentInput, StudentUncheckedCreateWithoutExamEnrollmentInput>
    connectOrCreate?: StudentCreateOrConnectWithoutExamEnrollmentInput
    connect?: StudentWhereUniqueInput
  }

  export type ExamCreateNestedOneWithoutExamEnrollmentInput = {
    create?: XOR<ExamCreateWithoutExamEnrollmentInput, ExamUncheckedCreateWithoutExamEnrollmentInput>
    connectOrCreate?: ExamCreateOrConnectWithoutExamEnrollmentInput
    connect?: ExamWhereUniqueInput
  }

  export type EnumStudentExamStatusFieldUpdateOperationsInput = {
    set?: $Enums.StudentExamStatus
  }

  export type StudentUpdateOneRequiredWithoutExamEnrollmentNestedInput = {
    create?: XOR<StudentCreateWithoutExamEnrollmentInput, StudentUncheckedCreateWithoutExamEnrollmentInput>
    connectOrCreate?: StudentCreateOrConnectWithoutExamEnrollmentInput
    upsert?: StudentUpsertWithoutExamEnrollmentInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutExamEnrollmentInput, StudentUpdateWithoutExamEnrollmentInput>, StudentUncheckedUpdateWithoutExamEnrollmentInput>
  }

  export type ExamUpdateOneRequiredWithoutExamEnrollmentNestedInput = {
    create?: XOR<ExamCreateWithoutExamEnrollmentInput, ExamUncheckedCreateWithoutExamEnrollmentInput>
    connectOrCreate?: ExamCreateOrConnectWithoutExamEnrollmentInput
    upsert?: ExamUpsertWithoutExamEnrollmentInput
    connect?: ExamWhereUniqueInput
    update?: XOR<XOR<ExamUpdateToOneWithWhereWithoutExamEnrollmentInput, ExamUpdateWithoutExamEnrollmentInput>, ExamUncheckedUpdateWithoutExamEnrollmentInput>
  }

  export type StudentCreateNestedOneWithoutExamResultInput = {
    create?: XOR<StudentCreateWithoutExamResultInput, StudentUncheckedCreateWithoutExamResultInput>
    connectOrCreate?: StudentCreateOrConnectWithoutExamResultInput
    connect?: StudentWhereUniqueInput
  }

  export type ExamCreateNestedOneWithoutExamResultInput = {
    create?: XOR<ExamCreateWithoutExamResultInput, ExamUncheckedCreateWithoutExamResultInput>
    connectOrCreate?: ExamCreateOrConnectWithoutExamResultInput
    connect?: ExamWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutExamResultInput = {
    create?: XOR<SubjectCreateWithoutExamResultInput, SubjectUncheckedCreateWithoutExamResultInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutExamResultInput
    connect?: SubjectWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutExamResultNestedInput = {
    create?: XOR<StudentCreateWithoutExamResultInput, StudentUncheckedCreateWithoutExamResultInput>
    connectOrCreate?: StudentCreateOrConnectWithoutExamResultInput
    upsert?: StudentUpsertWithoutExamResultInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutExamResultInput, StudentUpdateWithoutExamResultInput>, StudentUncheckedUpdateWithoutExamResultInput>
  }

  export type ExamUpdateOneRequiredWithoutExamResultNestedInput = {
    create?: XOR<ExamCreateWithoutExamResultInput, ExamUncheckedCreateWithoutExamResultInput>
    connectOrCreate?: ExamCreateOrConnectWithoutExamResultInput
    upsert?: ExamUpsertWithoutExamResultInput
    connect?: ExamWhereUniqueInput
    update?: XOR<XOR<ExamUpdateToOneWithWhereWithoutExamResultInput, ExamUpdateWithoutExamResultInput>, ExamUncheckedUpdateWithoutExamResultInput>
  }

  export type SubjectUpdateOneWithoutExamResultNestedInput = {
    create?: XOR<SubjectCreateWithoutExamResultInput, SubjectUncheckedCreateWithoutExamResultInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutExamResultInput
    upsert?: SubjectUpsertWithoutExamResultInput
    disconnect?: SubjectWhereInput | boolean
    delete?: SubjectWhereInput | boolean
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutExamResultInput, SubjectUpdateWithoutExamResultInput>, SubjectUncheckedUpdateWithoutExamResultInput>
  }

  export type StudentCreateNestedOneWithoutHallTicketInput = {
    create?: XOR<StudentCreateWithoutHallTicketInput, StudentUncheckedCreateWithoutHallTicketInput>
    connectOrCreate?: StudentCreateOrConnectWithoutHallTicketInput
    connect?: StudentWhereUniqueInput
  }

  export type ExamCreateNestedOneWithoutHallTicketsInput = {
    create?: XOR<ExamCreateWithoutHallTicketsInput, ExamUncheckedCreateWithoutHallTicketsInput>
    connectOrCreate?: ExamCreateOrConnectWithoutHallTicketsInput
    connect?: ExamWhereUniqueInput
  }

  export type ExamSessionCreateNestedOneWithoutHallTicketsInput = {
    create?: XOR<ExamSessionCreateWithoutHallTicketsInput, ExamSessionUncheckedCreateWithoutHallTicketsInput>
    connectOrCreate?: ExamSessionCreateOrConnectWithoutHallTicketsInput
    connect?: ExamSessionWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutHallTicketInput = {
    create?: XOR<OrganizationCreateWithoutHallTicketInput, OrganizationUncheckedCreateWithoutHallTicketInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutHallTicketInput
    connect?: OrganizationWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutHallTicketNestedInput = {
    create?: XOR<StudentCreateWithoutHallTicketInput, StudentUncheckedCreateWithoutHallTicketInput>
    connectOrCreate?: StudentCreateOrConnectWithoutHallTicketInput
    upsert?: StudentUpsertWithoutHallTicketInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutHallTicketInput, StudentUpdateWithoutHallTicketInput>, StudentUncheckedUpdateWithoutHallTicketInput>
  }

  export type ExamUpdateOneWithoutHallTicketsNestedInput = {
    create?: XOR<ExamCreateWithoutHallTicketsInput, ExamUncheckedCreateWithoutHallTicketsInput>
    connectOrCreate?: ExamCreateOrConnectWithoutHallTicketsInput
    upsert?: ExamUpsertWithoutHallTicketsInput
    disconnect?: ExamWhereInput | boolean
    delete?: ExamWhereInput | boolean
    connect?: ExamWhereUniqueInput
    update?: XOR<XOR<ExamUpdateToOneWithWhereWithoutHallTicketsInput, ExamUpdateWithoutHallTicketsInput>, ExamUncheckedUpdateWithoutHallTicketsInput>
  }

  export type ExamSessionUpdateOneWithoutHallTicketsNestedInput = {
    create?: XOR<ExamSessionCreateWithoutHallTicketsInput, ExamSessionUncheckedCreateWithoutHallTicketsInput>
    connectOrCreate?: ExamSessionCreateOrConnectWithoutHallTicketsInput
    upsert?: ExamSessionUpsertWithoutHallTicketsInput
    disconnect?: ExamSessionWhereInput | boolean
    delete?: ExamSessionWhereInput | boolean
    connect?: ExamSessionWhereUniqueInput
    update?: XOR<XOR<ExamSessionUpdateToOneWithWhereWithoutHallTicketsInput, ExamSessionUpdateWithoutHallTicketsInput>, ExamSessionUncheckedUpdateWithoutHallTicketsInput>
  }

  export type OrganizationUpdateOneRequiredWithoutHallTicketNestedInput = {
    create?: XOR<OrganizationCreateWithoutHallTicketInput, OrganizationUncheckedCreateWithoutHallTicketInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutHallTicketInput
    upsert?: OrganizationUpsertWithoutHallTicketInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutHallTicketInput, OrganizationUpdateWithoutHallTicketInput>, OrganizationUncheckedUpdateWithoutHallTicketInput>
  }

  export type StudentCreateNestedOneWithoutReportCardInput = {
    create?: XOR<StudentCreateWithoutReportCardInput, StudentUncheckedCreateWithoutReportCardInput>
    connectOrCreate?: StudentCreateOrConnectWithoutReportCardInput
    connect?: StudentWhereUniqueInput
  }

  export type ExamSessionCreateNestedOneWithoutReportCardsInput = {
    create?: XOR<ExamSessionCreateWithoutReportCardsInput, ExamSessionUncheckedCreateWithoutReportCardsInput>
    connectOrCreate?: ExamSessionCreateOrConnectWithoutReportCardsInput
    connect?: ExamSessionWhereUniqueInput
  }

  export type EnumResultStatusFieldUpdateOperationsInput = {
    set?: $Enums.ResultStatus
  }

  export type StudentUpdateOneRequiredWithoutReportCardNestedInput = {
    create?: XOR<StudentCreateWithoutReportCardInput, StudentUncheckedCreateWithoutReportCardInput>
    connectOrCreate?: StudentCreateOrConnectWithoutReportCardInput
    upsert?: StudentUpsertWithoutReportCardInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutReportCardInput, StudentUpdateWithoutReportCardInput>, StudentUncheckedUpdateWithoutReportCardInput>
  }

  export type ExamSessionUpdateOneRequiredWithoutReportCardsNestedInput = {
    create?: XOR<ExamSessionCreateWithoutReportCardsInput, ExamSessionUncheckedCreateWithoutReportCardsInput>
    connectOrCreate?: ExamSessionCreateOrConnectWithoutReportCardsInput
    upsert?: ExamSessionUpsertWithoutReportCardsInput
    connect?: ExamSessionWhereUniqueInput
    update?: XOR<XOR<ExamSessionUpdateToOneWithWhereWithoutReportCardsInput, ExamSessionUpdateWithoutReportCardsInput>, ExamSessionUncheckedUpdateWithoutReportCardsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumYearTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.YearType | EnumYearTypeFieldRefInput<$PrismaModel>
    in?: $Enums.YearType[] | ListEnumYearTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.YearType[] | ListEnumYearTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumYearTypeFilter<$PrismaModel> | $Enums.YearType
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumYearTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.YearType | EnumYearTypeFieldRefInput<$PrismaModel>
    in?: $Enums.YearType[] | ListEnumYearTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.YearType[] | ListEnumYearTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumYearTypeWithAggregatesFilter<$PrismaModel> | $Enums.YearType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumYearTypeFilter<$PrismaModel>
    _max?: NestedEnumYearTypeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumPlanTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeFilter<$PrismaModel> | $Enums.PlanType
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumOrganizationTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OrganizationType | EnumOrganizationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrganizationType[] | ListEnumOrganizationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrganizationType[] | ListEnumOrganizationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrganizationTypeNullableFilter<$PrismaModel> | $Enums.OrganizationType | null
  }

  export type NestedEnumPlanTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeWithAggregatesFilter<$PrismaModel> | $Enums.PlanType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanTypeFilter<$PrismaModel>
    _max?: NestedEnumPlanTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumOrganizationTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrganizationType | EnumOrganizationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrganizationType[] | ListEnumOrganizationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrganizationType[] | ListEnumOrganizationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrganizationTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.OrganizationType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOrganizationTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumOrganizationTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumEmploymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EmploymentStatus | EnumEmploymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmploymentStatus[] | ListEnumEmploymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmploymentStatus[] | ListEnumEmploymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmploymentStatusFilter<$PrismaModel> | $Enums.EmploymentStatus
  }

  export type NestedEnumEmploymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmploymentStatus | EnumEmploymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmploymentStatus[] | ListEnumEmploymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmploymentStatus[] | ListEnumEmploymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmploymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.EmploymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmploymentStatusFilter<$PrismaModel>
    _max?: NestedEnumEmploymentStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumAssignmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentStatus | EnumAssignmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentStatusFilter<$PrismaModel> | $Enums.AssignmentStatus
  }

  export type NestedEnumAssignmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentStatus | EnumAssignmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AssignmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssignmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAssignmentStatusFilter<$PrismaModel>
  }

  export type NestedEnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NestedEnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type NestedEnumFeeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FeeStatus | EnumFeeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FeeStatus[] | ListEnumFeeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeeStatus[] | ListEnumFeeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFeeStatusFilter<$PrismaModel> | $Enums.FeeStatus
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumFeeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeeStatus | EnumFeeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FeeStatus[] | ListEnumFeeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeeStatus[] | ListEnumFeeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFeeStatusWithAggregatesFilter<$PrismaModel> | $Enums.FeeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeeStatusFilter<$PrismaModel>
    _max?: NestedEnumFeeStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumscheduledJobTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.scheduledJobType | EnumscheduledJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.scheduledJobType[] | ListEnumscheduledJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.scheduledJobType[] | ListEnumscheduledJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumscheduledJobTypeFilter<$PrismaModel> | $Enums.scheduledJobType
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumscheduledJobTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.scheduledJobType | EnumscheduledJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.scheduledJobType[] | ListEnumscheduledJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.scheduledJobType[] | ListEnumscheduledJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumscheduledJobTypeWithAggregatesFilter<$PrismaModel> | $Enums.scheduledJobType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumscheduledJobTypeFilter<$PrismaModel>
    _max?: NestedEnumscheduledJobTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumCalendarEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CalendarEventType | EnumCalendarEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CalendarEventType[] | ListEnumCalendarEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalendarEventType[] | ListEnumCalendarEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCalendarEventTypeFilter<$PrismaModel> | $Enums.CalendarEventType
  }

  export type NestedEnumCalendarEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CalendarEventType | EnumCalendarEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CalendarEventType[] | ListEnumCalendarEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalendarEventType[] | ListEnumCalendarEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCalendarEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.CalendarEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCalendarEventTypeFilter<$PrismaModel>
    _max?: NestedEnumCalendarEventTypeFilter<$PrismaModel>
  }

  export type NestedEnumSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.Severity | EnumSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSeverityFilter<$PrismaModel> | $Enums.Severity
  }

  export type NestedEnumComplaintStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintStatus | EnumComplaintStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintStatus[] | ListEnumComplaintStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplaintStatus[] | ListEnumComplaintStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumComplaintStatusFilter<$PrismaModel> | $Enums.ComplaintStatus
  }

  export type NestedEnumSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Severity | EnumSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSeverityWithAggregatesFilter<$PrismaModel> | $Enums.Severity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSeverityFilter<$PrismaModel>
    _max?: NestedEnumSeverityFilter<$PrismaModel>
  }

  export type NestedEnumComplaintStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintStatus | EnumComplaintStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintStatus[] | ListEnumComplaintStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplaintStatus[] | ListEnumComplaintStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumComplaintStatusWithAggregatesFilter<$PrismaModel> | $Enums.ComplaintStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComplaintStatusFilter<$PrismaModel>
    _max?: NestedEnumComplaintStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationChannelFilter<$PrismaModel> | $Enums.NotificationChannel
  }

  export type NestedEnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationChannelWithAggregatesFilter<$PrismaModel> | $Enums.NotificationChannel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationChannelFilter<$PrismaModel>
    _max?: NestedEnumNotificationChannelFilter<$PrismaModel>
  }

  export type NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumEvaluationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EvaluationType | EnumEvaluationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EvaluationType[] | ListEnumEvaluationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EvaluationType[] | ListEnumEvaluationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEvaluationTypeFilter<$PrismaModel> | $Enums.EvaluationType
  }

  export type NestedEnumExamModeFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamMode | EnumExamModeFieldRefInput<$PrismaModel>
    in?: $Enums.ExamMode[] | ListEnumExamModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExamMode[] | ListEnumExamModeFieldRefInput<$PrismaModel>
    not?: NestedEnumExamModeFilter<$PrismaModel> | $Enums.ExamMode
  }

  export type NestedEnumExamStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamStatus | EnumExamStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExamStatus[] | ListEnumExamStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExamStatus[] | ListEnumExamStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExamStatusFilter<$PrismaModel> | $Enums.ExamStatus
  }

  export type NestedEnumEvaluationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EvaluationType | EnumEvaluationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EvaluationType[] | ListEnumEvaluationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EvaluationType[] | ListEnumEvaluationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEvaluationTypeWithAggregatesFilter<$PrismaModel> | $Enums.EvaluationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEvaluationTypeFilter<$PrismaModel>
    _max?: NestedEnumEvaluationTypeFilter<$PrismaModel>
  }

  export type NestedEnumExamModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamMode | EnumExamModeFieldRefInput<$PrismaModel>
    in?: $Enums.ExamMode[] | ListEnumExamModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExamMode[] | ListEnumExamModeFieldRefInput<$PrismaModel>
    not?: NestedEnumExamModeWithAggregatesFilter<$PrismaModel> | $Enums.ExamMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExamModeFilter<$PrismaModel>
    _max?: NestedEnumExamModeFilter<$PrismaModel>
  }

  export type NestedEnumExamStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamStatus | EnumExamStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExamStatus[] | ListEnumExamStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExamStatus[] | ListEnumExamStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExamStatusWithAggregatesFilter<$PrismaModel> | $Enums.ExamStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExamStatusFilter<$PrismaModel>
    _max?: NestedEnumExamStatusFilter<$PrismaModel>
  }

  export type NestedEnumStudentExamStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentExamStatus | EnumStudentExamStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentExamStatus[] | ListEnumStudentExamStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudentExamStatus[] | ListEnumStudentExamStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudentExamStatusFilter<$PrismaModel> | $Enums.StudentExamStatus
  }

  export type NestedEnumStudentExamStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentExamStatus | EnumStudentExamStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentExamStatus[] | ListEnumStudentExamStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudentExamStatus[] | ListEnumStudentExamStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudentExamStatusWithAggregatesFilter<$PrismaModel> | $Enums.StudentExamStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStudentExamStatusFilter<$PrismaModel>
    _max?: NestedEnumStudentExamStatusFilter<$PrismaModel>
  }

  export type NestedEnumResultStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ResultStatus | EnumResultStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ResultStatus[] | ListEnumResultStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResultStatus[] | ListEnumResultStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumResultStatusFilter<$PrismaModel> | $Enums.ResultStatus
  }

  export type NestedEnumResultStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResultStatus | EnumResultStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ResultStatus[] | ListEnumResultStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResultStatus[] | ListEnumResultStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumResultStatusWithAggregatesFilter<$PrismaModel> | $Enums.ResultStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResultStatusFilter<$PrismaModel>
    _max?: NestedEnumResultStatusFilter<$PrismaModel>
  }

  export type OrganizationCreateWithoutAcademicYearInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    notices?: NoticeCreateNestedManyWithoutOrganizationInput
    Student?: StudentCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentCreateNestedManyWithoutOrganizationInput
    Grade?: GradeCreateNestedManyWithoutOrganizationInput
    Section?: SectionCreateNestedManyWithoutOrganizationInput
    Fee?: FeeCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobCreateNestedManyWithoutOrganizationInput
    Exam?: ExamCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutAcademicYearInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    notices?: NoticeUncheckedCreateNestedManyWithoutOrganizationInput
    Student?: StudentUncheckedCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutOrganizationInput
    Grade?: GradeUncheckedCreateNestedManyWithoutOrganizationInput
    Section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    Fee?: FeeUncheckedCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryUncheckedCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarUncheckedCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintUncheckedCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherUncheckedCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectUncheckedCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobUncheckedCreateNestedManyWithoutOrganizationInput
    Exam?: ExamUncheckedCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutAcademicYearInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutAcademicYearInput, OrganizationUncheckedCreateWithoutAcademicYearInput>
  }

  export type AnonymousComplaintCreateWithoutAcademicYearInput = {
    id?: string
    trackingId: string
    category: string
    severity?: $Enums.Severity
    subject: string
    description: string
    evidenceUrls?: AnonymousComplaintCreateevidenceUrlsInput | string[]
    submittedAt?: Date | string
    currentStatus?: $Enums.ComplaintStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutAnonymousComplaintInput
    ComplaintStatusTimeline?: ComplaintStatusTimelineCreateNestedManyWithoutComplaintInput
  }

  export type AnonymousComplaintUncheckedCreateWithoutAcademicYearInput = {
    id?: string
    trackingId: string
    category: string
    severity?: $Enums.Severity
    subject: string
    description: string
    evidenceUrls?: AnonymousComplaintCreateevidenceUrlsInput | string[]
    submittedAt?: Date | string
    currentStatus?: $Enums.ComplaintStatus
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ComplaintStatusTimeline?: ComplaintStatusTimelineUncheckedCreateNestedManyWithoutComplaintInput
  }

  export type AnonymousComplaintCreateOrConnectWithoutAcademicYearInput = {
    where: AnonymousComplaintWhereUniqueInput
    create: XOR<AnonymousComplaintCreateWithoutAcademicYearInput, AnonymousComplaintUncheckedCreateWithoutAcademicYearInput>
  }

  export type AnonymousComplaintCreateManyAcademicYearInputEnvelope = {
    data: AnonymousComplaintCreateManyAcademicYearInput | AnonymousComplaintCreateManyAcademicYearInput[]
    skipDuplicates?: boolean
  }

  export type NoticeCreateWithoutAcademicYearInput = {
    id?: string
    noticeType: string
    title: string
    startDate: Date | string
    endDate: Date | string
    content: string
    summary?: string | null
    isNoticeApproved?: boolean
    isDraft?: boolean
    isPublished?: boolean
    emailNotification?: boolean
    pushNotification?: boolean
    WhatsAppNotification?: boolean
    smsNotification?: boolean
    targetAudience?: NoticeCreatetargetAudienceInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    publishedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Organization: OrganizationCreateNestedOneWithoutNoticesInput
  }

  export type NoticeUncheckedCreateWithoutAcademicYearInput = {
    id?: string
    noticeType: string
    title: string
    startDate: Date | string
    endDate: Date | string
    content: string
    summary?: string | null
    isNoticeApproved?: boolean
    isDraft?: boolean
    isPublished?: boolean
    emailNotification?: boolean
    pushNotification?: boolean
    WhatsAppNotification?: boolean
    smsNotification?: boolean
    targetAudience?: NoticeCreatetargetAudienceInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    publishedBy: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoticeCreateOrConnectWithoutAcademicYearInput = {
    where: NoticeWhereUniqueInput
    create: XOR<NoticeCreateWithoutAcademicYearInput, NoticeUncheckedCreateWithoutAcademicYearInput>
  }

  export type NoticeCreateManyAcademicYearInputEnvelope = {
    data: NoticeCreateManyAcademicYearInput | NoticeCreateManyAcademicYearInput[]
    skipDuplicates?: boolean
  }

  export type TeachingAssignmentCreateWithoutAcademicYearInput = {
    id?: string
    academicYear?: string | null
    status?: $Enums.AssignmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: TeacherCreateNestedOneWithoutTeachingAssignmentInput
    subject: SubjectCreateNestedOneWithoutTeachingAssignmentsInput
    grade: GradeCreateNestedOneWithoutTeachingAssignmentInput
    section: SectionCreateNestedOneWithoutTeachingAssignmentInput
    organization: OrganizationCreateNestedOneWithoutTeachingAssignmentInput
  }

  export type TeachingAssignmentUncheckedCreateWithoutAcademicYearInput = {
    id?: string
    teacherId: string
    subjectId: string
    gradeId: string
    sectionId: string
    organizationId: string
    academicYear?: string | null
    status?: $Enums.AssignmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeachingAssignmentCreateOrConnectWithoutAcademicYearInput = {
    where: TeachingAssignmentWhereUniqueInput
    create: XOR<TeachingAssignmentCreateWithoutAcademicYearInput, TeachingAssignmentUncheckedCreateWithoutAcademicYearInput>
  }

  export type TeachingAssignmentCreateManyAcademicYearInputEnvelope = {
    data: TeachingAssignmentCreateManyAcademicYearInput | TeachingAssignmentCreateManyAcademicYearInput[]
    skipDuplicates?: boolean
  }

  export type StudentAttendanceCreateWithoutAcademicYearInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    note?: string | null
    recordedBy: string
    present?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    section: SectionCreateNestedOneWithoutStudentAttendanceInput
    student: StudentCreateNestedOneWithoutStudentAttendanceInput
  }

  export type StudentAttendanceUncheckedCreateWithoutAcademicYearInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    note?: string | null
    recordedBy: string
    studentId: string
    present?: boolean
    sectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAttendanceCreateOrConnectWithoutAcademicYearInput = {
    where: StudentAttendanceWhereUniqueInput
    create: XOR<StudentAttendanceCreateWithoutAcademicYearInput, StudentAttendanceUncheckedCreateWithoutAcademicYearInput>
  }

  export type StudentAttendanceCreateManyAcademicYearInputEnvelope = {
    data: StudentAttendanceCreateManyAcademicYearInput | StudentAttendanceCreateManyAcademicYearInput[]
    skipDuplicates?: boolean
  }

  export type AcademicCalendarCreateWithoutAcademicYearInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    type: $Enums.CalendarEventType
    reason?: string | null
    isRecurring?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutAcademicCalendarInput
  }

  export type AcademicCalendarUncheckedCreateWithoutAcademicYearInput = {
    id?: string
    organizationId: string
    name: string
    startDate: Date | string
    endDate: Date | string
    type: $Enums.CalendarEventType
    reason?: string | null
    isRecurring?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicCalendarCreateOrConnectWithoutAcademicYearInput = {
    where: AcademicCalendarWhereUniqueInput
    create: XOR<AcademicCalendarCreateWithoutAcademicYearInput, AcademicCalendarUncheckedCreateWithoutAcademicYearInput>
  }

  export type AcademicCalendarCreateManyAcademicYearInputEnvelope = {
    data: AcademicCalendarCreateManyAcademicYearInput | AcademicCalendarCreateManyAcademicYearInput[]
    skipDuplicates?: boolean
  }

  export type ExamSessionCreateWithoutAcademicYearInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    exams?: ExamCreateNestedManyWithoutExamSessionInput
    reportCards?: ReportCardCreateNestedManyWithoutExamSessionInput
    hallTickets?: HallTicketCreateNestedManyWithoutExamSessionInput
  }

  export type ExamSessionUncheckedCreateWithoutAcademicYearInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    exams?: ExamUncheckedCreateNestedManyWithoutExamSessionInput
    reportCards?: ReportCardUncheckedCreateNestedManyWithoutExamSessionInput
    hallTickets?: HallTicketUncheckedCreateNestedManyWithoutExamSessionInput
  }

  export type ExamSessionCreateOrConnectWithoutAcademicYearInput = {
    where: ExamSessionWhereUniqueInput
    create: XOR<ExamSessionCreateWithoutAcademicYearInput, ExamSessionUncheckedCreateWithoutAcademicYearInput>
  }

  export type ExamSessionCreateManyAcademicYearInputEnvelope = {
    data: ExamSessionCreateManyAcademicYearInput | ExamSessionCreateManyAcademicYearInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutAcademicYearInput = {
    update: XOR<OrganizationUpdateWithoutAcademicYearInput, OrganizationUncheckedUpdateWithoutAcademicYearInput>
    create: XOR<OrganizationCreateWithoutAcademicYearInput, OrganizationUncheckedCreateWithoutAcademicYearInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutAcademicYearInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutAcademicYearInput, OrganizationUncheckedUpdateWithoutAcademicYearInput>
  }

  export type OrganizationUpdateWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUncheckedUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUncheckedUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUncheckedUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUncheckedUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUncheckedUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUncheckedUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUncheckedUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUncheckedUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type AnonymousComplaintUpsertWithWhereUniqueWithoutAcademicYearInput = {
    where: AnonymousComplaintWhereUniqueInput
    update: XOR<AnonymousComplaintUpdateWithoutAcademicYearInput, AnonymousComplaintUncheckedUpdateWithoutAcademicYearInput>
    create: XOR<AnonymousComplaintCreateWithoutAcademicYearInput, AnonymousComplaintUncheckedCreateWithoutAcademicYearInput>
  }

  export type AnonymousComplaintUpdateWithWhereUniqueWithoutAcademicYearInput = {
    where: AnonymousComplaintWhereUniqueInput
    data: XOR<AnonymousComplaintUpdateWithoutAcademicYearInput, AnonymousComplaintUncheckedUpdateWithoutAcademicYearInput>
  }

  export type AnonymousComplaintUpdateManyWithWhereWithoutAcademicYearInput = {
    where: AnonymousComplaintScalarWhereInput
    data: XOR<AnonymousComplaintUpdateManyMutationInput, AnonymousComplaintUncheckedUpdateManyWithoutAcademicYearInput>
  }

  export type AnonymousComplaintScalarWhereInput = {
    AND?: AnonymousComplaintScalarWhereInput | AnonymousComplaintScalarWhereInput[]
    OR?: AnonymousComplaintScalarWhereInput[]
    NOT?: AnonymousComplaintScalarWhereInput | AnonymousComplaintScalarWhereInput[]
    id?: StringFilter<"AnonymousComplaint"> | string
    trackingId?: StringFilter<"AnonymousComplaint"> | string
    category?: StringFilter<"AnonymousComplaint"> | string
    severity?: EnumSeverityFilter<"AnonymousComplaint"> | $Enums.Severity
    subject?: StringFilter<"AnonymousComplaint"> | string
    description?: StringFilter<"AnonymousComplaint"> | string
    evidenceUrls?: StringNullableListFilter<"AnonymousComplaint">
    submittedAt?: DateTimeFilter<"AnonymousComplaint"> | Date | string
    currentStatus?: EnumComplaintStatusFilter<"AnonymousComplaint"> | $Enums.ComplaintStatus
    organizationId?: StringFilter<"AnonymousComplaint"> | string
    createdAt?: DateTimeFilter<"AnonymousComplaint"> | Date | string
    updatedAt?: DateTimeFilter<"AnonymousComplaint"> | Date | string
    academicYearId?: StringNullableFilter<"AnonymousComplaint"> | string | null
  }

  export type NoticeUpsertWithWhereUniqueWithoutAcademicYearInput = {
    where: NoticeWhereUniqueInput
    update: XOR<NoticeUpdateWithoutAcademicYearInput, NoticeUncheckedUpdateWithoutAcademicYearInput>
    create: XOR<NoticeCreateWithoutAcademicYearInput, NoticeUncheckedCreateWithoutAcademicYearInput>
  }

  export type NoticeUpdateWithWhereUniqueWithoutAcademicYearInput = {
    where: NoticeWhereUniqueInput
    data: XOR<NoticeUpdateWithoutAcademicYearInput, NoticeUncheckedUpdateWithoutAcademicYearInput>
  }

  export type NoticeUpdateManyWithWhereWithoutAcademicYearInput = {
    where: NoticeScalarWhereInput
    data: XOR<NoticeUpdateManyMutationInput, NoticeUncheckedUpdateManyWithoutAcademicYearInput>
  }

  export type NoticeScalarWhereInput = {
    AND?: NoticeScalarWhereInput | NoticeScalarWhereInput[]
    OR?: NoticeScalarWhereInput[]
    NOT?: NoticeScalarWhereInput | NoticeScalarWhereInput[]
    id?: StringFilter<"Notice"> | string
    noticeType?: StringFilter<"Notice"> | string
    title?: StringFilter<"Notice"> | string
    startDate?: DateTimeFilter<"Notice"> | Date | string
    endDate?: DateTimeFilter<"Notice"> | Date | string
    content?: StringFilter<"Notice"> | string
    summary?: StringNullableFilter<"Notice"> | string | null
    isNoticeApproved?: BoolFilter<"Notice"> | boolean
    isDraft?: BoolFilter<"Notice"> | boolean
    isPublished?: BoolFilter<"Notice"> | boolean
    emailNotification?: BoolFilter<"Notice"> | boolean
    pushNotification?: BoolFilter<"Notice"> | boolean
    WhatsAppNotification?: BoolFilter<"Notice"> | boolean
    smsNotification?: BoolFilter<"Notice"> | boolean
    targetAudience?: StringNullableListFilter<"Notice">
    attachments?: JsonNullableFilter<"Notice">
    publishedBy?: StringFilter<"Notice"> | string
    organizationId?: StringFilter<"Notice"> | string
    createdAt?: DateTimeFilter<"Notice"> | Date | string
    updatedAt?: DateTimeFilter<"Notice"> | Date | string
    academicYearId?: StringNullableFilter<"Notice"> | string | null
  }

  export type TeachingAssignmentUpsertWithWhereUniqueWithoutAcademicYearInput = {
    where: TeachingAssignmentWhereUniqueInput
    update: XOR<TeachingAssignmentUpdateWithoutAcademicYearInput, TeachingAssignmentUncheckedUpdateWithoutAcademicYearInput>
    create: XOR<TeachingAssignmentCreateWithoutAcademicYearInput, TeachingAssignmentUncheckedCreateWithoutAcademicYearInput>
  }

  export type TeachingAssignmentUpdateWithWhereUniqueWithoutAcademicYearInput = {
    where: TeachingAssignmentWhereUniqueInput
    data: XOR<TeachingAssignmentUpdateWithoutAcademicYearInput, TeachingAssignmentUncheckedUpdateWithoutAcademicYearInput>
  }

  export type TeachingAssignmentUpdateManyWithWhereWithoutAcademicYearInput = {
    where: TeachingAssignmentScalarWhereInput
    data: XOR<TeachingAssignmentUpdateManyMutationInput, TeachingAssignmentUncheckedUpdateManyWithoutAcademicYearInput>
  }

  export type TeachingAssignmentScalarWhereInput = {
    AND?: TeachingAssignmentScalarWhereInput | TeachingAssignmentScalarWhereInput[]
    OR?: TeachingAssignmentScalarWhereInput[]
    NOT?: TeachingAssignmentScalarWhereInput | TeachingAssignmentScalarWhereInput[]
    id?: StringFilter<"TeachingAssignment"> | string
    teacherId?: StringFilter<"TeachingAssignment"> | string
    subjectId?: StringFilter<"TeachingAssignment"> | string
    gradeId?: StringFilter<"TeachingAssignment"> | string
    sectionId?: StringFilter<"TeachingAssignment"> | string
    organizationId?: StringFilter<"TeachingAssignment"> | string
    academicYear?: StringNullableFilter<"TeachingAssignment"> | string | null
    status?: EnumAssignmentStatusFilter<"TeachingAssignment"> | $Enums.AssignmentStatus
    createdAt?: DateTimeFilter<"TeachingAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"TeachingAssignment"> | Date | string
    academicYearId?: StringNullableFilter<"TeachingAssignment"> | string | null
  }

  export type StudentAttendanceUpsertWithWhereUniqueWithoutAcademicYearInput = {
    where: StudentAttendanceWhereUniqueInput
    update: XOR<StudentAttendanceUpdateWithoutAcademicYearInput, StudentAttendanceUncheckedUpdateWithoutAcademicYearInput>
    create: XOR<StudentAttendanceCreateWithoutAcademicYearInput, StudentAttendanceUncheckedCreateWithoutAcademicYearInput>
  }

  export type StudentAttendanceUpdateWithWhereUniqueWithoutAcademicYearInput = {
    where: StudentAttendanceWhereUniqueInput
    data: XOR<StudentAttendanceUpdateWithoutAcademicYearInput, StudentAttendanceUncheckedUpdateWithoutAcademicYearInput>
  }

  export type StudentAttendanceUpdateManyWithWhereWithoutAcademicYearInput = {
    where: StudentAttendanceScalarWhereInput
    data: XOR<StudentAttendanceUpdateManyMutationInput, StudentAttendanceUncheckedUpdateManyWithoutAcademicYearInput>
  }

  export type StudentAttendanceScalarWhereInput = {
    AND?: StudentAttendanceScalarWhereInput | StudentAttendanceScalarWhereInput[]
    OR?: StudentAttendanceScalarWhereInput[]
    NOT?: StudentAttendanceScalarWhereInput | StudentAttendanceScalarWhereInput[]
    id?: StringFilter<"StudentAttendance"> | string
    date?: DateTimeFilter<"StudentAttendance"> | Date | string
    status?: EnumAttendanceStatusFilter<"StudentAttendance"> | $Enums.AttendanceStatus
    note?: StringNullableFilter<"StudentAttendance"> | string | null
    recordedBy?: StringFilter<"StudentAttendance"> | string
    studentId?: StringFilter<"StudentAttendance"> | string
    present?: BoolFilter<"StudentAttendance"> | boolean
    sectionId?: StringFilter<"StudentAttendance"> | string
    academicYearId?: StringNullableFilter<"StudentAttendance"> | string | null
    createdAt?: DateTimeFilter<"StudentAttendance"> | Date | string
    updatedAt?: DateTimeFilter<"StudentAttendance"> | Date | string
  }

  export type AcademicCalendarUpsertWithWhereUniqueWithoutAcademicYearInput = {
    where: AcademicCalendarWhereUniqueInput
    update: XOR<AcademicCalendarUpdateWithoutAcademicYearInput, AcademicCalendarUncheckedUpdateWithoutAcademicYearInput>
    create: XOR<AcademicCalendarCreateWithoutAcademicYearInput, AcademicCalendarUncheckedCreateWithoutAcademicYearInput>
  }

  export type AcademicCalendarUpdateWithWhereUniqueWithoutAcademicYearInput = {
    where: AcademicCalendarWhereUniqueInput
    data: XOR<AcademicCalendarUpdateWithoutAcademicYearInput, AcademicCalendarUncheckedUpdateWithoutAcademicYearInput>
  }

  export type AcademicCalendarUpdateManyWithWhereWithoutAcademicYearInput = {
    where: AcademicCalendarScalarWhereInput
    data: XOR<AcademicCalendarUpdateManyMutationInput, AcademicCalendarUncheckedUpdateManyWithoutAcademicYearInput>
  }

  export type AcademicCalendarScalarWhereInput = {
    AND?: AcademicCalendarScalarWhereInput | AcademicCalendarScalarWhereInput[]
    OR?: AcademicCalendarScalarWhereInput[]
    NOT?: AcademicCalendarScalarWhereInput | AcademicCalendarScalarWhereInput[]
    id?: StringFilter<"AcademicCalendar"> | string
    organizationId?: StringFilter<"AcademicCalendar"> | string
    name?: StringFilter<"AcademicCalendar"> | string
    startDate?: DateTimeFilter<"AcademicCalendar"> | Date | string
    endDate?: DateTimeFilter<"AcademicCalendar"> | Date | string
    type?: EnumCalendarEventTypeFilter<"AcademicCalendar"> | $Enums.CalendarEventType
    reason?: StringNullableFilter<"AcademicCalendar"> | string | null
    isRecurring?: BoolFilter<"AcademicCalendar"> | boolean
    createdBy?: StringFilter<"AcademicCalendar"> | string
    createdAt?: DateTimeFilter<"AcademicCalendar"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicCalendar"> | Date | string
    academicYearId?: StringNullableFilter<"AcademicCalendar"> | string | null
  }

  export type ExamSessionUpsertWithWhereUniqueWithoutAcademicYearInput = {
    where: ExamSessionWhereUniqueInput
    update: XOR<ExamSessionUpdateWithoutAcademicYearInput, ExamSessionUncheckedUpdateWithoutAcademicYearInput>
    create: XOR<ExamSessionCreateWithoutAcademicYearInput, ExamSessionUncheckedCreateWithoutAcademicYearInput>
  }

  export type ExamSessionUpdateWithWhereUniqueWithoutAcademicYearInput = {
    where: ExamSessionWhereUniqueInput
    data: XOR<ExamSessionUpdateWithoutAcademicYearInput, ExamSessionUncheckedUpdateWithoutAcademicYearInput>
  }

  export type ExamSessionUpdateManyWithWhereWithoutAcademicYearInput = {
    where: ExamSessionScalarWhereInput
    data: XOR<ExamSessionUpdateManyMutationInput, ExamSessionUncheckedUpdateManyWithoutAcademicYearInput>
  }

  export type ExamSessionScalarWhereInput = {
    AND?: ExamSessionScalarWhereInput | ExamSessionScalarWhereInput[]
    OR?: ExamSessionScalarWhereInput[]
    NOT?: ExamSessionScalarWhereInput | ExamSessionScalarWhereInput[]
    id?: StringFilter<"ExamSession"> | string
    title?: StringFilter<"ExamSession"> | string
    description?: StringNullableFilter<"ExamSession"> | string | null
    academicYearId?: StringFilter<"ExamSession"> | string
    startDate?: DateTimeFilter<"ExamSession"> | Date | string
    endDate?: DateTimeFilter<"ExamSession"> | Date | string
    createdBy?: StringFilter<"ExamSession"> | string
    createdAt?: DateTimeFilter<"ExamSession"> | Date | string
    updatedAt?: DateTimeFilter<"ExamSession"> | Date | string
  }

  export type UserCreateWithoutOrganizationInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password?: string | null
    profileImage: string
    role?: $Enums.Role
    clerkId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher?: TeacherCreateNestedOneWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    parent?: ParentCreateNestedOneWithoutUserInput
    FeePayment?: FeePaymentCreateNestedManyWithoutPayerInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrganizationInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password?: string | null
    profileImage: string
    role?: $Enums.Role
    clerkId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    parent?: ParentUncheckedCreateNestedOneWithoutUserInput
    FeePayment?: FeePaymentUncheckedCreateNestedManyWithoutPayerInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
  }

  export type UserCreateManyOrganizationInputEnvelope = {
    data: UserCreateManyOrganizationInput | UserCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type NoticeCreateWithoutOrganizationInput = {
    id?: string
    noticeType: string
    title: string
    startDate: Date | string
    endDate: Date | string
    content: string
    summary?: string | null
    isNoticeApproved?: boolean
    isDraft?: boolean
    isPublished?: boolean
    emailNotification?: boolean
    pushNotification?: boolean
    WhatsAppNotification?: boolean
    smsNotification?: boolean
    targetAudience?: NoticeCreatetargetAudienceInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    publishedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicYear?: AcademicYearCreateNestedOneWithoutNoticesInput
  }

  export type NoticeUncheckedCreateWithoutOrganizationInput = {
    id?: string
    noticeType: string
    title: string
    startDate: Date | string
    endDate: Date | string
    content: string
    summary?: string | null
    isNoticeApproved?: boolean
    isDraft?: boolean
    isPublished?: boolean
    emailNotification?: boolean
    pushNotification?: boolean
    WhatsAppNotification?: boolean
    smsNotification?: boolean
    targetAudience?: NoticeCreatetargetAudienceInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    publishedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicYearId?: string | null
  }

  export type NoticeCreateOrConnectWithoutOrganizationInput = {
    where: NoticeWhereUniqueInput
    create: XOR<NoticeCreateWithoutOrganizationInput, NoticeUncheckedCreateWithoutOrganizationInput>
  }

  export type NoticeCreateManyOrganizationInputEnvelope = {
    data: NoticeCreateManyOrganizationInput | NoticeCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutOrganizationInput = {
    id?: string
    firstName: string
    lastName: string
    middleName?: string | null
    motherName?: string | null
    fullName?: string | null
    dateOfBirth: Date | string
    profileImage?: string | null
    rollNumber: string
    phoneNumber: string
    whatsAppNumber: string
    email: string
    emergencyContact: string
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    section: SectionCreateNestedOneWithoutStudentsInput
    grade: GradeCreateNestedOneWithoutStudentsInput
    Fee?: FeeCreateNestedManyWithoutStudentInput
    parents?: ParentStudentCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutStudentInput
    StudentDocument?: StudentDocumentCreateNestedManyWithoutStudentInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutStudentInput
    reportCard?: ReportCardCreateNestedManyWithoutStudentInput
    hallTicket?: HallTicketCreateNestedManyWithoutStudentInput
    examResult?: ExamResultCreateNestedManyWithoutStudentInput
    examEnrollment?: ExamEnrollmentCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutOrganizationInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    middleName?: string | null
    motherName?: string | null
    fullName?: string | null
    dateOfBirth: Date | string
    profileImage?: string | null
    rollNumber: string
    phoneNumber: string
    whatsAppNumber: string
    email: string
    emergencyContact: string
    gender: $Enums.Gender
    sectionId: string
    gradeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Fee?: FeeUncheckedCreateNestedManyWithoutStudentInput
    parents?: ParentStudentUncheckedCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutStudentInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutStudentInput
    reportCard?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
    hallTicket?: HallTicketUncheckedCreateNestedManyWithoutStudentInput
    examResult?: ExamResultUncheckedCreateNestedManyWithoutStudentInput
    examEnrollment?: ExamEnrollmentUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutOrganizationInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutOrganizationInput, StudentUncheckedCreateWithoutOrganizationInput>
  }

  export type StudentCreateManyOrganizationInputEnvelope = {
    data: StudentCreateManyOrganizationInput | StudentCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type StudentDocumentCreateWithoutOrganizationInput = {
    id?: string
    type: $Enums.DocumentType
    fileName?: string | null
    fileSize?: number | null
    fileType?: string | null
    documentUrl: string
    verified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    rejected?: boolean
    rejectedBy?: string | null
    rejectedAt?: Date | string | null
    rejectReason?: string | null
    uploadedBy?: string | null
    uploadedAt?: Date | string
    note?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentDocumentInput
  }

  export type StudentDocumentUncheckedCreateWithoutOrganizationInput = {
    id?: string
    type: $Enums.DocumentType
    fileName?: string | null
    fileSize?: number | null
    fileType?: string | null
    documentUrl: string
    studentId: string
    verified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    rejected?: boolean
    rejectedBy?: string | null
    rejectedAt?: Date | string | null
    rejectReason?: string | null
    uploadedBy?: string | null
    uploadedAt?: Date | string
    note?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentDocumentCreateOrConnectWithoutOrganizationInput = {
    where: StudentDocumentWhereUniqueInput
    create: XOR<StudentDocumentCreateWithoutOrganizationInput, StudentDocumentUncheckedCreateWithoutOrganizationInput>
  }

  export type StudentDocumentCreateManyOrganizationInputEnvelope = {
    data: StudentDocumentCreateManyOrganizationInput | StudentDocumentCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type GradeCreateWithoutOrganizationInput = {
    id?: string
    grade: string
    students?: StudentCreateNestedManyWithoutGradeInput
    section?: SectionCreateNestedManyWithoutGradeInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutGradeInput
  }

  export type GradeUncheckedCreateWithoutOrganizationInput = {
    id?: string
    grade: string
    students?: StudentUncheckedCreateNestedManyWithoutGradeInput
    section?: SectionUncheckedCreateNestedManyWithoutGradeInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutGradeInput
  }

  export type GradeCreateOrConnectWithoutOrganizationInput = {
    where: GradeWhereUniqueInput
    create: XOR<GradeCreateWithoutOrganizationInput, GradeUncheckedCreateWithoutOrganizationInput>
  }

  export type GradeCreateManyOrganizationInputEnvelope = {
    data: GradeCreateManyOrganizationInput | GradeCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type SectionCreateWithoutOrganizationInput = {
    id?: string
    name: string
    grade: GradeCreateNestedOneWithoutSectionInput
    classTeacher?: TeacherCreateNestedOneWithoutSectionInput
    students?: StudentCreateNestedManyWithoutSectionInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutSectionInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    gradeId: string
    classTeacherId?: string | null
    students?: StudentUncheckedCreateNestedManyWithoutSectionInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutSectionInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutOrganizationInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutOrganizationInput, SectionUncheckedCreateWithoutOrganizationInput>
  }

  export type SectionCreateManyOrganizationInputEnvelope = {
    data: SectionCreateManyOrganizationInput | SectionCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type FeeCreateWithoutOrganizationInput = {
    id?: string
    totalFee: number
    paidAmount?: number
    pendingAmount?: number | null
    dueDate: Date | string
    status?: $Enums.FeeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutFeeInput
    feeCategory: FeeCategoryCreateNestedOneWithoutFeesInput
    payments?: FeePaymentCreateNestedManyWithoutFeeInput
  }

  export type FeeUncheckedCreateWithoutOrganizationInput = {
    id?: string
    totalFee: number
    paidAmount?: number
    pendingAmount?: number | null
    dueDate: Date | string
    status?: $Enums.FeeStatus
    studentId: string
    feeCategoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: FeePaymentUncheckedCreateNestedManyWithoutFeeInput
  }

  export type FeeCreateOrConnectWithoutOrganizationInput = {
    where: FeeWhereUniqueInput
    create: XOR<FeeCreateWithoutOrganizationInput, FeeUncheckedCreateWithoutOrganizationInput>
  }

  export type FeeCreateManyOrganizationInputEnvelope = {
    data: FeeCreateManyOrganizationInput | FeeCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type FeeCategoryCreateWithoutOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fees?: FeeCreateNestedManyWithoutFeeCategoryInput
  }

  export type FeeCategoryUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fees?: FeeUncheckedCreateNestedManyWithoutFeeCategoryInput
  }

  export type FeeCategoryCreateOrConnectWithoutOrganizationInput = {
    where: FeeCategoryWhereUniqueInput
    create: XOR<FeeCategoryCreateWithoutOrganizationInput, FeeCategoryUncheckedCreateWithoutOrganizationInput>
  }

  export type FeeCategoryCreateManyOrganizationInputEnvelope = {
    data: FeeCategoryCreateManyOrganizationInput | FeeCategoryCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type FeePaymentCreateWithoutOrganizationInput = {
    id?: string
    amount: number
    status?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    receiptNumber: string
    note?: string | null
    transactionId?: string | null
    platformFee?: number | null
    recordedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fee: FeeCreateNestedOneWithoutPaymentsInput
    payer: UserCreateNestedOneWithoutFeePaymentInput
  }

  export type FeePaymentUncheckedCreateWithoutOrganizationInput = {
    id?: string
    feeId: string
    amount: number
    status?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    receiptNumber: string
    note?: string | null
    transactionId?: string | null
    payerId: string
    platformFee?: number | null
    recordedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeePaymentCreateOrConnectWithoutOrganizationInput = {
    where: FeePaymentWhereUniqueInput
    create: XOR<FeePaymentCreateWithoutOrganizationInput, FeePaymentUncheckedCreateWithoutOrganizationInput>
  }

  export type FeePaymentCreateManyOrganizationInputEnvelope = {
    data: FeePaymentCreateManyOrganizationInput | FeePaymentCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type AcademicCalendarCreateWithoutOrganizationInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    type: $Enums.CalendarEventType
    reason?: string | null
    isRecurring?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicYear?: AcademicYearCreateNestedOneWithoutAcademicCalendarInput
  }

  export type AcademicCalendarUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    type: $Enums.CalendarEventType
    reason?: string | null
    isRecurring?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicYearId?: string | null
  }

  export type AcademicCalendarCreateOrConnectWithoutOrganizationInput = {
    where: AcademicCalendarWhereUniqueInput
    create: XOR<AcademicCalendarCreateWithoutOrganizationInput, AcademicCalendarUncheckedCreateWithoutOrganizationInput>
  }

  export type AcademicCalendarCreateManyOrganizationInputEnvelope = {
    data: AcademicCalendarCreateManyOrganizationInput | AcademicCalendarCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type AnonymousComplaintCreateWithoutOrganizationInput = {
    id?: string
    trackingId: string
    category: string
    severity?: $Enums.Severity
    subject: string
    description: string
    evidenceUrls?: AnonymousComplaintCreateevidenceUrlsInput | string[]
    submittedAt?: Date | string
    currentStatus?: $Enums.ComplaintStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    ComplaintStatusTimeline?: ComplaintStatusTimelineCreateNestedManyWithoutComplaintInput
    academicYear?: AcademicYearCreateNestedOneWithoutComplaintsInput
  }

  export type AnonymousComplaintUncheckedCreateWithoutOrganizationInput = {
    id?: string
    trackingId: string
    category: string
    severity?: $Enums.Severity
    subject: string
    description: string
    evidenceUrls?: AnonymousComplaintCreateevidenceUrlsInput | string[]
    submittedAt?: Date | string
    currentStatus?: $Enums.ComplaintStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    academicYearId?: string | null
    ComplaintStatusTimeline?: ComplaintStatusTimelineUncheckedCreateNestedManyWithoutComplaintInput
  }

  export type AnonymousComplaintCreateOrConnectWithoutOrganizationInput = {
    where: AnonymousComplaintWhereUniqueInput
    create: XOR<AnonymousComplaintCreateWithoutOrganizationInput, AnonymousComplaintUncheckedCreateWithoutOrganizationInput>
  }

  export type AnonymousComplaintCreateManyOrganizationInputEnvelope = {
    data: AnonymousComplaintCreateManyOrganizationInput | AnonymousComplaintCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type TeacherCreateWithoutOrganizationInput = {
    id?: string
    employeeCode?: string | null
    employmentStatus?: $Enums.EmploymentStatus
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTeacherInput
    profile?: TeacherProfileCreateNestedOneWithoutTeacherInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutTeacherInput
    Section?: SectionCreateNestedManyWithoutClassTeacherInput
  }

  export type TeacherUncheckedCreateWithoutOrganizationInput = {
    id?: string
    userId: string
    employeeCode?: string | null
    employmentStatus?: $Enums.EmploymentStatus
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: TeacherProfileUncheckedCreateNestedOneWithoutTeacherInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutTeacherInput
    Section?: SectionUncheckedCreateNestedManyWithoutClassTeacherInput
  }

  export type TeacherCreateOrConnectWithoutOrganizationInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutOrganizationInput, TeacherUncheckedCreateWithoutOrganizationInput>
  }

  export type TeacherCreateManyOrganizationInputEnvelope = {
    data: TeacherCreateManyOrganizationInput | TeacherCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type SubjectCreateWithoutOrganizationInput = {
    id?: string
    name: string
    code: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teachingAssignments?: TeachingAssignmentCreateNestedManyWithoutSubjectInput
    exam?: ExamCreateNestedManyWithoutSubjectInput
    examResult?: ExamResultCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    code: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teachingAssignments?: TeachingAssignmentUncheckedCreateNestedManyWithoutSubjectInput
    exam?: ExamUncheckedCreateNestedManyWithoutSubjectInput
    examResult?: ExamResultUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutOrganizationInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutOrganizationInput, SubjectUncheckedCreateWithoutOrganizationInput>
  }

  export type SubjectCreateManyOrganizationInputEnvelope = {
    data: SubjectCreateManyOrganizationInput | SubjectCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type TeachingAssignmentCreateWithoutOrganizationInput = {
    id?: string
    academicYear?: string | null
    status?: $Enums.AssignmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: TeacherCreateNestedOneWithoutTeachingAssignmentInput
    subject: SubjectCreateNestedOneWithoutTeachingAssignmentsInput
    grade: GradeCreateNestedOneWithoutTeachingAssignmentInput
    section: SectionCreateNestedOneWithoutTeachingAssignmentInput
    AcademicYear?: AcademicYearCreateNestedOneWithoutTeachingAssignmentInput
  }

  export type TeachingAssignmentUncheckedCreateWithoutOrganizationInput = {
    id?: string
    teacherId: string
    subjectId: string
    gradeId: string
    sectionId: string
    academicYear?: string | null
    status?: $Enums.AssignmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    academicYearId?: string | null
  }

  export type TeachingAssignmentCreateOrConnectWithoutOrganizationInput = {
    where: TeachingAssignmentWhereUniqueInput
    create: XOR<TeachingAssignmentCreateWithoutOrganizationInput, TeachingAssignmentUncheckedCreateWithoutOrganizationInput>
  }

  export type TeachingAssignmentCreateManyOrganizationInputEnvelope = {
    data: TeachingAssignmentCreateManyOrganizationInput | TeachingAssignmentCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type NotificationLogCreateWithoutOrganizationInput = {
    id?: string
    channel: $Enums.NotificationChannel
    status?: $Enums.NotificationStatus
    notificationType: $Enums.NotificationType
    units?: number
    cost?: number
    sentAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutNotificationLogInput
    parent?: ParentCreateNestedOneWithoutNotificationLogInput
    student?: StudentCreateNestedOneWithoutNotificationLogInput
  }

  export type NotificationLogUncheckedCreateWithoutOrganizationInput = {
    id?: string
    userId?: string | null
    parentId?: string | null
    studentId?: string | null
    channel: $Enums.NotificationChannel
    status?: $Enums.NotificationStatus
    notificationType: $Enums.NotificationType
    units?: number
    cost?: number
    sentAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationLogCreateOrConnectWithoutOrganizationInput = {
    where: NotificationLogWhereUniqueInput
    create: XOR<NotificationLogCreateWithoutOrganizationInput, NotificationLogUncheckedCreateWithoutOrganizationInput>
  }

  export type NotificationLogCreateManyOrganizationInputEnvelope = {
    data: NotificationLogCreateManyOrganizationInput | NotificationLogCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type AcademicYearCreateWithoutOrganizationInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    type?: $Enums.YearType
    isCurrent?: boolean
    description?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    complaints?: AnonymousComplaintCreateNestedManyWithoutAcademicYearInput
    notices?: NoticeCreateNestedManyWithoutAcademicYearInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutAcademicYearInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutAcademicYearInput
    AcademicCalendar?: AcademicCalendarCreateNestedManyWithoutAcademicYearInput
    ExamSession?: ExamSessionCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    type?: $Enums.YearType
    isCurrent?: boolean
    description?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    complaints?: AnonymousComplaintUncheckedCreateNestedManyWithoutAcademicYearInput
    notices?: NoticeUncheckedCreateNestedManyWithoutAcademicYearInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutAcademicYearInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutAcademicYearInput
    AcademicCalendar?: AcademicCalendarUncheckedCreateNestedManyWithoutAcademicYearInput
    ExamSession?: ExamSessionUncheckedCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearCreateOrConnectWithoutOrganizationInput = {
    where: AcademicYearWhereUniqueInput
    create: XOR<AcademicYearCreateWithoutOrganizationInput, AcademicYearUncheckedCreateWithoutOrganizationInput>
  }

  export type AcademicYearCreateManyOrganizationInputEnvelope = {
    data: AcademicYearCreateManyOrganizationInput | AcademicYearCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type ScheduledJobCreateWithoutOrganizationInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    type: $Enums.scheduledJobType
    scheduledAt: Date | string
    channels?: ScheduledJobCreatechannelsInput | $Enums.NotificationChannel[]
    status?: string
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledJobUncheckedCreateWithoutOrganizationInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    type: $Enums.scheduledJobType
    scheduledAt: Date | string
    channels?: ScheduledJobCreatechannelsInput | $Enums.NotificationChannel[]
    status?: string
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledJobCreateOrConnectWithoutOrganizationInput = {
    where: ScheduledJobWhereUniqueInput
    create: XOR<ScheduledJobCreateWithoutOrganizationInput, ScheduledJobUncheckedCreateWithoutOrganizationInput>
  }

  export type ScheduledJobCreateManyOrganizationInputEnvelope = {
    data: ScheduledJobCreateManyOrganizationInput | ScheduledJobCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type ExamCreateWithoutOrganizationInput = {
    id?: string
    title: string
    description?: string | null
    gradeId: string
    sectionId: string
    maxMarks: number
    passingMarks?: number | null
    weightage?: number | null
    evaluationType: $Enums.EvaluationType
    mode: $Enums.ExamMode
    status?: $Enums.ExamStatus
    instructions?: string | null
    durationInMinutes?: number | null
    venueMapUrl?: string | null
    venue?: string | null
    isResultsPublished?: boolean
    supervisors?: ExamCreatesupervisorsInput | string[]
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    examSession: ExamSessionCreateNestedOneWithoutExamsInput
    subject: SubjectCreateNestedOneWithoutExamInput
    hallTickets?: HallTicketCreateNestedManyWithoutExamInput
    examResult?: ExamResultCreateNestedManyWithoutExamInput
    examEnrollment?: ExamEnrollmentCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutOrganizationInput = {
    id?: string
    title: string
    description?: string | null
    examSessionId: string
    subjectId: string
    gradeId: string
    sectionId: string
    maxMarks: number
    passingMarks?: number | null
    weightage?: number | null
    evaluationType: $Enums.EvaluationType
    mode: $Enums.ExamMode
    status?: $Enums.ExamStatus
    instructions?: string | null
    durationInMinutes?: number | null
    venueMapUrl?: string | null
    venue?: string | null
    isResultsPublished?: boolean
    supervisors?: ExamCreatesupervisorsInput | string[]
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    hallTickets?: HallTicketUncheckedCreateNestedManyWithoutExamInput
    examResult?: ExamResultUncheckedCreateNestedManyWithoutExamInput
    examEnrollment?: ExamEnrollmentUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutOrganizationInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutOrganizationInput, ExamUncheckedCreateWithoutOrganizationInput>
  }

  export type ExamCreateManyOrganizationInputEnvelope = {
    data: ExamCreateManyOrganizationInput | ExamCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type HallTicketCreateWithoutOrganizationInput = {
    id?: string
    pdfUrl: string
    qrCode?: string | null
    generatedAt?: Date | string
    downloadedAt?: Date | string | null
    expiryDate?: Date | string | null
    student: StudentCreateNestedOneWithoutHallTicketInput
    exam?: ExamCreateNestedOneWithoutHallTicketsInput
    examSession?: ExamSessionCreateNestedOneWithoutHallTicketsInput
  }

  export type HallTicketUncheckedCreateWithoutOrganizationInput = {
    id?: string
    studentId: string
    examId?: string | null
    examSessionId?: string | null
    pdfUrl: string
    qrCode?: string | null
    generatedAt?: Date | string
    downloadedAt?: Date | string | null
    expiryDate?: Date | string | null
  }

  export type HallTicketCreateOrConnectWithoutOrganizationInput = {
    where: HallTicketWhereUniqueInput
    create: XOR<HallTicketCreateWithoutOrganizationInput, HallTicketUncheckedCreateWithoutOrganizationInput>
  }

  export type HallTicketCreateManyOrganizationInputEnvelope = {
    data: HallTicketCreateManyOrganizationInput | HallTicketCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutOrganizationInput, UserUncheckedUpdateWithoutOrganizationInput>
    create: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
  }

  export type UserUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutOrganizationInput, UserUncheckedUpdateWithoutOrganizationInput>
  }

  export type UserUpdateManyWithWhereWithoutOrganizationInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    profileImage?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    clerkId?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    organizationId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type NoticeUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: NoticeWhereUniqueInput
    update: XOR<NoticeUpdateWithoutOrganizationInput, NoticeUncheckedUpdateWithoutOrganizationInput>
    create: XOR<NoticeCreateWithoutOrganizationInput, NoticeUncheckedCreateWithoutOrganizationInput>
  }

  export type NoticeUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: NoticeWhereUniqueInput
    data: XOR<NoticeUpdateWithoutOrganizationInput, NoticeUncheckedUpdateWithoutOrganizationInput>
  }

  export type NoticeUpdateManyWithWhereWithoutOrganizationInput = {
    where: NoticeScalarWhereInput
    data: XOR<NoticeUpdateManyMutationInput, NoticeUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type StudentUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutOrganizationInput, StudentUncheckedUpdateWithoutOrganizationInput>
    create: XOR<StudentCreateWithoutOrganizationInput, StudentUncheckedCreateWithoutOrganizationInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutOrganizationInput, StudentUncheckedUpdateWithoutOrganizationInput>
  }

  export type StudentUpdateManyWithWhereWithoutOrganizationInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type StudentScalarWhereInput = {
    AND?: StudentScalarWhereInput | StudentScalarWhereInput[]
    OR?: StudentScalarWhereInput[]
    NOT?: StudentScalarWhereInput | StudentScalarWhereInput[]
    id?: StringFilter<"Student"> | string
    userId?: StringFilter<"Student"> | string
    firstName?: StringFilter<"Student"> | string
    lastName?: StringFilter<"Student"> | string
    middleName?: StringNullableFilter<"Student"> | string | null
    motherName?: StringNullableFilter<"Student"> | string | null
    fullName?: StringNullableFilter<"Student"> | string | null
    dateOfBirth?: DateTimeFilter<"Student"> | Date | string
    profileImage?: StringNullableFilter<"Student"> | string | null
    rollNumber?: StringFilter<"Student"> | string
    phoneNumber?: StringFilter<"Student"> | string
    whatsAppNumber?: StringFilter<"Student"> | string
    email?: StringFilter<"Student"> | string
    emergencyContact?: StringFilter<"Student"> | string
    gender?: EnumGenderFilter<"Student"> | $Enums.Gender
    sectionId?: StringFilter<"Student"> | string
    gradeId?: StringFilter<"Student"> | string
    organizationId?: StringFilter<"Student"> | string
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
  }

  export type StudentDocumentUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: StudentDocumentWhereUniqueInput
    update: XOR<StudentDocumentUpdateWithoutOrganizationInput, StudentDocumentUncheckedUpdateWithoutOrganizationInput>
    create: XOR<StudentDocumentCreateWithoutOrganizationInput, StudentDocumentUncheckedCreateWithoutOrganizationInput>
  }

  export type StudentDocumentUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: StudentDocumentWhereUniqueInput
    data: XOR<StudentDocumentUpdateWithoutOrganizationInput, StudentDocumentUncheckedUpdateWithoutOrganizationInput>
  }

  export type StudentDocumentUpdateManyWithWhereWithoutOrganizationInput = {
    where: StudentDocumentScalarWhereInput
    data: XOR<StudentDocumentUpdateManyMutationInput, StudentDocumentUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type StudentDocumentScalarWhereInput = {
    AND?: StudentDocumentScalarWhereInput | StudentDocumentScalarWhereInput[]
    OR?: StudentDocumentScalarWhereInput[]
    NOT?: StudentDocumentScalarWhereInput | StudentDocumentScalarWhereInput[]
    id?: StringFilter<"StudentDocument"> | string
    type?: EnumDocumentTypeFilter<"StudentDocument"> | $Enums.DocumentType
    fileName?: StringNullableFilter<"StudentDocument"> | string | null
    fileSize?: IntNullableFilter<"StudentDocument"> | number | null
    fileType?: StringNullableFilter<"StudentDocument"> | string | null
    documentUrl?: StringFilter<"StudentDocument"> | string
    studentId?: StringFilter<"StudentDocument"> | string
    verified?: BoolFilter<"StudentDocument"> | boolean
    verifiedBy?: StringNullableFilter<"StudentDocument"> | string | null
    verifiedAt?: DateTimeNullableFilter<"StudentDocument"> | Date | string | null
    rejected?: BoolFilter<"StudentDocument"> | boolean
    rejectedBy?: StringNullableFilter<"StudentDocument"> | string | null
    rejectedAt?: DateTimeNullableFilter<"StudentDocument"> | Date | string | null
    rejectReason?: StringNullableFilter<"StudentDocument"> | string | null
    uploadedBy?: StringNullableFilter<"StudentDocument"> | string | null
    uploadedAt?: DateTimeFilter<"StudentDocument"> | Date | string
    note?: StringNullableFilter<"StudentDocument"> | string | null
    isDeleted?: BoolFilter<"StudentDocument"> | boolean
    deletedAt?: DateTimeNullableFilter<"StudentDocument"> | Date | string | null
    createdAt?: DateTimeFilter<"StudentDocument"> | Date | string
    updatedAt?: DateTimeFilter<"StudentDocument"> | Date | string
    organizationId?: StringFilter<"StudentDocument"> | string
  }

  export type GradeUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: GradeWhereUniqueInput
    update: XOR<GradeUpdateWithoutOrganizationInput, GradeUncheckedUpdateWithoutOrganizationInput>
    create: XOR<GradeCreateWithoutOrganizationInput, GradeUncheckedCreateWithoutOrganizationInput>
  }

  export type GradeUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: GradeWhereUniqueInput
    data: XOR<GradeUpdateWithoutOrganizationInput, GradeUncheckedUpdateWithoutOrganizationInput>
  }

  export type GradeUpdateManyWithWhereWithoutOrganizationInput = {
    where: GradeScalarWhereInput
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type GradeScalarWhereInput = {
    AND?: GradeScalarWhereInput | GradeScalarWhereInput[]
    OR?: GradeScalarWhereInput[]
    NOT?: GradeScalarWhereInput | GradeScalarWhereInput[]
    id?: StringFilter<"Grade"> | string
    grade?: StringFilter<"Grade"> | string
    organizationId?: StringFilter<"Grade"> | string
  }

  export type SectionUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: SectionWhereUniqueInput
    update: XOR<SectionUpdateWithoutOrganizationInput, SectionUncheckedUpdateWithoutOrganizationInput>
    create: XOR<SectionCreateWithoutOrganizationInput, SectionUncheckedCreateWithoutOrganizationInput>
  }

  export type SectionUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: SectionWhereUniqueInput
    data: XOR<SectionUpdateWithoutOrganizationInput, SectionUncheckedUpdateWithoutOrganizationInput>
  }

  export type SectionUpdateManyWithWhereWithoutOrganizationInput = {
    where: SectionScalarWhereInput
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type SectionScalarWhereInput = {
    AND?: SectionScalarWhereInput | SectionScalarWhereInput[]
    OR?: SectionScalarWhereInput[]
    NOT?: SectionScalarWhereInput | SectionScalarWhereInput[]
    id?: StringFilter<"Section"> | string
    name?: StringFilter<"Section"> | string
    gradeId?: StringFilter<"Section"> | string
    organizationId?: StringFilter<"Section"> | string
    classTeacherId?: StringNullableFilter<"Section"> | string | null
  }

  export type FeeUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: FeeWhereUniqueInput
    update: XOR<FeeUpdateWithoutOrganizationInput, FeeUncheckedUpdateWithoutOrganizationInput>
    create: XOR<FeeCreateWithoutOrganizationInput, FeeUncheckedCreateWithoutOrganizationInput>
  }

  export type FeeUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: FeeWhereUniqueInput
    data: XOR<FeeUpdateWithoutOrganizationInput, FeeUncheckedUpdateWithoutOrganizationInput>
  }

  export type FeeUpdateManyWithWhereWithoutOrganizationInput = {
    where: FeeScalarWhereInput
    data: XOR<FeeUpdateManyMutationInput, FeeUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type FeeScalarWhereInput = {
    AND?: FeeScalarWhereInput | FeeScalarWhereInput[]
    OR?: FeeScalarWhereInput[]
    NOT?: FeeScalarWhereInput | FeeScalarWhereInput[]
    id?: StringFilter<"Fee"> | string
    totalFee?: FloatFilter<"Fee"> | number
    paidAmount?: FloatFilter<"Fee"> | number
    pendingAmount?: FloatNullableFilter<"Fee"> | number | null
    dueDate?: DateTimeFilter<"Fee"> | Date | string
    status?: EnumFeeStatusFilter<"Fee"> | $Enums.FeeStatus
    studentId?: StringFilter<"Fee"> | string
    feeCategoryId?: StringFilter<"Fee"> | string
    organizationId?: StringFilter<"Fee"> | string
    createdAt?: DateTimeFilter<"Fee"> | Date | string
    updatedAt?: DateTimeFilter<"Fee"> | Date | string
  }

  export type FeeCategoryUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: FeeCategoryWhereUniqueInput
    update: XOR<FeeCategoryUpdateWithoutOrganizationInput, FeeCategoryUncheckedUpdateWithoutOrganizationInput>
    create: XOR<FeeCategoryCreateWithoutOrganizationInput, FeeCategoryUncheckedCreateWithoutOrganizationInput>
  }

  export type FeeCategoryUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: FeeCategoryWhereUniqueInput
    data: XOR<FeeCategoryUpdateWithoutOrganizationInput, FeeCategoryUncheckedUpdateWithoutOrganizationInput>
  }

  export type FeeCategoryUpdateManyWithWhereWithoutOrganizationInput = {
    where: FeeCategoryScalarWhereInput
    data: XOR<FeeCategoryUpdateManyMutationInput, FeeCategoryUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type FeeCategoryScalarWhereInput = {
    AND?: FeeCategoryScalarWhereInput | FeeCategoryScalarWhereInput[]
    OR?: FeeCategoryScalarWhereInput[]
    NOT?: FeeCategoryScalarWhereInput | FeeCategoryScalarWhereInput[]
    id?: StringFilter<"FeeCategory"> | string
    name?: StringFilter<"FeeCategory"> | string
    description?: StringNullableFilter<"FeeCategory"> | string | null
    createdAt?: DateTimeFilter<"FeeCategory"> | Date | string
    updatedAt?: DateTimeFilter<"FeeCategory"> | Date | string
    organizationId?: StringFilter<"FeeCategory"> | string
  }

  export type FeePaymentUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: FeePaymentWhereUniqueInput
    update: XOR<FeePaymentUpdateWithoutOrganizationInput, FeePaymentUncheckedUpdateWithoutOrganizationInput>
    create: XOR<FeePaymentCreateWithoutOrganizationInput, FeePaymentUncheckedCreateWithoutOrganizationInput>
  }

  export type FeePaymentUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: FeePaymentWhereUniqueInput
    data: XOR<FeePaymentUpdateWithoutOrganizationInput, FeePaymentUncheckedUpdateWithoutOrganizationInput>
  }

  export type FeePaymentUpdateManyWithWhereWithoutOrganizationInput = {
    where: FeePaymentScalarWhereInput
    data: XOR<FeePaymentUpdateManyMutationInput, FeePaymentUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type FeePaymentScalarWhereInput = {
    AND?: FeePaymentScalarWhereInput | FeePaymentScalarWhereInput[]
    OR?: FeePaymentScalarWhereInput[]
    NOT?: FeePaymentScalarWhereInput | FeePaymentScalarWhereInput[]
    id?: StringFilter<"FeePayment"> | string
    feeId?: StringFilter<"FeePayment"> | string
    amount?: FloatFilter<"FeePayment"> | number
    status?: EnumPaymentStatusFilter<"FeePayment"> | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFilter<"FeePayment"> | $Enums.PaymentMethod
    paymentDate?: DateTimeFilter<"FeePayment"> | Date | string
    receiptNumber?: StringFilter<"FeePayment"> | string
    note?: StringNullableFilter<"FeePayment"> | string | null
    transactionId?: StringNullableFilter<"FeePayment"> | string | null
    payerId?: StringFilter<"FeePayment"> | string
    platformFee?: FloatNullableFilter<"FeePayment"> | number | null
    recordedBy?: StringNullableFilter<"FeePayment"> | string | null
    organizationId?: StringFilter<"FeePayment"> | string
    createdAt?: DateTimeFilter<"FeePayment"> | Date | string
    updatedAt?: DateTimeFilter<"FeePayment"> | Date | string
  }

  export type AcademicCalendarUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: AcademicCalendarWhereUniqueInput
    update: XOR<AcademicCalendarUpdateWithoutOrganizationInput, AcademicCalendarUncheckedUpdateWithoutOrganizationInput>
    create: XOR<AcademicCalendarCreateWithoutOrganizationInput, AcademicCalendarUncheckedCreateWithoutOrganizationInput>
  }

  export type AcademicCalendarUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: AcademicCalendarWhereUniqueInput
    data: XOR<AcademicCalendarUpdateWithoutOrganizationInput, AcademicCalendarUncheckedUpdateWithoutOrganizationInput>
  }

  export type AcademicCalendarUpdateManyWithWhereWithoutOrganizationInput = {
    where: AcademicCalendarScalarWhereInput
    data: XOR<AcademicCalendarUpdateManyMutationInput, AcademicCalendarUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type AnonymousComplaintUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: AnonymousComplaintWhereUniqueInput
    update: XOR<AnonymousComplaintUpdateWithoutOrganizationInput, AnonymousComplaintUncheckedUpdateWithoutOrganizationInput>
    create: XOR<AnonymousComplaintCreateWithoutOrganizationInput, AnonymousComplaintUncheckedCreateWithoutOrganizationInput>
  }

  export type AnonymousComplaintUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: AnonymousComplaintWhereUniqueInput
    data: XOR<AnonymousComplaintUpdateWithoutOrganizationInput, AnonymousComplaintUncheckedUpdateWithoutOrganizationInput>
  }

  export type AnonymousComplaintUpdateManyWithWhereWithoutOrganizationInput = {
    where: AnonymousComplaintScalarWhereInput
    data: XOR<AnonymousComplaintUpdateManyMutationInput, AnonymousComplaintUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type TeacherUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: TeacherWhereUniqueInput
    update: XOR<TeacherUpdateWithoutOrganizationInput, TeacherUncheckedUpdateWithoutOrganizationInput>
    create: XOR<TeacherCreateWithoutOrganizationInput, TeacherUncheckedCreateWithoutOrganizationInput>
  }

  export type TeacherUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: TeacherWhereUniqueInput
    data: XOR<TeacherUpdateWithoutOrganizationInput, TeacherUncheckedUpdateWithoutOrganizationInput>
  }

  export type TeacherUpdateManyWithWhereWithoutOrganizationInput = {
    where: TeacherScalarWhereInput
    data: XOR<TeacherUpdateManyMutationInput, TeacherUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type TeacherScalarWhereInput = {
    AND?: TeacherScalarWhereInput | TeacherScalarWhereInput[]
    OR?: TeacherScalarWhereInput[]
    NOT?: TeacherScalarWhereInput | TeacherScalarWhereInput[]
    id?: StringFilter<"Teacher"> | string
    userId?: StringFilter<"Teacher"> | string
    employeeCode?: StringNullableFilter<"Teacher"> | string | null
    employmentStatus?: EnumEmploymentStatusFilter<"Teacher"> | $Enums.EmploymentStatus
    isActive?: BoolFilter<"Teacher"> | boolean
    organizationId?: StringFilter<"Teacher"> | string
    createdAt?: DateTimeFilter<"Teacher"> | Date | string
    updatedAt?: DateTimeFilter<"Teacher"> | Date | string
  }

  export type SubjectUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutOrganizationInput, SubjectUncheckedUpdateWithoutOrganizationInput>
    create: XOR<SubjectCreateWithoutOrganizationInput, SubjectUncheckedCreateWithoutOrganizationInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutOrganizationInput, SubjectUncheckedUpdateWithoutOrganizationInput>
  }

  export type SubjectUpdateManyWithWhereWithoutOrganizationInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type SubjectScalarWhereInput = {
    AND?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
    OR?: SubjectScalarWhereInput[]
    NOT?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
    id?: StringFilter<"Subject"> | string
    name?: StringFilter<"Subject"> | string
    code?: StringFilter<"Subject"> | string
    description?: StringFilter<"Subject"> | string
    organizationId?: StringFilter<"Subject"> | string
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    updatedAt?: DateTimeFilter<"Subject"> | Date | string
  }

  export type TeachingAssignmentUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: TeachingAssignmentWhereUniqueInput
    update: XOR<TeachingAssignmentUpdateWithoutOrganizationInput, TeachingAssignmentUncheckedUpdateWithoutOrganizationInput>
    create: XOR<TeachingAssignmentCreateWithoutOrganizationInput, TeachingAssignmentUncheckedCreateWithoutOrganizationInput>
  }

  export type TeachingAssignmentUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: TeachingAssignmentWhereUniqueInput
    data: XOR<TeachingAssignmentUpdateWithoutOrganizationInput, TeachingAssignmentUncheckedUpdateWithoutOrganizationInput>
  }

  export type TeachingAssignmentUpdateManyWithWhereWithoutOrganizationInput = {
    where: TeachingAssignmentScalarWhereInput
    data: XOR<TeachingAssignmentUpdateManyMutationInput, TeachingAssignmentUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type NotificationLogUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: NotificationLogWhereUniqueInput
    update: XOR<NotificationLogUpdateWithoutOrganizationInput, NotificationLogUncheckedUpdateWithoutOrganizationInput>
    create: XOR<NotificationLogCreateWithoutOrganizationInput, NotificationLogUncheckedCreateWithoutOrganizationInput>
  }

  export type NotificationLogUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: NotificationLogWhereUniqueInput
    data: XOR<NotificationLogUpdateWithoutOrganizationInput, NotificationLogUncheckedUpdateWithoutOrganizationInput>
  }

  export type NotificationLogUpdateManyWithWhereWithoutOrganizationInput = {
    where: NotificationLogScalarWhereInput
    data: XOR<NotificationLogUpdateManyMutationInput, NotificationLogUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type NotificationLogScalarWhereInput = {
    AND?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
    OR?: NotificationLogScalarWhereInput[]
    NOT?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
    id?: StringFilter<"NotificationLog"> | string
    organizationId?: StringFilter<"NotificationLog"> | string
    userId?: StringNullableFilter<"NotificationLog"> | string | null
    parentId?: StringNullableFilter<"NotificationLog"> | string | null
    studentId?: StringNullableFilter<"NotificationLog"> | string | null
    channel?: EnumNotificationChannelFilter<"NotificationLog"> | $Enums.NotificationChannel
    status?: EnumNotificationStatusFilter<"NotificationLog"> | $Enums.NotificationStatus
    notificationType?: EnumNotificationTypeFilter<"NotificationLog"> | $Enums.NotificationType
    units?: IntFilter<"NotificationLog"> | number
    cost?: FloatFilter<"NotificationLog"> | number
    sentAt?: DateTimeFilter<"NotificationLog"> | Date | string
    createdAt?: DateTimeFilter<"NotificationLog"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationLog"> | Date | string
  }

  export type AcademicYearUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: AcademicYearWhereUniqueInput
    update: XOR<AcademicYearUpdateWithoutOrganizationInput, AcademicYearUncheckedUpdateWithoutOrganizationInput>
    create: XOR<AcademicYearCreateWithoutOrganizationInput, AcademicYearUncheckedCreateWithoutOrganizationInput>
  }

  export type AcademicYearUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: AcademicYearWhereUniqueInput
    data: XOR<AcademicYearUpdateWithoutOrganizationInput, AcademicYearUncheckedUpdateWithoutOrganizationInput>
  }

  export type AcademicYearUpdateManyWithWhereWithoutOrganizationInput = {
    where: AcademicYearScalarWhereInput
    data: XOR<AcademicYearUpdateManyMutationInput, AcademicYearUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type AcademicYearScalarWhereInput = {
    AND?: AcademicYearScalarWhereInput | AcademicYearScalarWhereInput[]
    OR?: AcademicYearScalarWhereInput[]
    NOT?: AcademicYearScalarWhereInput | AcademicYearScalarWhereInput[]
    id?: StringFilter<"AcademicYear"> | string
    organizationId?: StringFilter<"AcademicYear"> | string
    name?: StringFilter<"AcademicYear"> | string
    startDate?: DateTimeFilter<"AcademicYear"> | Date | string
    endDate?: DateTimeFilter<"AcademicYear"> | Date | string
    type?: EnumYearTypeFilter<"AcademicYear"> | $Enums.YearType
    isCurrent?: BoolFilter<"AcademicYear"> | boolean
    description?: StringNullableFilter<"AcademicYear"> | string | null
    createdBy?: StringFilter<"AcademicYear"> | string
    createdAt?: DateTimeFilter<"AcademicYear"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicYear"> | Date | string
  }

  export type ScheduledJobUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ScheduledJobWhereUniqueInput
    update: XOR<ScheduledJobUpdateWithoutOrganizationInput, ScheduledJobUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ScheduledJobCreateWithoutOrganizationInput, ScheduledJobUncheckedCreateWithoutOrganizationInput>
  }

  export type ScheduledJobUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ScheduledJobWhereUniqueInput
    data: XOR<ScheduledJobUpdateWithoutOrganizationInput, ScheduledJobUncheckedUpdateWithoutOrganizationInput>
  }

  export type ScheduledJobUpdateManyWithWhereWithoutOrganizationInput = {
    where: ScheduledJobScalarWhereInput
    data: XOR<ScheduledJobUpdateManyMutationInput, ScheduledJobUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ScheduledJobScalarWhereInput = {
    AND?: ScheduledJobScalarWhereInput | ScheduledJobScalarWhereInput[]
    OR?: ScheduledJobScalarWhereInput[]
    NOT?: ScheduledJobScalarWhereInput | ScheduledJobScalarWhereInput[]
    id?: StringFilter<"ScheduledJob"> | string
    data?: JsonFilter<"ScheduledJob">
    type?: EnumscheduledJobTypeFilter<"ScheduledJob"> | $Enums.scheduledJobType
    scheduledAt?: DateTimeFilter<"ScheduledJob"> | Date | string
    channels?: EnumNotificationChannelNullableListFilter<"ScheduledJob">
    status?: StringFilter<"ScheduledJob"> | string
    result?: JsonNullableFilter<"ScheduledJob">
    error?: StringNullableFilter<"ScheduledJob"> | string | null
    createdBy?: StringNullableFilter<"ScheduledJob"> | string | null
    createdAt?: DateTimeFilter<"ScheduledJob"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledJob"> | Date | string
    organizationId?: StringFilter<"ScheduledJob"> | string
  }

  export type ExamUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ExamWhereUniqueInput
    update: XOR<ExamUpdateWithoutOrganizationInput, ExamUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ExamCreateWithoutOrganizationInput, ExamUncheckedCreateWithoutOrganizationInput>
  }

  export type ExamUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ExamWhereUniqueInput
    data: XOR<ExamUpdateWithoutOrganizationInput, ExamUncheckedUpdateWithoutOrganizationInput>
  }

  export type ExamUpdateManyWithWhereWithoutOrganizationInput = {
    where: ExamScalarWhereInput
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ExamScalarWhereInput = {
    AND?: ExamScalarWhereInput | ExamScalarWhereInput[]
    OR?: ExamScalarWhereInput[]
    NOT?: ExamScalarWhereInput | ExamScalarWhereInput[]
    id?: StringFilter<"Exam"> | string
    title?: StringFilter<"Exam"> | string
    description?: StringNullableFilter<"Exam"> | string | null
    examSessionId?: StringFilter<"Exam"> | string
    subjectId?: StringFilter<"Exam"> | string
    gradeId?: StringFilter<"Exam"> | string
    sectionId?: StringFilter<"Exam"> | string
    organizationId?: StringFilter<"Exam"> | string
    maxMarks?: FloatFilter<"Exam"> | number
    passingMarks?: FloatNullableFilter<"Exam"> | number | null
    weightage?: FloatNullableFilter<"Exam"> | number | null
    evaluationType?: EnumEvaluationTypeFilter<"Exam"> | $Enums.EvaluationType
    mode?: EnumExamModeFilter<"Exam"> | $Enums.ExamMode
    status?: EnumExamStatusFilter<"Exam"> | $Enums.ExamStatus
    instructions?: StringNullableFilter<"Exam"> | string | null
    durationInMinutes?: IntNullableFilter<"Exam"> | number | null
    venueMapUrl?: StringNullableFilter<"Exam"> | string | null
    venue?: StringNullableFilter<"Exam"> | string | null
    isResultsPublished?: BoolFilter<"Exam"> | boolean
    supervisors?: StringNullableListFilter<"Exam">
    startDate?: DateTimeFilter<"Exam"> | Date | string
    endDate?: DateTimeFilter<"Exam"> | Date | string
    createdAt?: DateTimeFilter<"Exam"> | Date | string
    updatedAt?: DateTimeFilter<"Exam"> | Date | string
  }

  export type HallTicketUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: HallTicketWhereUniqueInput
    update: XOR<HallTicketUpdateWithoutOrganizationInput, HallTicketUncheckedUpdateWithoutOrganizationInput>
    create: XOR<HallTicketCreateWithoutOrganizationInput, HallTicketUncheckedCreateWithoutOrganizationInput>
  }

  export type HallTicketUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: HallTicketWhereUniqueInput
    data: XOR<HallTicketUpdateWithoutOrganizationInput, HallTicketUncheckedUpdateWithoutOrganizationInput>
  }

  export type HallTicketUpdateManyWithWhereWithoutOrganizationInput = {
    where: HallTicketScalarWhereInput
    data: XOR<HallTicketUpdateManyMutationInput, HallTicketUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type HallTicketScalarWhereInput = {
    AND?: HallTicketScalarWhereInput | HallTicketScalarWhereInput[]
    OR?: HallTicketScalarWhereInput[]
    NOT?: HallTicketScalarWhereInput | HallTicketScalarWhereInput[]
    id?: StringFilter<"HallTicket"> | string
    studentId?: StringFilter<"HallTicket"> | string
    examId?: StringNullableFilter<"HallTicket"> | string | null
    examSessionId?: StringNullableFilter<"HallTicket"> | string | null
    pdfUrl?: StringFilter<"HallTicket"> | string
    qrCode?: StringNullableFilter<"HallTicket"> | string | null
    generatedAt?: DateTimeFilter<"HallTicket"> | Date | string
    downloadedAt?: DateTimeNullableFilter<"HallTicket"> | Date | string | null
    expiryDate?: DateTimeNullableFilter<"HallTicket"> | Date | string | null
    organizationId?: StringFilter<"HallTicket"> | string
  }

  export type OrganizationCreateWithoutUsersInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notices?: NoticeCreateNestedManyWithoutOrganizationInput
    Student?: StudentCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentCreateNestedManyWithoutOrganizationInput
    Grade?: GradeCreateNestedManyWithoutOrganizationInput
    Section?: SectionCreateNestedManyWithoutOrganizationInput
    Fee?: FeeCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobCreateNestedManyWithoutOrganizationInput
    Exam?: ExamCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutUsersInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notices?: NoticeUncheckedCreateNestedManyWithoutOrganizationInput
    Student?: StudentUncheckedCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutOrganizationInput
    Grade?: GradeUncheckedCreateNestedManyWithoutOrganizationInput
    Section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    Fee?: FeeUncheckedCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryUncheckedCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarUncheckedCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintUncheckedCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherUncheckedCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectUncheckedCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearUncheckedCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobUncheckedCreateNestedManyWithoutOrganizationInput
    Exam?: ExamUncheckedCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutUsersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
  }

  export type TeacherCreateWithoutUserInput = {
    id?: string
    employeeCode?: string | null
    employmentStatus?: $Enums.EmploymentStatus
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutTeacherInput
    profile?: TeacherProfileCreateNestedOneWithoutTeacherInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutTeacherInput
    Section?: SectionCreateNestedManyWithoutClassTeacherInput
  }

  export type TeacherUncheckedCreateWithoutUserInput = {
    id?: string
    employeeCode?: string | null
    employmentStatus?: $Enums.EmploymentStatus
    isActive?: boolean
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: TeacherProfileUncheckedCreateNestedOneWithoutTeacherInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutTeacherInput
    Section?: SectionUncheckedCreateNestedManyWithoutClassTeacherInput
  }

  export type TeacherCreateOrConnectWithoutUserInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
  }

  export type StudentCreateWithoutUserInput = {
    id?: string
    firstName: string
    lastName: string
    middleName?: string | null
    motherName?: string | null
    fullName?: string | null
    dateOfBirth: Date | string
    profileImage?: string | null
    rollNumber: string
    phoneNumber: string
    whatsAppNumber: string
    email: string
    emergencyContact: string
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt?: Date | string
    section: SectionCreateNestedOneWithoutStudentsInput
    grade: GradeCreateNestedOneWithoutStudentsInput
    organization: OrganizationCreateNestedOneWithoutStudentInput
    Fee?: FeeCreateNestedManyWithoutStudentInput
    parents?: ParentStudentCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutStudentInput
    StudentDocument?: StudentDocumentCreateNestedManyWithoutStudentInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutStudentInput
    reportCard?: ReportCardCreateNestedManyWithoutStudentInput
    hallTicket?: HallTicketCreateNestedManyWithoutStudentInput
    examResult?: ExamResultCreateNestedManyWithoutStudentInput
    examEnrollment?: ExamEnrollmentCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutUserInput = {
    id?: string
    firstName: string
    lastName: string
    middleName?: string | null
    motherName?: string | null
    fullName?: string | null
    dateOfBirth: Date | string
    profileImage?: string | null
    rollNumber: string
    phoneNumber: string
    whatsAppNumber: string
    email: string
    emergencyContact: string
    gender: $Enums.Gender
    sectionId: string
    gradeId: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Fee?: FeeUncheckedCreateNestedManyWithoutStudentInput
    parents?: ParentStudentUncheckedCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutStudentInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutStudentInput
    reportCard?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
    hallTicket?: HallTicketUncheckedCreateNestedManyWithoutStudentInput
    examResult?: ExamResultUncheckedCreateNestedManyWithoutStudentInput
    examEnrollment?: ExamEnrollmentUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutUserInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
  }

  export type ParentCreateWithoutUserInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phoneNumber: string
    whatsAppNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: ParentStudentCreateNestedManyWithoutParentInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutParentInput
  }

  export type ParentUncheckedCreateWithoutUserInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phoneNumber: string
    whatsAppNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: ParentStudentUncheckedCreateNestedManyWithoutParentInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutParentInput
  }

  export type ParentCreateOrConnectWithoutUserInput = {
    where: ParentWhereUniqueInput
    create: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
  }

  export type FeePaymentCreateWithoutPayerInput = {
    id?: string
    amount: number
    status?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    receiptNumber: string
    note?: string | null
    transactionId?: string | null
    platformFee?: number | null
    recordedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fee: FeeCreateNestedOneWithoutPaymentsInput
    organization: OrganizationCreateNestedOneWithoutFeePaymentInput
  }

  export type FeePaymentUncheckedCreateWithoutPayerInput = {
    id?: string
    feeId: string
    amount: number
    status?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    receiptNumber: string
    note?: string | null
    transactionId?: string | null
    platformFee?: number | null
    recordedBy?: string | null
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeePaymentCreateOrConnectWithoutPayerInput = {
    where: FeePaymentWhereUniqueInput
    create: XOR<FeePaymentCreateWithoutPayerInput, FeePaymentUncheckedCreateWithoutPayerInput>
  }

  export type FeePaymentCreateManyPayerInputEnvelope = {
    data: FeePaymentCreateManyPayerInput | FeePaymentCreateManyPayerInput[]
    skipDuplicates?: boolean
  }

  export type NotificationLogCreateWithoutUserInput = {
    id?: string
    channel: $Enums.NotificationChannel
    status?: $Enums.NotificationStatus
    notificationType: $Enums.NotificationType
    units?: number
    cost?: number
    sentAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutNotificationLogInput
    parent?: ParentCreateNestedOneWithoutNotificationLogInput
    student?: StudentCreateNestedOneWithoutNotificationLogInput
  }

  export type NotificationLogUncheckedCreateWithoutUserInput = {
    id?: string
    organizationId: string
    parentId?: string | null
    studentId?: string | null
    channel: $Enums.NotificationChannel
    status?: $Enums.NotificationStatus
    notificationType: $Enums.NotificationType
    units?: number
    cost?: number
    sentAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationLogCreateOrConnectWithoutUserInput = {
    where: NotificationLogWhereUniqueInput
    create: XOR<NotificationLogCreateWithoutUserInput, NotificationLogUncheckedCreateWithoutUserInput>
  }

  export type NotificationLogCreateManyUserInputEnvelope = {
    data: NotificationLogCreateManyUserInput | NotificationLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutUsersInput = {
    update: XOR<OrganizationUpdateWithoutUsersInput, OrganizationUncheckedUpdateWithoutUsersInput>
    create: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutUsersInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutUsersInput, OrganizationUncheckedUpdateWithoutUsersInput>
  }

  export type OrganizationUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notices?: NoticeUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notices?: NoticeUncheckedUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUncheckedUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUncheckedUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUncheckedUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUncheckedUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUncheckedUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUncheckedUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUncheckedUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUncheckedUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUncheckedUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type TeacherUpsertWithoutUserInput = {
    update: XOR<TeacherUpdateWithoutUserInput, TeacherUncheckedUpdateWithoutUserInput>
    create: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutUserInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutUserInput, TeacherUncheckedUpdateWithoutUserInput>
  }

  export type TeacherUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutTeacherNestedInput
    profile?: TeacherProfileUpdateOneWithoutTeacherNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutTeacherNestedInput
    Section?: SectionUpdateManyWithoutClassTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: TeacherProfileUncheckedUpdateOneWithoutTeacherNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    Section?: SectionUncheckedUpdateManyWithoutClassTeacherNestedInput
  }

  export type StudentUpsertWithoutUserInput = {
    update: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutUserInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
  }

  export type StudentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emergencyContact?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    section?: SectionUpdateOneRequiredWithoutStudentsNestedInput
    grade?: GradeUpdateOneRequiredWithoutStudentsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutStudentNestedInput
    Fee?: FeeUpdateManyWithoutStudentNestedInput
    parents?: ParentStudentUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    StudentDocument?: StudentDocumentUpdateManyWithoutStudentNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutStudentNestedInput
    reportCard?: ReportCardUpdateManyWithoutStudentNestedInput
    hallTicket?: HallTicketUpdateManyWithoutStudentNestedInput
    examResult?: ExamResultUpdateManyWithoutStudentNestedInput
    examEnrollment?: ExamEnrollmentUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emergencyContact?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    sectionId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Fee?: FeeUncheckedUpdateManyWithoutStudentNestedInput
    parents?: ParentStudentUncheckedUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutStudentNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutStudentNestedInput
    reportCard?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
    hallTicket?: HallTicketUncheckedUpdateManyWithoutStudentNestedInput
    examResult?: ExamResultUncheckedUpdateManyWithoutStudentNestedInput
    examEnrollment?: ExamEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ParentUpsertWithoutUserInput = {
    update: XOR<ParentUpdateWithoutUserInput, ParentUncheckedUpdateWithoutUserInput>
    create: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    where?: ParentWhereInput
  }

  export type ParentUpdateToOneWithWhereWithoutUserInput = {
    where?: ParentWhereInput
    data: XOR<ParentUpdateWithoutUserInput, ParentUncheckedUpdateWithoutUserInput>
  }

  export type ParentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: ParentStudentUpdateManyWithoutParentNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutParentNestedInput
  }

  export type ParentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: ParentStudentUncheckedUpdateManyWithoutParentNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutParentNestedInput
  }

  export type FeePaymentUpsertWithWhereUniqueWithoutPayerInput = {
    where: FeePaymentWhereUniqueInput
    update: XOR<FeePaymentUpdateWithoutPayerInput, FeePaymentUncheckedUpdateWithoutPayerInput>
    create: XOR<FeePaymentCreateWithoutPayerInput, FeePaymentUncheckedCreateWithoutPayerInput>
  }

  export type FeePaymentUpdateWithWhereUniqueWithoutPayerInput = {
    where: FeePaymentWhereUniqueInput
    data: XOR<FeePaymentUpdateWithoutPayerInput, FeePaymentUncheckedUpdateWithoutPayerInput>
  }

  export type FeePaymentUpdateManyWithWhereWithoutPayerInput = {
    where: FeePaymentScalarWhereInput
    data: XOR<FeePaymentUpdateManyMutationInput, FeePaymentUncheckedUpdateManyWithoutPayerInput>
  }

  export type NotificationLogUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationLogWhereUniqueInput
    update: XOR<NotificationLogUpdateWithoutUserInput, NotificationLogUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationLogCreateWithoutUserInput, NotificationLogUncheckedCreateWithoutUserInput>
  }

  export type NotificationLogUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationLogWhereUniqueInput
    data: XOR<NotificationLogUpdateWithoutUserInput, NotificationLogUncheckedUpdateWithoutUserInput>
  }

  export type NotificationLogUpdateManyWithWhereWithoutUserInput = {
    where: NotificationLogScalarWhereInput
    data: XOR<NotificationLogUpdateManyMutationInput, NotificationLogUncheckedUpdateManyWithoutUserInput>
  }

  export type OrganizationCreateWithoutGradeInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    notices?: NoticeCreateNestedManyWithoutOrganizationInput
    Student?: StudentCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentCreateNestedManyWithoutOrganizationInput
    Section?: SectionCreateNestedManyWithoutOrganizationInput
    Fee?: FeeCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobCreateNestedManyWithoutOrganizationInput
    Exam?: ExamCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutGradeInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    notices?: NoticeUncheckedCreateNestedManyWithoutOrganizationInput
    Student?: StudentUncheckedCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutOrganizationInput
    Section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    Fee?: FeeUncheckedCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryUncheckedCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarUncheckedCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintUncheckedCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherUncheckedCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectUncheckedCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearUncheckedCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobUncheckedCreateNestedManyWithoutOrganizationInput
    Exam?: ExamUncheckedCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutGradeInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutGradeInput, OrganizationUncheckedCreateWithoutGradeInput>
  }

  export type StudentCreateWithoutGradeInput = {
    id?: string
    firstName: string
    lastName: string
    middleName?: string | null
    motherName?: string | null
    fullName?: string | null
    dateOfBirth: Date | string
    profileImage?: string | null
    rollNumber: string
    phoneNumber: string
    whatsAppNumber: string
    email: string
    emergencyContact: string
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    section: SectionCreateNestedOneWithoutStudentsInput
    organization: OrganizationCreateNestedOneWithoutStudentInput
    Fee?: FeeCreateNestedManyWithoutStudentInput
    parents?: ParentStudentCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutStudentInput
    StudentDocument?: StudentDocumentCreateNestedManyWithoutStudentInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutStudentInput
    reportCard?: ReportCardCreateNestedManyWithoutStudentInput
    hallTicket?: HallTicketCreateNestedManyWithoutStudentInput
    examResult?: ExamResultCreateNestedManyWithoutStudentInput
    examEnrollment?: ExamEnrollmentCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutGradeInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    middleName?: string | null
    motherName?: string | null
    fullName?: string | null
    dateOfBirth: Date | string
    profileImage?: string | null
    rollNumber: string
    phoneNumber: string
    whatsAppNumber: string
    email: string
    emergencyContact: string
    gender: $Enums.Gender
    sectionId: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Fee?: FeeUncheckedCreateNestedManyWithoutStudentInput
    parents?: ParentStudentUncheckedCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutStudentInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutStudentInput
    reportCard?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
    hallTicket?: HallTicketUncheckedCreateNestedManyWithoutStudentInput
    examResult?: ExamResultUncheckedCreateNestedManyWithoutStudentInput
    examEnrollment?: ExamEnrollmentUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutGradeInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutGradeInput, StudentUncheckedCreateWithoutGradeInput>
  }

  export type StudentCreateManyGradeInputEnvelope = {
    data: StudentCreateManyGradeInput | StudentCreateManyGradeInput[]
    skipDuplicates?: boolean
  }

  export type SectionCreateWithoutGradeInput = {
    id?: string
    name: string
    organization: OrganizationCreateNestedOneWithoutSectionInput
    classTeacher?: TeacherCreateNestedOneWithoutSectionInput
    students?: StudentCreateNestedManyWithoutSectionInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutSectionInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutGradeInput = {
    id?: string
    name: string
    organizationId: string
    classTeacherId?: string | null
    students?: StudentUncheckedCreateNestedManyWithoutSectionInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutSectionInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutGradeInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutGradeInput, SectionUncheckedCreateWithoutGradeInput>
  }

  export type SectionCreateManyGradeInputEnvelope = {
    data: SectionCreateManyGradeInput | SectionCreateManyGradeInput[]
    skipDuplicates?: boolean
  }

  export type TeachingAssignmentCreateWithoutGradeInput = {
    id?: string
    academicYear?: string | null
    status?: $Enums.AssignmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: TeacherCreateNestedOneWithoutTeachingAssignmentInput
    subject: SubjectCreateNestedOneWithoutTeachingAssignmentsInput
    section: SectionCreateNestedOneWithoutTeachingAssignmentInput
    organization: OrganizationCreateNestedOneWithoutTeachingAssignmentInput
    AcademicYear?: AcademicYearCreateNestedOneWithoutTeachingAssignmentInput
  }

  export type TeachingAssignmentUncheckedCreateWithoutGradeInput = {
    id?: string
    teacherId: string
    subjectId: string
    sectionId: string
    organizationId: string
    academicYear?: string | null
    status?: $Enums.AssignmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    academicYearId?: string | null
  }

  export type TeachingAssignmentCreateOrConnectWithoutGradeInput = {
    where: TeachingAssignmentWhereUniqueInput
    create: XOR<TeachingAssignmentCreateWithoutGradeInput, TeachingAssignmentUncheckedCreateWithoutGradeInput>
  }

  export type TeachingAssignmentCreateManyGradeInputEnvelope = {
    data: TeachingAssignmentCreateManyGradeInput | TeachingAssignmentCreateManyGradeInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutGradeInput = {
    update: XOR<OrganizationUpdateWithoutGradeInput, OrganizationUncheckedUpdateWithoutGradeInput>
    create: XOR<OrganizationCreateWithoutGradeInput, OrganizationUncheckedCreateWithoutGradeInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutGradeInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutGradeInput, OrganizationUncheckedUpdateWithoutGradeInput>
  }

  export type OrganizationUpdateWithoutGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUncheckedUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUncheckedUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUncheckedUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUncheckedUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUncheckedUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUncheckedUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUncheckedUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUncheckedUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUncheckedUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type StudentUpsertWithWhereUniqueWithoutGradeInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutGradeInput, StudentUncheckedUpdateWithoutGradeInput>
    create: XOR<StudentCreateWithoutGradeInput, StudentUncheckedCreateWithoutGradeInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutGradeInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutGradeInput, StudentUncheckedUpdateWithoutGradeInput>
  }

  export type StudentUpdateManyWithWhereWithoutGradeInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutGradeInput>
  }

  export type SectionUpsertWithWhereUniqueWithoutGradeInput = {
    where: SectionWhereUniqueInput
    update: XOR<SectionUpdateWithoutGradeInput, SectionUncheckedUpdateWithoutGradeInput>
    create: XOR<SectionCreateWithoutGradeInput, SectionUncheckedCreateWithoutGradeInput>
  }

  export type SectionUpdateWithWhereUniqueWithoutGradeInput = {
    where: SectionWhereUniqueInput
    data: XOR<SectionUpdateWithoutGradeInput, SectionUncheckedUpdateWithoutGradeInput>
  }

  export type SectionUpdateManyWithWhereWithoutGradeInput = {
    where: SectionScalarWhereInput
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyWithoutGradeInput>
  }

  export type TeachingAssignmentUpsertWithWhereUniqueWithoutGradeInput = {
    where: TeachingAssignmentWhereUniqueInput
    update: XOR<TeachingAssignmentUpdateWithoutGradeInput, TeachingAssignmentUncheckedUpdateWithoutGradeInput>
    create: XOR<TeachingAssignmentCreateWithoutGradeInput, TeachingAssignmentUncheckedCreateWithoutGradeInput>
  }

  export type TeachingAssignmentUpdateWithWhereUniqueWithoutGradeInput = {
    where: TeachingAssignmentWhereUniqueInput
    data: XOR<TeachingAssignmentUpdateWithoutGradeInput, TeachingAssignmentUncheckedUpdateWithoutGradeInput>
  }

  export type TeachingAssignmentUpdateManyWithWhereWithoutGradeInput = {
    where: TeachingAssignmentScalarWhereInput
    data: XOR<TeachingAssignmentUpdateManyMutationInput, TeachingAssignmentUncheckedUpdateManyWithoutGradeInput>
  }

  export type GradeCreateWithoutSectionInput = {
    id?: string
    grade: string
    organization: OrganizationCreateNestedOneWithoutGradeInput
    students?: StudentCreateNestedManyWithoutGradeInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutGradeInput
  }

  export type GradeUncheckedCreateWithoutSectionInput = {
    id?: string
    grade: string
    organizationId: string
    students?: StudentUncheckedCreateNestedManyWithoutGradeInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutGradeInput
  }

  export type GradeCreateOrConnectWithoutSectionInput = {
    where: GradeWhereUniqueInput
    create: XOR<GradeCreateWithoutSectionInput, GradeUncheckedCreateWithoutSectionInput>
  }

  export type OrganizationCreateWithoutSectionInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    notices?: NoticeCreateNestedManyWithoutOrganizationInput
    Student?: StudentCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentCreateNestedManyWithoutOrganizationInput
    Grade?: GradeCreateNestedManyWithoutOrganizationInput
    Fee?: FeeCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobCreateNestedManyWithoutOrganizationInput
    Exam?: ExamCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutSectionInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    notices?: NoticeUncheckedCreateNestedManyWithoutOrganizationInput
    Student?: StudentUncheckedCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutOrganizationInput
    Grade?: GradeUncheckedCreateNestedManyWithoutOrganizationInput
    Fee?: FeeUncheckedCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryUncheckedCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarUncheckedCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintUncheckedCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherUncheckedCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectUncheckedCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearUncheckedCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobUncheckedCreateNestedManyWithoutOrganizationInput
    Exam?: ExamUncheckedCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutSectionInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutSectionInput, OrganizationUncheckedCreateWithoutSectionInput>
  }

  export type TeacherCreateWithoutSectionInput = {
    id?: string
    employeeCode?: string | null
    employmentStatus?: $Enums.EmploymentStatus
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTeacherInput
    organization: OrganizationCreateNestedOneWithoutTeacherInput
    profile?: TeacherProfileCreateNestedOneWithoutTeacherInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutSectionInput = {
    id?: string
    userId: string
    employeeCode?: string | null
    employmentStatus?: $Enums.EmploymentStatus
    isActive?: boolean
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: TeacherProfileUncheckedCreateNestedOneWithoutTeacherInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutSectionInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutSectionInput, TeacherUncheckedCreateWithoutSectionInput>
  }

  export type StudentCreateWithoutSectionInput = {
    id?: string
    firstName: string
    lastName: string
    middleName?: string | null
    motherName?: string | null
    fullName?: string | null
    dateOfBirth: Date | string
    profileImage?: string | null
    rollNumber: string
    phoneNumber: string
    whatsAppNumber: string
    email: string
    emergencyContact: string
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    grade: GradeCreateNestedOneWithoutStudentsInput
    organization: OrganizationCreateNestedOneWithoutStudentInput
    Fee?: FeeCreateNestedManyWithoutStudentInput
    parents?: ParentStudentCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutStudentInput
    StudentDocument?: StudentDocumentCreateNestedManyWithoutStudentInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutStudentInput
    reportCard?: ReportCardCreateNestedManyWithoutStudentInput
    hallTicket?: HallTicketCreateNestedManyWithoutStudentInput
    examResult?: ExamResultCreateNestedManyWithoutStudentInput
    examEnrollment?: ExamEnrollmentCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutSectionInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    middleName?: string | null
    motherName?: string | null
    fullName?: string | null
    dateOfBirth: Date | string
    profileImage?: string | null
    rollNumber: string
    phoneNumber: string
    whatsAppNumber: string
    email: string
    emergencyContact: string
    gender: $Enums.Gender
    gradeId: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Fee?: FeeUncheckedCreateNestedManyWithoutStudentInput
    parents?: ParentStudentUncheckedCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutStudentInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutStudentInput
    reportCard?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
    hallTicket?: HallTicketUncheckedCreateNestedManyWithoutStudentInput
    examResult?: ExamResultUncheckedCreateNestedManyWithoutStudentInput
    examEnrollment?: ExamEnrollmentUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutSectionInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutSectionInput, StudentUncheckedCreateWithoutSectionInput>
  }

  export type StudentCreateManySectionInputEnvelope = {
    data: StudentCreateManySectionInput | StudentCreateManySectionInput[]
    skipDuplicates?: boolean
  }

  export type StudentAttendanceCreateWithoutSectionInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    note?: string | null
    recordedBy: string
    present?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentAttendanceInput
    academicYear?: AcademicYearCreateNestedOneWithoutStudentAttendanceInput
  }

  export type StudentAttendanceUncheckedCreateWithoutSectionInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    note?: string | null
    recordedBy: string
    studentId: string
    present?: boolean
    academicYearId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAttendanceCreateOrConnectWithoutSectionInput = {
    where: StudentAttendanceWhereUniqueInput
    create: XOR<StudentAttendanceCreateWithoutSectionInput, StudentAttendanceUncheckedCreateWithoutSectionInput>
  }

  export type StudentAttendanceCreateManySectionInputEnvelope = {
    data: StudentAttendanceCreateManySectionInput | StudentAttendanceCreateManySectionInput[]
    skipDuplicates?: boolean
  }

  export type TeachingAssignmentCreateWithoutSectionInput = {
    id?: string
    academicYear?: string | null
    status?: $Enums.AssignmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: TeacherCreateNestedOneWithoutTeachingAssignmentInput
    subject: SubjectCreateNestedOneWithoutTeachingAssignmentsInput
    grade: GradeCreateNestedOneWithoutTeachingAssignmentInput
    organization: OrganizationCreateNestedOneWithoutTeachingAssignmentInput
    AcademicYear?: AcademicYearCreateNestedOneWithoutTeachingAssignmentInput
  }

  export type TeachingAssignmentUncheckedCreateWithoutSectionInput = {
    id?: string
    teacherId: string
    subjectId: string
    gradeId: string
    organizationId: string
    academicYear?: string | null
    status?: $Enums.AssignmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    academicYearId?: string | null
  }

  export type TeachingAssignmentCreateOrConnectWithoutSectionInput = {
    where: TeachingAssignmentWhereUniqueInput
    create: XOR<TeachingAssignmentCreateWithoutSectionInput, TeachingAssignmentUncheckedCreateWithoutSectionInput>
  }

  export type TeachingAssignmentCreateManySectionInputEnvelope = {
    data: TeachingAssignmentCreateManySectionInput | TeachingAssignmentCreateManySectionInput[]
    skipDuplicates?: boolean
  }

  export type GradeUpsertWithoutSectionInput = {
    update: XOR<GradeUpdateWithoutSectionInput, GradeUncheckedUpdateWithoutSectionInput>
    create: XOR<GradeCreateWithoutSectionInput, GradeUncheckedCreateWithoutSectionInput>
    where?: GradeWhereInput
  }

  export type GradeUpdateToOneWithWhereWithoutSectionInput = {
    where?: GradeWhereInput
    data: XOR<GradeUpdateWithoutSectionInput, GradeUncheckedUpdateWithoutSectionInput>
  }

  export type GradeUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    organization?: OrganizationUpdateOneRequiredWithoutGradeNestedInput
    students?: StudentUpdateManyWithoutGradeNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutGradeNestedInput
  }

  export type GradeUncheckedUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    students?: StudentUncheckedUpdateManyWithoutGradeNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutGradeNestedInput
  }

  export type OrganizationUpsertWithoutSectionInput = {
    update: XOR<OrganizationUpdateWithoutSectionInput, OrganizationUncheckedUpdateWithoutSectionInput>
    create: XOR<OrganizationCreateWithoutSectionInput, OrganizationUncheckedCreateWithoutSectionInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutSectionInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutSectionInput, OrganizationUncheckedUpdateWithoutSectionInput>
  }

  export type OrganizationUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUncheckedUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUncheckedUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUncheckedUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUncheckedUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUncheckedUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUncheckedUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUncheckedUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUncheckedUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUncheckedUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type TeacherUpsertWithoutSectionInput = {
    update: XOR<TeacherUpdateWithoutSectionInput, TeacherUncheckedUpdateWithoutSectionInput>
    create: XOR<TeacherCreateWithoutSectionInput, TeacherUncheckedCreateWithoutSectionInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutSectionInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutSectionInput, TeacherUncheckedUpdateWithoutSectionInput>
  }

  export type TeacherUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutTeacherNestedInput
    profile?: TeacherProfileUpdateOneWithoutTeacherNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: TeacherProfileUncheckedUpdateOneWithoutTeacherNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type StudentUpsertWithWhereUniqueWithoutSectionInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutSectionInput, StudentUncheckedUpdateWithoutSectionInput>
    create: XOR<StudentCreateWithoutSectionInput, StudentUncheckedCreateWithoutSectionInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutSectionInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutSectionInput, StudentUncheckedUpdateWithoutSectionInput>
  }

  export type StudentUpdateManyWithWhereWithoutSectionInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutSectionInput>
  }

  export type StudentAttendanceUpsertWithWhereUniqueWithoutSectionInput = {
    where: StudentAttendanceWhereUniqueInput
    update: XOR<StudentAttendanceUpdateWithoutSectionInput, StudentAttendanceUncheckedUpdateWithoutSectionInput>
    create: XOR<StudentAttendanceCreateWithoutSectionInput, StudentAttendanceUncheckedCreateWithoutSectionInput>
  }

  export type StudentAttendanceUpdateWithWhereUniqueWithoutSectionInput = {
    where: StudentAttendanceWhereUniqueInput
    data: XOR<StudentAttendanceUpdateWithoutSectionInput, StudentAttendanceUncheckedUpdateWithoutSectionInput>
  }

  export type StudentAttendanceUpdateManyWithWhereWithoutSectionInput = {
    where: StudentAttendanceScalarWhereInput
    data: XOR<StudentAttendanceUpdateManyMutationInput, StudentAttendanceUncheckedUpdateManyWithoutSectionInput>
  }

  export type TeachingAssignmentUpsertWithWhereUniqueWithoutSectionInput = {
    where: TeachingAssignmentWhereUniqueInput
    update: XOR<TeachingAssignmentUpdateWithoutSectionInput, TeachingAssignmentUncheckedUpdateWithoutSectionInput>
    create: XOR<TeachingAssignmentCreateWithoutSectionInput, TeachingAssignmentUncheckedCreateWithoutSectionInput>
  }

  export type TeachingAssignmentUpdateWithWhereUniqueWithoutSectionInput = {
    where: TeachingAssignmentWhereUniqueInput
    data: XOR<TeachingAssignmentUpdateWithoutSectionInput, TeachingAssignmentUncheckedUpdateWithoutSectionInput>
  }

  export type TeachingAssignmentUpdateManyWithWhereWithoutSectionInput = {
    where: TeachingAssignmentScalarWhereInput
    data: XOR<TeachingAssignmentUpdateManyMutationInput, TeachingAssignmentUncheckedUpdateManyWithoutSectionInput>
  }

  export type UserCreateWithoutTeacherInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password?: string | null
    profileImage: string
    role?: $Enums.Role
    clerkId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    student?: StudentCreateNestedOneWithoutUserInput
    parent?: ParentCreateNestedOneWithoutUserInput
    FeePayment?: FeePaymentCreateNestedManyWithoutPayerInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeacherInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password?: string | null
    profileImage: string
    role?: $Enums.Role
    clerkId: string
    isActive?: boolean
    organizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    parent?: ParentUncheckedCreateNestedOneWithoutUserInput
    FeePayment?: FeePaymentUncheckedCreateNestedManyWithoutPayerInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeacherInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
  }

  export type OrganizationCreateWithoutTeacherInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    notices?: NoticeCreateNestedManyWithoutOrganizationInput
    Student?: StudentCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentCreateNestedManyWithoutOrganizationInput
    Grade?: GradeCreateNestedManyWithoutOrganizationInput
    Section?: SectionCreateNestedManyWithoutOrganizationInput
    Fee?: FeeCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobCreateNestedManyWithoutOrganizationInput
    Exam?: ExamCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutTeacherInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    notices?: NoticeUncheckedCreateNestedManyWithoutOrganizationInput
    Student?: StudentUncheckedCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutOrganizationInput
    Grade?: GradeUncheckedCreateNestedManyWithoutOrganizationInput
    Section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    Fee?: FeeUncheckedCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryUncheckedCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarUncheckedCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintUncheckedCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectUncheckedCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearUncheckedCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobUncheckedCreateNestedManyWithoutOrganizationInput
    Exam?: ExamUncheckedCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutTeacherInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutTeacherInput, OrganizationUncheckedCreateWithoutTeacherInput>
  }

  export type TeacherProfileCreateWithoutTeacherInput = {
    id?: string
    contactEmail: string
    contactPhone: string
    address: string
    city?: string | null
    state?: string | null
    dateOfBirth: Date | string
    qualification: string
    experienceInYears: number
    resumeUrl?: string | null
    joinedAt: Date | string
    bio?: string | null
    teachingPhilosophy?: string | null
    specializedSubjects?: TeacherProfileCreatespecializedSubjectsInput | string[]
    preferredGrades?: TeacherProfileCreatepreferredGradesInput | string[]
    idProofUrl: string
    linkedinPortfolio?: string | null
    languagesKnown?: TeacherProfileCreatelanguagesKnownInput | string[]
    certificateUrls?: TeacherProfileCreatecertificateUrlsInput | string[]
  }

  export type TeacherProfileUncheckedCreateWithoutTeacherInput = {
    id?: string
    contactEmail: string
    contactPhone: string
    address: string
    city?: string | null
    state?: string | null
    dateOfBirth: Date | string
    qualification: string
    experienceInYears: number
    resumeUrl?: string | null
    joinedAt: Date | string
    bio?: string | null
    teachingPhilosophy?: string | null
    specializedSubjects?: TeacherProfileCreatespecializedSubjectsInput | string[]
    preferredGrades?: TeacherProfileCreatepreferredGradesInput | string[]
    idProofUrl: string
    linkedinPortfolio?: string | null
    languagesKnown?: TeacherProfileCreatelanguagesKnownInput | string[]
    certificateUrls?: TeacherProfileCreatecertificateUrlsInput | string[]
  }

  export type TeacherProfileCreateOrConnectWithoutTeacherInput = {
    where: TeacherProfileWhereUniqueInput
    create: XOR<TeacherProfileCreateWithoutTeacherInput, TeacherProfileUncheckedCreateWithoutTeacherInput>
  }

  export type TeachingAssignmentCreateWithoutTeacherInput = {
    id?: string
    academicYear?: string | null
    status?: $Enums.AssignmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: SubjectCreateNestedOneWithoutTeachingAssignmentsInput
    grade: GradeCreateNestedOneWithoutTeachingAssignmentInput
    section: SectionCreateNestedOneWithoutTeachingAssignmentInput
    organization: OrganizationCreateNestedOneWithoutTeachingAssignmentInput
    AcademicYear?: AcademicYearCreateNestedOneWithoutTeachingAssignmentInput
  }

  export type TeachingAssignmentUncheckedCreateWithoutTeacherInput = {
    id?: string
    subjectId: string
    gradeId: string
    sectionId: string
    organizationId: string
    academicYear?: string | null
    status?: $Enums.AssignmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    academicYearId?: string | null
  }

  export type TeachingAssignmentCreateOrConnectWithoutTeacherInput = {
    where: TeachingAssignmentWhereUniqueInput
    create: XOR<TeachingAssignmentCreateWithoutTeacherInput, TeachingAssignmentUncheckedCreateWithoutTeacherInput>
  }

  export type TeachingAssignmentCreateManyTeacherInputEnvelope = {
    data: TeachingAssignmentCreateManyTeacherInput | TeachingAssignmentCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type SectionCreateWithoutClassTeacherInput = {
    id?: string
    name: string
    grade: GradeCreateNestedOneWithoutSectionInput
    organization: OrganizationCreateNestedOneWithoutSectionInput
    students?: StudentCreateNestedManyWithoutSectionInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutSectionInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutClassTeacherInput = {
    id?: string
    name: string
    gradeId: string
    organizationId: string
    students?: StudentUncheckedCreateNestedManyWithoutSectionInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutSectionInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutClassTeacherInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutClassTeacherInput, SectionUncheckedCreateWithoutClassTeacherInput>
  }

  export type SectionCreateManyClassTeacherInputEnvelope = {
    data: SectionCreateManyClassTeacherInput | SectionCreateManyClassTeacherInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTeacherInput = {
    update: XOR<UserUpdateWithoutTeacherInput, UserUncheckedUpdateWithoutTeacherInput>
    create: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeacherInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeacherInput, UserUncheckedUpdateWithoutTeacherInput>
  }

  export type UserUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    clerkId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    parent?: ParentUpdateOneWithoutUserNestedInput
    FeePayment?: FeePaymentUpdateManyWithoutPayerNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    clerkId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    parent?: ParentUncheckedUpdateOneWithoutUserNestedInput
    FeePayment?: FeePaymentUncheckedUpdateManyWithoutPayerNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationUpsertWithoutTeacherInput = {
    update: XOR<OrganizationUpdateWithoutTeacherInput, OrganizationUncheckedUpdateWithoutTeacherInput>
    create: XOR<OrganizationCreateWithoutTeacherInput, OrganizationUncheckedCreateWithoutTeacherInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutTeacherInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutTeacherInput, OrganizationUncheckedUpdateWithoutTeacherInput>
  }

  export type OrganizationUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUncheckedUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUncheckedUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUncheckedUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUncheckedUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUncheckedUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUncheckedUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUncheckedUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUncheckedUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type TeacherProfileUpsertWithoutTeacherInput = {
    update: XOR<TeacherProfileUpdateWithoutTeacherInput, TeacherProfileUncheckedUpdateWithoutTeacherInput>
    create: XOR<TeacherProfileCreateWithoutTeacherInput, TeacherProfileUncheckedCreateWithoutTeacherInput>
    where?: TeacherProfileWhereInput
  }

  export type TeacherProfileUpdateToOneWithWhereWithoutTeacherInput = {
    where?: TeacherProfileWhereInput
    data: XOR<TeacherProfileUpdateWithoutTeacherInput, TeacherProfileUncheckedUpdateWithoutTeacherInput>
  }

  export type TeacherProfileUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    qualification?: StringFieldUpdateOperationsInput | string
    experienceInYears?: IntFieldUpdateOperationsInput | number
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    teachingPhilosophy?: NullableStringFieldUpdateOperationsInput | string | null
    specializedSubjects?: TeacherProfileUpdatespecializedSubjectsInput | string[]
    preferredGrades?: TeacherProfileUpdatepreferredGradesInput | string[]
    idProofUrl?: StringFieldUpdateOperationsInput | string
    linkedinPortfolio?: NullableStringFieldUpdateOperationsInput | string | null
    languagesKnown?: TeacherProfileUpdatelanguagesKnownInput | string[]
    certificateUrls?: TeacherProfileUpdatecertificateUrlsInput | string[]
  }

  export type TeacherProfileUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    qualification?: StringFieldUpdateOperationsInput | string
    experienceInYears?: IntFieldUpdateOperationsInput | number
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    teachingPhilosophy?: NullableStringFieldUpdateOperationsInput | string | null
    specializedSubjects?: TeacherProfileUpdatespecializedSubjectsInput | string[]
    preferredGrades?: TeacherProfileUpdatepreferredGradesInput | string[]
    idProofUrl?: StringFieldUpdateOperationsInput | string
    linkedinPortfolio?: NullableStringFieldUpdateOperationsInput | string | null
    languagesKnown?: TeacherProfileUpdatelanguagesKnownInput | string[]
    certificateUrls?: TeacherProfileUpdatecertificateUrlsInput | string[]
  }

  export type TeachingAssignmentUpsertWithWhereUniqueWithoutTeacherInput = {
    where: TeachingAssignmentWhereUniqueInput
    update: XOR<TeachingAssignmentUpdateWithoutTeacherInput, TeachingAssignmentUncheckedUpdateWithoutTeacherInput>
    create: XOR<TeachingAssignmentCreateWithoutTeacherInput, TeachingAssignmentUncheckedCreateWithoutTeacherInput>
  }

  export type TeachingAssignmentUpdateWithWhereUniqueWithoutTeacherInput = {
    where: TeachingAssignmentWhereUniqueInput
    data: XOR<TeachingAssignmentUpdateWithoutTeacherInput, TeachingAssignmentUncheckedUpdateWithoutTeacherInput>
  }

  export type TeachingAssignmentUpdateManyWithWhereWithoutTeacherInput = {
    where: TeachingAssignmentScalarWhereInput
    data: XOR<TeachingAssignmentUpdateManyMutationInput, TeachingAssignmentUncheckedUpdateManyWithoutTeacherInput>
  }

  export type SectionUpsertWithWhereUniqueWithoutClassTeacherInput = {
    where: SectionWhereUniqueInput
    update: XOR<SectionUpdateWithoutClassTeacherInput, SectionUncheckedUpdateWithoutClassTeacherInput>
    create: XOR<SectionCreateWithoutClassTeacherInput, SectionUncheckedCreateWithoutClassTeacherInput>
  }

  export type SectionUpdateWithWhereUniqueWithoutClassTeacherInput = {
    where: SectionWhereUniqueInput
    data: XOR<SectionUpdateWithoutClassTeacherInput, SectionUncheckedUpdateWithoutClassTeacherInput>
  }

  export type SectionUpdateManyWithWhereWithoutClassTeacherInput = {
    where: SectionScalarWhereInput
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyWithoutClassTeacherInput>
  }

  export type TeacherCreateWithoutProfileInput = {
    id?: string
    employeeCode?: string | null
    employmentStatus?: $Enums.EmploymentStatus
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTeacherInput
    organization: OrganizationCreateNestedOneWithoutTeacherInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutTeacherInput
    Section?: SectionCreateNestedManyWithoutClassTeacherInput
  }

  export type TeacherUncheckedCreateWithoutProfileInput = {
    id?: string
    userId: string
    employeeCode?: string | null
    employmentStatus?: $Enums.EmploymentStatus
    isActive?: boolean
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutTeacherInput
    Section?: SectionUncheckedCreateNestedManyWithoutClassTeacherInput
  }

  export type TeacherCreateOrConnectWithoutProfileInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutProfileInput, TeacherUncheckedCreateWithoutProfileInput>
  }

  export type TeacherUpsertWithoutProfileInput = {
    update: XOR<TeacherUpdateWithoutProfileInput, TeacherUncheckedUpdateWithoutProfileInput>
    create: XOR<TeacherCreateWithoutProfileInput, TeacherUncheckedCreateWithoutProfileInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutProfileInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutProfileInput, TeacherUncheckedUpdateWithoutProfileInput>
  }

  export type TeacherUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutTeacherNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutTeacherNestedInput
    Section?: SectionUpdateManyWithoutClassTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    Section?: SectionUncheckedUpdateManyWithoutClassTeacherNestedInput
  }

  export type OrganizationCreateWithoutSubjectInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    notices?: NoticeCreateNestedManyWithoutOrganizationInput
    Student?: StudentCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentCreateNestedManyWithoutOrganizationInput
    Grade?: GradeCreateNestedManyWithoutOrganizationInput
    Section?: SectionCreateNestedManyWithoutOrganizationInput
    Fee?: FeeCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobCreateNestedManyWithoutOrganizationInput
    Exam?: ExamCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutSubjectInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    notices?: NoticeUncheckedCreateNestedManyWithoutOrganizationInput
    Student?: StudentUncheckedCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutOrganizationInput
    Grade?: GradeUncheckedCreateNestedManyWithoutOrganizationInput
    Section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    Fee?: FeeUncheckedCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryUncheckedCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarUncheckedCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintUncheckedCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherUncheckedCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearUncheckedCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobUncheckedCreateNestedManyWithoutOrganizationInput
    Exam?: ExamUncheckedCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutSubjectInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutSubjectInput, OrganizationUncheckedCreateWithoutSubjectInput>
  }

  export type TeachingAssignmentCreateWithoutSubjectInput = {
    id?: string
    academicYear?: string | null
    status?: $Enums.AssignmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: TeacherCreateNestedOneWithoutTeachingAssignmentInput
    grade: GradeCreateNestedOneWithoutTeachingAssignmentInput
    section: SectionCreateNestedOneWithoutTeachingAssignmentInput
    organization: OrganizationCreateNestedOneWithoutTeachingAssignmentInput
    AcademicYear?: AcademicYearCreateNestedOneWithoutTeachingAssignmentInput
  }

  export type TeachingAssignmentUncheckedCreateWithoutSubjectInput = {
    id?: string
    teacherId: string
    gradeId: string
    sectionId: string
    organizationId: string
    academicYear?: string | null
    status?: $Enums.AssignmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    academicYearId?: string | null
  }

  export type TeachingAssignmentCreateOrConnectWithoutSubjectInput = {
    where: TeachingAssignmentWhereUniqueInput
    create: XOR<TeachingAssignmentCreateWithoutSubjectInput, TeachingAssignmentUncheckedCreateWithoutSubjectInput>
  }

  export type TeachingAssignmentCreateManySubjectInputEnvelope = {
    data: TeachingAssignmentCreateManySubjectInput | TeachingAssignmentCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type ExamCreateWithoutSubjectInput = {
    id?: string
    title: string
    description?: string | null
    gradeId: string
    sectionId: string
    maxMarks: number
    passingMarks?: number | null
    weightage?: number | null
    evaluationType: $Enums.EvaluationType
    mode: $Enums.ExamMode
    status?: $Enums.ExamStatus
    instructions?: string | null
    durationInMinutes?: number | null
    venueMapUrl?: string | null
    venue?: string | null
    isResultsPublished?: boolean
    supervisors?: ExamCreatesupervisorsInput | string[]
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    examSession: ExamSessionCreateNestedOneWithoutExamsInput
    organization: OrganizationCreateNestedOneWithoutExamInput
    hallTickets?: HallTicketCreateNestedManyWithoutExamInput
    examResult?: ExamResultCreateNestedManyWithoutExamInput
    examEnrollment?: ExamEnrollmentCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutSubjectInput = {
    id?: string
    title: string
    description?: string | null
    examSessionId: string
    gradeId: string
    sectionId: string
    organizationId: string
    maxMarks: number
    passingMarks?: number | null
    weightage?: number | null
    evaluationType: $Enums.EvaluationType
    mode: $Enums.ExamMode
    status?: $Enums.ExamStatus
    instructions?: string | null
    durationInMinutes?: number | null
    venueMapUrl?: string | null
    venue?: string | null
    isResultsPublished?: boolean
    supervisors?: ExamCreatesupervisorsInput | string[]
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    hallTickets?: HallTicketUncheckedCreateNestedManyWithoutExamInput
    examResult?: ExamResultUncheckedCreateNestedManyWithoutExamInput
    examEnrollment?: ExamEnrollmentUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutSubjectInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutSubjectInput, ExamUncheckedCreateWithoutSubjectInput>
  }

  export type ExamCreateManySubjectInputEnvelope = {
    data: ExamCreateManySubjectInput | ExamCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type ExamResultCreateWithoutSubjectInput = {
    id?: string
    maxMarks: number
    obtainedMarks?: number | null
    percentage?: number | null
    gradeLabel?: string | null
    remarks?: string | null
    isPassed?: boolean | null
    isAbsent?: boolean
    isResultsPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutExamResultInput
    exam: ExamCreateNestedOneWithoutExamResultInput
  }

  export type ExamResultUncheckedCreateWithoutSubjectInput = {
    id?: string
    studentId: string
    examId: string
    maxMarks: number
    obtainedMarks?: number | null
    percentage?: number | null
    gradeLabel?: string | null
    remarks?: string | null
    isPassed?: boolean | null
    isAbsent?: boolean
    isResultsPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamResultCreateOrConnectWithoutSubjectInput = {
    where: ExamResultWhereUniqueInput
    create: XOR<ExamResultCreateWithoutSubjectInput, ExamResultUncheckedCreateWithoutSubjectInput>
  }

  export type ExamResultCreateManySubjectInputEnvelope = {
    data: ExamResultCreateManySubjectInput | ExamResultCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutSubjectInput = {
    update: XOR<OrganizationUpdateWithoutSubjectInput, OrganizationUncheckedUpdateWithoutSubjectInput>
    create: XOR<OrganizationCreateWithoutSubjectInput, OrganizationUncheckedCreateWithoutSubjectInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutSubjectInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutSubjectInput, OrganizationUncheckedUpdateWithoutSubjectInput>
  }

  export type OrganizationUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUncheckedUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUncheckedUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUncheckedUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUncheckedUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUncheckedUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUncheckedUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUncheckedUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUncheckedUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type TeachingAssignmentUpsertWithWhereUniqueWithoutSubjectInput = {
    where: TeachingAssignmentWhereUniqueInput
    update: XOR<TeachingAssignmentUpdateWithoutSubjectInput, TeachingAssignmentUncheckedUpdateWithoutSubjectInput>
    create: XOR<TeachingAssignmentCreateWithoutSubjectInput, TeachingAssignmentUncheckedCreateWithoutSubjectInput>
  }

  export type TeachingAssignmentUpdateWithWhereUniqueWithoutSubjectInput = {
    where: TeachingAssignmentWhereUniqueInput
    data: XOR<TeachingAssignmentUpdateWithoutSubjectInput, TeachingAssignmentUncheckedUpdateWithoutSubjectInput>
  }

  export type TeachingAssignmentUpdateManyWithWhereWithoutSubjectInput = {
    where: TeachingAssignmentScalarWhereInput
    data: XOR<TeachingAssignmentUpdateManyMutationInput, TeachingAssignmentUncheckedUpdateManyWithoutSubjectInput>
  }

  export type ExamUpsertWithWhereUniqueWithoutSubjectInput = {
    where: ExamWhereUniqueInput
    update: XOR<ExamUpdateWithoutSubjectInput, ExamUncheckedUpdateWithoutSubjectInput>
    create: XOR<ExamCreateWithoutSubjectInput, ExamUncheckedCreateWithoutSubjectInput>
  }

  export type ExamUpdateWithWhereUniqueWithoutSubjectInput = {
    where: ExamWhereUniqueInput
    data: XOR<ExamUpdateWithoutSubjectInput, ExamUncheckedUpdateWithoutSubjectInput>
  }

  export type ExamUpdateManyWithWhereWithoutSubjectInput = {
    where: ExamScalarWhereInput
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyWithoutSubjectInput>
  }

  export type ExamResultUpsertWithWhereUniqueWithoutSubjectInput = {
    where: ExamResultWhereUniqueInput
    update: XOR<ExamResultUpdateWithoutSubjectInput, ExamResultUncheckedUpdateWithoutSubjectInput>
    create: XOR<ExamResultCreateWithoutSubjectInput, ExamResultUncheckedCreateWithoutSubjectInput>
  }

  export type ExamResultUpdateWithWhereUniqueWithoutSubjectInput = {
    where: ExamResultWhereUniqueInput
    data: XOR<ExamResultUpdateWithoutSubjectInput, ExamResultUncheckedUpdateWithoutSubjectInput>
  }

  export type ExamResultUpdateManyWithWhereWithoutSubjectInput = {
    where: ExamResultScalarWhereInput
    data: XOR<ExamResultUpdateManyMutationInput, ExamResultUncheckedUpdateManyWithoutSubjectInput>
  }

  export type ExamResultScalarWhereInput = {
    AND?: ExamResultScalarWhereInput | ExamResultScalarWhereInput[]
    OR?: ExamResultScalarWhereInput[]
    NOT?: ExamResultScalarWhereInput | ExamResultScalarWhereInput[]
    id?: StringFilter<"ExamResult"> | string
    studentId?: StringFilter<"ExamResult"> | string
    examId?: StringFilter<"ExamResult"> | string
    subjectId?: StringNullableFilter<"ExamResult"> | string | null
    maxMarks?: FloatFilter<"ExamResult"> | number
    obtainedMarks?: FloatNullableFilter<"ExamResult"> | number | null
    percentage?: FloatNullableFilter<"ExamResult"> | number | null
    gradeLabel?: StringNullableFilter<"ExamResult"> | string | null
    remarks?: StringNullableFilter<"ExamResult"> | string | null
    isPassed?: BoolNullableFilter<"ExamResult"> | boolean | null
    isAbsent?: BoolFilter<"ExamResult"> | boolean
    isResultsPublished?: BoolFilter<"ExamResult"> | boolean
    createdAt?: DateTimeFilter<"ExamResult"> | Date | string
    updatedAt?: DateTimeFilter<"ExamResult"> | Date | string
  }

  export type TeacherCreateWithoutTeachingAssignmentInput = {
    id?: string
    employeeCode?: string | null
    employmentStatus?: $Enums.EmploymentStatus
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTeacherInput
    organization: OrganizationCreateNestedOneWithoutTeacherInput
    profile?: TeacherProfileCreateNestedOneWithoutTeacherInput
    Section?: SectionCreateNestedManyWithoutClassTeacherInput
  }

  export type TeacherUncheckedCreateWithoutTeachingAssignmentInput = {
    id?: string
    userId: string
    employeeCode?: string | null
    employmentStatus?: $Enums.EmploymentStatus
    isActive?: boolean
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: TeacherProfileUncheckedCreateNestedOneWithoutTeacherInput
    Section?: SectionUncheckedCreateNestedManyWithoutClassTeacherInput
  }

  export type TeacherCreateOrConnectWithoutTeachingAssignmentInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutTeachingAssignmentInput, TeacherUncheckedCreateWithoutTeachingAssignmentInput>
  }

  export type SubjectCreateWithoutTeachingAssignmentsInput = {
    id?: string
    name: string
    code: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutSubjectInput
    exam?: ExamCreateNestedManyWithoutSubjectInput
    examResult?: ExamResultCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutTeachingAssignmentsInput = {
    id?: string
    name: string
    code: string
    description: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    exam?: ExamUncheckedCreateNestedManyWithoutSubjectInput
    examResult?: ExamResultUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutTeachingAssignmentsInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutTeachingAssignmentsInput, SubjectUncheckedCreateWithoutTeachingAssignmentsInput>
  }

  export type GradeCreateWithoutTeachingAssignmentInput = {
    id?: string
    grade: string
    organization: OrganizationCreateNestedOneWithoutGradeInput
    students?: StudentCreateNestedManyWithoutGradeInput
    section?: SectionCreateNestedManyWithoutGradeInput
  }

  export type GradeUncheckedCreateWithoutTeachingAssignmentInput = {
    id?: string
    grade: string
    organizationId: string
    students?: StudentUncheckedCreateNestedManyWithoutGradeInput
    section?: SectionUncheckedCreateNestedManyWithoutGradeInput
  }

  export type GradeCreateOrConnectWithoutTeachingAssignmentInput = {
    where: GradeWhereUniqueInput
    create: XOR<GradeCreateWithoutTeachingAssignmentInput, GradeUncheckedCreateWithoutTeachingAssignmentInput>
  }

  export type SectionCreateWithoutTeachingAssignmentInput = {
    id?: string
    name: string
    grade: GradeCreateNestedOneWithoutSectionInput
    organization: OrganizationCreateNestedOneWithoutSectionInput
    classTeacher?: TeacherCreateNestedOneWithoutSectionInput
    students?: StudentCreateNestedManyWithoutSectionInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutTeachingAssignmentInput = {
    id?: string
    name: string
    gradeId: string
    organizationId: string
    classTeacherId?: string | null
    students?: StudentUncheckedCreateNestedManyWithoutSectionInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutTeachingAssignmentInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutTeachingAssignmentInput, SectionUncheckedCreateWithoutTeachingAssignmentInput>
  }

  export type OrganizationCreateWithoutTeachingAssignmentInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    notices?: NoticeCreateNestedManyWithoutOrganizationInput
    Student?: StudentCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentCreateNestedManyWithoutOrganizationInput
    Grade?: GradeCreateNestedManyWithoutOrganizationInput
    Section?: SectionCreateNestedManyWithoutOrganizationInput
    Fee?: FeeCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobCreateNestedManyWithoutOrganizationInput
    Exam?: ExamCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutTeachingAssignmentInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    notices?: NoticeUncheckedCreateNestedManyWithoutOrganizationInput
    Student?: StudentUncheckedCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutOrganizationInput
    Grade?: GradeUncheckedCreateNestedManyWithoutOrganizationInput
    Section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    Fee?: FeeUncheckedCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryUncheckedCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarUncheckedCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintUncheckedCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherUncheckedCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectUncheckedCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearUncheckedCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobUncheckedCreateNestedManyWithoutOrganizationInput
    Exam?: ExamUncheckedCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutTeachingAssignmentInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutTeachingAssignmentInput, OrganizationUncheckedCreateWithoutTeachingAssignmentInput>
  }

  export type AcademicYearCreateWithoutTeachingAssignmentInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    type?: $Enums.YearType
    isCurrent?: boolean
    description?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutAcademicYearInput
    complaints?: AnonymousComplaintCreateNestedManyWithoutAcademicYearInput
    notices?: NoticeCreateNestedManyWithoutAcademicYearInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutAcademicYearInput
    AcademicCalendar?: AcademicCalendarCreateNestedManyWithoutAcademicYearInput
    ExamSession?: ExamSessionCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearUncheckedCreateWithoutTeachingAssignmentInput = {
    id?: string
    organizationId: string
    name: string
    startDate: Date | string
    endDate: Date | string
    type?: $Enums.YearType
    isCurrent?: boolean
    description?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    complaints?: AnonymousComplaintUncheckedCreateNestedManyWithoutAcademicYearInput
    notices?: NoticeUncheckedCreateNestedManyWithoutAcademicYearInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutAcademicYearInput
    AcademicCalendar?: AcademicCalendarUncheckedCreateNestedManyWithoutAcademicYearInput
    ExamSession?: ExamSessionUncheckedCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearCreateOrConnectWithoutTeachingAssignmentInput = {
    where: AcademicYearWhereUniqueInput
    create: XOR<AcademicYearCreateWithoutTeachingAssignmentInput, AcademicYearUncheckedCreateWithoutTeachingAssignmentInput>
  }

  export type TeacherUpsertWithoutTeachingAssignmentInput = {
    update: XOR<TeacherUpdateWithoutTeachingAssignmentInput, TeacherUncheckedUpdateWithoutTeachingAssignmentInput>
    create: XOR<TeacherCreateWithoutTeachingAssignmentInput, TeacherUncheckedCreateWithoutTeachingAssignmentInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutTeachingAssignmentInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutTeachingAssignmentInput, TeacherUncheckedUpdateWithoutTeachingAssignmentInput>
  }

  export type TeacherUpdateWithoutTeachingAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutTeacherNestedInput
    profile?: TeacherProfileUpdateOneWithoutTeacherNestedInput
    Section?: SectionUpdateManyWithoutClassTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutTeachingAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: TeacherProfileUncheckedUpdateOneWithoutTeacherNestedInput
    Section?: SectionUncheckedUpdateManyWithoutClassTeacherNestedInput
  }

  export type SubjectUpsertWithoutTeachingAssignmentsInput = {
    update: XOR<SubjectUpdateWithoutTeachingAssignmentsInput, SubjectUncheckedUpdateWithoutTeachingAssignmentsInput>
    create: XOR<SubjectCreateWithoutTeachingAssignmentsInput, SubjectUncheckedCreateWithoutTeachingAssignmentsInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutTeachingAssignmentsInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutTeachingAssignmentsInput, SubjectUncheckedUpdateWithoutTeachingAssignmentsInput>
  }

  export type SubjectUpdateWithoutTeachingAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutSubjectNestedInput
    exam?: ExamUpdateManyWithoutSubjectNestedInput
    examResult?: ExamResultUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutTeachingAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exam?: ExamUncheckedUpdateManyWithoutSubjectNestedInput
    examResult?: ExamResultUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type GradeUpsertWithoutTeachingAssignmentInput = {
    update: XOR<GradeUpdateWithoutTeachingAssignmentInput, GradeUncheckedUpdateWithoutTeachingAssignmentInput>
    create: XOR<GradeCreateWithoutTeachingAssignmentInput, GradeUncheckedCreateWithoutTeachingAssignmentInput>
    where?: GradeWhereInput
  }

  export type GradeUpdateToOneWithWhereWithoutTeachingAssignmentInput = {
    where?: GradeWhereInput
    data: XOR<GradeUpdateWithoutTeachingAssignmentInput, GradeUncheckedUpdateWithoutTeachingAssignmentInput>
  }

  export type GradeUpdateWithoutTeachingAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    organization?: OrganizationUpdateOneRequiredWithoutGradeNestedInput
    students?: StudentUpdateManyWithoutGradeNestedInput
    section?: SectionUpdateManyWithoutGradeNestedInput
  }

  export type GradeUncheckedUpdateWithoutTeachingAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    students?: StudentUncheckedUpdateManyWithoutGradeNestedInput
    section?: SectionUncheckedUpdateManyWithoutGradeNestedInput
  }

  export type SectionUpsertWithoutTeachingAssignmentInput = {
    update: XOR<SectionUpdateWithoutTeachingAssignmentInput, SectionUncheckedUpdateWithoutTeachingAssignmentInput>
    create: XOR<SectionCreateWithoutTeachingAssignmentInput, SectionUncheckedCreateWithoutTeachingAssignmentInput>
    where?: SectionWhereInput
  }

  export type SectionUpdateToOneWithWhereWithoutTeachingAssignmentInput = {
    where?: SectionWhereInput
    data: XOR<SectionUpdateWithoutTeachingAssignmentInput, SectionUncheckedUpdateWithoutTeachingAssignmentInput>
  }

  export type SectionUpdateWithoutTeachingAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    grade?: GradeUpdateOneRequiredWithoutSectionNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutSectionNestedInput
    classTeacher?: TeacherUpdateOneWithoutSectionNestedInput
    students?: StudentUpdateManyWithoutSectionNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutTeachingAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    classTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    students?: StudentUncheckedUpdateManyWithoutSectionNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type OrganizationUpsertWithoutTeachingAssignmentInput = {
    update: XOR<OrganizationUpdateWithoutTeachingAssignmentInput, OrganizationUncheckedUpdateWithoutTeachingAssignmentInput>
    create: XOR<OrganizationCreateWithoutTeachingAssignmentInput, OrganizationUncheckedCreateWithoutTeachingAssignmentInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutTeachingAssignmentInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutTeachingAssignmentInput, OrganizationUncheckedUpdateWithoutTeachingAssignmentInput>
  }

  export type OrganizationUpdateWithoutTeachingAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutTeachingAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUncheckedUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUncheckedUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUncheckedUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUncheckedUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUncheckedUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUncheckedUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUncheckedUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUncheckedUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUncheckedUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type AcademicYearUpsertWithoutTeachingAssignmentInput = {
    update: XOR<AcademicYearUpdateWithoutTeachingAssignmentInput, AcademicYearUncheckedUpdateWithoutTeachingAssignmentInput>
    create: XOR<AcademicYearCreateWithoutTeachingAssignmentInput, AcademicYearUncheckedCreateWithoutTeachingAssignmentInput>
    where?: AcademicYearWhereInput
  }

  export type AcademicYearUpdateToOneWithWhereWithoutTeachingAssignmentInput = {
    where?: AcademicYearWhereInput
    data: XOR<AcademicYearUpdateWithoutTeachingAssignmentInput, AcademicYearUncheckedUpdateWithoutTeachingAssignmentInput>
  }

  export type AcademicYearUpdateWithoutTeachingAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumYearTypeFieldUpdateOperationsInput | $Enums.YearType
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutAcademicYearNestedInput
    complaints?: AnonymousComplaintUpdateManyWithoutAcademicYearNestedInput
    notices?: NoticeUpdateManyWithoutAcademicYearNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutAcademicYearNestedInput
    AcademicCalendar?: AcademicCalendarUpdateManyWithoutAcademicYearNestedInput
    ExamSession?: ExamSessionUpdateManyWithoutAcademicYearNestedInput
  }

  export type AcademicYearUncheckedUpdateWithoutTeachingAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumYearTypeFieldUpdateOperationsInput | $Enums.YearType
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    complaints?: AnonymousComplaintUncheckedUpdateManyWithoutAcademicYearNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutAcademicYearNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutAcademicYearNestedInput
    AcademicCalendar?: AcademicCalendarUncheckedUpdateManyWithoutAcademicYearNestedInput
    ExamSession?: ExamSessionUncheckedUpdateManyWithoutAcademicYearNestedInput
  }

  export type UserCreateWithoutStudentInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password?: string | null
    profileImage: string
    role?: $Enums.Role
    clerkId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    parent?: ParentCreateNestedOneWithoutUserInput
    FeePayment?: FeePaymentCreateNestedManyWithoutPayerInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStudentInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password?: string | null
    profileImage: string
    role?: $Enums.Role
    clerkId: string
    isActive?: boolean
    organizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    parent?: ParentUncheckedCreateNestedOneWithoutUserInput
    FeePayment?: FeePaymentUncheckedCreateNestedManyWithoutPayerInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStudentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
  }

  export type SectionCreateWithoutStudentsInput = {
    id?: string
    name: string
    grade: GradeCreateNestedOneWithoutSectionInput
    organization: OrganizationCreateNestedOneWithoutSectionInput
    classTeacher?: TeacherCreateNestedOneWithoutSectionInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutSectionInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutStudentsInput = {
    id?: string
    name: string
    gradeId: string
    organizationId: string
    classTeacherId?: string | null
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutSectionInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutStudentsInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutStudentsInput, SectionUncheckedCreateWithoutStudentsInput>
  }

  export type GradeCreateWithoutStudentsInput = {
    id?: string
    grade: string
    organization: OrganizationCreateNestedOneWithoutGradeInput
    section?: SectionCreateNestedManyWithoutGradeInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutGradeInput
  }

  export type GradeUncheckedCreateWithoutStudentsInput = {
    id?: string
    grade: string
    organizationId: string
    section?: SectionUncheckedCreateNestedManyWithoutGradeInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutGradeInput
  }

  export type GradeCreateOrConnectWithoutStudentsInput = {
    where: GradeWhereUniqueInput
    create: XOR<GradeCreateWithoutStudentsInput, GradeUncheckedCreateWithoutStudentsInput>
  }

  export type OrganizationCreateWithoutStudentInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    notices?: NoticeCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentCreateNestedManyWithoutOrganizationInput
    Grade?: GradeCreateNestedManyWithoutOrganizationInput
    Section?: SectionCreateNestedManyWithoutOrganizationInput
    Fee?: FeeCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobCreateNestedManyWithoutOrganizationInput
    Exam?: ExamCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutStudentInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    notices?: NoticeUncheckedCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutOrganizationInput
    Grade?: GradeUncheckedCreateNestedManyWithoutOrganizationInput
    Section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    Fee?: FeeUncheckedCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryUncheckedCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarUncheckedCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintUncheckedCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherUncheckedCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectUncheckedCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearUncheckedCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobUncheckedCreateNestedManyWithoutOrganizationInput
    Exam?: ExamUncheckedCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutStudentInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutStudentInput, OrganizationUncheckedCreateWithoutStudentInput>
  }

  export type FeeCreateWithoutStudentInput = {
    id?: string
    totalFee: number
    paidAmount?: number
    pendingAmount?: number | null
    dueDate: Date | string
    status?: $Enums.FeeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    feeCategory: FeeCategoryCreateNestedOneWithoutFeesInput
    Organization: OrganizationCreateNestedOneWithoutFeeInput
    payments?: FeePaymentCreateNestedManyWithoutFeeInput
  }

  export type FeeUncheckedCreateWithoutStudentInput = {
    id?: string
    totalFee: number
    paidAmount?: number
    pendingAmount?: number | null
    dueDate: Date | string
    status?: $Enums.FeeStatus
    feeCategoryId: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: FeePaymentUncheckedCreateNestedManyWithoutFeeInput
  }

  export type FeeCreateOrConnectWithoutStudentInput = {
    where: FeeWhereUniqueInput
    create: XOR<FeeCreateWithoutStudentInput, FeeUncheckedCreateWithoutStudentInput>
  }

  export type FeeCreateManyStudentInputEnvelope = {
    data: FeeCreateManyStudentInput | FeeCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type ParentStudentCreateWithoutStudentInput = {
    id?: string
    relationship: string
    isPrimary?: boolean | null
    parent: ParentCreateNestedOneWithoutStudentsInput
  }

  export type ParentStudentUncheckedCreateWithoutStudentInput = {
    id?: string
    relationship: string
    parentId: string
    isPrimary?: boolean | null
  }

  export type ParentStudentCreateOrConnectWithoutStudentInput = {
    where: ParentStudentWhereUniqueInput
    create: XOR<ParentStudentCreateWithoutStudentInput, ParentStudentUncheckedCreateWithoutStudentInput>
  }

  export type ParentStudentCreateManyStudentInputEnvelope = {
    data: ParentStudentCreateManyStudentInput | ParentStudentCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentAttendanceCreateWithoutStudentInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    note?: string | null
    recordedBy: string
    present?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    section: SectionCreateNestedOneWithoutStudentAttendanceInput
    academicYear?: AcademicYearCreateNestedOneWithoutStudentAttendanceInput
  }

  export type StudentAttendanceUncheckedCreateWithoutStudentInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    note?: string | null
    recordedBy: string
    present?: boolean
    sectionId: string
    academicYearId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAttendanceCreateOrConnectWithoutStudentInput = {
    where: StudentAttendanceWhereUniqueInput
    create: XOR<StudentAttendanceCreateWithoutStudentInput, StudentAttendanceUncheckedCreateWithoutStudentInput>
  }

  export type StudentAttendanceCreateManyStudentInputEnvelope = {
    data: StudentAttendanceCreateManyStudentInput | StudentAttendanceCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentDocumentCreateWithoutStudentInput = {
    id?: string
    type: $Enums.DocumentType
    fileName?: string | null
    fileSize?: number | null
    fileType?: string | null
    documentUrl: string
    verified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    rejected?: boolean
    rejectedBy?: string | null
    rejectedAt?: Date | string | null
    rejectReason?: string | null
    uploadedBy?: string | null
    uploadedAt?: Date | string
    note?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Organization?: OrganizationCreateNestedOneWithoutStudentDocumentInput
  }

  export type StudentDocumentUncheckedCreateWithoutStudentInput = {
    id?: string
    type: $Enums.DocumentType
    fileName?: string | null
    fileSize?: number | null
    fileType?: string | null
    documentUrl: string
    verified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    rejected?: boolean
    rejectedBy?: string | null
    rejectedAt?: Date | string | null
    rejectReason?: string | null
    uploadedBy?: string | null
    uploadedAt?: Date | string
    note?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId: string
  }

  export type StudentDocumentCreateOrConnectWithoutStudentInput = {
    where: StudentDocumentWhereUniqueInput
    create: XOR<StudentDocumentCreateWithoutStudentInput, StudentDocumentUncheckedCreateWithoutStudentInput>
  }

  export type StudentDocumentCreateManyStudentInputEnvelope = {
    data: StudentDocumentCreateManyStudentInput | StudentDocumentCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type NotificationLogCreateWithoutStudentInput = {
    id?: string
    channel: $Enums.NotificationChannel
    status?: $Enums.NotificationStatus
    notificationType: $Enums.NotificationType
    units?: number
    cost?: number
    sentAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutNotificationLogInput
    user?: UserCreateNestedOneWithoutNotificationLogInput
    parent?: ParentCreateNestedOneWithoutNotificationLogInput
  }

  export type NotificationLogUncheckedCreateWithoutStudentInput = {
    id?: string
    organizationId: string
    userId?: string | null
    parentId?: string | null
    channel: $Enums.NotificationChannel
    status?: $Enums.NotificationStatus
    notificationType: $Enums.NotificationType
    units?: number
    cost?: number
    sentAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationLogCreateOrConnectWithoutStudentInput = {
    where: NotificationLogWhereUniqueInput
    create: XOR<NotificationLogCreateWithoutStudentInput, NotificationLogUncheckedCreateWithoutStudentInput>
  }

  export type NotificationLogCreateManyStudentInputEnvelope = {
    data: NotificationLogCreateManyStudentInput | NotificationLogCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type ReportCardCreateWithoutStudentInput = {
    id?: string
    totalMaxMarks: number
    totalObtained: number
    percentage: number
    cgpa?: number | null
    overallGrade: string
    resultStatus: $Enums.ResultStatus
    classRank?: number | null
    gradeRank?: number | null
    attendancePercent?: number | null
    conductGrade?: string | null
    remarks?: string | null
    principalRemarks?: string | null
    rank?: number | null
    pdfUrl?: string | null
    generatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examSession: ExamSessionCreateNestedOneWithoutReportCardsInput
  }

  export type ReportCardUncheckedCreateWithoutStudentInput = {
    id?: string
    examSessionId: string
    totalMaxMarks: number
    totalObtained: number
    percentage: number
    cgpa?: number | null
    overallGrade: string
    resultStatus: $Enums.ResultStatus
    classRank?: number | null
    gradeRank?: number | null
    attendancePercent?: number | null
    conductGrade?: string | null
    remarks?: string | null
    principalRemarks?: string | null
    rank?: number | null
    pdfUrl?: string | null
    generatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCardCreateOrConnectWithoutStudentInput = {
    where: ReportCardWhereUniqueInput
    create: XOR<ReportCardCreateWithoutStudentInput, ReportCardUncheckedCreateWithoutStudentInput>
  }

  export type ReportCardCreateManyStudentInputEnvelope = {
    data: ReportCardCreateManyStudentInput | ReportCardCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type HallTicketCreateWithoutStudentInput = {
    id?: string
    pdfUrl: string
    qrCode?: string | null
    generatedAt?: Date | string
    downloadedAt?: Date | string | null
    expiryDate?: Date | string | null
    exam?: ExamCreateNestedOneWithoutHallTicketsInput
    examSession?: ExamSessionCreateNestedOneWithoutHallTicketsInput
    organization: OrganizationCreateNestedOneWithoutHallTicketInput
  }

  export type HallTicketUncheckedCreateWithoutStudentInput = {
    id?: string
    examId?: string | null
    examSessionId?: string | null
    pdfUrl: string
    qrCode?: string | null
    generatedAt?: Date | string
    downloadedAt?: Date | string | null
    expiryDate?: Date | string | null
    organizationId: string
  }

  export type HallTicketCreateOrConnectWithoutStudentInput = {
    where: HallTicketWhereUniqueInput
    create: XOR<HallTicketCreateWithoutStudentInput, HallTicketUncheckedCreateWithoutStudentInput>
  }

  export type HallTicketCreateManyStudentInputEnvelope = {
    data: HallTicketCreateManyStudentInput | HallTicketCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type ExamResultCreateWithoutStudentInput = {
    id?: string
    maxMarks: number
    obtainedMarks?: number | null
    percentage?: number | null
    gradeLabel?: string | null
    remarks?: string | null
    isPassed?: boolean | null
    isAbsent?: boolean
    isResultsPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    exam: ExamCreateNestedOneWithoutExamResultInput
    subject?: SubjectCreateNestedOneWithoutExamResultInput
  }

  export type ExamResultUncheckedCreateWithoutStudentInput = {
    id?: string
    examId: string
    subjectId?: string | null
    maxMarks: number
    obtainedMarks?: number | null
    percentage?: number | null
    gradeLabel?: string | null
    remarks?: string | null
    isPassed?: boolean | null
    isAbsent?: boolean
    isResultsPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamResultCreateOrConnectWithoutStudentInput = {
    where: ExamResultWhereUniqueInput
    create: XOR<ExamResultCreateWithoutStudentInput, ExamResultUncheckedCreateWithoutStudentInput>
  }

  export type ExamResultCreateManyStudentInputEnvelope = {
    data: ExamResultCreateManyStudentInput | ExamResultCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type ExamEnrollmentCreateWithoutStudentInput = {
    id?: string
    status?: $Enums.StudentExamStatus
    enrolledAt?: Date | string
    exemptionReason?: string | null
    exam: ExamCreateNestedOneWithoutExamEnrollmentInput
  }

  export type ExamEnrollmentUncheckedCreateWithoutStudentInput = {
    id?: string
    examId: string
    status?: $Enums.StudentExamStatus
    enrolledAt?: Date | string
    exemptionReason?: string | null
  }

  export type ExamEnrollmentCreateOrConnectWithoutStudentInput = {
    where: ExamEnrollmentWhereUniqueInput
    create: XOR<ExamEnrollmentCreateWithoutStudentInput, ExamEnrollmentUncheckedCreateWithoutStudentInput>
  }

  export type ExamEnrollmentCreateManyStudentInputEnvelope = {
    data: ExamEnrollmentCreateManyStudentInput | ExamEnrollmentCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutStudentInput = {
    update: XOR<UserUpdateWithoutStudentInput, UserUncheckedUpdateWithoutStudentInput>
    create: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudentInput, UserUncheckedUpdateWithoutStudentInput>
  }

  export type UserUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    clerkId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    parent?: ParentUpdateOneWithoutUserNestedInput
    FeePayment?: FeePaymentUpdateManyWithoutPayerNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    clerkId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    parent?: ParentUncheckedUpdateOneWithoutUserNestedInput
    FeePayment?: FeePaymentUncheckedUpdateManyWithoutPayerNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SectionUpsertWithoutStudentsInput = {
    update: XOR<SectionUpdateWithoutStudentsInput, SectionUncheckedUpdateWithoutStudentsInput>
    create: XOR<SectionCreateWithoutStudentsInput, SectionUncheckedCreateWithoutStudentsInput>
    where?: SectionWhereInput
  }

  export type SectionUpdateToOneWithWhereWithoutStudentsInput = {
    where?: SectionWhereInput
    data: XOR<SectionUpdateWithoutStudentsInput, SectionUncheckedUpdateWithoutStudentsInput>
  }

  export type SectionUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    grade?: GradeUpdateOneRequiredWithoutSectionNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutSectionNestedInput
    classTeacher?: TeacherUpdateOneWithoutSectionNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutSectionNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    classTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutSectionNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type GradeUpsertWithoutStudentsInput = {
    update: XOR<GradeUpdateWithoutStudentsInput, GradeUncheckedUpdateWithoutStudentsInput>
    create: XOR<GradeCreateWithoutStudentsInput, GradeUncheckedCreateWithoutStudentsInput>
    where?: GradeWhereInput
  }

  export type GradeUpdateToOneWithWhereWithoutStudentsInput = {
    where?: GradeWhereInput
    data: XOR<GradeUpdateWithoutStudentsInput, GradeUncheckedUpdateWithoutStudentsInput>
  }

  export type GradeUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    organization?: OrganizationUpdateOneRequiredWithoutGradeNestedInput
    section?: SectionUpdateManyWithoutGradeNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutGradeNestedInput
  }

  export type GradeUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    section?: SectionUncheckedUpdateManyWithoutGradeNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutGradeNestedInput
  }

  export type OrganizationUpsertWithoutStudentInput = {
    update: XOR<OrganizationUpdateWithoutStudentInput, OrganizationUncheckedUpdateWithoutStudentInput>
    create: XOR<OrganizationCreateWithoutStudentInput, OrganizationUncheckedCreateWithoutStudentInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutStudentInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutStudentInput, OrganizationUncheckedUpdateWithoutStudentInput>
  }

  export type OrganizationUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUncheckedUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUncheckedUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUncheckedUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUncheckedUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUncheckedUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUncheckedUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUncheckedUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUncheckedUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type FeeUpsertWithWhereUniqueWithoutStudentInput = {
    where: FeeWhereUniqueInput
    update: XOR<FeeUpdateWithoutStudentInput, FeeUncheckedUpdateWithoutStudentInput>
    create: XOR<FeeCreateWithoutStudentInput, FeeUncheckedCreateWithoutStudentInput>
  }

  export type FeeUpdateWithWhereUniqueWithoutStudentInput = {
    where: FeeWhereUniqueInput
    data: XOR<FeeUpdateWithoutStudentInput, FeeUncheckedUpdateWithoutStudentInput>
  }

  export type FeeUpdateManyWithWhereWithoutStudentInput = {
    where: FeeScalarWhereInput
    data: XOR<FeeUpdateManyMutationInput, FeeUncheckedUpdateManyWithoutStudentInput>
  }

  export type ParentStudentUpsertWithWhereUniqueWithoutStudentInput = {
    where: ParentStudentWhereUniqueInput
    update: XOR<ParentStudentUpdateWithoutStudentInput, ParentStudentUncheckedUpdateWithoutStudentInput>
    create: XOR<ParentStudentCreateWithoutStudentInput, ParentStudentUncheckedCreateWithoutStudentInput>
  }

  export type ParentStudentUpdateWithWhereUniqueWithoutStudentInput = {
    where: ParentStudentWhereUniqueInput
    data: XOR<ParentStudentUpdateWithoutStudentInput, ParentStudentUncheckedUpdateWithoutStudentInput>
  }

  export type ParentStudentUpdateManyWithWhereWithoutStudentInput = {
    where: ParentStudentScalarWhereInput
    data: XOR<ParentStudentUpdateManyMutationInput, ParentStudentUncheckedUpdateManyWithoutStudentInput>
  }

  export type ParentStudentScalarWhereInput = {
    AND?: ParentStudentScalarWhereInput | ParentStudentScalarWhereInput[]
    OR?: ParentStudentScalarWhereInput[]
    NOT?: ParentStudentScalarWhereInput | ParentStudentScalarWhereInput[]
    id?: StringFilter<"ParentStudent"> | string
    relationship?: StringFilter<"ParentStudent"> | string
    studentId?: StringFilter<"ParentStudent"> | string
    parentId?: StringFilter<"ParentStudent"> | string
    isPrimary?: BoolNullableFilter<"ParentStudent"> | boolean | null
  }

  export type StudentAttendanceUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentAttendanceWhereUniqueInput
    update: XOR<StudentAttendanceUpdateWithoutStudentInput, StudentAttendanceUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentAttendanceCreateWithoutStudentInput, StudentAttendanceUncheckedCreateWithoutStudentInput>
  }

  export type StudentAttendanceUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentAttendanceWhereUniqueInput
    data: XOR<StudentAttendanceUpdateWithoutStudentInput, StudentAttendanceUncheckedUpdateWithoutStudentInput>
  }

  export type StudentAttendanceUpdateManyWithWhereWithoutStudentInput = {
    where: StudentAttendanceScalarWhereInput
    data: XOR<StudentAttendanceUpdateManyMutationInput, StudentAttendanceUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentDocumentUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentDocumentWhereUniqueInput
    update: XOR<StudentDocumentUpdateWithoutStudentInput, StudentDocumentUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentDocumentCreateWithoutStudentInput, StudentDocumentUncheckedCreateWithoutStudentInput>
  }

  export type StudentDocumentUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentDocumentWhereUniqueInput
    data: XOR<StudentDocumentUpdateWithoutStudentInput, StudentDocumentUncheckedUpdateWithoutStudentInput>
  }

  export type StudentDocumentUpdateManyWithWhereWithoutStudentInput = {
    where: StudentDocumentScalarWhereInput
    data: XOR<StudentDocumentUpdateManyMutationInput, StudentDocumentUncheckedUpdateManyWithoutStudentInput>
  }

  export type NotificationLogUpsertWithWhereUniqueWithoutStudentInput = {
    where: NotificationLogWhereUniqueInput
    update: XOR<NotificationLogUpdateWithoutStudentInput, NotificationLogUncheckedUpdateWithoutStudentInput>
    create: XOR<NotificationLogCreateWithoutStudentInput, NotificationLogUncheckedCreateWithoutStudentInput>
  }

  export type NotificationLogUpdateWithWhereUniqueWithoutStudentInput = {
    where: NotificationLogWhereUniqueInput
    data: XOR<NotificationLogUpdateWithoutStudentInput, NotificationLogUncheckedUpdateWithoutStudentInput>
  }

  export type NotificationLogUpdateManyWithWhereWithoutStudentInput = {
    where: NotificationLogScalarWhereInput
    data: XOR<NotificationLogUpdateManyMutationInput, NotificationLogUncheckedUpdateManyWithoutStudentInput>
  }

  export type ReportCardUpsertWithWhereUniqueWithoutStudentInput = {
    where: ReportCardWhereUniqueInput
    update: XOR<ReportCardUpdateWithoutStudentInput, ReportCardUncheckedUpdateWithoutStudentInput>
    create: XOR<ReportCardCreateWithoutStudentInput, ReportCardUncheckedCreateWithoutStudentInput>
  }

  export type ReportCardUpdateWithWhereUniqueWithoutStudentInput = {
    where: ReportCardWhereUniqueInput
    data: XOR<ReportCardUpdateWithoutStudentInput, ReportCardUncheckedUpdateWithoutStudentInput>
  }

  export type ReportCardUpdateManyWithWhereWithoutStudentInput = {
    where: ReportCardScalarWhereInput
    data: XOR<ReportCardUpdateManyMutationInput, ReportCardUncheckedUpdateManyWithoutStudentInput>
  }

  export type ReportCardScalarWhereInput = {
    AND?: ReportCardScalarWhereInput | ReportCardScalarWhereInput[]
    OR?: ReportCardScalarWhereInput[]
    NOT?: ReportCardScalarWhereInput | ReportCardScalarWhereInput[]
    id?: StringFilter<"ReportCard"> | string
    studentId?: StringFilter<"ReportCard"> | string
    examSessionId?: StringFilter<"ReportCard"> | string
    totalMaxMarks?: FloatFilter<"ReportCard"> | number
    totalObtained?: FloatFilter<"ReportCard"> | number
    percentage?: FloatFilter<"ReportCard"> | number
    cgpa?: FloatNullableFilter<"ReportCard"> | number | null
    overallGrade?: StringFilter<"ReportCard"> | string
    resultStatus?: EnumResultStatusFilter<"ReportCard"> | $Enums.ResultStatus
    classRank?: IntNullableFilter<"ReportCard"> | number | null
    gradeRank?: IntNullableFilter<"ReportCard"> | number | null
    attendancePercent?: FloatNullableFilter<"ReportCard"> | number | null
    conductGrade?: StringNullableFilter<"ReportCard"> | string | null
    remarks?: StringNullableFilter<"ReportCard"> | string | null
    principalRemarks?: StringNullableFilter<"ReportCard"> | string | null
    rank?: IntNullableFilter<"ReportCard"> | number | null
    pdfUrl?: StringNullableFilter<"ReportCard"> | string | null
    generatedAt?: DateTimeNullableFilter<"ReportCard"> | Date | string | null
    createdAt?: DateTimeFilter<"ReportCard"> | Date | string
    updatedAt?: DateTimeFilter<"ReportCard"> | Date | string
  }

  export type HallTicketUpsertWithWhereUniqueWithoutStudentInput = {
    where: HallTicketWhereUniqueInput
    update: XOR<HallTicketUpdateWithoutStudentInput, HallTicketUncheckedUpdateWithoutStudentInput>
    create: XOR<HallTicketCreateWithoutStudentInput, HallTicketUncheckedCreateWithoutStudentInput>
  }

  export type HallTicketUpdateWithWhereUniqueWithoutStudentInput = {
    where: HallTicketWhereUniqueInput
    data: XOR<HallTicketUpdateWithoutStudentInput, HallTicketUncheckedUpdateWithoutStudentInput>
  }

  export type HallTicketUpdateManyWithWhereWithoutStudentInput = {
    where: HallTicketScalarWhereInput
    data: XOR<HallTicketUpdateManyMutationInput, HallTicketUncheckedUpdateManyWithoutStudentInput>
  }

  export type ExamResultUpsertWithWhereUniqueWithoutStudentInput = {
    where: ExamResultWhereUniqueInput
    update: XOR<ExamResultUpdateWithoutStudentInput, ExamResultUncheckedUpdateWithoutStudentInput>
    create: XOR<ExamResultCreateWithoutStudentInput, ExamResultUncheckedCreateWithoutStudentInput>
  }

  export type ExamResultUpdateWithWhereUniqueWithoutStudentInput = {
    where: ExamResultWhereUniqueInput
    data: XOR<ExamResultUpdateWithoutStudentInput, ExamResultUncheckedUpdateWithoutStudentInput>
  }

  export type ExamResultUpdateManyWithWhereWithoutStudentInput = {
    where: ExamResultScalarWhereInput
    data: XOR<ExamResultUpdateManyMutationInput, ExamResultUncheckedUpdateManyWithoutStudentInput>
  }

  export type ExamEnrollmentUpsertWithWhereUniqueWithoutStudentInput = {
    where: ExamEnrollmentWhereUniqueInput
    update: XOR<ExamEnrollmentUpdateWithoutStudentInput, ExamEnrollmentUncheckedUpdateWithoutStudentInput>
    create: XOR<ExamEnrollmentCreateWithoutStudentInput, ExamEnrollmentUncheckedCreateWithoutStudentInput>
  }

  export type ExamEnrollmentUpdateWithWhereUniqueWithoutStudentInput = {
    where: ExamEnrollmentWhereUniqueInput
    data: XOR<ExamEnrollmentUpdateWithoutStudentInput, ExamEnrollmentUncheckedUpdateWithoutStudentInput>
  }

  export type ExamEnrollmentUpdateManyWithWhereWithoutStudentInput = {
    where: ExamEnrollmentScalarWhereInput
    data: XOR<ExamEnrollmentUpdateManyMutationInput, ExamEnrollmentUncheckedUpdateManyWithoutStudentInput>
  }

  export type ExamEnrollmentScalarWhereInput = {
    AND?: ExamEnrollmentScalarWhereInput | ExamEnrollmentScalarWhereInput[]
    OR?: ExamEnrollmentScalarWhereInput[]
    NOT?: ExamEnrollmentScalarWhereInput | ExamEnrollmentScalarWhereInput[]
    id?: StringFilter<"ExamEnrollment"> | string
    studentId?: StringFilter<"ExamEnrollment"> | string
    examId?: StringFilter<"ExamEnrollment"> | string
    status?: EnumStudentExamStatusFilter<"ExamEnrollment"> | $Enums.StudentExamStatus
    enrolledAt?: DateTimeFilter<"ExamEnrollment"> | Date | string
    exemptionReason?: StringNullableFilter<"ExamEnrollment"> | string | null
  }

  export type UserCreateWithoutParentInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password?: string | null
    profileImage: string
    role?: $Enums.Role
    clerkId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    FeePayment?: FeePaymentCreateNestedManyWithoutPayerInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutParentInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password?: string | null
    profileImage: string
    role?: $Enums.Role
    clerkId: string
    isActive?: boolean
    organizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    FeePayment?: FeePaymentUncheckedCreateNestedManyWithoutPayerInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutParentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutParentInput, UserUncheckedCreateWithoutParentInput>
  }

  export type ParentStudentCreateWithoutParentInput = {
    id?: string
    relationship: string
    isPrimary?: boolean | null
    student: StudentCreateNestedOneWithoutParentsInput
  }

  export type ParentStudentUncheckedCreateWithoutParentInput = {
    id?: string
    relationship: string
    studentId: string
    isPrimary?: boolean | null
  }

  export type ParentStudentCreateOrConnectWithoutParentInput = {
    where: ParentStudentWhereUniqueInput
    create: XOR<ParentStudentCreateWithoutParentInput, ParentStudentUncheckedCreateWithoutParentInput>
  }

  export type ParentStudentCreateManyParentInputEnvelope = {
    data: ParentStudentCreateManyParentInput | ParentStudentCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type NotificationLogCreateWithoutParentInput = {
    id?: string
    channel: $Enums.NotificationChannel
    status?: $Enums.NotificationStatus
    notificationType: $Enums.NotificationType
    units?: number
    cost?: number
    sentAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutNotificationLogInput
    user?: UserCreateNestedOneWithoutNotificationLogInput
    student?: StudentCreateNestedOneWithoutNotificationLogInput
  }

  export type NotificationLogUncheckedCreateWithoutParentInput = {
    id?: string
    organizationId: string
    userId?: string | null
    studentId?: string | null
    channel: $Enums.NotificationChannel
    status?: $Enums.NotificationStatus
    notificationType: $Enums.NotificationType
    units?: number
    cost?: number
    sentAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationLogCreateOrConnectWithoutParentInput = {
    where: NotificationLogWhereUniqueInput
    create: XOR<NotificationLogCreateWithoutParentInput, NotificationLogUncheckedCreateWithoutParentInput>
  }

  export type NotificationLogCreateManyParentInputEnvelope = {
    data: NotificationLogCreateManyParentInput | NotificationLogCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutParentInput = {
    update: XOR<UserUpdateWithoutParentInput, UserUncheckedUpdateWithoutParentInput>
    create: XOR<UserCreateWithoutParentInput, UserUncheckedCreateWithoutParentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutParentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutParentInput, UserUncheckedUpdateWithoutParentInput>
  }

  export type UserUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    clerkId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    FeePayment?: FeePaymentUpdateManyWithoutPayerNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    clerkId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    FeePayment?: FeePaymentUncheckedUpdateManyWithoutPayerNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ParentStudentUpsertWithWhereUniqueWithoutParentInput = {
    where: ParentStudentWhereUniqueInput
    update: XOR<ParentStudentUpdateWithoutParentInput, ParentStudentUncheckedUpdateWithoutParentInput>
    create: XOR<ParentStudentCreateWithoutParentInput, ParentStudentUncheckedCreateWithoutParentInput>
  }

  export type ParentStudentUpdateWithWhereUniqueWithoutParentInput = {
    where: ParentStudentWhereUniqueInput
    data: XOR<ParentStudentUpdateWithoutParentInput, ParentStudentUncheckedUpdateWithoutParentInput>
  }

  export type ParentStudentUpdateManyWithWhereWithoutParentInput = {
    where: ParentStudentScalarWhereInput
    data: XOR<ParentStudentUpdateManyMutationInput, ParentStudentUncheckedUpdateManyWithoutParentInput>
  }

  export type NotificationLogUpsertWithWhereUniqueWithoutParentInput = {
    where: NotificationLogWhereUniqueInput
    update: XOR<NotificationLogUpdateWithoutParentInput, NotificationLogUncheckedUpdateWithoutParentInput>
    create: XOR<NotificationLogCreateWithoutParentInput, NotificationLogUncheckedCreateWithoutParentInput>
  }

  export type NotificationLogUpdateWithWhereUniqueWithoutParentInput = {
    where: NotificationLogWhereUniqueInput
    data: XOR<NotificationLogUpdateWithoutParentInput, NotificationLogUncheckedUpdateWithoutParentInput>
  }

  export type NotificationLogUpdateManyWithWhereWithoutParentInput = {
    where: NotificationLogScalarWhereInput
    data: XOR<NotificationLogUpdateManyMutationInput, NotificationLogUncheckedUpdateManyWithoutParentInput>
  }

  export type StudentCreateWithoutParentsInput = {
    id?: string
    firstName: string
    lastName: string
    middleName?: string | null
    motherName?: string | null
    fullName?: string | null
    dateOfBirth: Date | string
    profileImage?: string | null
    rollNumber: string
    phoneNumber: string
    whatsAppNumber: string
    email: string
    emergencyContact: string
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    section: SectionCreateNestedOneWithoutStudentsInput
    grade: GradeCreateNestedOneWithoutStudentsInput
    organization: OrganizationCreateNestedOneWithoutStudentInput
    Fee?: FeeCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutStudentInput
    StudentDocument?: StudentDocumentCreateNestedManyWithoutStudentInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutStudentInput
    reportCard?: ReportCardCreateNestedManyWithoutStudentInput
    hallTicket?: HallTicketCreateNestedManyWithoutStudentInput
    examResult?: ExamResultCreateNestedManyWithoutStudentInput
    examEnrollment?: ExamEnrollmentCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutParentsInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    middleName?: string | null
    motherName?: string | null
    fullName?: string | null
    dateOfBirth: Date | string
    profileImage?: string | null
    rollNumber: string
    phoneNumber: string
    whatsAppNumber: string
    email: string
    emergencyContact: string
    gender: $Enums.Gender
    sectionId: string
    gradeId: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Fee?: FeeUncheckedCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutStudentInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutStudentInput
    reportCard?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
    hallTicket?: HallTicketUncheckedCreateNestedManyWithoutStudentInput
    examResult?: ExamResultUncheckedCreateNestedManyWithoutStudentInput
    examEnrollment?: ExamEnrollmentUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutParentsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutParentsInput, StudentUncheckedCreateWithoutParentsInput>
  }

  export type ParentCreateWithoutStudentsInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phoneNumber: string
    whatsAppNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutParentInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutParentInput
  }

  export type ParentUncheckedCreateWithoutStudentsInput = {
    id?: string
    userId?: string | null
    firstName: string
    lastName: string
    email: string
    phoneNumber: string
    whatsAppNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutParentInput
  }

  export type ParentCreateOrConnectWithoutStudentsInput = {
    where: ParentWhereUniqueInput
    create: XOR<ParentCreateWithoutStudentsInput, ParentUncheckedCreateWithoutStudentsInput>
  }

  export type StudentUpsertWithoutParentsInput = {
    update: XOR<StudentUpdateWithoutParentsInput, StudentUncheckedUpdateWithoutParentsInput>
    create: XOR<StudentCreateWithoutParentsInput, StudentUncheckedCreateWithoutParentsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutParentsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutParentsInput, StudentUncheckedUpdateWithoutParentsInput>
  }

  export type StudentUpdateWithoutParentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emergencyContact?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    section?: SectionUpdateOneRequiredWithoutStudentsNestedInput
    grade?: GradeUpdateOneRequiredWithoutStudentsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutStudentNestedInput
    Fee?: FeeUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    StudentDocument?: StudentDocumentUpdateManyWithoutStudentNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutStudentNestedInput
    reportCard?: ReportCardUpdateManyWithoutStudentNestedInput
    hallTicket?: HallTicketUpdateManyWithoutStudentNestedInput
    examResult?: ExamResultUpdateManyWithoutStudentNestedInput
    examEnrollment?: ExamEnrollmentUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutParentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emergencyContact?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    sectionId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Fee?: FeeUncheckedUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutStudentNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutStudentNestedInput
    reportCard?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
    hallTicket?: HallTicketUncheckedUpdateManyWithoutStudentNestedInput
    examResult?: ExamResultUncheckedUpdateManyWithoutStudentNestedInput
    examEnrollment?: ExamEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ParentUpsertWithoutStudentsInput = {
    update: XOR<ParentUpdateWithoutStudentsInput, ParentUncheckedUpdateWithoutStudentsInput>
    create: XOR<ParentCreateWithoutStudentsInput, ParentUncheckedCreateWithoutStudentsInput>
    where?: ParentWhereInput
  }

  export type ParentUpdateToOneWithWhereWithoutStudentsInput = {
    where?: ParentWhereInput
    data: XOR<ParentUpdateWithoutStudentsInput, ParentUncheckedUpdateWithoutStudentsInput>
  }

  export type ParentUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutParentNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutParentNestedInput
  }

  export type ParentUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutParentNestedInput
  }

  export type SectionCreateWithoutStudentAttendanceInput = {
    id?: string
    name: string
    grade: GradeCreateNestedOneWithoutSectionInput
    organization: OrganizationCreateNestedOneWithoutSectionInput
    classTeacher?: TeacherCreateNestedOneWithoutSectionInput
    students?: StudentCreateNestedManyWithoutSectionInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutStudentAttendanceInput = {
    id?: string
    name: string
    gradeId: string
    organizationId: string
    classTeacherId?: string | null
    students?: StudentUncheckedCreateNestedManyWithoutSectionInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutStudentAttendanceInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutStudentAttendanceInput, SectionUncheckedCreateWithoutStudentAttendanceInput>
  }

  export type StudentCreateWithoutStudentAttendanceInput = {
    id?: string
    firstName: string
    lastName: string
    middleName?: string | null
    motherName?: string | null
    fullName?: string | null
    dateOfBirth: Date | string
    profileImage?: string | null
    rollNumber: string
    phoneNumber: string
    whatsAppNumber: string
    email: string
    emergencyContact: string
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    section: SectionCreateNestedOneWithoutStudentsInput
    grade: GradeCreateNestedOneWithoutStudentsInput
    organization: OrganizationCreateNestedOneWithoutStudentInput
    Fee?: FeeCreateNestedManyWithoutStudentInput
    parents?: ParentStudentCreateNestedManyWithoutStudentInput
    StudentDocument?: StudentDocumentCreateNestedManyWithoutStudentInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutStudentInput
    reportCard?: ReportCardCreateNestedManyWithoutStudentInput
    hallTicket?: HallTicketCreateNestedManyWithoutStudentInput
    examResult?: ExamResultCreateNestedManyWithoutStudentInput
    examEnrollment?: ExamEnrollmentCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentAttendanceInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    middleName?: string | null
    motherName?: string | null
    fullName?: string | null
    dateOfBirth: Date | string
    profileImage?: string | null
    rollNumber: string
    phoneNumber: string
    whatsAppNumber: string
    email: string
    emergencyContact: string
    gender: $Enums.Gender
    sectionId: string
    gradeId: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Fee?: FeeUncheckedCreateNestedManyWithoutStudentInput
    parents?: ParentStudentUncheckedCreateNestedManyWithoutStudentInput
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutStudentInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutStudentInput
    reportCard?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
    hallTicket?: HallTicketUncheckedCreateNestedManyWithoutStudentInput
    examResult?: ExamResultUncheckedCreateNestedManyWithoutStudentInput
    examEnrollment?: ExamEnrollmentUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentAttendanceInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentAttendanceInput, StudentUncheckedCreateWithoutStudentAttendanceInput>
  }

  export type AcademicYearCreateWithoutStudentAttendanceInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    type?: $Enums.YearType
    isCurrent?: boolean
    description?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutAcademicYearInput
    complaints?: AnonymousComplaintCreateNestedManyWithoutAcademicYearInput
    notices?: NoticeCreateNestedManyWithoutAcademicYearInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutAcademicYearInput
    AcademicCalendar?: AcademicCalendarCreateNestedManyWithoutAcademicYearInput
    ExamSession?: ExamSessionCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearUncheckedCreateWithoutStudentAttendanceInput = {
    id?: string
    organizationId: string
    name: string
    startDate: Date | string
    endDate: Date | string
    type?: $Enums.YearType
    isCurrent?: boolean
    description?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    complaints?: AnonymousComplaintUncheckedCreateNestedManyWithoutAcademicYearInput
    notices?: NoticeUncheckedCreateNestedManyWithoutAcademicYearInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutAcademicYearInput
    AcademicCalendar?: AcademicCalendarUncheckedCreateNestedManyWithoutAcademicYearInput
    ExamSession?: ExamSessionUncheckedCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearCreateOrConnectWithoutStudentAttendanceInput = {
    where: AcademicYearWhereUniqueInput
    create: XOR<AcademicYearCreateWithoutStudentAttendanceInput, AcademicYearUncheckedCreateWithoutStudentAttendanceInput>
  }

  export type SectionUpsertWithoutStudentAttendanceInput = {
    update: XOR<SectionUpdateWithoutStudentAttendanceInput, SectionUncheckedUpdateWithoutStudentAttendanceInput>
    create: XOR<SectionCreateWithoutStudentAttendanceInput, SectionUncheckedCreateWithoutStudentAttendanceInput>
    where?: SectionWhereInput
  }

  export type SectionUpdateToOneWithWhereWithoutStudentAttendanceInput = {
    where?: SectionWhereInput
    data: XOR<SectionUpdateWithoutStudentAttendanceInput, SectionUncheckedUpdateWithoutStudentAttendanceInput>
  }

  export type SectionUpdateWithoutStudentAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    grade?: GradeUpdateOneRequiredWithoutSectionNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutSectionNestedInput
    classTeacher?: TeacherUpdateOneWithoutSectionNestedInput
    students?: StudentUpdateManyWithoutSectionNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutStudentAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    classTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    students?: StudentUncheckedUpdateManyWithoutSectionNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type StudentUpsertWithoutStudentAttendanceInput = {
    update: XOR<StudentUpdateWithoutStudentAttendanceInput, StudentUncheckedUpdateWithoutStudentAttendanceInput>
    create: XOR<StudentCreateWithoutStudentAttendanceInput, StudentUncheckedCreateWithoutStudentAttendanceInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutStudentAttendanceInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutStudentAttendanceInput, StudentUncheckedUpdateWithoutStudentAttendanceInput>
  }

  export type StudentUpdateWithoutStudentAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emergencyContact?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    section?: SectionUpdateOneRequiredWithoutStudentsNestedInput
    grade?: GradeUpdateOneRequiredWithoutStudentsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutStudentNestedInput
    Fee?: FeeUpdateManyWithoutStudentNestedInput
    parents?: ParentStudentUpdateManyWithoutStudentNestedInput
    StudentDocument?: StudentDocumentUpdateManyWithoutStudentNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutStudentNestedInput
    reportCard?: ReportCardUpdateManyWithoutStudentNestedInput
    hallTicket?: HallTicketUpdateManyWithoutStudentNestedInput
    examResult?: ExamResultUpdateManyWithoutStudentNestedInput
    examEnrollment?: ExamEnrollmentUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutStudentAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emergencyContact?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    sectionId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Fee?: FeeUncheckedUpdateManyWithoutStudentNestedInput
    parents?: ParentStudentUncheckedUpdateManyWithoutStudentNestedInput
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutStudentNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutStudentNestedInput
    reportCard?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
    hallTicket?: HallTicketUncheckedUpdateManyWithoutStudentNestedInput
    examResult?: ExamResultUncheckedUpdateManyWithoutStudentNestedInput
    examEnrollment?: ExamEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type AcademicYearUpsertWithoutStudentAttendanceInput = {
    update: XOR<AcademicYearUpdateWithoutStudentAttendanceInput, AcademicYearUncheckedUpdateWithoutStudentAttendanceInput>
    create: XOR<AcademicYearCreateWithoutStudentAttendanceInput, AcademicYearUncheckedCreateWithoutStudentAttendanceInput>
    where?: AcademicYearWhereInput
  }

  export type AcademicYearUpdateToOneWithWhereWithoutStudentAttendanceInput = {
    where?: AcademicYearWhereInput
    data: XOR<AcademicYearUpdateWithoutStudentAttendanceInput, AcademicYearUncheckedUpdateWithoutStudentAttendanceInput>
  }

  export type AcademicYearUpdateWithoutStudentAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumYearTypeFieldUpdateOperationsInput | $Enums.YearType
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutAcademicYearNestedInput
    complaints?: AnonymousComplaintUpdateManyWithoutAcademicYearNestedInput
    notices?: NoticeUpdateManyWithoutAcademicYearNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutAcademicYearNestedInput
    AcademicCalendar?: AcademicCalendarUpdateManyWithoutAcademicYearNestedInput
    ExamSession?: ExamSessionUpdateManyWithoutAcademicYearNestedInput
  }

  export type AcademicYearUncheckedUpdateWithoutStudentAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumYearTypeFieldUpdateOperationsInput | $Enums.YearType
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    complaints?: AnonymousComplaintUncheckedUpdateManyWithoutAcademicYearNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutAcademicYearNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutAcademicYearNestedInput
    AcademicCalendar?: AcademicCalendarUncheckedUpdateManyWithoutAcademicYearNestedInput
    ExamSession?: ExamSessionUncheckedUpdateManyWithoutAcademicYearNestedInput
  }

  export type StudentCreateWithoutStudentDocumentInput = {
    id?: string
    firstName: string
    lastName: string
    middleName?: string | null
    motherName?: string | null
    fullName?: string | null
    dateOfBirth: Date | string
    profileImage?: string | null
    rollNumber: string
    phoneNumber: string
    whatsAppNumber: string
    email: string
    emergencyContact: string
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    section: SectionCreateNestedOneWithoutStudentsInput
    grade: GradeCreateNestedOneWithoutStudentsInput
    organization: OrganizationCreateNestedOneWithoutStudentInput
    Fee?: FeeCreateNestedManyWithoutStudentInput
    parents?: ParentStudentCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutStudentInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutStudentInput
    reportCard?: ReportCardCreateNestedManyWithoutStudentInput
    hallTicket?: HallTicketCreateNestedManyWithoutStudentInput
    examResult?: ExamResultCreateNestedManyWithoutStudentInput
    examEnrollment?: ExamEnrollmentCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentDocumentInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    middleName?: string | null
    motherName?: string | null
    fullName?: string | null
    dateOfBirth: Date | string
    profileImage?: string | null
    rollNumber: string
    phoneNumber: string
    whatsAppNumber: string
    email: string
    emergencyContact: string
    gender: $Enums.Gender
    sectionId: string
    gradeId: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Fee?: FeeUncheckedCreateNestedManyWithoutStudentInput
    parents?: ParentStudentUncheckedCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutStudentInput
    reportCard?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
    hallTicket?: HallTicketUncheckedCreateNestedManyWithoutStudentInput
    examResult?: ExamResultUncheckedCreateNestedManyWithoutStudentInput
    examEnrollment?: ExamEnrollmentUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentDocumentInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentDocumentInput, StudentUncheckedCreateWithoutStudentDocumentInput>
  }

  export type OrganizationCreateWithoutStudentDocumentInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    notices?: NoticeCreateNestedManyWithoutOrganizationInput
    Student?: StudentCreateNestedManyWithoutOrganizationInput
    Grade?: GradeCreateNestedManyWithoutOrganizationInput
    Section?: SectionCreateNestedManyWithoutOrganizationInput
    Fee?: FeeCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobCreateNestedManyWithoutOrganizationInput
    Exam?: ExamCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutStudentDocumentInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    notices?: NoticeUncheckedCreateNestedManyWithoutOrganizationInput
    Student?: StudentUncheckedCreateNestedManyWithoutOrganizationInput
    Grade?: GradeUncheckedCreateNestedManyWithoutOrganizationInput
    Section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    Fee?: FeeUncheckedCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryUncheckedCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarUncheckedCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintUncheckedCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherUncheckedCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectUncheckedCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearUncheckedCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobUncheckedCreateNestedManyWithoutOrganizationInput
    Exam?: ExamUncheckedCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutStudentDocumentInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutStudentDocumentInput, OrganizationUncheckedCreateWithoutStudentDocumentInput>
  }

  export type StudentUpsertWithoutStudentDocumentInput = {
    update: XOR<StudentUpdateWithoutStudentDocumentInput, StudentUncheckedUpdateWithoutStudentDocumentInput>
    create: XOR<StudentCreateWithoutStudentDocumentInput, StudentUncheckedCreateWithoutStudentDocumentInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutStudentDocumentInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutStudentDocumentInput, StudentUncheckedUpdateWithoutStudentDocumentInput>
  }

  export type StudentUpdateWithoutStudentDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emergencyContact?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    section?: SectionUpdateOneRequiredWithoutStudentsNestedInput
    grade?: GradeUpdateOneRequiredWithoutStudentsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutStudentNestedInput
    Fee?: FeeUpdateManyWithoutStudentNestedInput
    parents?: ParentStudentUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutStudentNestedInput
    reportCard?: ReportCardUpdateManyWithoutStudentNestedInput
    hallTicket?: HallTicketUpdateManyWithoutStudentNestedInput
    examResult?: ExamResultUpdateManyWithoutStudentNestedInput
    examEnrollment?: ExamEnrollmentUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutStudentDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emergencyContact?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    sectionId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Fee?: FeeUncheckedUpdateManyWithoutStudentNestedInput
    parents?: ParentStudentUncheckedUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutStudentNestedInput
    reportCard?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
    hallTicket?: HallTicketUncheckedUpdateManyWithoutStudentNestedInput
    examResult?: ExamResultUncheckedUpdateManyWithoutStudentNestedInput
    examEnrollment?: ExamEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type OrganizationUpsertWithoutStudentDocumentInput = {
    update: XOR<OrganizationUpdateWithoutStudentDocumentInput, OrganizationUncheckedUpdateWithoutStudentDocumentInput>
    create: XOR<OrganizationCreateWithoutStudentDocumentInput, OrganizationUncheckedCreateWithoutStudentDocumentInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutStudentDocumentInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutStudentDocumentInput, OrganizationUncheckedUpdateWithoutStudentDocumentInput>
  }

  export type OrganizationUpdateWithoutStudentDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutStudentDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUncheckedUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUncheckedUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUncheckedUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUncheckedUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUncheckedUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUncheckedUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUncheckedUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUncheckedUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUncheckedUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type StudentCreateWithoutFeeInput = {
    id?: string
    firstName: string
    lastName: string
    middleName?: string | null
    motherName?: string | null
    fullName?: string | null
    dateOfBirth: Date | string
    profileImage?: string | null
    rollNumber: string
    phoneNumber: string
    whatsAppNumber: string
    email: string
    emergencyContact: string
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    section: SectionCreateNestedOneWithoutStudentsInput
    grade: GradeCreateNestedOneWithoutStudentsInput
    organization: OrganizationCreateNestedOneWithoutStudentInput
    parents?: ParentStudentCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutStudentInput
    StudentDocument?: StudentDocumentCreateNestedManyWithoutStudentInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutStudentInput
    reportCard?: ReportCardCreateNestedManyWithoutStudentInput
    hallTicket?: HallTicketCreateNestedManyWithoutStudentInput
    examResult?: ExamResultCreateNestedManyWithoutStudentInput
    examEnrollment?: ExamEnrollmentCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutFeeInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    middleName?: string | null
    motherName?: string | null
    fullName?: string | null
    dateOfBirth: Date | string
    profileImage?: string | null
    rollNumber: string
    phoneNumber: string
    whatsAppNumber: string
    email: string
    emergencyContact: string
    gender: $Enums.Gender
    sectionId: string
    gradeId: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: ParentStudentUncheckedCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutStudentInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutStudentInput
    reportCard?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
    hallTicket?: HallTicketUncheckedCreateNestedManyWithoutStudentInput
    examResult?: ExamResultUncheckedCreateNestedManyWithoutStudentInput
    examEnrollment?: ExamEnrollmentUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutFeeInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutFeeInput, StudentUncheckedCreateWithoutFeeInput>
  }

  export type FeeCategoryCreateWithoutFeesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Organization: OrganizationCreateNestedOneWithoutFeeCategoryInput
  }

  export type FeeCategoryUncheckedCreateWithoutFeesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId: string
  }

  export type FeeCategoryCreateOrConnectWithoutFeesInput = {
    where: FeeCategoryWhereUniqueInput
    create: XOR<FeeCategoryCreateWithoutFeesInput, FeeCategoryUncheckedCreateWithoutFeesInput>
  }

  export type OrganizationCreateWithoutFeeInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    notices?: NoticeCreateNestedManyWithoutOrganizationInput
    Student?: StudentCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentCreateNestedManyWithoutOrganizationInput
    Grade?: GradeCreateNestedManyWithoutOrganizationInput
    Section?: SectionCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobCreateNestedManyWithoutOrganizationInput
    Exam?: ExamCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutFeeInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    notices?: NoticeUncheckedCreateNestedManyWithoutOrganizationInput
    Student?: StudentUncheckedCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutOrganizationInput
    Grade?: GradeUncheckedCreateNestedManyWithoutOrganizationInput
    Section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryUncheckedCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarUncheckedCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintUncheckedCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherUncheckedCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectUncheckedCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearUncheckedCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobUncheckedCreateNestedManyWithoutOrganizationInput
    Exam?: ExamUncheckedCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutFeeInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutFeeInput, OrganizationUncheckedCreateWithoutFeeInput>
  }

  export type FeePaymentCreateWithoutFeeInput = {
    id?: string
    amount: number
    status?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    receiptNumber: string
    note?: string | null
    transactionId?: string | null
    platformFee?: number | null
    recordedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payer: UserCreateNestedOneWithoutFeePaymentInput
    organization: OrganizationCreateNestedOneWithoutFeePaymentInput
  }

  export type FeePaymentUncheckedCreateWithoutFeeInput = {
    id?: string
    amount: number
    status?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    receiptNumber: string
    note?: string | null
    transactionId?: string | null
    payerId: string
    platformFee?: number | null
    recordedBy?: string | null
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeePaymentCreateOrConnectWithoutFeeInput = {
    where: FeePaymentWhereUniqueInput
    create: XOR<FeePaymentCreateWithoutFeeInput, FeePaymentUncheckedCreateWithoutFeeInput>
  }

  export type FeePaymentCreateManyFeeInputEnvelope = {
    data: FeePaymentCreateManyFeeInput | FeePaymentCreateManyFeeInput[]
    skipDuplicates?: boolean
  }

  export type StudentUpsertWithoutFeeInput = {
    update: XOR<StudentUpdateWithoutFeeInput, StudentUncheckedUpdateWithoutFeeInput>
    create: XOR<StudentCreateWithoutFeeInput, StudentUncheckedCreateWithoutFeeInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutFeeInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutFeeInput, StudentUncheckedUpdateWithoutFeeInput>
  }

  export type StudentUpdateWithoutFeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emergencyContact?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    section?: SectionUpdateOneRequiredWithoutStudentsNestedInput
    grade?: GradeUpdateOneRequiredWithoutStudentsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutStudentNestedInput
    parents?: ParentStudentUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    StudentDocument?: StudentDocumentUpdateManyWithoutStudentNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutStudentNestedInput
    reportCard?: ReportCardUpdateManyWithoutStudentNestedInput
    hallTicket?: HallTicketUpdateManyWithoutStudentNestedInput
    examResult?: ExamResultUpdateManyWithoutStudentNestedInput
    examEnrollment?: ExamEnrollmentUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutFeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emergencyContact?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    sectionId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: ParentStudentUncheckedUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutStudentNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutStudentNestedInput
    reportCard?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
    hallTicket?: HallTicketUncheckedUpdateManyWithoutStudentNestedInput
    examResult?: ExamResultUncheckedUpdateManyWithoutStudentNestedInput
    examEnrollment?: ExamEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type FeeCategoryUpsertWithoutFeesInput = {
    update: XOR<FeeCategoryUpdateWithoutFeesInput, FeeCategoryUncheckedUpdateWithoutFeesInput>
    create: XOR<FeeCategoryCreateWithoutFeesInput, FeeCategoryUncheckedCreateWithoutFeesInput>
    where?: FeeCategoryWhereInput
  }

  export type FeeCategoryUpdateToOneWithWhereWithoutFeesInput = {
    where?: FeeCategoryWhereInput
    data: XOR<FeeCategoryUpdateWithoutFeesInput, FeeCategoryUncheckedUpdateWithoutFeesInput>
  }

  export type FeeCategoryUpdateWithoutFeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Organization?: OrganizationUpdateOneRequiredWithoutFeeCategoryNestedInput
  }

  export type FeeCategoryUncheckedUpdateWithoutFeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type OrganizationUpsertWithoutFeeInput = {
    update: XOR<OrganizationUpdateWithoutFeeInput, OrganizationUncheckedUpdateWithoutFeeInput>
    create: XOR<OrganizationCreateWithoutFeeInput, OrganizationUncheckedCreateWithoutFeeInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutFeeInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutFeeInput, OrganizationUncheckedUpdateWithoutFeeInput>
  }

  export type OrganizationUpdateWithoutFeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutFeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUncheckedUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUncheckedUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUncheckedUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUncheckedUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUncheckedUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUncheckedUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUncheckedUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUncheckedUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type FeePaymentUpsertWithWhereUniqueWithoutFeeInput = {
    where: FeePaymentWhereUniqueInput
    update: XOR<FeePaymentUpdateWithoutFeeInput, FeePaymentUncheckedUpdateWithoutFeeInput>
    create: XOR<FeePaymentCreateWithoutFeeInput, FeePaymentUncheckedCreateWithoutFeeInput>
  }

  export type FeePaymentUpdateWithWhereUniqueWithoutFeeInput = {
    where: FeePaymentWhereUniqueInput
    data: XOR<FeePaymentUpdateWithoutFeeInput, FeePaymentUncheckedUpdateWithoutFeeInput>
  }

  export type FeePaymentUpdateManyWithWhereWithoutFeeInput = {
    where: FeePaymentScalarWhereInput
    data: XOR<FeePaymentUpdateManyMutationInput, FeePaymentUncheckedUpdateManyWithoutFeeInput>
  }

  export type FeeCreateWithoutPaymentsInput = {
    id?: string
    totalFee: number
    paidAmount?: number
    pendingAmount?: number | null
    dueDate: Date | string
    status?: $Enums.FeeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutFeeInput
    feeCategory: FeeCategoryCreateNestedOneWithoutFeesInput
    Organization: OrganizationCreateNestedOneWithoutFeeInput
  }

  export type FeeUncheckedCreateWithoutPaymentsInput = {
    id?: string
    totalFee: number
    paidAmount?: number
    pendingAmount?: number | null
    dueDate: Date | string
    status?: $Enums.FeeStatus
    studentId: string
    feeCategoryId: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeeCreateOrConnectWithoutPaymentsInput = {
    where: FeeWhereUniqueInput
    create: XOR<FeeCreateWithoutPaymentsInput, FeeUncheckedCreateWithoutPaymentsInput>
  }

  export type UserCreateWithoutFeePaymentInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password?: string | null
    profileImage: string
    role?: $Enums.Role
    clerkId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    parent?: ParentCreateNestedOneWithoutUserInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFeePaymentInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password?: string | null
    profileImage: string
    role?: $Enums.Role
    clerkId: string
    isActive?: boolean
    organizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    parent?: ParentUncheckedCreateNestedOneWithoutUserInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFeePaymentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeePaymentInput, UserUncheckedCreateWithoutFeePaymentInput>
  }

  export type OrganizationCreateWithoutFeePaymentInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    notices?: NoticeCreateNestedManyWithoutOrganizationInput
    Student?: StudentCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentCreateNestedManyWithoutOrganizationInput
    Grade?: GradeCreateNestedManyWithoutOrganizationInput
    Section?: SectionCreateNestedManyWithoutOrganizationInput
    Fee?: FeeCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobCreateNestedManyWithoutOrganizationInput
    Exam?: ExamCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutFeePaymentInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    notices?: NoticeUncheckedCreateNestedManyWithoutOrganizationInput
    Student?: StudentUncheckedCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutOrganizationInput
    Grade?: GradeUncheckedCreateNestedManyWithoutOrganizationInput
    Section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    Fee?: FeeUncheckedCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarUncheckedCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintUncheckedCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherUncheckedCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectUncheckedCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearUncheckedCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobUncheckedCreateNestedManyWithoutOrganizationInput
    Exam?: ExamUncheckedCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutFeePaymentInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutFeePaymentInput, OrganizationUncheckedCreateWithoutFeePaymentInput>
  }

  export type FeeUpsertWithoutPaymentsInput = {
    update: XOR<FeeUpdateWithoutPaymentsInput, FeeUncheckedUpdateWithoutPaymentsInput>
    create: XOR<FeeCreateWithoutPaymentsInput, FeeUncheckedCreateWithoutPaymentsInput>
    where?: FeeWhereInput
  }

  export type FeeUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: FeeWhereInput
    data: XOR<FeeUpdateWithoutPaymentsInput, FeeUncheckedUpdateWithoutPaymentsInput>
  }

  export type FeeUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalFee?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFeeStatusFieldUpdateOperationsInput | $Enums.FeeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutFeeNestedInput
    feeCategory?: FeeCategoryUpdateOneRequiredWithoutFeesNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutFeeNestedInput
  }

  export type FeeUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalFee?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFeeStatusFieldUpdateOperationsInput | $Enums.FeeStatus
    studentId?: StringFieldUpdateOperationsInput | string
    feeCategoryId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutFeePaymentInput = {
    update: XOR<UserUpdateWithoutFeePaymentInput, UserUncheckedUpdateWithoutFeePaymentInput>
    create: XOR<UserCreateWithoutFeePaymentInput, UserUncheckedCreateWithoutFeePaymentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFeePaymentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFeePaymentInput, UserUncheckedUpdateWithoutFeePaymentInput>
  }

  export type UserUpdateWithoutFeePaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    clerkId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    parent?: ParentUpdateOneWithoutUserNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFeePaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    clerkId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    parent?: ParentUncheckedUpdateOneWithoutUserNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationUpsertWithoutFeePaymentInput = {
    update: XOR<OrganizationUpdateWithoutFeePaymentInput, OrganizationUncheckedUpdateWithoutFeePaymentInput>
    create: XOR<OrganizationCreateWithoutFeePaymentInput, OrganizationUncheckedCreateWithoutFeePaymentInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutFeePaymentInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutFeePaymentInput, OrganizationUncheckedUpdateWithoutFeePaymentInput>
  }

  export type OrganizationUpdateWithoutFeePaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutFeePaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUncheckedUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUncheckedUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUncheckedUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUncheckedUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUncheckedUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUncheckedUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUncheckedUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUncheckedUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUncheckedUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateWithoutScheduledJobInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    notices?: NoticeCreateNestedManyWithoutOrganizationInput
    Student?: StudentCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentCreateNestedManyWithoutOrganizationInput
    Grade?: GradeCreateNestedManyWithoutOrganizationInput
    Section?: SectionCreateNestedManyWithoutOrganizationInput
    Fee?: FeeCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearCreateNestedManyWithoutOrganizationInput
    Exam?: ExamCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutScheduledJobInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    notices?: NoticeUncheckedCreateNestedManyWithoutOrganizationInput
    Student?: StudentUncheckedCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutOrganizationInput
    Grade?: GradeUncheckedCreateNestedManyWithoutOrganizationInput
    Section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    Fee?: FeeUncheckedCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryUncheckedCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarUncheckedCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintUncheckedCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherUncheckedCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectUncheckedCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearUncheckedCreateNestedManyWithoutOrganizationInput
    Exam?: ExamUncheckedCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutScheduledJobInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutScheduledJobInput, OrganizationUncheckedCreateWithoutScheduledJobInput>
  }

  export type OrganizationUpsertWithoutScheduledJobInput = {
    update: XOR<OrganizationUpdateWithoutScheduledJobInput, OrganizationUncheckedUpdateWithoutScheduledJobInput>
    create: XOR<OrganizationCreateWithoutScheduledJobInput, OrganizationUncheckedCreateWithoutScheduledJobInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutScheduledJobInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutScheduledJobInput, OrganizationUncheckedUpdateWithoutScheduledJobInput>
  }

  export type OrganizationUpdateWithoutScheduledJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutScheduledJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUncheckedUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUncheckedUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUncheckedUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUncheckedUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUncheckedUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUncheckedUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUncheckedUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUncheckedUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type FeeCreateWithoutFeeCategoryInput = {
    id?: string
    totalFee: number
    paidAmount?: number
    pendingAmount?: number | null
    dueDate: Date | string
    status?: $Enums.FeeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutFeeInput
    Organization: OrganizationCreateNestedOneWithoutFeeInput
    payments?: FeePaymentCreateNestedManyWithoutFeeInput
  }

  export type FeeUncheckedCreateWithoutFeeCategoryInput = {
    id?: string
    totalFee: number
    paidAmount?: number
    pendingAmount?: number | null
    dueDate: Date | string
    status?: $Enums.FeeStatus
    studentId: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: FeePaymentUncheckedCreateNestedManyWithoutFeeInput
  }

  export type FeeCreateOrConnectWithoutFeeCategoryInput = {
    where: FeeWhereUniqueInput
    create: XOR<FeeCreateWithoutFeeCategoryInput, FeeUncheckedCreateWithoutFeeCategoryInput>
  }

  export type FeeCreateManyFeeCategoryInputEnvelope = {
    data: FeeCreateManyFeeCategoryInput | FeeCreateManyFeeCategoryInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationCreateWithoutFeeCategoryInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    notices?: NoticeCreateNestedManyWithoutOrganizationInput
    Student?: StudentCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentCreateNestedManyWithoutOrganizationInput
    Grade?: GradeCreateNestedManyWithoutOrganizationInput
    Section?: SectionCreateNestedManyWithoutOrganizationInput
    Fee?: FeeCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobCreateNestedManyWithoutOrganizationInput
    Exam?: ExamCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutFeeCategoryInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    notices?: NoticeUncheckedCreateNestedManyWithoutOrganizationInput
    Student?: StudentUncheckedCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutOrganizationInput
    Grade?: GradeUncheckedCreateNestedManyWithoutOrganizationInput
    Section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    Fee?: FeeUncheckedCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarUncheckedCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintUncheckedCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherUncheckedCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectUncheckedCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearUncheckedCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobUncheckedCreateNestedManyWithoutOrganizationInput
    Exam?: ExamUncheckedCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutFeeCategoryInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutFeeCategoryInput, OrganizationUncheckedCreateWithoutFeeCategoryInput>
  }

  export type FeeUpsertWithWhereUniqueWithoutFeeCategoryInput = {
    where: FeeWhereUniqueInput
    update: XOR<FeeUpdateWithoutFeeCategoryInput, FeeUncheckedUpdateWithoutFeeCategoryInput>
    create: XOR<FeeCreateWithoutFeeCategoryInput, FeeUncheckedCreateWithoutFeeCategoryInput>
  }

  export type FeeUpdateWithWhereUniqueWithoutFeeCategoryInput = {
    where: FeeWhereUniqueInput
    data: XOR<FeeUpdateWithoutFeeCategoryInput, FeeUncheckedUpdateWithoutFeeCategoryInput>
  }

  export type FeeUpdateManyWithWhereWithoutFeeCategoryInput = {
    where: FeeScalarWhereInput
    data: XOR<FeeUpdateManyMutationInput, FeeUncheckedUpdateManyWithoutFeeCategoryInput>
  }

  export type OrganizationUpsertWithoutFeeCategoryInput = {
    update: XOR<OrganizationUpdateWithoutFeeCategoryInput, OrganizationUncheckedUpdateWithoutFeeCategoryInput>
    create: XOR<OrganizationCreateWithoutFeeCategoryInput, OrganizationUncheckedCreateWithoutFeeCategoryInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutFeeCategoryInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutFeeCategoryInput, OrganizationUncheckedUpdateWithoutFeeCategoryInput>
  }

  export type OrganizationUpdateWithoutFeeCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutFeeCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUncheckedUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUncheckedUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUncheckedUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUncheckedUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUncheckedUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUncheckedUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUncheckedUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUncheckedUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUncheckedUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateWithoutAcademicCalendarInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    notices?: NoticeCreateNestedManyWithoutOrganizationInput
    Student?: StudentCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentCreateNestedManyWithoutOrganizationInput
    Grade?: GradeCreateNestedManyWithoutOrganizationInput
    Section?: SectionCreateNestedManyWithoutOrganizationInput
    Fee?: FeeCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobCreateNestedManyWithoutOrganizationInput
    Exam?: ExamCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutAcademicCalendarInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    notices?: NoticeUncheckedCreateNestedManyWithoutOrganizationInput
    Student?: StudentUncheckedCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutOrganizationInput
    Grade?: GradeUncheckedCreateNestedManyWithoutOrganizationInput
    Section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    Fee?: FeeUncheckedCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryUncheckedCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentUncheckedCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintUncheckedCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherUncheckedCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectUncheckedCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearUncheckedCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobUncheckedCreateNestedManyWithoutOrganizationInput
    Exam?: ExamUncheckedCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutAcademicCalendarInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutAcademicCalendarInput, OrganizationUncheckedCreateWithoutAcademicCalendarInput>
  }

  export type AcademicYearCreateWithoutAcademicCalendarInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    type?: $Enums.YearType
    isCurrent?: boolean
    description?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutAcademicYearInput
    complaints?: AnonymousComplaintCreateNestedManyWithoutAcademicYearInput
    notices?: NoticeCreateNestedManyWithoutAcademicYearInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutAcademicYearInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutAcademicYearInput
    ExamSession?: ExamSessionCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearUncheckedCreateWithoutAcademicCalendarInput = {
    id?: string
    organizationId: string
    name: string
    startDate: Date | string
    endDate: Date | string
    type?: $Enums.YearType
    isCurrent?: boolean
    description?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    complaints?: AnonymousComplaintUncheckedCreateNestedManyWithoutAcademicYearInput
    notices?: NoticeUncheckedCreateNestedManyWithoutAcademicYearInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutAcademicYearInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutAcademicYearInput
    ExamSession?: ExamSessionUncheckedCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearCreateOrConnectWithoutAcademicCalendarInput = {
    where: AcademicYearWhereUniqueInput
    create: XOR<AcademicYearCreateWithoutAcademicCalendarInput, AcademicYearUncheckedCreateWithoutAcademicCalendarInput>
  }

  export type OrganizationUpsertWithoutAcademicCalendarInput = {
    update: XOR<OrganizationUpdateWithoutAcademicCalendarInput, OrganizationUncheckedUpdateWithoutAcademicCalendarInput>
    create: XOR<OrganizationCreateWithoutAcademicCalendarInput, OrganizationUncheckedCreateWithoutAcademicCalendarInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutAcademicCalendarInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutAcademicCalendarInput, OrganizationUncheckedUpdateWithoutAcademicCalendarInput>
  }

  export type OrganizationUpdateWithoutAcademicCalendarInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutAcademicCalendarInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUncheckedUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUncheckedUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUncheckedUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUncheckedUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUncheckedUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUncheckedUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUncheckedUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUncheckedUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUncheckedUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type AcademicYearUpsertWithoutAcademicCalendarInput = {
    update: XOR<AcademicYearUpdateWithoutAcademicCalendarInput, AcademicYearUncheckedUpdateWithoutAcademicCalendarInput>
    create: XOR<AcademicYearCreateWithoutAcademicCalendarInput, AcademicYearUncheckedCreateWithoutAcademicCalendarInput>
    where?: AcademicYearWhereInput
  }

  export type AcademicYearUpdateToOneWithWhereWithoutAcademicCalendarInput = {
    where?: AcademicYearWhereInput
    data: XOR<AcademicYearUpdateWithoutAcademicCalendarInput, AcademicYearUncheckedUpdateWithoutAcademicCalendarInput>
  }

  export type AcademicYearUpdateWithoutAcademicCalendarInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumYearTypeFieldUpdateOperationsInput | $Enums.YearType
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutAcademicYearNestedInput
    complaints?: AnonymousComplaintUpdateManyWithoutAcademicYearNestedInput
    notices?: NoticeUpdateManyWithoutAcademicYearNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutAcademicYearNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutAcademicYearNestedInput
    ExamSession?: ExamSessionUpdateManyWithoutAcademicYearNestedInput
  }

  export type AcademicYearUncheckedUpdateWithoutAcademicCalendarInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumYearTypeFieldUpdateOperationsInput | $Enums.YearType
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    complaints?: AnonymousComplaintUncheckedUpdateManyWithoutAcademicYearNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutAcademicYearNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutAcademicYearNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutAcademicYearNestedInput
    ExamSession?: ExamSessionUncheckedUpdateManyWithoutAcademicYearNestedInput
  }

  export type OrganizationCreateWithoutAnonymousComplaintInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    notices?: NoticeCreateNestedManyWithoutOrganizationInput
    Student?: StudentCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentCreateNestedManyWithoutOrganizationInput
    Grade?: GradeCreateNestedManyWithoutOrganizationInput
    Section?: SectionCreateNestedManyWithoutOrganizationInput
    Fee?: FeeCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobCreateNestedManyWithoutOrganizationInput
    Exam?: ExamCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutAnonymousComplaintInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    notices?: NoticeUncheckedCreateNestedManyWithoutOrganizationInput
    Student?: StudentUncheckedCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutOrganizationInput
    Grade?: GradeUncheckedCreateNestedManyWithoutOrganizationInput
    Section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    Fee?: FeeUncheckedCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryUncheckedCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarUncheckedCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherUncheckedCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectUncheckedCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearUncheckedCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobUncheckedCreateNestedManyWithoutOrganizationInput
    Exam?: ExamUncheckedCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutAnonymousComplaintInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutAnonymousComplaintInput, OrganizationUncheckedCreateWithoutAnonymousComplaintInput>
  }

  export type ComplaintStatusTimelineCreateWithoutComplaintInput = {
    id?: string
    note?: string | null
    status?: $Enums.ComplaintStatus
    changedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplaintStatusTimelineUncheckedCreateWithoutComplaintInput = {
    id?: string
    note?: string | null
    status?: $Enums.ComplaintStatus
    changedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplaintStatusTimelineCreateOrConnectWithoutComplaintInput = {
    where: ComplaintStatusTimelineWhereUniqueInput
    create: XOR<ComplaintStatusTimelineCreateWithoutComplaintInput, ComplaintStatusTimelineUncheckedCreateWithoutComplaintInput>
  }

  export type ComplaintStatusTimelineCreateManyComplaintInputEnvelope = {
    data: ComplaintStatusTimelineCreateManyComplaintInput | ComplaintStatusTimelineCreateManyComplaintInput[]
    skipDuplicates?: boolean
  }

  export type AcademicYearCreateWithoutComplaintsInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    type?: $Enums.YearType
    isCurrent?: boolean
    description?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutAcademicYearInput
    notices?: NoticeCreateNestedManyWithoutAcademicYearInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutAcademicYearInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutAcademicYearInput
    AcademicCalendar?: AcademicCalendarCreateNestedManyWithoutAcademicYearInput
    ExamSession?: ExamSessionCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearUncheckedCreateWithoutComplaintsInput = {
    id?: string
    organizationId: string
    name: string
    startDate: Date | string
    endDate: Date | string
    type?: $Enums.YearType
    isCurrent?: boolean
    description?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notices?: NoticeUncheckedCreateNestedManyWithoutAcademicYearInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutAcademicYearInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutAcademicYearInput
    AcademicCalendar?: AcademicCalendarUncheckedCreateNestedManyWithoutAcademicYearInput
    ExamSession?: ExamSessionUncheckedCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearCreateOrConnectWithoutComplaintsInput = {
    where: AcademicYearWhereUniqueInput
    create: XOR<AcademicYearCreateWithoutComplaintsInput, AcademicYearUncheckedCreateWithoutComplaintsInput>
  }

  export type OrganizationUpsertWithoutAnonymousComplaintInput = {
    update: XOR<OrganizationUpdateWithoutAnonymousComplaintInput, OrganizationUncheckedUpdateWithoutAnonymousComplaintInput>
    create: XOR<OrganizationCreateWithoutAnonymousComplaintInput, OrganizationUncheckedCreateWithoutAnonymousComplaintInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutAnonymousComplaintInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutAnonymousComplaintInput, OrganizationUncheckedUpdateWithoutAnonymousComplaintInput>
  }

  export type OrganizationUpdateWithoutAnonymousComplaintInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutAnonymousComplaintInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUncheckedUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUncheckedUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUncheckedUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUncheckedUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUncheckedUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUncheckedUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUncheckedUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUncheckedUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type ComplaintStatusTimelineUpsertWithWhereUniqueWithoutComplaintInput = {
    where: ComplaintStatusTimelineWhereUniqueInput
    update: XOR<ComplaintStatusTimelineUpdateWithoutComplaintInput, ComplaintStatusTimelineUncheckedUpdateWithoutComplaintInput>
    create: XOR<ComplaintStatusTimelineCreateWithoutComplaintInput, ComplaintStatusTimelineUncheckedCreateWithoutComplaintInput>
  }

  export type ComplaintStatusTimelineUpdateWithWhereUniqueWithoutComplaintInput = {
    where: ComplaintStatusTimelineWhereUniqueInput
    data: XOR<ComplaintStatusTimelineUpdateWithoutComplaintInput, ComplaintStatusTimelineUncheckedUpdateWithoutComplaintInput>
  }

  export type ComplaintStatusTimelineUpdateManyWithWhereWithoutComplaintInput = {
    where: ComplaintStatusTimelineScalarWhereInput
    data: XOR<ComplaintStatusTimelineUpdateManyMutationInput, ComplaintStatusTimelineUncheckedUpdateManyWithoutComplaintInput>
  }

  export type ComplaintStatusTimelineScalarWhereInput = {
    AND?: ComplaintStatusTimelineScalarWhereInput | ComplaintStatusTimelineScalarWhereInput[]
    OR?: ComplaintStatusTimelineScalarWhereInput[]
    NOT?: ComplaintStatusTimelineScalarWhereInput | ComplaintStatusTimelineScalarWhereInput[]
    id?: StringFilter<"ComplaintStatusTimeline"> | string
    complaintId?: StringFilter<"ComplaintStatusTimeline"> | string
    note?: StringNullableFilter<"ComplaintStatusTimeline"> | string | null
    status?: EnumComplaintStatusFilter<"ComplaintStatusTimeline"> | $Enums.ComplaintStatus
    changedBy?: StringNullableFilter<"ComplaintStatusTimeline"> | string | null
    createdAt?: DateTimeFilter<"ComplaintStatusTimeline"> | Date | string
    updatedAt?: DateTimeFilter<"ComplaintStatusTimeline"> | Date | string
  }

  export type AcademicYearUpsertWithoutComplaintsInput = {
    update: XOR<AcademicYearUpdateWithoutComplaintsInput, AcademicYearUncheckedUpdateWithoutComplaintsInput>
    create: XOR<AcademicYearCreateWithoutComplaintsInput, AcademicYearUncheckedCreateWithoutComplaintsInput>
    where?: AcademicYearWhereInput
  }

  export type AcademicYearUpdateToOneWithWhereWithoutComplaintsInput = {
    where?: AcademicYearWhereInput
    data: XOR<AcademicYearUpdateWithoutComplaintsInput, AcademicYearUncheckedUpdateWithoutComplaintsInput>
  }

  export type AcademicYearUpdateWithoutComplaintsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumYearTypeFieldUpdateOperationsInput | $Enums.YearType
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutAcademicYearNestedInput
    notices?: NoticeUpdateManyWithoutAcademicYearNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutAcademicYearNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutAcademicYearNestedInput
    AcademicCalendar?: AcademicCalendarUpdateManyWithoutAcademicYearNestedInput
    ExamSession?: ExamSessionUpdateManyWithoutAcademicYearNestedInput
  }

  export type AcademicYearUncheckedUpdateWithoutComplaintsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumYearTypeFieldUpdateOperationsInput | $Enums.YearType
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notices?: NoticeUncheckedUpdateManyWithoutAcademicYearNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutAcademicYearNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutAcademicYearNestedInput
    AcademicCalendar?: AcademicCalendarUncheckedUpdateManyWithoutAcademicYearNestedInput
    ExamSession?: ExamSessionUncheckedUpdateManyWithoutAcademicYearNestedInput
  }

  export type AnonymousComplaintCreateWithoutComplaintStatusTimelineInput = {
    id?: string
    trackingId: string
    category: string
    severity?: $Enums.Severity
    subject: string
    description: string
    evidenceUrls?: AnonymousComplaintCreateevidenceUrlsInput | string[]
    submittedAt?: Date | string
    currentStatus?: $Enums.ComplaintStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutAnonymousComplaintInput
    academicYear?: AcademicYearCreateNestedOneWithoutComplaintsInput
  }

  export type AnonymousComplaintUncheckedCreateWithoutComplaintStatusTimelineInput = {
    id?: string
    trackingId: string
    category: string
    severity?: $Enums.Severity
    subject: string
    description: string
    evidenceUrls?: AnonymousComplaintCreateevidenceUrlsInput | string[]
    submittedAt?: Date | string
    currentStatus?: $Enums.ComplaintStatus
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicYearId?: string | null
  }

  export type AnonymousComplaintCreateOrConnectWithoutComplaintStatusTimelineInput = {
    where: AnonymousComplaintWhereUniqueInput
    create: XOR<AnonymousComplaintCreateWithoutComplaintStatusTimelineInput, AnonymousComplaintUncheckedCreateWithoutComplaintStatusTimelineInput>
  }

  export type AnonymousComplaintUpsertWithoutComplaintStatusTimelineInput = {
    update: XOR<AnonymousComplaintUpdateWithoutComplaintStatusTimelineInput, AnonymousComplaintUncheckedUpdateWithoutComplaintStatusTimelineInput>
    create: XOR<AnonymousComplaintCreateWithoutComplaintStatusTimelineInput, AnonymousComplaintUncheckedCreateWithoutComplaintStatusTimelineInput>
    where?: AnonymousComplaintWhereInput
  }

  export type AnonymousComplaintUpdateToOneWithWhereWithoutComplaintStatusTimelineInput = {
    where?: AnonymousComplaintWhereInput
    data: XOR<AnonymousComplaintUpdateWithoutComplaintStatusTimelineInput, AnonymousComplaintUncheckedUpdateWithoutComplaintStatusTimelineInput>
  }

  export type AnonymousComplaintUpdateWithoutComplaintStatusTimelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    evidenceUrls?: AnonymousComplaintUpdateevidenceUrlsInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentStatus?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutAnonymousComplaintNestedInput
    academicYear?: AcademicYearUpdateOneWithoutComplaintsNestedInput
  }

  export type AnonymousComplaintUncheckedUpdateWithoutComplaintStatusTimelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    evidenceUrls?: AnonymousComplaintUpdateevidenceUrlsInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentStatus?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrganizationCreateWithoutNoticesInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    Student?: StudentCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentCreateNestedManyWithoutOrganizationInput
    Grade?: GradeCreateNestedManyWithoutOrganizationInput
    Section?: SectionCreateNestedManyWithoutOrganizationInput
    Fee?: FeeCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobCreateNestedManyWithoutOrganizationInput
    Exam?: ExamCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutNoticesInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    Student?: StudentUncheckedCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutOrganizationInput
    Grade?: GradeUncheckedCreateNestedManyWithoutOrganizationInput
    Section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    Fee?: FeeUncheckedCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryUncheckedCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarUncheckedCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintUncheckedCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherUncheckedCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectUncheckedCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearUncheckedCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobUncheckedCreateNestedManyWithoutOrganizationInput
    Exam?: ExamUncheckedCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutNoticesInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutNoticesInput, OrganizationUncheckedCreateWithoutNoticesInput>
  }

  export type AcademicYearCreateWithoutNoticesInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    type?: $Enums.YearType
    isCurrent?: boolean
    description?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutAcademicYearInput
    complaints?: AnonymousComplaintCreateNestedManyWithoutAcademicYearInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutAcademicYearInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutAcademicYearInput
    AcademicCalendar?: AcademicCalendarCreateNestedManyWithoutAcademicYearInput
    ExamSession?: ExamSessionCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearUncheckedCreateWithoutNoticesInput = {
    id?: string
    organizationId: string
    name: string
    startDate: Date | string
    endDate: Date | string
    type?: $Enums.YearType
    isCurrent?: boolean
    description?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    complaints?: AnonymousComplaintUncheckedCreateNestedManyWithoutAcademicYearInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutAcademicYearInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutAcademicYearInput
    AcademicCalendar?: AcademicCalendarUncheckedCreateNestedManyWithoutAcademicYearInput
    ExamSession?: ExamSessionUncheckedCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearCreateOrConnectWithoutNoticesInput = {
    where: AcademicYearWhereUniqueInput
    create: XOR<AcademicYearCreateWithoutNoticesInput, AcademicYearUncheckedCreateWithoutNoticesInput>
  }

  export type OrganizationUpsertWithoutNoticesInput = {
    update: XOR<OrganizationUpdateWithoutNoticesInput, OrganizationUncheckedUpdateWithoutNoticesInput>
    create: XOR<OrganizationCreateWithoutNoticesInput, OrganizationUncheckedCreateWithoutNoticesInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutNoticesInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutNoticesInput, OrganizationUncheckedUpdateWithoutNoticesInput>
  }

  export type OrganizationUpdateWithoutNoticesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutNoticesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUncheckedUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUncheckedUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUncheckedUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUncheckedUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUncheckedUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUncheckedUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUncheckedUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUncheckedUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUncheckedUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type AcademicYearUpsertWithoutNoticesInput = {
    update: XOR<AcademicYearUpdateWithoutNoticesInput, AcademicYearUncheckedUpdateWithoutNoticesInput>
    create: XOR<AcademicYearCreateWithoutNoticesInput, AcademicYearUncheckedCreateWithoutNoticesInput>
    where?: AcademicYearWhereInput
  }

  export type AcademicYearUpdateToOneWithWhereWithoutNoticesInput = {
    where?: AcademicYearWhereInput
    data: XOR<AcademicYearUpdateWithoutNoticesInput, AcademicYearUncheckedUpdateWithoutNoticesInput>
  }

  export type AcademicYearUpdateWithoutNoticesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumYearTypeFieldUpdateOperationsInput | $Enums.YearType
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutAcademicYearNestedInput
    complaints?: AnonymousComplaintUpdateManyWithoutAcademicYearNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutAcademicYearNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutAcademicYearNestedInput
    AcademicCalendar?: AcademicCalendarUpdateManyWithoutAcademicYearNestedInput
    ExamSession?: ExamSessionUpdateManyWithoutAcademicYearNestedInput
  }

  export type AcademicYearUncheckedUpdateWithoutNoticesInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumYearTypeFieldUpdateOperationsInput | $Enums.YearType
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    complaints?: AnonymousComplaintUncheckedUpdateManyWithoutAcademicYearNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutAcademicYearNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutAcademicYearNestedInput
    AcademicCalendar?: AcademicCalendarUncheckedUpdateManyWithoutAcademicYearNestedInput
    ExamSession?: ExamSessionUncheckedUpdateManyWithoutAcademicYearNestedInput
  }

  export type OrganizationCreateWithoutNotificationLogInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    notices?: NoticeCreateNestedManyWithoutOrganizationInput
    Student?: StudentCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentCreateNestedManyWithoutOrganizationInput
    Grade?: GradeCreateNestedManyWithoutOrganizationInput
    Section?: SectionCreateNestedManyWithoutOrganizationInput
    Fee?: FeeCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobCreateNestedManyWithoutOrganizationInput
    Exam?: ExamCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutNotificationLogInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    notices?: NoticeUncheckedCreateNestedManyWithoutOrganizationInput
    Student?: StudentUncheckedCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutOrganizationInput
    Grade?: GradeUncheckedCreateNestedManyWithoutOrganizationInput
    Section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    Fee?: FeeUncheckedCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryUncheckedCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarUncheckedCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintUncheckedCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherUncheckedCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectUncheckedCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearUncheckedCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobUncheckedCreateNestedManyWithoutOrganizationInput
    Exam?: ExamUncheckedCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutNotificationLogInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutNotificationLogInput, OrganizationUncheckedCreateWithoutNotificationLogInput>
  }

  export type UserCreateWithoutNotificationLogInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password?: string | null
    profileImage: string
    role?: $Enums.Role
    clerkId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    parent?: ParentCreateNestedOneWithoutUserInput
    FeePayment?: FeePaymentCreateNestedManyWithoutPayerInput
  }

  export type UserUncheckedCreateWithoutNotificationLogInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password?: string | null
    profileImage: string
    role?: $Enums.Role
    clerkId: string
    isActive?: boolean
    organizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    parent?: ParentUncheckedCreateNestedOneWithoutUserInput
    FeePayment?: FeePaymentUncheckedCreateNestedManyWithoutPayerInput
  }

  export type UserCreateOrConnectWithoutNotificationLogInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationLogInput, UserUncheckedCreateWithoutNotificationLogInput>
  }

  export type ParentCreateWithoutNotificationLogInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phoneNumber: string
    whatsAppNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutParentInput
    students?: ParentStudentCreateNestedManyWithoutParentInput
  }

  export type ParentUncheckedCreateWithoutNotificationLogInput = {
    id?: string
    userId?: string | null
    firstName: string
    lastName: string
    email: string
    phoneNumber: string
    whatsAppNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: ParentStudentUncheckedCreateNestedManyWithoutParentInput
  }

  export type ParentCreateOrConnectWithoutNotificationLogInput = {
    where: ParentWhereUniqueInput
    create: XOR<ParentCreateWithoutNotificationLogInput, ParentUncheckedCreateWithoutNotificationLogInput>
  }

  export type StudentCreateWithoutNotificationLogInput = {
    id?: string
    firstName: string
    lastName: string
    middleName?: string | null
    motherName?: string | null
    fullName?: string | null
    dateOfBirth: Date | string
    profileImage?: string | null
    rollNumber: string
    phoneNumber: string
    whatsAppNumber: string
    email: string
    emergencyContact: string
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    section: SectionCreateNestedOneWithoutStudentsInput
    grade: GradeCreateNestedOneWithoutStudentsInput
    organization: OrganizationCreateNestedOneWithoutStudentInput
    Fee?: FeeCreateNestedManyWithoutStudentInput
    parents?: ParentStudentCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutStudentInput
    StudentDocument?: StudentDocumentCreateNestedManyWithoutStudentInput
    reportCard?: ReportCardCreateNestedManyWithoutStudentInput
    hallTicket?: HallTicketCreateNestedManyWithoutStudentInput
    examResult?: ExamResultCreateNestedManyWithoutStudentInput
    examEnrollment?: ExamEnrollmentCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutNotificationLogInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    middleName?: string | null
    motherName?: string | null
    fullName?: string | null
    dateOfBirth: Date | string
    profileImage?: string | null
    rollNumber: string
    phoneNumber: string
    whatsAppNumber: string
    email: string
    emergencyContact: string
    gender: $Enums.Gender
    sectionId: string
    gradeId: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Fee?: FeeUncheckedCreateNestedManyWithoutStudentInput
    parents?: ParentStudentUncheckedCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutStudentInput
    reportCard?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
    hallTicket?: HallTicketUncheckedCreateNestedManyWithoutStudentInput
    examResult?: ExamResultUncheckedCreateNestedManyWithoutStudentInput
    examEnrollment?: ExamEnrollmentUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutNotificationLogInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutNotificationLogInput, StudentUncheckedCreateWithoutNotificationLogInput>
  }

  export type OrganizationUpsertWithoutNotificationLogInput = {
    update: XOR<OrganizationUpdateWithoutNotificationLogInput, OrganizationUncheckedUpdateWithoutNotificationLogInput>
    create: XOR<OrganizationCreateWithoutNotificationLogInput, OrganizationUncheckedCreateWithoutNotificationLogInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutNotificationLogInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutNotificationLogInput, OrganizationUncheckedUpdateWithoutNotificationLogInput>
  }

  export type OrganizationUpdateWithoutNotificationLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutNotificationLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUncheckedUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUncheckedUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUncheckedUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUncheckedUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUncheckedUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUncheckedUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUncheckedUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUncheckedUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUncheckedUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserUpsertWithoutNotificationLogInput = {
    update: XOR<UserUpdateWithoutNotificationLogInput, UserUncheckedUpdateWithoutNotificationLogInput>
    create: XOR<UserCreateWithoutNotificationLogInput, UserUncheckedCreateWithoutNotificationLogInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationLogInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationLogInput, UserUncheckedUpdateWithoutNotificationLogInput>
  }

  export type UserUpdateWithoutNotificationLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    clerkId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    parent?: ParentUpdateOneWithoutUserNestedInput
    FeePayment?: FeePaymentUpdateManyWithoutPayerNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    clerkId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    parent?: ParentUncheckedUpdateOneWithoutUserNestedInput
    FeePayment?: FeePaymentUncheckedUpdateManyWithoutPayerNestedInput
  }

  export type ParentUpsertWithoutNotificationLogInput = {
    update: XOR<ParentUpdateWithoutNotificationLogInput, ParentUncheckedUpdateWithoutNotificationLogInput>
    create: XOR<ParentCreateWithoutNotificationLogInput, ParentUncheckedCreateWithoutNotificationLogInput>
    where?: ParentWhereInput
  }

  export type ParentUpdateToOneWithWhereWithoutNotificationLogInput = {
    where?: ParentWhereInput
    data: XOR<ParentUpdateWithoutNotificationLogInput, ParentUncheckedUpdateWithoutNotificationLogInput>
  }

  export type ParentUpdateWithoutNotificationLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutParentNestedInput
    students?: ParentStudentUpdateManyWithoutParentNestedInput
  }

  export type ParentUncheckedUpdateWithoutNotificationLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: ParentStudentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type StudentUpsertWithoutNotificationLogInput = {
    update: XOR<StudentUpdateWithoutNotificationLogInput, StudentUncheckedUpdateWithoutNotificationLogInput>
    create: XOR<StudentCreateWithoutNotificationLogInput, StudentUncheckedCreateWithoutNotificationLogInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutNotificationLogInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutNotificationLogInput, StudentUncheckedUpdateWithoutNotificationLogInput>
  }

  export type StudentUpdateWithoutNotificationLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emergencyContact?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    section?: SectionUpdateOneRequiredWithoutStudentsNestedInput
    grade?: GradeUpdateOneRequiredWithoutStudentsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutStudentNestedInput
    Fee?: FeeUpdateManyWithoutStudentNestedInput
    parents?: ParentStudentUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    StudentDocument?: StudentDocumentUpdateManyWithoutStudentNestedInput
    reportCard?: ReportCardUpdateManyWithoutStudentNestedInput
    hallTicket?: HallTicketUpdateManyWithoutStudentNestedInput
    examResult?: ExamResultUpdateManyWithoutStudentNestedInput
    examEnrollment?: ExamEnrollmentUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutNotificationLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emergencyContact?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    sectionId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Fee?: FeeUncheckedUpdateManyWithoutStudentNestedInput
    parents?: ParentStudentUncheckedUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutStudentNestedInput
    reportCard?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
    hallTicket?: HallTicketUncheckedUpdateManyWithoutStudentNestedInput
    examResult?: ExamResultUncheckedUpdateManyWithoutStudentNestedInput
    examEnrollment?: ExamEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type AcademicYearCreateWithoutExamSessionInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    type?: $Enums.YearType
    isCurrent?: boolean
    description?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutAcademicYearInput
    complaints?: AnonymousComplaintCreateNestedManyWithoutAcademicYearInput
    notices?: NoticeCreateNestedManyWithoutAcademicYearInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutAcademicYearInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutAcademicYearInput
    AcademicCalendar?: AcademicCalendarCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearUncheckedCreateWithoutExamSessionInput = {
    id?: string
    organizationId: string
    name: string
    startDate: Date | string
    endDate: Date | string
    type?: $Enums.YearType
    isCurrent?: boolean
    description?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    complaints?: AnonymousComplaintUncheckedCreateNestedManyWithoutAcademicYearInput
    notices?: NoticeUncheckedCreateNestedManyWithoutAcademicYearInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutAcademicYearInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutAcademicYearInput
    AcademicCalendar?: AcademicCalendarUncheckedCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearCreateOrConnectWithoutExamSessionInput = {
    where: AcademicYearWhereUniqueInput
    create: XOR<AcademicYearCreateWithoutExamSessionInput, AcademicYearUncheckedCreateWithoutExamSessionInput>
  }

  export type ExamCreateWithoutExamSessionInput = {
    id?: string
    title: string
    description?: string | null
    gradeId: string
    sectionId: string
    maxMarks: number
    passingMarks?: number | null
    weightage?: number | null
    evaluationType: $Enums.EvaluationType
    mode: $Enums.ExamMode
    status?: $Enums.ExamStatus
    instructions?: string | null
    durationInMinutes?: number | null
    venueMapUrl?: string | null
    venue?: string | null
    isResultsPublished?: boolean
    supervisors?: ExamCreatesupervisorsInput | string[]
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: SubjectCreateNestedOneWithoutExamInput
    organization: OrganizationCreateNestedOneWithoutExamInput
    hallTickets?: HallTicketCreateNestedManyWithoutExamInput
    examResult?: ExamResultCreateNestedManyWithoutExamInput
    examEnrollment?: ExamEnrollmentCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutExamSessionInput = {
    id?: string
    title: string
    description?: string | null
    subjectId: string
    gradeId: string
    sectionId: string
    organizationId: string
    maxMarks: number
    passingMarks?: number | null
    weightage?: number | null
    evaluationType: $Enums.EvaluationType
    mode: $Enums.ExamMode
    status?: $Enums.ExamStatus
    instructions?: string | null
    durationInMinutes?: number | null
    venueMapUrl?: string | null
    venue?: string | null
    isResultsPublished?: boolean
    supervisors?: ExamCreatesupervisorsInput | string[]
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    hallTickets?: HallTicketUncheckedCreateNestedManyWithoutExamInput
    examResult?: ExamResultUncheckedCreateNestedManyWithoutExamInput
    examEnrollment?: ExamEnrollmentUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutExamSessionInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutExamSessionInput, ExamUncheckedCreateWithoutExamSessionInput>
  }

  export type ExamCreateManyExamSessionInputEnvelope = {
    data: ExamCreateManyExamSessionInput | ExamCreateManyExamSessionInput[]
    skipDuplicates?: boolean
  }

  export type ReportCardCreateWithoutExamSessionInput = {
    id?: string
    totalMaxMarks: number
    totalObtained: number
    percentage: number
    cgpa?: number | null
    overallGrade: string
    resultStatus: $Enums.ResultStatus
    classRank?: number | null
    gradeRank?: number | null
    attendancePercent?: number | null
    conductGrade?: string | null
    remarks?: string | null
    principalRemarks?: string | null
    rank?: number | null
    pdfUrl?: string | null
    generatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutReportCardInput
  }

  export type ReportCardUncheckedCreateWithoutExamSessionInput = {
    id?: string
    studentId: string
    totalMaxMarks: number
    totalObtained: number
    percentage: number
    cgpa?: number | null
    overallGrade: string
    resultStatus: $Enums.ResultStatus
    classRank?: number | null
    gradeRank?: number | null
    attendancePercent?: number | null
    conductGrade?: string | null
    remarks?: string | null
    principalRemarks?: string | null
    rank?: number | null
    pdfUrl?: string | null
    generatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCardCreateOrConnectWithoutExamSessionInput = {
    where: ReportCardWhereUniqueInput
    create: XOR<ReportCardCreateWithoutExamSessionInput, ReportCardUncheckedCreateWithoutExamSessionInput>
  }

  export type ReportCardCreateManyExamSessionInputEnvelope = {
    data: ReportCardCreateManyExamSessionInput | ReportCardCreateManyExamSessionInput[]
    skipDuplicates?: boolean
  }

  export type HallTicketCreateWithoutExamSessionInput = {
    id?: string
    pdfUrl: string
    qrCode?: string | null
    generatedAt?: Date | string
    downloadedAt?: Date | string | null
    expiryDate?: Date | string | null
    student: StudentCreateNestedOneWithoutHallTicketInput
    exam?: ExamCreateNestedOneWithoutHallTicketsInput
    organization: OrganizationCreateNestedOneWithoutHallTicketInput
  }

  export type HallTicketUncheckedCreateWithoutExamSessionInput = {
    id?: string
    studentId: string
    examId?: string | null
    pdfUrl: string
    qrCode?: string | null
    generatedAt?: Date | string
    downloadedAt?: Date | string | null
    expiryDate?: Date | string | null
    organizationId: string
  }

  export type HallTicketCreateOrConnectWithoutExamSessionInput = {
    where: HallTicketWhereUniqueInput
    create: XOR<HallTicketCreateWithoutExamSessionInput, HallTicketUncheckedCreateWithoutExamSessionInput>
  }

  export type HallTicketCreateManyExamSessionInputEnvelope = {
    data: HallTicketCreateManyExamSessionInput | HallTicketCreateManyExamSessionInput[]
    skipDuplicates?: boolean
  }

  export type AcademicYearUpsertWithoutExamSessionInput = {
    update: XOR<AcademicYearUpdateWithoutExamSessionInput, AcademicYearUncheckedUpdateWithoutExamSessionInput>
    create: XOR<AcademicYearCreateWithoutExamSessionInput, AcademicYearUncheckedCreateWithoutExamSessionInput>
    where?: AcademicYearWhereInput
  }

  export type AcademicYearUpdateToOneWithWhereWithoutExamSessionInput = {
    where?: AcademicYearWhereInput
    data: XOR<AcademicYearUpdateWithoutExamSessionInput, AcademicYearUncheckedUpdateWithoutExamSessionInput>
  }

  export type AcademicYearUpdateWithoutExamSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumYearTypeFieldUpdateOperationsInput | $Enums.YearType
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutAcademicYearNestedInput
    complaints?: AnonymousComplaintUpdateManyWithoutAcademicYearNestedInput
    notices?: NoticeUpdateManyWithoutAcademicYearNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutAcademicYearNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutAcademicYearNestedInput
    AcademicCalendar?: AcademicCalendarUpdateManyWithoutAcademicYearNestedInput
  }

  export type AcademicYearUncheckedUpdateWithoutExamSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumYearTypeFieldUpdateOperationsInput | $Enums.YearType
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    complaints?: AnonymousComplaintUncheckedUpdateManyWithoutAcademicYearNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutAcademicYearNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutAcademicYearNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutAcademicYearNestedInput
    AcademicCalendar?: AcademicCalendarUncheckedUpdateManyWithoutAcademicYearNestedInput
  }

  export type ExamUpsertWithWhereUniqueWithoutExamSessionInput = {
    where: ExamWhereUniqueInput
    update: XOR<ExamUpdateWithoutExamSessionInput, ExamUncheckedUpdateWithoutExamSessionInput>
    create: XOR<ExamCreateWithoutExamSessionInput, ExamUncheckedCreateWithoutExamSessionInput>
  }

  export type ExamUpdateWithWhereUniqueWithoutExamSessionInput = {
    where: ExamWhereUniqueInput
    data: XOR<ExamUpdateWithoutExamSessionInput, ExamUncheckedUpdateWithoutExamSessionInput>
  }

  export type ExamUpdateManyWithWhereWithoutExamSessionInput = {
    where: ExamScalarWhereInput
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyWithoutExamSessionInput>
  }

  export type ReportCardUpsertWithWhereUniqueWithoutExamSessionInput = {
    where: ReportCardWhereUniqueInput
    update: XOR<ReportCardUpdateWithoutExamSessionInput, ReportCardUncheckedUpdateWithoutExamSessionInput>
    create: XOR<ReportCardCreateWithoutExamSessionInput, ReportCardUncheckedCreateWithoutExamSessionInput>
  }

  export type ReportCardUpdateWithWhereUniqueWithoutExamSessionInput = {
    where: ReportCardWhereUniqueInput
    data: XOR<ReportCardUpdateWithoutExamSessionInput, ReportCardUncheckedUpdateWithoutExamSessionInput>
  }

  export type ReportCardUpdateManyWithWhereWithoutExamSessionInput = {
    where: ReportCardScalarWhereInput
    data: XOR<ReportCardUpdateManyMutationInput, ReportCardUncheckedUpdateManyWithoutExamSessionInput>
  }

  export type HallTicketUpsertWithWhereUniqueWithoutExamSessionInput = {
    where: HallTicketWhereUniqueInput
    update: XOR<HallTicketUpdateWithoutExamSessionInput, HallTicketUncheckedUpdateWithoutExamSessionInput>
    create: XOR<HallTicketCreateWithoutExamSessionInput, HallTicketUncheckedCreateWithoutExamSessionInput>
  }

  export type HallTicketUpdateWithWhereUniqueWithoutExamSessionInput = {
    where: HallTicketWhereUniqueInput
    data: XOR<HallTicketUpdateWithoutExamSessionInput, HallTicketUncheckedUpdateWithoutExamSessionInput>
  }

  export type HallTicketUpdateManyWithWhereWithoutExamSessionInput = {
    where: HallTicketScalarWhereInput
    data: XOR<HallTicketUpdateManyMutationInput, HallTicketUncheckedUpdateManyWithoutExamSessionInput>
  }

  export type ExamSessionCreateWithoutExamsInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicYear: AcademicYearCreateNestedOneWithoutExamSessionInput
    reportCards?: ReportCardCreateNestedManyWithoutExamSessionInput
    hallTickets?: HallTicketCreateNestedManyWithoutExamSessionInput
  }

  export type ExamSessionUncheckedCreateWithoutExamsInput = {
    id?: string
    title: string
    description?: string | null
    academicYearId: string
    startDate: Date | string
    endDate: Date | string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    reportCards?: ReportCardUncheckedCreateNestedManyWithoutExamSessionInput
    hallTickets?: HallTicketUncheckedCreateNestedManyWithoutExamSessionInput
  }

  export type ExamSessionCreateOrConnectWithoutExamsInput = {
    where: ExamSessionWhereUniqueInput
    create: XOR<ExamSessionCreateWithoutExamsInput, ExamSessionUncheckedCreateWithoutExamsInput>
  }

  export type SubjectCreateWithoutExamInput = {
    id?: string
    name: string
    code: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutSubjectInput
    teachingAssignments?: TeachingAssignmentCreateNestedManyWithoutSubjectInput
    examResult?: ExamResultCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutExamInput = {
    id?: string
    name: string
    code: string
    description: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teachingAssignments?: TeachingAssignmentUncheckedCreateNestedManyWithoutSubjectInput
    examResult?: ExamResultUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutExamInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutExamInput, SubjectUncheckedCreateWithoutExamInput>
  }

  export type OrganizationCreateWithoutExamInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    notices?: NoticeCreateNestedManyWithoutOrganizationInput
    Student?: StudentCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentCreateNestedManyWithoutOrganizationInput
    Grade?: GradeCreateNestedManyWithoutOrganizationInput
    Section?: SectionCreateNestedManyWithoutOrganizationInput
    Fee?: FeeCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutExamInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    notices?: NoticeUncheckedCreateNestedManyWithoutOrganizationInput
    Student?: StudentUncheckedCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutOrganizationInput
    Grade?: GradeUncheckedCreateNestedManyWithoutOrganizationInput
    Section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    Fee?: FeeUncheckedCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryUncheckedCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarUncheckedCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintUncheckedCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherUncheckedCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectUncheckedCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearUncheckedCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobUncheckedCreateNestedManyWithoutOrganizationInput
    hallTicket?: HallTicketUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutExamInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutExamInput, OrganizationUncheckedCreateWithoutExamInput>
  }

  export type HallTicketCreateWithoutExamInput = {
    id?: string
    pdfUrl: string
    qrCode?: string | null
    generatedAt?: Date | string
    downloadedAt?: Date | string | null
    expiryDate?: Date | string | null
    student: StudentCreateNestedOneWithoutHallTicketInput
    examSession?: ExamSessionCreateNestedOneWithoutHallTicketsInput
    organization: OrganizationCreateNestedOneWithoutHallTicketInput
  }

  export type HallTicketUncheckedCreateWithoutExamInput = {
    id?: string
    studentId: string
    examSessionId?: string | null
    pdfUrl: string
    qrCode?: string | null
    generatedAt?: Date | string
    downloadedAt?: Date | string | null
    expiryDate?: Date | string | null
    organizationId: string
  }

  export type HallTicketCreateOrConnectWithoutExamInput = {
    where: HallTicketWhereUniqueInput
    create: XOR<HallTicketCreateWithoutExamInput, HallTicketUncheckedCreateWithoutExamInput>
  }

  export type HallTicketCreateManyExamInputEnvelope = {
    data: HallTicketCreateManyExamInput | HallTicketCreateManyExamInput[]
    skipDuplicates?: boolean
  }

  export type ExamResultCreateWithoutExamInput = {
    id?: string
    maxMarks: number
    obtainedMarks?: number | null
    percentage?: number | null
    gradeLabel?: string | null
    remarks?: string | null
    isPassed?: boolean | null
    isAbsent?: boolean
    isResultsPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutExamResultInput
    subject?: SubjectCreateNestedOneWithoutExamResultInput
  }

  export type ExamResultUncheckedCreateWithoutExamInput = {
    id?: string
    studentId: string
    subjectId?: string | null
    maxMarks: number
    obtainedMarks?: number | null
    percentage?: number | null
    gradeLabel?: string | null
    remarks?: string | null
    isPassed?: boolean | null
    isAbsent?: boolean
    isResultsPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamResultCreateOrConnectWithoutExamInput = {
    where: ExamResultWhereUniqueInput
    create: XOR<ExamResultCreateWithoutExamInput, ExamResultUncheckedCreateWithoutExamInput>
  }

  export type ExamResultCreateManyExamInputEnvelope = {
    data: ExamResultCreateManyExamInput | ExamResultCreateManyExamInput[]
    skipDuplicates?: boolean
  }

  export type ExamEnrollmentCreateWithoutExamInput = {
    id?: string
    status?: $Enums.StudentExamStatus
    enrolledAt?: Date | string
    exemptionReason?: string | null
    student: StudentCreateNestedOneWithoutExamEnrollmentInput
  }

  export type ExamEnrollmentUncheckedCreateWithoutExamInput = {
    id?: string
    studentId: string
    status?: $Enums.StudentExamStatus
    enrolledAt?: Date | string
    exemptionReason?: string | null
  }

  export type ExamEnrollmentCreateOrConnectWithoutExamInput = {
    where: ExamEnrollmentWhereUniqueInput
    create: XOR<ExamEnrollmentCreateWithoutExamInput, ExamEnrollmentUncheckedCreateWithoutExamInput>
  }

  export type ExamEnrollmentCreateManyExamInputEnvelope = {
    data: ExamEnrollmentCreateManyExamInput | ExamEnrollmentCreateManyExamInput[]
    skipDuplicates?: boolean
  }

  export type ExamSessionUpsertWithoutExamsInput = {
    update: XOR<ExamSessionUpdateWithoutExamsInput, ExamSessionUncheckedUpdateWithoutExamsInput>
    create: XOR<ExamSessionCreateWithoutExamsInput, ExamSessionUncheckedCreateWithoutExamsInput>
    where?: ExamSessionWhereInput
  }

  export type ExamSessionUpdateToOneWithWhereWithoutExamsInput = {
    where?: ExamSessionWhereInput
    data: XOR<ExamSessionUpdateWithoutExamsInput, ExamSessionUncheckedUpdateWithoutExamsInput>
  }

  export type ExamSessionUpdateWithoutExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYear?: AcademicYearUpdateOneRequiredWithoutExamSessionNestedInput
    reportCards?: ReportCardUpdateManyWithoutExamSessionNestedInput
    hallTickets?: HallTicketUpdateManyWithoutExamSessionNestedInput
  }

  export type ExamSessionUncheckedUpdateWithoutExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    academicYearId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportCards?: ReportCardUncheckedUpdateManyWithoutExamSessionNestedInput
    hallTickets?: HallTicketUncheckedUpdateManyWithoutExamSessionNestedInput
  }

  export type SubjectUpsertWithoutExamInput = {
    update: XOR<SubjectUpdateWithoutExamInput, SubjectUncheckedUpdateWithoutExamInput>
    create: XOR<SubjectCreateWithoutExamInput, SubjectUncheckedCreateWithoutExamInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutExamInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutExamInput, SubjectUncheckedUpdateWithoutExamInput>
  }

  export type SubjectUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutSubjectNestedInput
    teachingAssignments?: TeachingAssignmentUpdateManyWithoutSubjectNestedInput
    examResult?: ExamResultUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teachingAssignments?: TeachingAssignmentUncheckedUpdateManyWithoutSubjectNestedInput
    examResult?: ExamResultUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type OrganizationUpsertWithoutExamInput = {
    update: XOR<OrganizationUpdateWithoutExamInput, OrganizationUncheckedUpdateWithoutExamInput>
    create: XOR<OrganizationCreateWithoutExamInput, OrganizationUncheckedCreateWithoutExamInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutExamInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutExamInput, OrganizationUncheckedUpdateWithoutExamInput>
  }

  export type OrganizationUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUncheckedUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUncheckedUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUncheckedUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUncheckedUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUncheckedUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUncheckedUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUncheckedUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUncheckedUpdateManyWithoutOrganizationNestedInput
    hallTicket?: HallTicketUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type HallTicketUpsertWithWhereUniqueWithoutExamInput = {
    where: HallTicketWhereUniqueInput
    update: XOR<HallTicketUpdateWithoutExamInput, HallTicketUncheckedUpdateWithoutExamInput>
    create: XOR<HallTicketCreateWithoutExamInput, HallTicketUncheckedCreateWithoutExamInput>
  }

  export type HallTicketUpdateWithWhereUniqueWithoutExamInput = {
    where: HallTicketWhereUniqueInput
    data: XOR<HallTicketUpdateWithoutExamInput, HallTicketUncheckedUpdateWithoutExamInput>
  }

  export type HallTicketUpdateManyWithWhereWithoutExamInput = {
    where: HallTicketScalarWhereInput
    data: XOR<HallTicketUpdateManyMutationInput, HallTicketUncheckedUpdateManyWithoutExamInput>
  }

  export type ExamResultUpsertWithWhereUniqueWithoutExamInput = {
    where: ExamResultWhereUniqueInput
    update: XOR<ExamResultUpdateWithoutExamInput, ExamResultUncheckedUpdateWithoutExamInput>
    create: XOR<ExamResultCreateWithoutExamInput, ExamResultUncheckedCreateWithoutExamInput>
  }

  export type ExamResultUpdateWithWhereUniqueWithoutExamInput = {
    where: ExamResultWhereUniqueInput
    data: XOR<ExamResultUpdateWithoutExamInput, ExamResultUncheckedUpdateWithoutExamInput>
  }

  export type ExamResultUpdateManyWithWhereWithoutExamInput = {
    where: ExamResultScalarWhereInput
    data: XOR<ExamResultUpdateManyMutationInput, ExamResultUncheckedUpdateManyWithoutExamInput>
  }

  export type ExamEnrollmentUpsertWithWhereUniqueWithoutExamInput = {
    where: ExamEnrollmentWhereUniqueInput
    update: XOR<ExamEnrollmentUpdateWithoutExamInput, ExamEnrollmentUncheckedUpdateWithoutExamInput>
    create: XOR<ExamEnrollmentCreateWithoutExamInput, ExamEnrollmentUncheckedCreateWithoutExamInput>
  }

  export type ExamEnrollmentUpdateWithWhereUniqueWithoutExamInput = {
    where: ExamEnrollmentWhereUniqueInput
    data: XOR<ExamEnrollmentUpdateWithoutExamInput, ExamEnrollmentUncheckedUpdateWithoutExamInput>
  }

  export type ExamEnrollmentUpdateManyWithWhereWithoutExamInput = {
    where: ExamEnrollmentScalarWhereInput
    data: XOR<ExamEnrollmentUpdateManyMutationInput, ExamEnrollmentUncheckedUpdateManyWithoutExamInput>
  }

  export type StudentCreateWithoutExamEnrollmentInput = {
    id?: string
    firstName: string
    lastName: string
    middleName?: string | null
    motherName?: string | null
    fullName?: string | null
    dateOfBirth: Date | string
    profileImage?: string | null
    rollNumber: string
    phoneNumber: string
    whatsAppNumber: string
    email: string
    emergencyContact: string
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    section: SectionCreateNestedOneWithoutStudentsInput
    grade: GradeCreateNestedOneWithoutStudentsInput
    organization: OrganizationCreateNestedOneWithoutStudentInput
    Fee?: FeeCreateNestedManyWithoutStudentInput
    parents?: ParentStudentCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutStudentInput
    StudentDocument?: StudentDocumentCreateNestedManyWithoutStudentInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutStudentInput
    reportCard?: ReportCardCreateNestedManyWithoutStudentInput
    hallTicket?: HallTicketCreateNestedManyWithoutStudentInput
    examResult?: ExamResultCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutExamEnrollmentInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    middleName?: string | null
    motherName?: string | null
    fullName?: string | null
    dateOfBirth: Date | string
    profileImage?: string | null
    rollNumber: string
    phoneNumber: string
    whatsAppNumber: string
    email: string
    emergencyContact: string
    gender: $Enums.Gender
    sectionId: string
    gradeId: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Fee?: FeeUncheckedCreateNestedManyWithoutStudentInput
    parents?: ParentStudentUncheckedCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutStudentInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutStudentInput
    reportCard?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
    hallTicket?: HallTicketUncheckedCreateNestedManyWithoutStudentInput
    examResult?: ExamResultUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutExamEnrollmentInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutExamEnrollmentInput, StudentUncheckedCreateWithoutExamEnrollmentInput>
  }

  export type ExamCreateWithoutExamEnrollmentInput = {
    id?: string
    title: string
    description?: string | null
    gradeId: string
    sectionId: string
    maxMarks: number
    passingMarks?: number | null
    weightage?: number | null
    evaluationType: $Enums.EvaluationType
    mode: $Enums.ExamMode
    status?: $Enums.ExamStatus
    instructions?: string | null
    durationInMinutes?: number | null
    venueMapUrl?: string | null
    venue?: string | null
    isResultsPublished?: boolean
    supervisors?: ExamCreatesupervisorsInput | string[]
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    examSession: ExamSessionCreateNestedOneWithoutExamsInput
    subject: SubjectCreateNestedOneWithoutExamInput
    organization: OrganizationCreateNestedOneWithoutExamInput
    hallTickets?: HallTicketCreateNestedManyWithoutExamInput
    examResult?: ExamResultCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutExamEnrollmentInput = {
    id?: string
    title: string
    description?: string | null
    examSessionId: string
    subjectId: string
    gradeId: string
    sectionId: string
    organizationId: string
    maxMarks: number
    passingMarks?: number | null
    weightage?: number | null
    evaluationType: $Enums.EvaluationType
    mode: $Enums.ExamMode
    status?: $Enums.ExamStatus
    instructions?: string | null
    durationInMinutes?: number | null
    venueMapUrl?: string | null
    venue?: string | null
    isResultsPublished?: boolean
    supervisors?: ExamCreatesupervisorsInput | string[]
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    hallTickets?: HallTicketUncheckedCreateNestedManyWithoutExamInput
    examResult?: ExamResultUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutExamEnrollmentInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutExamEnrollmentInput, ExamUncheckedCreateWithoutExamEnrollmentInput>
  }

  export type StudentUpsertWithoutExamEnrollmentInput = {
    update: XOR<StudentUpdateWithoutExamEnrollmentInput, StudentUncheckedUpdateWithoutExamEnrollmentInput>
    create: XOR<StudentCreateWithoutExamEnrollmentInput, StudentUncheckedCreateWithoutExamEnrollmentInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutExamEnrollmentInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutExamEnrollmentInput, StudentUncheckedUpdateWithoutExamEnrollmentInput>
  }

  export type StudentUpdateWithoutExamEnrollmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emergencyContact?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    section?: SectionUpdateOneRequiredWithoutStudentsNestedInput
    grade?: GradeUpdateOneRequiredWithoutStudentsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutStudentNestedInput
    Fee?: FeeUpdateManyWithoutStudentNestedInput
    parents?: ParentStudentUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    StudentDocument?: StudentDocumentUpdateManyWithoutStudentNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutStudentNestedInput
    reportCard?: ReportCardUpdateManyWithoutStudentNestedInput
    hallTicket?: HallTicketUpdateManyWithoutStudentNestedInput
    examResult?: ExamResultUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutExamEnrollmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emergencyContact?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    sectionId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Fee?: FeeUncheckedUpdateManyWithoutStudentNestedInput
    parents?: ParentStudentUncheckedUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutStudentNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutStudentNestedInput
    reportCard?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
    hallTicket?: HallTicketUncheckedUpdateManyWithoutStudentNestedInput
    examResult?: ExamResultUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ExamUpsertWithoutExamEnrollmentInput = {
    update: XOR<ExamUpdateWithoutExamEnrollmentInput, ExamUncheckedUpdateWithoutExamEnrollmentInput>
    create: XOR<ExamCreateWithoutExamEnrollmentInput, ExamUncheckedCreateWithoutExamEnrollmentInput>
    where?: ExamWhereInput
  }

  export type ExamUpdateToOneWithWhereWithoutExamEnrollmentInput = {
    where?: ExamWhereInput
    data: XOR<ExamUpdateWithoutExamEnrollmentInput, ExamUncheckedUpdateWithoutExamEnrollmentInput>
  }

  export type ExamUpdateWithoutExamEnrollmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gradeId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    maxMarks?: FloatFieldUpdateOperationsInput | number
    passingMarks?: NullableFloatFieldUpdateOperationsInput | number | null
    weightage?: NullableFloatFieldUpdateOperationsInput | number | null
    evaluationType?: EnumEvaluationTypeFieldUpdateOperationsInput | $Enums.EvaluationType
    mode?: EnumExamModeFieldUpdateOperationsInput | $Enums.ExamMode
    status?: EnumExamStatusFieldUpdateOperationsInput | $Enums.ExamStatus
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    venueMapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    isResultsPublished?: BoolFieldUpdateOperationsInput | boolean
    supervisors?: ExamUpdatesupervisorsInput | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examSession?: ExamSessionUpdateOneRequiredWithoutExamsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutExamNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutExamNestedInput
    hallTickets?: HallTicketUpdateManyWithoutExamNestedInput
    examResult?: ExamResultUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutExamEnrollmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    examSessionId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    maxMarks?: FloatFieldUpdateOperationsInput | number
    passingMarks?: NullableFloatFieldUpdateOperationsInput | number | null
    weightage?: NullableFloatFieldUpdateOperationsInput | number | null
    evaluationType?: EnumEvaluationTypeFieldUpdateOperationsInput | $Enums.EvaluationType
    mode?: EnumExamModeFieldUpdateOperationsInput | $Enums.ExamMode
    status?: EnumExamStatusFieldUpdateOperationsInput | $Enums.ExamStatus
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    venueMapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    isResultsPublished?: BoolFieldUpdateOperationsInput | boolean
    supervisors?: ExamUpdatesupervisorsInput | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hallTickets?: HallTicketUncheckedUpdateManyWithoutExamNestedInput
    examResult?: ExamResultUncheckedUpdateManyWithoutExamNestedInput
  }

  export type StudentCreateWithoutExamResultInput = {
    id?: string
    firstName: string
    lastName: string
    middleName?: string | null
    motherName?: string | null
    fullName?: string | null
    dateOfBirth: Date | string
    profileImage?: string | null
    rollNumber: string
    phoneNumber: string
    whatsAppNumber: string
    email: string
    emergencyContact: string
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    section: SectionCreateNestedOneWithoutStudentsInput
    grade: GradeCreateNestedOneWithoutStudentsInput
    organization: OrganizationCreateNestedOneWithoutStudentInput
    Fee?: FeeCreateNestedManyWithoutStudentInput
    parents?: ParentStudentCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutStudentInput
    StudentDocument?: StudentDocumentCreateNestedManyWithoutStudentInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutStudentInput
    reportCard?: ReportCardCreateNestedManyWithoutStudentInput
    hallTicket?: HallTicketCreateNestedManyWithoutStudentInput
    examEnrollment?: ExamEnrollmentCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutExamResultInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    middleName?: string | null
    motherName?: string | null
    fullName?: string | null
    dateOfBirth: Date | string
    profileImage?: string | null
    rollNumber: string
    phoneNumber: string
    whatsAppNumber: string
    email: string
    emergencyContact: string
    gender: $Enums.Gender
    sectionId: string
    gradeId: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Fee?: FeeUncheckedCreateNestedManyWithoutStudentInput
    parents?: ParentStudentUncheckedCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutStudentInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutStudentInput
    reportCard?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
    hallTicket?: HallTicketUncheckedCreateNestedManyWithoutStudentInput
    examEnrollment?: ExamEnrollmentUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutExamResultInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutExamResultInput, StudentUncheckedCreateWithoutExamResultInput>
  }

  export type ExamCreateWithoutExamResultInput = {
    id?: string
    title: string
    description?: string | null
    gradeId: string
    sectionId: string
    maxMarks: number
    passingMarks?: number | null
    weightage?: number | null
    evaluationType: $Enums.EvaluationType
    mode: $Enums.ExamMode
    status?: $Enums.ExamStatus
    instructions?: string | null
    durationInMinutes?: number | null
    venueMapUrl?: string | null
    venue?: string | null
    isResultsPublished?: boolean
    supervisors?: ExamCreatesupervisorsInput | string[]
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    examSession: ExamSessionCreateNestedOneWithoutExamsInput
    subject: SubjectCreateNestedOneWithoutExamInput
    organization: OrganizationCreateNestedOneWithoutExamInput
    hallTickets?: HallTicketCreateNestedManyWithoutExamInput
    examEnrollment?: ExamEnrollmentCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutExamResultInput = {
    id?: string
    title: string
    description?: string | null
    examSessionId: string
    subjectId: string
    gradeId: string
    sectionId: string
    organizationId: string
    maxMarks: number
    passingMarks?: number | null
    weightage?: number | null
    evaluationType: $Enums.EvaluationType
    mode: $Enums.ExamMode
    status?: $Enums.ExamStatus
    instructions?: string | null
    durationInMinutes?: number | null
    venueMapUrl?: string | null
    venue?: string | null
    isResultsPublished?: boolean
    supervisors?: ExamCreatesupervisorsInput | string[]
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    hallTickets?: HallTicketUncheckedCreateNestedManyWithoutExamInput
    examEnrollment?: ExamEnrollmentUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutExamResultInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutExamResultInput, ExamUncheckedCreateWithoutExamResultInput>
  }

  export type SubjectCreateWithoutExamResultInput = {
    id?: string
    name: string
    code: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutSubjectInput
    teachingAssignments?: TeachingAssignmentCreateNestedManyWithoutSubjectInput
    exam?: ExamCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutExamResultInput = {
    id?: string
    name: string
    code: string
    description: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teachingAssignments?: TeachingAssignmentUncheckedCreateNestedManyWithoutSubjectInput
    exam?: ExamUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutExamResultInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutExamResultInput, SubjectUncheckedCreateWithoutExamResultInput>
  }

  export type StudentUpsertWithoutExamResultInput = {
    update: XOR<StudentUpdateWithoutExamResultInput, StudentUncheckedUpdateWithoutExamResultInput>
    create: XOR<StudentCreateWithoutExamResultInput, StudentUncheckedCreateWithoutExamResultInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutExamResultInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutExamResultInput, StudentUncheckedUpdateWithoutExamResultInput>
  }

  export type StudentUpdateWithoutExamResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emergencyContact?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    section?: SectionUpdateOneRequiredWithoutStudentsNestedInput
    grade?: GradeUpdateOneRequiredWithoutStudentsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutStudentNestedInput
    Fee?: FeeUpdateManyWithoutStudentNestedInput
    parents?: ParentStudentUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    StudentDocument?: StudentDocumentUpdateManyWithoutStudentNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutStudentNestedInput
    reportCard?: ReportCardUpdateManyWithoutStudentNestedInput
    hallTicket?: HallTicketUpdateManyWithoutStudentNestedInput
    examEnrollment?: ExamEnrollmentUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutExamResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emergencyContact?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    sectionId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Fee?: FeeUncheckedUpdateManyWithoutStudentNestedInput
    parents?: ParentStudentUncheckedUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutStudentNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutStudentNestedInput
    reportCard?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
    hallTicket?: HallTicketUncheckedUpdateManyWithoutStudentNestedInput
    examEnrollment?: ExamEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ExamUpsertWithoutExamResultInput = {
    update: XOR<ExamUpdateWithoutExamResultInput, ExamUncheckedUpdateWithoutExamResultInput>
    create: XOR<ExamCreateWithoutExamResultInput, ExamUncheckedCreateWithoutExamResultInput>
    where?: ExamWhereInput
  }

  export type ExamUpdateToOneWithWhereWithoutExamResultInput = {
    where?: ExamWhereInput
    data: XOR<ExamUpdateWithoutExamResultInput, ExamUncheckedUpdateWithoutExamResultInput>
  }

  export type ExamUpdateWithoutExamResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gradeId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    maxMarks?: FloatFieldUpdateOperationsInput | number
    passingMarks?: NullableFloatFieldUpdateOperationsInput | number | null
    weightage?: NullableFloatFieldUpdateOperationsInput | number | null
    evaluationType?: EnumEvaluationTypeFieldUpdateOperationsInput | $Enums.EvaluationType
    mode?: EnumExamModeFieldUpdateOperationsInput | $Enums.ExamMode
    status?: EnumExamStatusFieldUpdateOperationsInput | $Enums.ExamStatus
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    venueMapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    isResultsPublished?: BoolFieldUpdateOperationsInput | boolean
    supervisors?: ExamUpdatesupervisorsInput | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examSession?: ExamSessionUpdateOneRequiredWithoutExamsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutExamNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutExamNestedInput
    hallTickets?: HallTicketUpdateManyWithoutExamNestedInput
    examEnrollment?: ExamEnrollmentUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutExamResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    examSessionId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    maxMarks?: FloatFieldUpdateOperationsInput | number
    passingMarks?: NullableFloatFieldUpdateOperationsInput | number | null
    weightage?: NullableFloatFieldUpdateOperationsInput | number | null
    evaluationType?: EnumEvaluationTypeFieldUpdateOperationsInput | $Enums.EvaluationType
    mode?: EnumExamModeFieldUpdateOperationsInput | $Enums.ExamMode
    status?: EnumExamStatusFieldUpdateOperationsInput | $Enums.ExamStatus
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    venueMapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    isResultsPublished?: BoolFieldUpdateOperationsInput | boolean
    supervisors?: ExamUpdatesupervisorsInput | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hallTickets?: HallTicketUncheckedUpdateManyWithoutExamNestedInput
    examEnrollment?: ExamEnrollmentUncheckedUpdateManyWithoutExamNestedInput
  }

  export type SubjectUpsertWithoutExamResultInput = {
    update: XOR<SubjectUpdateWithoutExamResultInput, SubjectUncheckedUpdateWithoutExamResultInput>
    create: XOR<SubjectCreateWithoutExamResultInput, SubjectUncheckedCreateWithoutExamResultInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutExamResultInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutExamResultInput, SubjectUncheckedUpdateWithoutExamResultInput>
  }

  export type SubjectUpdateWithoutExamResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutSubjectNestedInput
    teachingAssignments?: TeachingAssignmentUpdateManyWithoutSubjectNestedInput
    exam?: ExamUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutExamResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teachingAssignments?: TeachingAssignmentUncheckedUpdateManyWithoutSubjectNestedInput
    exam?: ExamUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type StudentCreateWithoutHallTicketInput = {
    id?: string
    firstName: string
    lastName: string
    middleName?: string | null
    motherName?: string | null
    fullName?: string | null
    dateOfBirth: Date | string
    profileImage?: string | null
    rollNumber: string
    phoneNumber: string
    whatsAppNumber: string
    email: string
    emergencyContact: string
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    section: SectionCreateNestedOneWithoutStudentsInput
    grade: GradeCreateNestedOneWithoutStudentsInput
    organization: OrganizationCreateNestedOneWithoutStudentInput
    Fee?: FeeCreateNestedManyWithoutStudentInput
    parents?: ParentStudentCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutStudentInput
    StudentDocument?: StudentDocumentCreateNestedManyWithoutStudentInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutStudentInput
    reportCard?: ReportCardCreateNestedManyWithoutStudentInput
    examResult?: ExamResultCreateNestedManyWithoutStudentInput
    examEnrollment?: ExamEnrollmentCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutHallTicketInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    middleName?: string | null
    motherName?: string | null
    fullName?: string | null
    dateOfBirth: Date | string
    profileImage?: string | null
    rollNumber: string
    phoneNumber: string
    whatsAppNumber: string
    email: string
    emergencyContact: string
    gender: $Enums.Gender
    sectionId: string
    gradeId: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Fee?: FeeUncheckedCreateNestedManyWithoutStudentInput
    parents?: ParentStudentUncheckedCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutStudentInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutStudentInput
    reportCard?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
    examResult?: ExamResultUncheckedCreateNestedManyWithoutStudentInput
    examEnrollment?: ExamEnrollmentUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutHallTicketInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutHallTicketInput, StudentUncheckedCreateWithoutHallTicketInput>
  }

  export type ExamCreateWithoutHallTicketsInput = {
    id?: string
    title: string
    description?: string | null
    gradeId: string
    sectionId: string
    maxMarks: number
    passingMarks?: number | null
    weightage?: number | null
    evaluationType: $Enums.EvaluationType
    mode: $Enums.ExamMode
    status?: $Enums.ExamStatus
    instructions?: string | null
    durationInMinutes?: number | null
    venueMapUrl?: string | null
    venue?: string | null
    isResultsPublished?: boolean
    supervisors?: ExamCreatesupervisorsInput | string[]
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    examSession: ExamSessionCreateNestedOneWithoutExamsInput
    subject: SubjectCreateNestedOneWithoutExamInput
    organization: OrganizationCreateNestedOneWithoutExamInput
    examResult?: ExamResultCreateNestedManyWithoutExamInput
    examEnrollment?: ExamEnrollmentCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutHallTicketsInput = {
    id?: string
    title: string
    description?: string | null
    examSessionId: string
    subjectId: string
    gradeId: string
    sectionId: string
    organizationId: string
    maxMarks: number
    passingMarks?: number | null
    weightage?: number | null
    evaluationType: $Enums.EvaluationType
    mode: $Enums.ExamMode
    status?: $Enums.ExamStatus
    instructions?: string | null
    durationInMinutes?: number | null
    venueMapUrl?: string | null
    venue?: string | null
    isResultsPublished?: boolean
    supervisors?: ExamCreatesupervisorsInput | string[]
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    examResult?: ExamResultUncheckedCreateNestedManyWithoutExamInput
    examEnrollment?: ExamEnrollmentUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutHallTicketsInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutHallTicketsInput, ExamUncheckedCreateWithoutHallTicketsInput>
  }

  export type ExamSessionCreateWithoutHallTicketsInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicYear: AcademicYearCreateNestedOneWithoutExamSessionInput
    exams?: ExamCreateNestedManyWithoutExamSessionInput
    reportCards?: ReportCardCreateNestedManyWithoutExamSessionInput
  }

  export type ExamSessionUncheckedCreateWithoutHallTicketsInput = {
    id?: string
    title: string
    description?: string | null
    academicYearId: string
    startDate: Date | string
    endDate: Date | string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    exams?: ExamUncheckedCreateNestedManyWithoutExamSessionInput
    reportCards?: ReportCardUncheckedCreateNestedManyWithoutExamSessionInput
  }

  export type ExamSessionCreateOrConnectWithoutHallTicketsInput = {
    where: ExamSessionWhereUniqueInput
    create: XOR<ExamSessionCreateWithoutHallTicketsInput, ExamSessionUncheckedCreateWithoutHallTicketsInput>
  }

  export type OrganizationCreateWithoutHallTicketInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    notices?: NoticeCreateNestedManyWithoutOrganizationInput
    Student?: StudentCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentCreateNestedManyWithoutOrganizationInput
    Grade?: GradeCreateNestedManyWithoutOrganizationInput
    Section?: SectionCreateNestedManyWithoutOrganizationInput
    Fee?: FeeCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobCreateNestedManyWithoutOrganizationInput
    Exam?: ExamCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutHallTicketInput = {
    id?: string
    name?: string | null
    organizationSlug: string
    organizationLogo?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    isActive?: boolean
    isPaid?: boolean
    plan?: $Enums.PlanType
    planStartedAt?: Date | string | null
    planExpiresAt?: Date | string | null
    maxStudents?: number | null
    organizationType?: $Enums.OrganizationType | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    notices?: NoticeUncheckedCreateNestedManyWithoutOrganizationInput
    Student?: StudentUncheckedCreateNestedManyWithoutOrganizationInput
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutOrganizationInput
    Grade?: GradeUncheckedCreateNestedManyWithoutOrganizationInput
    Section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    Fee?: FeeUncheckedCreateNestedManyWithoutOrganizationInput
    FeeCategory?: FeeCategoryUncheckedCreateNestedManyWithoutOrganizationInput
    FeePayment?: FeePaymentUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicCalendar?: AcademicCalendarUncheckedCreateNestedManyWithoutOrganizationInput
    AnonymousComplaint?: AnonymousComplaintUncheckedCreateNestedManyWithoutOrganizationInput
    Teacher?: TeacherUncheckedCreateNestedManyWithoutOrganizationInput
    Subject?: SubjectUncheckedCreateNestedManyWithoutOrganizationInput
    TeachingAssignment?: TeachingAssignmentUncheckedCreateNestedManyWithoutOrganizationInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutOrganizationInput
    AcademicYear?: AcademicYearUncheckedCreateNestedManyWithoutOrganizationInput
    scheduledJob?: ScheduledJobUncheckedCreateNestedManyWithoutOrganizationInput
    Exam?: ExamUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutHallTicketInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutHallTicketInput, OrganizationUncheckedCreateWithoutHallTicketInput>
  }

  export type StudentUpsertWithoutHallTicketInput = {
    update: XOR<StudentUpdateWithoutHallTicketInput, StudentUncheckedUpdateWithoutHallTicketInput>
    create: XOR<StudentCreateWithoutHallTicketInput, StudentUncheckedCreateWithoutHallTicketInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutHallTicketInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutHallTicketInput, StudentUncheckedUpdateWithoutHallTicketInput>
  }

  export type StudentUpdateWithoutHallTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emergencyContact?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    section?: SectionUpdateOneRequiredWithoutStudentsNestedInput
    grade?: GradeUpdateOneRequiredWithoutStudentsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutStudentNestedInput
    Fee?: FeeUpdateManyWithoutStudentNestedInput
    parents?: ParentStudentUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    StudentDocument?: StudentDocumentUpdateManyWithoutStudentNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutStudentNestedInput
    reportCard?: ReportCardUpdateManyWithoutStudentNestedInput
    examResult?: ExamResultUpdateManyWithoutStudentNestedInput
    examEnrollment?: ExamEnrollmentUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutHallTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emergencyContact?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    sectionId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Fee?: FeeUncheckedUpdateManyWithoutStudentNestedInput
    parents?: ParentStudentUncheckedUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutStudentNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutStudentNestedInput
    reportCard?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
    examResult?: ExamResultUncheckedUpdateManyWithoutStudentNestedInput
    examEnrollment?: ExamEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ExamUpsertWithoutHallTicketsInput = {
    update: XOR<ExamUpdateWithoutHallTicketsInput, ExamUncheckedUpdateWithoutHallTicketsInput>
    create: XOR<ExamCreateWithoutHallTicketsInput, ExamUncheckedCreateWithoutHallTicketsInput>
    where?: ExamWhereInput
  }

  export type ExamUpdateToOneWithWhereWithoutHallTicketsInput = {
    where?: ExamWhereInput
    data: XOR<ExamUpdateWithoutHallTicketsInput, ExamUncheckedUpdateWithoutHallTicketsInput>
  }

  export type ExamUpdateWithoutHallTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gradeId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    maxMarks?: FloatFieldUpdateOperationsInput | number
    passingMarks?: NullableFloatFieldUpdateOperationsInput | number | null
    weightage?: NullableFloatFieldUpdateOperationsInput | number | null
    evaluationType?: EnumEvaluationTypeFieldUpdateOperationsInput | $Enums.EvaluationType
    mode?: EnumExamModeFieldUpdateOperationsInput | $Enums.ExamMode
    status?: EnumExamStatusFieldUpdateOperationsInput | $Enums.ExamStatus
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    venueMapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    isResultsPublished?: BoolFieldUpdateOperationsInput | boolean
    supervisors?: ExamUpdatesupervisorsInput | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examSession?: ExamSessionUpdateOneRequiredWithoutExamsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutExamNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutExamNestedInput
    examResult?: ExamResultUpdateManyWithoutExamNestedInput
    examEnrollment?: ExamEnrollmentUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutHallTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    examSessionId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    maxMarks?: FloatFieldUpdateOperationsInput | number
    passingMarks?: NullableFloatFieldUpdateOperationsInput | number | null
    weightage?: NullableFloatFieldUpdateOperationsInput | number | null
    evaluationType?: EnumEvaluationTypeFieldUpdateOperationsInput | $Enums.EvaluationType
    mode?: EnumExamModeFieldUpdateOperationsInput | $Enums.ExamMode
    status?: EnumExamStatusFieldUpdateOperationsInput | $Enums.ExamStatus
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    venueMapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    isResultsPublished?: BoolFieldUpdateOperationsInput | boolean
    supervisors?: ExamUpdatesupervisorsInput | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examResult?: ExamResultUncheckedUpdateManyWithoutExamNestedInput
    examEnrollment?: ExamEnrollmentUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ExamSessionUpsertWithoutHallTicketsInput = {
    update: XOR<ExamSessionUpdateWithoutHallTicketsInput, ExamSessionUncheckedUpdateWithoutHallTicketsInput>
    create: XOR<ExamSessionCreateWithoutHallTicketsInput, ExamSessionUncheckedCreateWithoutHallTicketsInput>
    where?: ExamSessionWhereInput
  }

  export type ExamSessionUpdateToOneWithWhereWithoutHallTicketsInput = {
    where?: ExamSessionWhereInput
    data: XOR<ExamSessionUpdateWithoutHallTicketsInput, ExamSessionUncheckedUpdateWithoutHallTicketsInput>
  }

  export type ExamSessionUpdateWithoutHallTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYear?: AcademicYearUpdateOneRequiredWithoutExamSessionNestedInput
    exams?: ExamUpdateManyWithoutExamSessionNestedInput
    reportCards?: ReportCardUpdateManyWithoutExamSessionNestedInput
  }

  export type ExamSessionUncheckedUpdateWithoutHallTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    academicYearId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exams?: ExamUncheckedUpdateManyWithoutExamSessionNestedInput
    reportCards?: ReportCardUncheckedUpdateManyWithoutExamSessionNestedInput
  }

  export type OrganizationUpsertWithoutHallTicketInput = {
    update: XOR<OrganizationUpdateWithoutHallTicketInput, OrganizationUncheckedUpdateWithoutHallTicketInput>
    create: XOR<OrganizationCreateWithoutHallTicketInput, OrganizationUncheckedCreateWithoutHallTicketInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutHallTicketInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutHallTicketInput, OrganizationUncheckedUpdateWithoutHallTicketInput>
  }

  export type OrganizationUpdateWithoutHallTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutHallTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    organizationSlug?: StringFieldUpdateOperationsInput | string
    organizationLogo?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    planStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    organizationType?: NullableEnumOrganizationTypeFieldUpdateOperationsInput | $Enums.OrganizationType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutOrganizationNestedInput
    Student?: StudentUncheckedUpdateManyWithoutOrganizationNestedInput
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutOrganizationNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutOrganizationNestedInput
    Section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Fee?: FeeUncheckedUpdateManyWithoutOrganizationNestedInput
    FeeCategory?: FeeCategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    FeePayment?: FeePaymentUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicCalendar?: AcademicCalendarUncheckedUpdateManyWithoutOrganizationNestedInput
    AnonymousComplaint?: AnonymousComplaintUncheckedUpdateManyWithoutOrganizationNestedInput
    Teacher?: TeacherUncheckedUpdateManyWithoutOrganizationNestedInput
    Subject?: SubjectUncheckedUpdateManyWithoutOrganizationNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutOrganizationNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutOrganizationNestedInput
    AcademicYear?: AcademicYearUncheckedUpdateManyWithoutOrganizationNestedInput
    scheduledJob?: ScheduledJobUncheckedUpdateManyWithoutOrganizationNestedInput
    Exam?: ExamUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type StudentCreateWithoutReportCardInput = {
    id?: string
    firstName: string
    lastName: string
    middleName?: string | null
    motherName?: string | null
    fullName?: string | null
    dateOfBirth: Date | string
    profileImage?: string | null
    rollNumber: string
    phoneNumber: string
    whatsAppNumber: string
    email: string
    emergencyContact: string
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    section: SectionCreateNestedOneWithoutStudentsInput
    grade: GradeCreateNestedOneWithoutStudentsInput
    organization: OrganizationCreateNestedOneWithoutStudentInput
    Fee?: FeeCreateNestedManyWithoutStudentInput
    parents?: ParentStudentCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceCreateNestedManyWithoutStudentInput
    StudentDocument?: StudentDocumentCreateNestedManyWithoutStudentInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutStudentInput
    hallTicket?: HallTicketCreateNestedManyWithoutStudentInput
    examResult?: ExamResultCreateNestedManyWithoutStudentInput
    examEnrollment?: ExamEnrollmentCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutReportCardInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    middleName?: string | null
    motherName?: string | null
    fullName?: string | null
    dateOfBirth: Date | string
    profileImage?: string | null
    rollNumber: string
    phoneNumber: string
    whatsAppNumber: string
    email: string
    emergencyContact: string
    gender: $Enums.Gender
    sectionId: string
    gradeId: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Fee?: FeeUncheckedCreateNestedManyWithoutStudentInput
    parents?: ParentStudentUncheckedCreateNestedManyWithoutStudentInput
    StudentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutStudentInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutStudentInput
    hallTicket?: HallTicketUncheckedCreateNestedManyWithoutStudentInput
    examResult?: ExamResultUncheckedCreateNestedManyWithoutStudentInput
    examEnrollment?: ExamEnrollmentUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutReportCardInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutReportCardInput, StudentUncheckedCreateWithoutReportCardInput>
  }

  export type ExamSessionCreateWithoutReportCardsInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicYear: AcademicYearCreateNestedOneWithoutExamSessionInput
    exams?: ExamCreateNestedManyWithoutExamSessionInput
    hallTickets?: HallTicketCreateNestedManyWithoutExamSessionInput
  }

  export type ExamSessionUncheckedCreateWithoutReportCardsInput = {
    id?: string
    title: string
    description?: string | null
    academicYearId: string
    startDate: Date | string
    endDate: Date | string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    exams?: ExamUncheckedCreateNestedManyWithoutExamSessionInput
    hallTickets?: HallTicketUncheckedCreateNestedManyWithoutExamSessionInput
  }

  export type ExamSessionCreateOrConnectWithoutReportCardsInput = {
    where: ExamSessionWhereUniqueInput
    create: XOR<ExamSessionCreateWithoutReportCardsInput, ExamSessionUncheckedCreateWithoutReportCardsInput>
  }

  export type StudentUpsertWithoutReportCardInput = {
    update: XOR<StudentUpdateWithoutReportCardInput, StudentUncheckedUpdateWithoutReportCardInput>
    create: XOR<StudentCreateWithoutReportCardInput, StudentUncheckedCreateWithoutReportCardInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutReportCardInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutReportCardInput, StudentUncheckedUpdateWithoutReportCardInput>
  }

  export type StudentUpdateWithoutReportCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emergencyContact?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    section?: SectionUpdateOneRequiredWithoutStudentsNestedInput
    grade?: GradeUpdateOneRequiredWithoutStudentsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutStudentNestedInput
    Fee?: FeeUpdateManyWithoutStudentNestedInput
    parents?: ParentStudentUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    StudentDocument?: StudentDocumentUpdateManyWithoutStudentNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutStudentNestedInput
    hallTicket?: HallTicketUpdateManyWithoutStudentNestedInput
    examResult?: ExamResultUpdateManyWithoutStudentNestedInput
    examEnrollment?: ExamEnrollmentUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutReportCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emergencyContact?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    sectionId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Fee?: FeeUncheckedUpdateManyWithoutStudentNestedInput
    parents?: ParentStudentUncheckedUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutStudentNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutStudentNestedInput
    hallTicket?: HallTicketUncheckedUpdateManyWithoutStudentNestedInput
    examResult?: ExamResultUncheckedUpdateManyWithoutStudentNestedInput
    examEnrollment?: ExamEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ExamSessionUpsertWithoutReportCardsInput = {
    update: XOR<ExamSessionUpdateWithoutReportCardsInput, ExamSessionUncheckedUpdateWithoutReportCardsInput>
    create: XOR<ExamSessionCreateWithoutReportCardsInput, ExamSessionUncheckedCreateWithoutReportCardsInput>
    where?: ExamSessionWhereInput
  }

  export type ExamSessionUpdateToOneWithWhereWithoutReportCardsInput = {
    where?: ExamSessionWhereInput
    data: XOR<ExamSessionUpdateWithoutReportCardsInput, ExamSessionUncheckedUpdateWithoutReportCardsInput>
  }

  export type ExamSessionUpdateWithoutReportCardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYear?: AcademicYearUpdateOneRequiredWithoutExamSessionNestedInput
    exams?: ExamUpdateManyWithoutExamSessionNestedInput
    hallTickets?: HallTicketUpdateManyWithoutExamSessionNestedInput
  }

  export type ExamSessionUncheckedUpdateWithoutReportCardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    academicYearId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exams?: ExamUncheckedUpdateManyWithoutExamSessionNestedInput
    hallTickets?: HallTicketUncheckedUpdateManyWithoutExamSessionNestedInput
  }

  export type AnonymousComplaintCreateManyAcademicYearInput = {
    id?: string
    trackingId: string
    category: string
    severity?: $Enums.Severity
    subject: string
    description: string
    evidenceUrls?: AnonymousComplaintCreateevidenceUrlsInput | string[]
    submittedAt?: Date | string
    currentStatus?: $Enums.ComplaintStatus
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoticeCreateManyAcademicYearInput = {
    id?: string
    noticeType: string
    title: string
    startDate: Date | string
    endDate: Date | string
    content: string
    summary?: string | null
    isNoticeApproved?: boolean
    isDraft?: boolean
    isPublished?: boolean
    emailNotification?: boolean
    pushNotification?: boolean
    WhatsAppNotification?: boolean
    smsNotification?: boolean
    targetAudience?: NoticeCreatetargetAudienceInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    publishedBy: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeachingAssignmentCreateManyAcademicYearInput = {
    id?: string
    teacherId: string
    subjectId: string
    gradeId: string
    sectionId: string
    organizationId: string
    academicYear?: string | null
    status?: $Enums.AssignmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAttendanceCreateManyAcademicYearInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    note?: string | null
    recordedBy: string
    studentId: string
    present?: boolean
    sectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicCalendarCreateManyAcademicYearInput = {
    id?: string
    organizationId: string
    name: string
    startDate: Date | string
    endDate: Date | string
    type: $Enums.CalendarEventType
    reason?: string | null
    isRecurring?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamSessionCreateManyAcademicYearInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnonymousComplaintUpdateWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    evidenceUrls?: AnonymousComplaintUpdateevidenceUrlsInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentStatus?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutAnonymousComplaintNestedInput
    ComplaintStatusTimeline?: ComplaintStatusTimelineUpdateManyWithoutComplaintNestedInput
  }

  export type AnonymousComplaintUncheckedUpdateWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    evidenceUrls?: AnonymousComplaintUpdateevidenceUrlsInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentStatus?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ComplaintStatusTimeline?: ComplaintStatusTimelineUncheckedUpdateManyWithoutComplaintNestedInput
  }

  export type AnonymousComplaintUncheckedUpdateManyWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    evidenceUrls?: AnonymousComplaintUpdateevidenceUrlsInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentStatus?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoticeUpdateWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    noticeType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isNoticeApproved?: BoolFieldUpdateOperationsInput | boolean
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    emailNotification?: BoolFieldUpdateOperationsInput | boolean
    pushNotification?: BoolFieldUpdateOperationsInput | boolean
    WhatsAppNotification?: BoolFieldUpdateOperationsInput | boolean
    smsNotification?: BoolFieldUpdateOperationsInput | boolean
    targetAudience?: NoticeUpdatetargetAudienceInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    publishedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Organization?: OrganizationUpdateOneRequiredWithoutNoticesNestedInput
  }

  export type NoticeUncheckedUpdateWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    noticeType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isNoticeApproved?: BoolFieldUpdateOperationsInput | boolean
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    emailNotification?: BoolFieldUpdateOperationsInput | boolean
    pushNotification?: BoolFieldUpdateOperationsInput | boolean
    WhatsAppNotification?: BoolFieldUpdateOperationsInput | boolean
    smsNotification?: BoolFieldUpdateOperationsInput | boolean
    targetAudience?: NoticeUpdatetargetAudienceInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    publishedBy?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoticeUncheckedUpdateManyWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    noticeType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isNoticeApproved?: BoolFieldUpdateOperationsInput | boolean
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    emailNotification?: BoolFieldUpdateOperationsInput | boolean
    pushNotification?: BoolFieldUpdateOperationsInput | boolean
    WhatsAppNotification?: BoolFieldUpdateOperationsInput | boolean
    smsNotification?: BoolFieldUpdateOperationsInput | boolean
    targetAudience?: NoticeUpdatetargetAudienceInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    publishedBy?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeachingAssignmentUpdateWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneRequiredWithoutTeachingAssignmentNestedInput
    subject?: SubjectUpdateOneRequiredWithoutTeachingAssignmentsNestedInput
    grade?: GradeUpdateOneRequiredWithoutTeachingAssignmentNestedInput
    section?: SectionUpdateOneRequiredWithoutTeachingAssignmentNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutTeachingAssignmentNestedInput
  }

  export type TeachingAssignmentUncheckedUpdateWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeachingAssignmentUncheckedUpdateManyWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceUpdateWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    present?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    section?: SectionUpdateOneRequiredWithoutStudentAttendanceNestedInput
    student?: StudentUpdateOneRequiredWithoutStudentAttendanceNestedInput
  }

  export type StudentAttendanceUncheckedUpdateWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    present?: BoolFieldUpdateOperationsInput | boolean
    sectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceUncheckedUpdateManyWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    present?: BoolFieldUpdateOperationsInput | boolean
    sectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicCalendarUpdateWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCalendarEventTypeFieldUpdateOperationsInput | $Enums.CalendarEventType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutAcademicCalendarNestedInput
  }

  export type AcademicCalendarUncheckedUpdateWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCalendarEventTypeFieldUpdateOperationsInput | $Enums.CalendarEventType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicCalendarUncheckedUpdateManyWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCalendarEventTypeFieldUpdateOperationsInput | $Enums.CalendarEventType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamSessionUpdateWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exams?: ExamUpdateManyWithoutExamSessionNestedInput
    reportCards?: ReportCardUpdateManyWithoutExamSessionNestedInput
    hallTickets?: HallTicketUpdateManyWithoutExamSessionNestedInput
  }

  export type ExamSessionUncheckedUpdateWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exams?: ExamUncheckedUpdateManyWithoutExamSessionNestedInput
    reportCards?: ReportCardUncheckedUpdateManyWithoutExamSessionNestedInput
    hallTickets?: HallTicketUncheckedUpdateManyWithoutExamSessionNestedInput
  }

  export type ExamSessionUncheckedUpdateManyWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyOrganizationInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password?: string | null
    profileImage: string
    role?: $Enums.Role
    clerkId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoticeCreateManyOrganizationInput = {
    id?: string
    noticeType: string
    title: string
    startDate: Date | string
    endDate: Date | string
    content: string
    summary?: string | null
    isNoticeApproved?: boolean
    isDraft?: boolean
    isPublished?: boolean
    emailNotification?: boolean
    pushNotification?: boolean
    WhatsAppNotification?: boolean
    smsNotification?: boolean
    targetAudience?: NoticeCreatetargetAudienceInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    publishedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicYearId?: string | null
  }

  export type StudentCreateManyOrganizationInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    middleName?: string | null
    motherName?: string | null
    fullName?: string | null
    dateOfBirth: Date | string
    profileImage?: string | null
    rollNumber: string
    phoneNumber: string
    whatsAppNumber: string
    email: string
    emergencyContact: string
    gender: $Enums.Gender
    sectionId: string
    gradeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentDocumentCreateManyOrganizationInput = {
    id?: string
    type: $Enums.DocumentType
    fileName?: string | null
    fileSize?: number | null
    fileType?: string | null
    documentUrl: string
    studentId: string
    verified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    rejected?: boolean
    rejectedBy?: string | null
    rejectedAt?: Date | string | null
    rejectReason?: string | null
    uploadedBy?: string | null
    uploadedAt?: Date | string
    note?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GradeCreateManyOrganizationInput = {
    id?: string
    grade: string
  }

  export type SectionCreateManyOrganizationInput = {
    id?: string
    name: string
    gradeId: string
    classTeacherId?: string | null
  }

  export type FeeCreateManyOrganizationInput = {
    id?: string
    totalFee: number
    paidAmount?: number
    pendingAmount?: number | null
    dueDate: Date | string
    status?: $Enums.FeeStatus
    studentId: string
    feeCategoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeeCategoryCreateManyOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeePaymentCreateManyOrganizationInput = {
    id?: string
    feeId: string
    amount: number
    status?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    receiptNumber: string
    note?: string | null
    transactionId?: string | null
    payerId: string
    platformFee?: number | null
    recordedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicCalendarCreateManyOrganizationInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    type: $Enums.CalendarEventType
    reason?: string | null
    isRecurring?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicYearId?: string | null
  }

  export type AnonymousComplaintCreateManyOrganizationInput = {
    id?: string
    trackingId: string
    category: string
    severity?: $Enums.Severity
    subject: string
    description: string
    evidenceUrls?: AnonymousComplaintCreateevidenceUrlsInput | string[]
    submittedAt?: Date | string
    currentStatus?: $Enums.ComplaintStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    academicYearId?: string | null
  }

  export type TeacherCreateManyOrganizationInput = {
    id?: string
    userId: string
    employeeCode?: string | null
    employmentStatus?: $Enums.EmploymentStatus
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectCreateManyOrganizationInput = {
    id?: string
    name: string
    code: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeachingAssignmentCreateManyOrganizationInput = {
    id?: string
    teacherId: string
    subjectId: string
    gradeId: string
    sectionId: string
    academicYear?: string | null
    status?: $Enums.AssignmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    academicYearId?: string | null
  }

  export type NotificationLogCreateManyOrganizationInput = {
    id?: string
    userId?: string | null
    parentId?: string | null
    studentId?: string | null
    channel: $Enums.NotificationChannel
    status?: $Enums.NotificationStatus
    notificationType: $Enums.NotificationType
    units?: number
    cost?: number
    sentAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicYearCreateManyOrganizationInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    type?: $Enums.YearType
    isCurrent?: boolean
    description?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledJobCreateManyOrganizationInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    type: $Enums.scheduledJobType
    scheduledAt: Date | string
    channels?: ScheduledJobCreatechannelsInput | $Enums.NotificationChannel[]
    status?: string
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamCreateManyOrganizationInput = {
    id?: string
    title: string
    description?: string | null
    examSessionId: string
    subjectId: string
    gradeId: string
    sectionId: string
    maxMarks: number
    passingMarks?: number | null
    weightage?: number | null
    evaluationType: $Enums.EvaluationType
    mode: $Enums.ExamMode
    status?: $Enums.ExamStatus
    instructions?: string | null
    durationInMinutes?: number | null
    venueMapUrl?: string | null
    venue?: string | null
    isResultsPublished?: boolean
    supervisors?: ExamCreatesupervisorsInput | string[]
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HallTicketCreateManyOrganizationInput = {
    id?: string
    studentId: string
    examId?: string | null
    examSessionId?: string | null
    pdfUrl: string
    qrCode?: string | null
    generatedAt?: Date | string
    downloadedAt?: Date | string | null
    expiryDate?: Date | string | null
  }

  export type UserUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    clerkId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    parent?: ParentUpdateOneWithoutUserNestedInput
    FeePayment?: FeePaymentUpdateManyWithoutPayerNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    clerkId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    parent?: ParentUncheckedUpdateOneWithoutUserNestedInput
    FeePayment?: FeePaymentUncheckedUpdateManyWithoutPayerNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    clerkId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoticeUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    noticeType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isNoticeApproved?: BoolFieldUpdateOperationsInput | boolean
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    emailNotification?: BoolFieldUpdateOperationsInput | boolean
    pushNotification?: BoolFieldUpdateOperationsInput | boolean
    WhatsAppNotification?: BoolFieldUpdateOperationsInput | boolean
    smsNotification?: BoolFieldUpdateOperationsInput | boolean
    targetAudience?: NoticeUpdatetargetAudienceInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    publishedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYear?: AcademicYearUpdateOneWithoutNoticesNestedInput
  }

  export type NoticeUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    noticeType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isNoticeApproved?: BoolFieldUpdateOperationsInput | boolean
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    emailNotification?: BoolFieldUpdateOperationsInput | boolean
    pushNotification?: BoolFieldUpdateOperationsInput | boolean
    WhatsAppNotification?: BoolFieldUpdateOperationsInput | boolean
    smsNotification?: BoolFieldUpdateOperationsInput | boolean
    targetAudience?: NoticeUpdatetargetAudienceInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    publishedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NoticeUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    noticeType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isNoticeApproved?: BoolFieldUpdateOperationsInput | boolean
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    emailNotification?: BoolFieldUpdateOperationsInput | boolean
    pushNotification?: BoolFieldUpdateOperationsInput | boolean
    WhatsAppNotification?: BoolFieldUpdateOperationsInput | boolean
    smsNotification?: BoolFieldUpdateOperationsInput | boolean
    targetAudience?: NoticeUpdatetargetAudienceInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    publishedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emergencyContact?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    section?: SectionUpdateOneRequiredWithoutStudentsNestedInput
    grade?: GradeUpdateOneRequiredWithoutStudentsNestedInput
    Fee?: FeeUpdateManyWithoutStudentNestedInput
    parents?: ParentStudentUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    StudentDocument?: StudentDocumentUpdateManyWithoutStudentNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutStudentNestedInput
    reportCard?: ReportCardUpdateManyWithoutStudentNestedInput
    hallTicket?: HallTicketUpdateManyWithoutStudentNestedInput
    examResult?: ExamResultUpdateManyWithoutStudentNestedInput
    examEnrollment?: ExamEnrollmentUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emergencyContact?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    sectionId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Fee?: FeeUncheckedUpdateManyWithoutStudentNestedInput
    parents?: ParentStudentUncheckedUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutStudentNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutStudentNestedInput
    reportCard?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
    hallTicket?: HallTicketUncheckedUpdateManyWithoutStudentNestedInput
    examResult?: ExamResultUncheckedUpdateManyWithoutStudentNestedInput
    examEnrollment?: ExamEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emergencyContact?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    sectionId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentDocumentUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected?: BoolFieldUpdateOperationsInput | boolean
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentDocumentNestedInput
  }

  export type StudentDocumentUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected?: BoolFieldUpdateOperationsInput | boolean
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentDocumentUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected?: BoolFieldUpdateOperationsInput | boolean
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    students?: StudentUpdateManyWithoutGradeNestedInput
    section?: SectionUpdateManyWithoutGradeNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutGradeNestedInput
  }

  export type GradeUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    students?: StudentUncheckedUpdateManyWithoutGradeNestedInput
    section?: SectionUncheckedUpdateManyWithoutGradeNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutGradeNestedInput
  }

  export type GradeUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
  }

  export type SectionUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    grade?: GradeUpdateOneRequiredWithoutSectionNestedInput
    classTeacher?: TeacherUpdateOneWithoutSectionNestedInput
    students?: StudentUpdateManyWithoutSectionNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutSectionNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    classTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    students?: StudentUncheckedUpdateManyWithoutSectionNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutSectionNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    classTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FeeUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalFee?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFeeStatusFieldUpdateOperationsInput | $Enums.FeeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutFeeNestedInput
    feeCategory?: FeeCategoryUpdateOneRequiredWithoutFeesNestedInput
    payments?: FeePaymentUpdateManyWithoutFeeNestedInput
  }

  export type FeeUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalFee?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFeeStatusFieldUpdateOperationsInput | $Enums.FeeStatus
    studentId?: StringFieldUpdateOperationsInput | string
    feeCategoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: FeePaymentUncheckedUpdateManyWithoutFeeNestedInput
  }

  export type FeeUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalFee?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFeeStatusFieldUpdateOperationsInput | $Enums.FeeStatus
    studentId?: StringFieldUpdateOperationsInput | string
    feeCategoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeCategoryUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fees?: FeeUpdateManyWithoutFeeCategoryNestedInput
  }

  export type FeeCategoryUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fees?: FeeUncheckedUpdateManyWithoutFeeCategoryNestedInput
  }

  export type FeeCategoryUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeePaymentUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fee?: FeeUpdateOneRequiredWithoutPaymentsNestedInput
    payer?: UserUpdateOneRequiredWithoutFeePaymentNestedInput
  }

  export type FeePaymentUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    feeId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    payerId?: StringFieldUpdateOperationsInput | string
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeePaymentUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    feeId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    payerId?: StringFieldUpdateOperationsInput | string
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicCalendarUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCalendarEventTypeFieldUpdateOperationsInput | $Enums.CalendarEventType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYear?: AcademicYearUpdateOneWithoutAcademicCalendarNestedInput
  }

  export type AcademicCalendarUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCalendarEventTypeFieldUpdateOperationsInput | $Enums.CalendarEventType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AcademicCalendarUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCalendarEventTypeFieldUpdateOperationsInput | $Enums.CalendarEventType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnonymousComplaintUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    evidenceUrls?: AnonymousComplaintUpdateevidenceUrlsInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentStatus?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ComplaintStatusTimeline?: ComplaintStatusTimelineUpdateManyWithoutComplaintNestedInput
    academicYear?: AcademicYearUpdateOneWithoutComplaintsNestedInput
  }

  export type AnonymousComplaintUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    evidenceUrls?: AnonymousComplaintUpdateevidenceUrlsInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentStatus?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null
    ComplaintStatusTimeline?: ComplaintStatusTimelineUncheckedUpdateManyWithoutComplaintNestedInput
  }

  export type AnonymousComplaintUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    evidenceUrls?: AnonymousComplaintUpdateevidenceUrlsInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentStatus?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeacherUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    profile?: TeacherProfileUpdateOneWithoutTeacherNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutTeacherNestedInput
    Section?: SectionUpdateManyWithoutClassTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: TeacherProfileUncheckedUpdateOneWithoutTeacherNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    Section?: SectionUncheckedUpdateManyWithoutClassTeacherNestedInput
  }

  export type TeacherUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: EnumEmploymentStatusFieldUpdateOperationsInput | $Enums.EmploymentStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teachingAssignments?: TeachingAssignmentUpdateManyWithoutSubjectNestedInput
    exam?: ExamUpdateManyWithoutSubjectNestedInput
    examResult?: ExamResultUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teachingAssignments?: TeachingAssignmentUncheckedUpdateManyWithoutSubjectNestedInput
    exam?: ExamUncheckedUpdateManyWithoutSubjectNestedInput
    examResult?: ExamResultUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeachingAssignmentUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneRequiredWithoutTeachingAssignmentNestedInput
    subject?: SubjectUpdateOneRequiredWithoutTeachingAssignmentsNestedInput
    grade?: GradeUpdateOneRequiredWithoutTeachingAssignmentNestedInput
    section?: SectionUpdateOneRequiredWithoutTeachingAssignmentNestedInput
    AcademicYear?: AcademicYearUpdateOneWithoutTeachingAssignmentNestedInput
  }

  export type TeachingAssignmentUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeachingAssignmentUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationLogUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    units?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutNotificationLogNestedInput
    parent?: ParentUpdateOneWithoutNotificationLogNestedInput
    student?: StudentUpdateOneWithoutNotificationLogNestedInput
  }

  export type NotificationLogUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    units?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    units?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicYearUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumYearTypeFieldUpdateOperationsInput | $Enums.YearType
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    complaints?: AnonymousComplaintUpdateManyWithoutAcademicYearNestedInput
    notices?: NoticeUpdateManyWithoutAcademicYearNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutAcademicYearNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutAcademicYearNestedInput
    AcademicCalendar?: AcademicCalendarUpdateManyWithoutAcademicYearNestedInput
    ExamSession?: ExamSessionUpdateManyWithoutAcademicYearNestedInput
  }

  export type AcademicYearUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumYearTypeFieldUpdateOperationsInput | $Enums.YearType
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    complaints?: AnonymousComplaintUncheckedUpdateManyWithoutAcademicYearNestedInput
    notices?: NoticeUncheckedUpdateManyWithoutAcademicYearNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutAcademicYearNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutAcademicYearNestedInput
    AcademicCalendar?: AcademicCalendarUncheckedUpdateManyWithoutAcademicYearNestedInput
    ExamSession?: ExamSessionUncheckedUpdateManyWithoutAcademicYearNestedInput
  }

  export type AcademicYearUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumYearTypeFieldUpdateOperationsInput | $Enums.YearType
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledJobUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    type?: EnumscheduledJobTypeFieldUpdateOperationsInput | $Enums.scheduledJobType
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channels?: ScheduledJobUpdatechannelsInput | $Enums.NotificationChannel[]
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledJobUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    type?: EnumscheduledJobTypeFieldUpdateOperationsInput | $Enums.scheduledJobType
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channels?: ScheduledJobUpdatechannelsInput | $Enums.NotificationChannel[]
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledJobUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    type?: EnumscheduledJobTypeFieldUpdateOperationsInput | $Enums.scheduledJobType
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channels?: ScheduledJobUpdatechannelsInput | $Enums.NotificationChannel[]
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gradeId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    maxMarks?: FloatFieldUpdateOperationsInput | number
    passingMarks?: NullableFloatFieldUpdateOperationsInput | number | null
    weightage?: NullableFloatFieldUpdateOperationsInput | number | null
    evaluationType?: EnumEvaluationTypeFieldUpdateOperationsInput | $Enums.EvaluationType
    mode?: EnumExamModeFieldUpdateOperationsInput | $Enums.ExamMode
    status?: EnumExamStatusFieldUpdateOperationsInput | $Enums.ExamStatus
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    venueMapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    isResultsPublished?: BoolFieldUpdateOperationsInput | boolean
    supervisors?: ExamUpdatesupervisorsInput | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examSession?: ExamSessionUpdateOneRequiredWithoutExamsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutExamNestedInput
    hallTickets?: HallTicketUpdateManyWithoutExamNestedInput
    examResult?: ExamResultUpdateManyWithoutExamNestedInput
    examEnrollment?: ExamEnrollmentUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    examSessionId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    maxMarks?: FloatFieldUpdateOperationsInput | number
    passingMarks?: NullableFloatFieldUpdateOperationsInput | number | null
    weightage?: NullableFloatFieldUpdateOperationsInput | number | null
    evaluationType?: EnumEvaluationTypeFieldUpdateOperationsInput | $Enums.EvaluationType
    mode?: EnumExamModeFieldUpdateOperationsInput | $Enums.ExamMode
    status?: EnumExamStatusFieldUpdateOperationsInput | $Enums.ExamStatus
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    venueMapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    isResultsPublished?: BoolFieldUpdateOperationsInput | boolean
    supervisors?: ExamUpdatesupervisorsInput | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hallTickets?: HallTicketUncheckedUpdateManyWithoutExamNestedInput
    examResult?: ExamResultUncheckedUpdateManyWithoutExamNestedInput
    examEnrollment?: ExamEnrollmentUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    examSessionId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    maxMarks?: FloatFieldUpdateOperationsInput | number
    passingMarks?: NullableFloatFieldUpdateOperationsInput | number | null
    weightage?: NullableFloatFieldUpdateOperationsInput | number | null
    evaluationType?: EnumEvaluationTypeFieldUpdateOperationsInput | $Enums.EvaluationType
    mode?: EnumExamModeFieldUpdateOperationsInput | $Enums.ExamMode
    status?: EnumExamStatusFieldUpdateOperationsInput | $Enums.ExamStatus
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    venueMapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    isResultsPublished?: BoolFieldUpdateOperationsInput | boolean
    supervisors?: ExamUpdatesupervisorsInput | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HallTicketUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pdfUrl?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student?: StudentUpdateOneRequiredWithoutHallTicketNestedInput
    exam?: ExamUpdateOneWithoutHallTicketsNestedInput
    examSession?: ExamSessionUpdateOneWithoutHallTicketsNestedInput
  }

  export type HallTicketUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    examSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HallTicketUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    examSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FeePaymentCreateManyPayerInput = {
    id?: string
    feeId: string
    amount: number
    status?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    receiptNumber: string
    note?: string | null
    transactionId?: string | null
    platformFee?: number | null
    recordedBy?: string | null
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationLogCreateManyUserInput = {
    id?: string
    organizationId: string
    parentId?: string | null
    studentId?: string | null
    channel: $Enums.NotificationChannel
    status?: $Enums.NotificationStatus
    notificationType: $Enums.NotificationType
    units?: number
    cost?: number
    sentAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeePaymentUpdateWithoutPayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fee?: FeeUpdateOneRequiredWithoutPaymentsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutFeePaymentNestedInput
  }

  export type FeePaymentUncheckedUpdateWithoutPayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    feeId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeePaymentUncheckedUpdateManyWithoutPayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    feeId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    units?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutNotificationLogNestedInput
    parent?: ParentUpdateOneWithoutNotificationLogNestedInput
    student?: StudentUpdateOneWithoutNotificationLogNestedInput
  }

  export type NotificationLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    units?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    units?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateManyGradeInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    middleName?: string | null
    motherName?: string | null
    fullName?: string | null
    dateOfBirth: Date | string
    profileImage?: string | null
    rollNumber: string
    phoneNumber: string
    whatsAppNumber: string
    email: string
    emergencyContact: string
    gender: $Enums.Gender
    sectionId: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SectionCreateManyGradeInput = {
    id?: string
    name: string
    organizationId: string
    classTeacherId?: string | null
  }

  export type TeachingAssignmentCreateManyGradeInput = {
    id?: string
    teacherId: string
    subjectId: string
    sectionId: string
    organizationId: string
    academicYear?: string | null
    status?: $Enums.AssignmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    academicYearId?: string | null
  }

  export type StudentUpdateWithoutGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emergencyContact?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    section?: SectionUpdateOneRequiredWithoutStudentsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutStudentNestedInput
    Fee?: FeeUpdateManyWithoutStudentNestedInput
    parents?: ParentStudentUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    StudentDocument?: StudentDocumentUpdateManyWithoutStudentNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutStudentNestedInput
    reportCard?: ReportCardUpdateManyWithoutStudentNestedInput
    hallTicket?: HallTicketUpdateManyWithoutStudentNestedInput
    examResult?: ExamResultUpdateManyWithoutStudentNestedInput
    examEnrollment?: ExamEnrollmentUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emergencyContact?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    sectionId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Fee?: FeeUncheckedUpdateManyWithoutStudentNestedInput
    parents?: ParentStudentUncheckedUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutStudentNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutStudentNestedInput
    reportCard?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
    hallTicket?: HallTicketUncheckedUpdateManyWithoutStudentNestedInput
    examResult?: ExamResultUncheckedUpdateManyWithoutStudentNestedInput
    examEnrollment?: ExamEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emergencyContact?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    sectionId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionUpdateWithoutGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: OrganizationUpdateOneRequiredWithoutSectionNestedInput
    classTeacher?: TeacherUpdateOneWithoutSectionNestedInput
    students?: StudentUpdateManyWithoutSectionNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutSectionNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    classTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    students?: StudentUncheckedUpdateManyWithoutSectionNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutSectionNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateManyWithoutGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    classTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeachingAssignmentUpdateWithoutGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneRequiredWithoutTeachingAssignmentNestedInput
    subject?: SubjectUpdateOneRequiredWithoutTeachingAssignmentsNestedInput
    section?: SectionUpdateOneRequiredWithoutTeachingAssignmentNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutTeachingAssignmentNestedInput
    AcademicYear?: AcademicYearUpdateOneWithoutTeachingAssignmentNestedInput
  }

  export type TeachingAssignmentUncheckedUpdateWithoutGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeachingAssignmentUncheckedUpdateManyWithoutGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentCreateManySectionInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    middleName?: string | null
    motherName?: string | null
    fullName?: string | null
    dateOfBirth: Date | string
    profileImage?: string | null
    rollNumber: string
    phoneNumber: string
    whatsAppNumber: string
    email: string
    emergencyContact: string
    gender: $Enums.Gender
    gradeId: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAttendanceCreateManySectionInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    note?: string | null
    recordedBy: string
    studentId: string
    present?: boolean
    academicYearId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeachingAssignmentCreateManySectionInput = {
    id?: string
    teacherId: string
    subjectId: string
    gradeId: string
    organizationId: string
    academicYear?: string | null
    status?: $Enums.AssignmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    academicYearId?: string | null
  }

  export type StudentUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emergencyContact?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    grade?: GradeUpdateOneRequiredWithoutStudentsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutStudentNestedInput
    Fee?: FeeUpdateManyWithoutStudentNestedInput
    parents?: ParentStudentUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    StudentDocument?: StudentDocumentUpdateManyWithoutStudentNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutStudentNestedInput
    reportCard?: ReportCardUpdateManyWithoutStudentNestedInput
    hallTicket?: HallTicketUpdateManyWithoutStudentNestedInput
    examResult?: ExamResultUpdateManyWithoutStudentNestedInput
    examEnrollment?: ExamEnrollmentUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emergencyContact?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    gradeId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Fee?: FeeUncheckedUpdateManyWithoutStudentNestedInput
    parents?: ParentStudentUncheckedUpdateManyWithoutStudentNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutStudentNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutStudentNestedInput
    reportCard?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
    hallTicket?: HallTicketUncheckedUpdateManyWithoutStudentNestedInput
    examResult?: ExamResultUncheckedUpdateManyWithoutStudentNestedInput
    examEnrollment?: ExamEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    whatsAppNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emergencyContact?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    gradeId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    present?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentAttendanceNestedInput
    academicYear?: AcademicYearUpdateOneWithoutStudentAttendanceNestedInput
  }

  export type StudentAttendanceUncheckedUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    present?: BoolFieldUpdateOperationsInput | boolean
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceUncheckedUpdateManyWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    present?: BoolFieldUpdateOperationsInput | boolean
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeachingAssignmentUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneRequiredWithoutTeachingAssignmentNestedInput
    subject?: SubjectUpdateOneRequiredWithoutTeachingAssignmentsNestedInput
    grade?: GradeUpdateOneRequiredWithoutTeachingAssignmentNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutTeachingAssignmentNestedInput
    AcademicYear?: AcademicYearUpdateOneWithoutTeachingAssignmentNestedInput
  }

  export type TeachingAssignmentUncheckedUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeachingAssignmentUncheckedUpdateManyWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeachingAssignmentCreateManyTeacherInput = {
    id?: string
    subjectId: string
    gradeId: string
    sectionId: string
    organizationId: string
    academicYear?: string | null
    status?: $Enums.AssignmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    academicYearId?: string | null
  }

  export type SectionCreateManyClassTeacherInput = {
    id?: string
    name: string
    gradeId: string
    organizationId: string
  }

  export type TeachingAssignmentUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneRequiredWithoutTeachingAssignmentsNestedInput
    grade?: GradeUpdateOneRequiredWithoutTeachingAssignmentNestedInput
    section?: SectionUpdateOneRequiredWithoutTeachingAssignmentNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutTeachingAssignmentNestedInput
    AcademicYear?: AcademicYearUpdateOneWithoutTeachingAssignmentNestedInput
  }

  export type TeachingAssignmentUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeachingAssignmentUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SectionUpdateWithoutClassTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    grade?: GradeUpdateOneRequiredWithoutSectionNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutSectionNestedInput
    students?: StudentUpdateManyWithoutSectionNestedInput
    StudentAttendance?: StudentAttendanceUpdateManyWithoutSectionNestedInput
    TeachingAssignment?: TeachingAssignmentUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutClassTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    students?: StudentUncheckedUpdateManyWithoutSectionNestedInput
    StudentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutSectionNestedInput
    TeachingAssignment?: TeachingAssignmentUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateManyWithoutClassTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type TeachingAssignmentCreateManySubjectInput = {
    id?: string
    teacherId: string
    gradeId: string
    sectionId: string
    organizationId: string
    academicYear?: string | null
    status?: $Enums.AssignmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    academicYearId?: string | null
  }

  export type ExamCreateManySubjectInput = {
    id?: string
    title: string
    description?: string | null
    examSessionId: string
    gradeId: string
    sectionId: string
    organizationId: string
    maxMarks: number
    passingMarks?: number | null
    weightage?: number | null
    evaluationType: $Enums.EvaluationType
    mode: $Enums.ExamMode
    status?: $Enums.ExamStatus
    instructions?: string | null
    durationInMinutes?: number | null
    venueMapUrl?: string | null
    venue?: string | null
    isResultsPublished?: boolean
    supervisors?: ExamCreatesupervisorsInput | string[]
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamResultCreateManySubjectInput = {
    id?: string
    studentId: string
    examId: string
    maxMarks: number
    obtainedMarks?: number | null
    percentage?: number | null
    gradeLabel?: string | null
    remarks?: string | null
    isPassed?: boolean | null
    isAbsent?: boolean
    isResultsPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeachingAssignmentUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneRequiredWithoutTeachingAssignmentNestedInput
    grade?: GradeUpdateOneRequiredWithoutTeachingAssignmentNestedInput
    section?: SectionUpdateOneRequiredWithoutTeachingAssignmentNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutTeachingAssignmentNestedInput
    AcademicYear?: AcademicYearUpdateOneWithoutTeachingAssignmentNestedInput
  }

  export type TeachingAssignmentUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeachingAssignmentUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExamUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gradeId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    maxMarks?: FloatFieldUpdateOperationsInput | number
    passingMarks?: NullableFloatFieldUpdateOperationsInput | number | null
    weightage?: NullableFloatFieldUpdateOperationsInput | number | null
    evaluationType?: EnumEvaluationTypeFieldUpdateOperationsInput | $Enums.EvaluationType
    mode?: EnumExamModeFieldUpdateOperationsInput | $Enums.ExamMode
    status?: EnumExamStatusFieldUpdateOperationsInput | $Enums.ExamStatus
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    venueMapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    isResultsPublished?: BoolFieldUpdateOperationsInput | boolean
    supervisors?: ExamUpdatesupervisorsInput | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examSession?: ExamSessionUpdateOneRequiredWithoutExamsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutExamNestedInput
    hallTickets?: HallTicketUpdateManyWithoutExamNestedInput
    examResult?: ExamResultUpdateManyWithoutExamNestedInput
    examEnrollment?: ExamEnrollmentUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    examSessionId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    maxMarks?: FloatFieldUpdateOperationsInput | number
    passingMarks?: NullableFloatFieldUpdateOperationsInput | number | null
    weightage?: NullableFloatFieldUpdateOperationsInput | number | null
    evaluationType?: EnumEvaluationTypeFieldUpdateOperationsInput | $Enums.EvaluationType
    mode?: EnumExamModeFieldUpdateOperationsInput | $Enums.ExamMode
    status?: EnumExamStatusFieldUpdateOperationsInput | $Enums.ExamStatus
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    venueMapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    isResultsPublished?: BoolFieldUpdateOperationsInput | boolean
    supervisors?: ExamUpdatesupervisorsInput | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hallTickets?: HallTicketUncheckedUpdateManyWithoutExamNestedInput
    examResult?: ExamResultUncheckedUpdateManyWithoutExamNestedInput
    examEnrollment?: ExamEnrollmentUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    examSessionId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    maxMarks?: FloatFieldUpdateOperationsInput | number
    passingMarks?: NullableFloatFieldUpdateOperationsInput | number | null
    weightage?: NullableFloatFieldUpdateOperationsInput | number | null
    evaluationType?: EnumEvaluationTypeFieldUpdateOperationsInput | $Enums.EvaluationType
    mode?: EnumExamModeFieldUpdateOperationsInput | $Enums.ExamMode
    status?: EnumExamStatusFieldUpdateOperationsInput | $Enums.ExamStatus
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    venueMapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    isResultsPublished?: BoolFieldUpdateOperationsInput | boolean
    supervisors?: ExamUpdatesupervisorsInput | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamResultUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    maxMarks?: FloatFieldUpdateOperationsInput | number
    obtainedMarks?: NullableFloatFieldUpdateOperationsInput | number | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    gradeLabel?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAbsent?: BoolFieldUpdateOperationsInput | boolean
    isResultsPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutExamResultNestedInput
    exam?: ExamUpdateOneRequiredWithoutExamResultNestedInput
  }

  export type ExamResultUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    maxMarks?: FloatFieldUpdateOperationsInput | number
    obtainedMarks?: NullableFloatFieldUpdateOperationsInput | number | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    gradeLabel?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAbsent?: BoolFieldUpdateOperationsInput | boolean
    isResultsPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamResultUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    maxMarks?: FloatFieldUpdateOperationsInput | number
    obtainedMarks?: NullableFloatFieldUpdateOperationsInput | number | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    gradeLabel?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAbsent?: BoolFieldUpdateOperationsInput | boolean
    isResultsPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeCreateManyStudentInput = {
    id?: string
    totalFee: number
    paidAmount?: number
    pendingAmount?: number | null
    dueDate: Date | string
    status?: $Enums.FeeStatus
    feeCategoryId: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParentStudentCreateManyStudentInput = {
    id?: string
    relationship: string
    parentId: string
    isPrimary?: boolean | null
  }

  export type StudentAttendanceCreateManyStudentInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    note?: string | null
    recordedBy: string
    present?: boolean
    sectionId: string
    academicYearId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentDocumentCreateManyStudentInput = {
    id?: string
    type: $Enums.DocumentType
    fileName?: string | null
    fileSize?: number | null
    fileType?: string | null
    documentUrl: string
    verified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    rejected?: boolean
    rejectedBy?: string | null
    rejectedAt?: Date | string | null
    rejectReason?: string | null
    uploadedBy?: string | null
    uploadedAt?: Date | string
    note?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId: string
  }

  export type NotificationLogCreateManyStudentInput = {
    id?: string
    organizationId: string
    userId?: string | null
    parentId?: string | null
    channel: $Enums.NotificationChannel
    status?: $Enums.NotificationStatus
    notificationType: $Enums.NotificationType
    units?: number
    cost?: number
    sentAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCardCreateManyStudentInput = {
    id?: string
    examSessionId: string
    totalMaxMarks: number
    totalObtained: number
    percentage: number
    cgpa?: number | null
    overallGrade: string
    resultStatus: $Enums.ResultStatus
    classRank?: number | null
    gradeRank?: number | null
    attendancePercent?: number | null
    conductGrade?: string | null
    remarks?: string | null
    principalRemarks?: string | null
    rank?: number | null
    pdfUrl?: string | null
    generatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HallTicketCreateManyStudentInput = {
    id?: string
    examId?: string | null
    examSessionId?: string | null
    pdfUrl: string
    qrCode?: string | null
    generatedAt?: Date | string
    downloadedAt?: Date | string | null
    expiryDate?: Date | string | null
    organizationId: string
  }

  export type ExamResultCreateManyStudentInput = {
    id?: string
    examId: string
    subjectId?: string | null
    maxMarks: number
    obtainedMarks?: number | null
    percentage?: number | null
    gradeLabel?: string | null
    remarks?: string | null
    isPassed?: boolean | null
    isAbsent?: boolean
    isResultsPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamEnrollmentCreateManyStudentInput = {
    id?: string
    examId: string
    status?: $Enums.StudentExamStatus
    enrolledAt?: Date | string
    exemptionReason?: string | null
  }

  export type FeeUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalFee?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFeeStatusFieldUpdateOperationsInput | $Enums.FeeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feeCategory?: FeeCategoryUpdateOneRequiredWithoutFeesNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutFeeNestedInput
    payments?: FeePaymentUpdateManyWithoutFeeNestedInput
  }

  export type FeeUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalFee?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFeeStatusFieldUpdateOperationsInput | $Enums.FeeStatus
    feeCategoryId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: FeePaymentUncheckedUpdateManyWithoutFeeNestedInput
  }

  export type FeeUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalFee?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFeeStatusFieldUpdateOperationsInput | $Enums.FeeStatus
    feeCategoryId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentStudentUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    isPrimary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parent?: ParentUpdateOneRequiredWithoutStudentsNestedInput
  }

  export type ParentStudentUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    isPrimary?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ParentStudentUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    isPrimary?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type StudentAttendanceUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    present?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    section?: SectionUpdateOneRequiredWithoutStudentAttendanceNestedInput
    academicYear?: AcademicYearUpdateOneWithoutStudentAttendanceNestedInput
  }

  export type StudentAttendanceUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    present?: BoolFieldUpdateOperationsInput | boolean
    sectionId?: StringFieldUpdateOperationsInput | string
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    present?: BoolFieldUpdateOperationsInput | boolean
    sectionId?: StringFieldUpdateOperationsInput | string
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentDocumentUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected?: BoolFieldUpdateOperationsInput | boolean
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Organization?: OrganizationUpdateOneWithoutStudentDocumentNestedInput
  }

  export type StudentDocumentUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected?: BoolFieldUpdateOperationsInput | boolean
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentDocumentUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected?: BoolFieldUpdateOperationsInput | boolean
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationLogUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    units?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutNotificationLogNestedInput
    user?: UserUpdateOneWithoutNotificationLogNestedInput
    parent?: ParentUpdateOneWithoutNotificationLogNestedInput
  }

  export type NotificationLogUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    units?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    units?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCardUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalMaxMarks?: FloatFieldUpdateOperationsInput | number
    totalObtained?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    overallGrade?: StringFieldUpdateOperationsInput | string
    resultStatus?: EnumResultStatusFieldUpdateOperationsInput | $Enums.ResultStatus
    classRank?: NullableIntFieldUpdateOperationsInput | number | null
    gradeRank?: NullableIntFieldUpdateOperationsInput | number | null
    attendancePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    conductGrade?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    principalRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examSession?: ExamSessionUpdateOneRequiredWithoutReportCardsNestedInput
  }

  export type ReportCardUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    examSessionId?: StringFieldUpdateOperationsInput | string
    totalMaxMarks?: FloatFieldUpdateOperationsInput | number
    totalObtained?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    overallGrade?: StringFieldUpdateOperationsInput | string
    resultStatus?: EnumResultStatusFieldUpdateOperationsInput | $Enums.ResultStatus
    classRank?: NullableIntFieldUpdateOperationsInput | number | null
    gradeRank?: NullableIntFieldUpdateOperationsInput | number | null
    attendancePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    conductGrade?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    principalRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCardUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    examSessionId?: StringFieldUpdateOperationsInput | string
    totalMaxMarks?: FloatFieldUpdateOperationsInput | number
    totalObtained?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    overallGrade?: StringFieldUpdateOperationsInput | string
    resultStatus?: EnumResultStatusFieldUpdateOperationsInput | $Enums.ResultStatus
    classRank?: NullableIntFieldUpdateOperationsInput | number | null
    gradeRank?: NullableIntFieldUpdateOperationsInput | number | null
    attendancePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    conductGrade?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    principalRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HallTicketUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    pdfUrl?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exam?: ExamUpdateOneWithoutHallTicketsNestedInput
    examSession?: ExamSessionUpdateOneWithoutHallTicketsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutHallTicketNestedInput
  }

  export type HallTicketUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    examSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type HallTicketUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    examSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type ExamResultUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    maxMarks?: FloatFieldUpdateOperationsInput | number
    obtainedMarks?: NullableFloatFieldUpdateOperationsInput | number | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    gradeLabel?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAbsent?: BoolFieldUpdateOperationsInput | boolean
    isResultsPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exam?: ExamUpdateOneRequiredWithoutExamResultNestedInput
    subject?: SubjectUpdateOneWithoutExamResultNestedInput
  }

  export type ExamResultUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMarks?: FloatFieldUpdateOperationsInput | number
    obtainedMarks?: NullableFloatFieldUpdateOperationsInput | number | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    gradeLabel?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAbsent?: BoolFieldUpdateOperationsInput | boolean
    isResultsPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamResultUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMarks?: FloatFieldUpdateOperationsInput | number
    obtainedMarks?: NullableFloatFieldUpdateOperationsInput | number | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    gradeLabel?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAbsent?: BoolFieldUpdateOperationsInput | boolean
    isResultsPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamEnrollmentUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStudentExamStatusFieldUpdateOperationsInput | $Enums.StudentExamStatus
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exemptionReason?: NullableStringFieldUpdateOperationsInput | string | null
    exam?: ExamUpdateOneRequiredWithoutExamEnrollmentNestedInput
  }

  export type ExamEnrollmentUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    status?: EnumStudentExamStatusFieldUpdateOperationsInput | $Enums.StudentExamStatus
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exemptionReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExamEnrollmentUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    status?: EnumStudentExamStatusFieldUpdateOperationsInput | $Enums.StudentExamStatus
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exemptionReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ParentStudentCreateManyParentInput = {
    id?: string
    relationship: string
    studentId: string
    isPrimary?: boolean | null
  }

  export type NotificationLogCreateManyParentInput = {
    id?: string
    organizationId: string
    userId?: string | null
    studentId?: string | null
    channel: $Enums.NotificationChannel
    status?: $Enums.NotificationStatus
    notificationType: $Enums.NotificationType
    units?: number
    cost?: number
    sentAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParentStudentUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    isPrimary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    student?: StudentUpdateOneRequiredWithoutParentsNestedInput
  }

  export type ParentStudentUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    isPrimary?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ParentStudentUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    isPrimary?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type NotificationLogUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    units?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutNotificationLogNestedInput
    user?: UserUpdateOneWithoutNotificationLogNestedInput
    student?: StudentUpdateOneWithoutNotificationLogNestedInput
  }

  export type NotificationLogUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    units?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    units?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeePaymentCreateManyFeeInput = {
    id?: string
    amount: number
    status?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    receiptNumber: string
    note?: string | null
    transactionId?: string | null
    payerId: string
    platformFee?: number | null
    recordedBy?: string | null
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeePaymentUpdateWithoutFeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payer?: UserUpdateOneRequiredWithoutFeePaymentNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutFeePaymentNestedInput
  }

  export type FeePaymentUncheckedUpdateWithoutFeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    payerId?: StringFieldUpdateOperationsInput | string
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeePaymentUncheckedUpdateManyWithoutFeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    payerId?: StringFieldUpdateOperationsInput | string
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeCreateManyFeeCategoryInput = {
    id?: string
    totalFee: number
    paidAmount?: number
    pendingAmount?: number | null
    dueDate: Date | string
    status?: $Enums.FeeStatus
    studentId: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeeUpdateWithoutFeeCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalFee?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFeeStatusFieldUpdateOperationsInput | $Enums.FeeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutFeeNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutFeeNestedInput
    payments?: FeePaymentUpdateManyWithoutFeeNestedInput
  }

  export type FeeUncheckedUpdateWithoutFeeCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalFee?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFeeStatusFieldUpdateOperationsInput | $Enums.FeeStatus
    studentId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: FeePaymentUncheckedUpdateManyWithoutFeeNestedInput
  }

  export type FeeUncheckedUpdateManyWithoutFeeCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalFee?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFeeStatusFieldUpdateOperationsInput | $Enums.FeeStatus
    studentId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintStatusTimelineCreateManyComplaintInput = {
    id?: string
    note?: string | null
    status?: $Enums.ComplaintStatus
    changedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplaintStatusTimelineUpdateWithoutComplaintInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintStatusTimelineUncheckedUpdateWithoutComplaintInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintStatusTimelineUncheckedUpdateManyWithoutComplaintInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamCreateManyExamSessionInput = {
    id?: string
    title: string
    description?: string | null
    subjectId: string
    gradeId: string
    sectionId: string
    organizationId: string
    maxMarks: number
    passingMarks?: number | null
    weightage?: number | null
    evaluationType: $Enums.EvaluationType
    mode: $Enums.ExamMode
    status?: $Enums.ExamStatus
    instructions?: string | null
    durationInMinutes?: number | null
    venueMapUrl?: string | null
    venue?: string | null
    isResultsPublished?: boolean
    supervisors?: ExamCreatesupervisorsInput | string[]
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCardCreateManyExamSessionInput = {
    id?: string
    studentId: string
    totalMaxMarks: number
    totalObtained: number
    percentage: number
    cgpa?: number | null
    overallGrade: string
    resultStatus: $Enums.ResultStatus
    classRank?: number | null
    gradeRank?: number | null
    attendancePercent?: number | null
    conductGrade?: string | null
    remarks?: string | null
    principalRemarks?: string | null
    rank?: number | null
    pdfUrl?: string | null
    generatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HallTicketCreateManyExamSessionInput = {
    id?: string
    studentId: string
    examId?: string | null
    pdfUrl: string
    qrCode?: string | null
    generatedAt?: Date | string
    downloadedAt?: Date | string | null
    expiryDate?: Date | string | null
    organizationId: string
  }

  export type ExamUpdateWithoutExamSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gradeId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    maxMarks?: FloatFieldUpdateOperationsInput | number
    passingMarks?: NullableFloatFieldUpdateOperationsInput | number | null
    weightage?: NullableFloatFieldUpdateOperationsInput | number | null
    evaluationType?: EnumEvaluationTypeFieldUpdateOperationsInput | $Enums.EvaluationType
    mode?: EnumExamModeFieldUpdateOperationsInput | $Enums.ExamMode
    status?: EnumExamStatusFieldUpdateOperationsInput | $Enums.ExamStatus
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    venueMapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    isResultsPublished?: BoolFieldUpdateOperationsInput | boolean
    supervisors?: ExamUpdatesupervisorsInput | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneRequiredWithoutExamNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutExamNestedInput
    hallTickets?: HallTicketUpdateManyWithoutExamNestedInput
    examResult?: ExamResultUpdateManyWithoutExamNestedInput
    examEnrollment?: ExamEnrollmentUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutExamSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    maxMarks?: FloatFieldUpdateOperationsInput | number
    passingMarks?: NullableFloatFieldUpdateOperationsInput | number | null
    weightage?: NullableFloatFieldUpdateOperationsInput | number | null
    evaluationType?: EnumEvaluationTypeFieldUpdateOperationsInput | $Enums.EvaluationType
    mode?: EnumExamModeFieldUpdateOperationsInput | $Enums.ExamMode
    status?: EnumExamStatusFieldUpdateOperationsInput | $Enums.ExamStatus
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    venueMapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    isResultsPublished?: BoolFieldUpdateOperationsInput | boolean
    supervisors?: ExamUpdatesupervisorsInput | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hallTickets?: HallTicketUncheckedUpdateManyWithoutExamNestedInput
    examResult?: ExamResultUncheckedUpdateManyWithoutExamNestedInput
    examEnrollment?: ExamEnrollmentUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateManyWithoutExamSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    maxMarks?: FloatFieldUpdateOperationsInput | number
    passingMarks?: NullableFloatFieldUpdateOperationsInput | number | null
    weightage?: NullableFloatFieldUpdateOperationsInput | number | null
    evaluationType?: EnumEvaluationTypeFieldUpdateOperationsInput | $Enums.EvaluationType
    mode?: EnumExamModeFieldUpdateOperationsInput | $Enums.ExamMode
    status?: EnumExamStatusFieldUpdateOperationsInput | $Enums.ExamStatus
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    venueMapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    isResultsPublished?: BoolFieldUpdateOperationsInput | boolean
    supervisors?: ExamUpdatesupervisorsInput | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCardUpdateWithoutExamSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalMaxMarks?: FloatFieldUpdateOperationsInput | number
    totalObtained?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    overallGrade?: StringFieldUpdateOperationsInput | string
    resultStatus?: EnumResultStatusFieldUpdateOperationsInput | $Enums.ResultStatus
    classRank?: NullableIntFieldUpdateOperationsInput | number | null
    gradeRank?: NullableIntFieldUpdateOperationsInput | number | null
    attendancePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    conductGrade?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    principalRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutReportCardNestedInput
  }

  export type ReportCardUncheckedUpdateWithoutExamSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    totalMaxMarks?: FloatFieldUpdateOperationsInput | number
    totalObtained?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    overallGrade?: StringFieldUpdateOperationsInput | string
    resultStatus?: EnumResultStatusFieldUpdateOperationsInput | $Enums.ResultStatus
    classRank?: NullableIntFieldUpdateOperationsInput | number | null
    gradeRank?: NullableIntFieldUpdateOperationsInput | number | null
    attendancePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    conductGrade?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    principalRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCardUncheckedUpdateManyWithoutExamSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    totalMaxMarks?: FloatFieldUpdateOperationsInput | number
    totalObtained?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    overallGrade?: StringFieldUpdateOperationsInput | string
    resultStatus?: EnumResultStatusFieldUpdateOperationsInput | $Enums.ResultStatus
    classRank?: NullableIntFieldUpdateOperationsInput | number | null
    gradeRank?: NullableIntFieldUpdateOperationsInput | number | null
    attendancePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    conductGrade?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    principalRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HallTicketUpdateWithoutExamSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    pdfUrl?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student?: StudentUpdateOneRequiredWithoutHallTicketNestedInput
    exam?: ExamUpdateOneWithoutHallTicketsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutHallTicketNestedInput
  }

  export type HallTicketUncheckedUpdateWithoutExamSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type HallTicketUncheckedUpdateManyWithoutExamSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type HallTicketCreateManyExamInput = {
    id?: string
    studentId: string
    examSessionId?: string | null
    pdfUrl: string
    qrCode?: string | null
    generatedAt?: Date | string
    downloadedAt?: Date | string | null
    expiryDate?: Date | string | null
    organizationId: string
  }

  export type ExamResultCreateManyExamInput = {
    id?: string
    studentId: string
    subjectId?: string | null
    maxMarks: number
    obtainedMarks?: number | null
    percentage?: number | null
    gradeLabel?: string | null
    remarks?: string | null
    isPassed?: boolean | null
    isAbsent?: boolean
    isResultsPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamEnrollmentCreateManyExamInput = {
    id?: string
    studentId: string
    status?: $Enums.StudentExamStatus
    enrolledAt?: Date | string
    exemptionReason?: string | null
  }

  export type HallTicketUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    pdfUrl?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student?: StudentUpdateOneRequiredWithoutHallTicketNestedInput
    examSession?: ExamSessionUpdateOneWithoutHallTicketsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutHallTicketNestedInput
  }

  export type HallTicketUncheckedUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    examSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type HallTicketUncheckedUpdateManyWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    examSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type ExamResultUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    maxMarks?: FloatFieldUpdateOperationsInput | number
    obtainedMarks?: NullableFloatFieldUpdateOperationsInput | number | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    gradeLabel?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAbsent?: BoolFieldUpdateOperationsInput | boolean
    isResultsPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutExamResultNestedInput
    subject?: SubjectUpdateOneWithoutExamResultNestedInput
  }

  export type ExamResultUncheckedUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMarks?: FloatFieldUpdateOperationsInput | number
    obtainedMarks?: NullableFloatFieldUpdateOperationsInput | number | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    gradeLabel?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAbsent?: BoolFieldUpdateOperationsInput | boolean
    isResultsPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamResultUncheckedUpdateManyWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMarks?: FloatFieldUpdateOperationsInput | number
    obtainedMarks?: NullableFloatFieldUpdateOperationsInput | number | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    gradeLabel?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAbsent?: BoolFieldUpdateOperationsInput | boolean
    isResultsPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamEnrollmentUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStudentExamStatusFieldUpdateOperationsInput | $Enums.StudentExamStatus
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exemptionReason?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneRequiredWithoutExamEnrollmentNestedInput
  }

  export type ExamEnrollmentUncheckedUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    status?: EnumStudentExamStatusFieldUpdateOperationsInput | $Enums.StudentExamStatus
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exemptionReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExamEnrollmentUncheckedUpdateManyWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    status?: EnumStudentExamStatusFieldUpdateOperationsInput | $Enums.StudentExamStatus
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exemptionReason?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}